# 依赖类型

从值计算类型、将它们作为参数传递给函数并将它们作为函数结果返回的能力——简而言之，作为一种依赖类型的语言——是 Idris 最显着的特征之一。许多更高级的语言的类型级别扩展，如 Haskell（以及更多）都可以使用依赖类型来处理。

```idris
module Tutorial.Dependent

%default total
```

考虑以下函数：

```idris
bogusMapList : (a -> b) -> List a -> List b
bogusMapList _ _ = []

bogusZipList : (a -> b -> c) -> List a -> List b -> List c
bogusZipList _ _ _ = []
```

实现可以通过类型检查，但它们显然不是我们库的用户所期望的。在第一个示例中，我们希望实现将函数参数应用于存储在列表中的所有值，而不会删除它们中的任何一个或更改它们的顺序。第二个比较棘手：两个列表参数的长度可能不同。遇到这种情况我们该怎么办？返回与两者中较小的长度相同的列表？返回一个空列表？或者在大多数用例中我们不应该期望两个列表具有相同的长度吗？我们怎么能描述这样的前提条件呢？

## 长度索引列表

上述问题的答案当然是：依赖类型。最常见的介绍性示例是 *向量*：按长度索引的列表：

```idris
data Vect : (len : Nat) -> (a : Type) -> Type where
  Nil  : Vect 0 a
  (::) : (x : a) -> (xs : Vect n a) -> Vect (S n) a
```

在我们继续之前，请将此与 [关于代数数据类型的部分](DataTypes.md) 中的 `Seq` 的实现进行比较。构造函数完全相同：`Nil` 和 `(::)`。但是有一个重要的区别：`Vect` 不像`Seq`或`List`，不是从`Type`到`Type` 的函数，它是从 `Nat` 到 `Type` 到 `Type` 的函数。前进！打开 REPL 并验证这一点！ `Nat` 参数（也称为 *索引*）在这里表示向量的 *长度*。 `Nil` 的类型为 `Vect 0 a`：长度为零的向量。 `Cons` 的类型为 `a -> Vect n a -> Vect (S n) a`：它恰好比其长度为 `n` 的第二个参数多一个元素 (`S n`)，。

让我们尝试这个想法以获得更好的理解。只有一种方法可以得出长度为零的向量：

```idris
ex1 : Vect 0 Integer
ex1 = Nil
```

另一方面，以下会导致类型错误（实际上是一个非常复杂的错误）：

```idris
failing "Mismatch between: S ?n and 0."
  ex2 : Vect 0 Integer
  ex2 = [12]
```

问题：`[12]` 被脱糖为 `12 :: Nil`，但这类型错误！由于此处 `Nil` 的类型为 `Vect 0 Integer`，因此 `12 :: Nil` 的类型为 `Vect (S 0) Integer`，也就是 `Vect 1 Integer `。 Idris 在编译时验证我们的向量的长度是否正确！

```idris
ex3 : Vect 1 Integer
ex3 = [12]
```

因此，我们找到了一种方法，将类列表数据结构的 *长度* 编码为 *类型*，如果在向量中的元素个数与其类型中给出的长度不一致，会得到一个 *类型错误*，我们很快就会看到几个用例，这些额外的信息使我们能够更精确地确定类型并排除额外的编程错误。但首先，我们需要快速澄清一些术语。

### 类型索引与类型参数

`Vect` 不仅是一个泛型类型，参数化了它所拥有的元素的类型，它实际上是一个 *类型族*，它们中的每一个都与一个代表它的长度的自然数相关联。我们也说，类型族 `Vect` 按其长度 *被索引*。

类型参数和索引之间的区别在于，后者可以并且确实在数据构造函数中发生变化，而前者对于所有数据构造函数都是相同的。或者，换句话说，我们可以通过对类型族的*值*进行模式匹配来了解索引的*值*，而对于类型参数，这是不可能的。

让我们用一个人为的例子来证明这一点：

```idris
data Indexed : Nat -> Type where
  I0 : Indexed 0
  I3 : Indexed 3
  I4 : String -> Indexed 4
```

在这里，`Indexed` 在它的 `Nat` 参数上进行索引，因为索引的值在构造函数之间发生变化（我为每个构造函数选择了一些任意值），我们可以通过模式匹配了解这些 `Indexed` 值。例如，我们可以使用它来创建与 `Indexed` 的索引长度相同的 `Vect`：

```idris
fromIndexed : Indexed n -> a -> Vect n a
```

来吧，尝试自己实现它！使用孔，对 `Indexed` 参数进行模式匹配，并通过检查孔及其上下文了解每种情况下的预期输出类型。

这是我的实现：

```idris
fromIndexed I0     va = []
fromIndexed I3     va = [va, va, va]
fromIndexed (I4 _) va = [va, va, va, va]
```

如您所见，通过对 `Indexed n` 参数的值进行模式匹配，我们了解了 `n` 索引本身的值，这是返回 `Vect` 所必需的正确长度。

### 长度保持的 `map`

函数 `bogusMapList` 表现异常，因为它总是返回空列表。对于 `Vect`，我们需要忠实于这里的类型。如果我们在 `Vect` 上映射，参数 *和* 输出类型包含一个长度索引，这些长度索引将*确切的* 告诉我们，我们的向量长度如何被修改：

```idris
map3_1 : (a -> b) -> Vect 3 a -> Vect 1 b
map3_1 f [_,y,_] = [f y]

map5_0 : (a -> b) -> Vect 5 a -> Vect 0 b
map5_0 f _ = []

map5_10 : (a -> b) -> Vect 5 a -> Vect 10 b
map5_10 f [u,v,w,x,y] = [f u, f u, f v, f v, f w, f w, f x, f x, f y, f y]
```

虽然这些例子很有趣，但它们并不是真的有用，不是吗？那是因为他们太专业了。我们想要一个 *通用* 函数来映射任意长度的向量。除了在类型签名中使用具体的长度，我们还可以使用*变量*，正如在 `Vect` 的定义中已经看到的那样。这允许我们声明一般情况：

```idris
mapVect' : (a -> b) -> Vect n a -> Vect n b
```

这种类型描述了一个长度保持映射。包含隐式参数实际上更有指导意义（但不是必需的）：

```idris
mapVect : {0 a,b : _} -> {0 n : Nat} -> (a -> b) -> Vect n a -> Vect n b
```

我们忽略了两个类型参数 `a` 和 `b`，因为它们只是描述了一个泛型函数（但是请注意，我们可以将相同类型和定量的参数组合成一对大括号；这是可选的，但有时有助于使类型签名更短）。然而，`Nat` 类型的隐式参数告诉我们输入和输出 `Vect` 的长度相同。不遵守本合约属于类型错误。在实现 `mapVect` 时，遵循并使用一些孔非常有指导意义。为了获得关于 `Vect` 参数长度的 *任何* 信息，我们需要对其进行模式匹配：

```repl
mapVect _ Nil       = ?impl_0
mapVect f (x :: xs) = ?impl_1
```

在 REPL，我们学到以下内容：

```repl
Tutorial.Dependent> :t impl_0
 0 a : Type
 0 b : Type
 0 n : Nat
------------------------------
impl_0 : Vect 0 b


Tutorial.Dependent> :t impl_1
 0 a : Type
 0 b : Type
   x : a
   xs : Vect n a
   f : a -> b
 0 n : Nat
------------------------------
impl_1 : Vect (S n) b
```

第一个孔 `impl_0` 的类型为 `Vect 0 b`。如上所述，只有一个这样的值：

```idris
mapVect _ Nil       = Nil
```

第二种情况更有趣。我们注意到，`xs` 是 `Vect n a` 类型，对于任意长度 `n`（作为已擦除参数给出），而结果是类型 `Vect (S n) b`。因此，结果必须比 `xs` 长一个元素。幸运的是，我们已经有了一个 `a` 类型的值（绑定到变量 `x`）和一个从 `a` 到 `b` 的函数（绑定到变量 `f`)，因此我们可以将 `f` 应用于 `x` 并将结果添加到未知的余数：

```repl
mapVect f (x :: xs) = f x :: ?rest
```

让我们在 REPL 检查一下新的孔：

```repl
Tutorial.Dependent> :t rest
 0 a : Type
 0 b : Type
   x : a
   xs : Vect n a
   f : a -> b
 0 n : Nat
------------------------------
rest : Vect n b
```

现在，我们有一个 `Vect n a` 并且需要一个 `Vect n b`，而不知道关于 `n` 的任何其他信息。我们 *可以* 通过在 `xs` 上进一步进行模式匹配来了解更多关于 `n` 的信息，但这会很快将我们引向一个兔子洞，因为在这样的模式匹配之后，我们'最终会出现另一个 `Nil` 分支和另一个 `cons` 分支，新的尾巴长度未知。相反，我们可以递归调用 `mapVect` 以将余数 (`xs`) 转换为 `Vect n b`。类型检查器保证 `xs` 和 `mapVect f xs` 的长度是相同的，所以整个表达式类型检查，我们就完成了：

```idris
mapVect f (x :: xs) = f x :: mapVect f xs
```

### 向量压缩

现在让我们看一下 `bogusZipList`：我们希望通过给定的二元函数成对合并两个包含（可能）不同类型的元素的列表。如上所述，最合理的做法是期望两个列表以及结果的长度相等。使用 `Vect` 可以表达和实现如下：

```idris
zipWith : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c
zipWith f []        []         = Nil
zipWith f (x :: xs) (y :: ys)  = f x y :: zipWith f xs ys
```

现在，这是一件有趣的事情：完全性检查器（由于初始 `%default total` 杂注而在整个源文件中激活）接受上述实现作为全函数，尽管它缺少另外两个分支。这行得通，因为 Idris 可以自己弄清楚，其他两种情况是 *不可能的*。从第一个 `Vect` 参数的模式匹配中，Idris 了解 `n` 是零还是另一个自然数的后继。但由此可以得出，长度也为 `n` 的第二个向量是 `Nil` 还是 `cons`。尽管如此，明确添加不可能的情况仍然可以提供信息。我们可以使用关键字 `impossible` 来做到这一点：

```idris
zipWith _ [] (_ :: _) impossible
zipWith _ (_ :: _) [] impossible
```

如果 Idris 无法验证这种情况确实是不可能的，那么用 `impossible` 注释模式匹配中的情况当然是类型错误。当我们认为我们对不可能的情况是正确的而 Idris 不是时，我们将在后面的部分中学习该怎么做。

让我们在 REPL 上给 `zipWith` 一个旋转：

```repl
Tutorial.Dependent> zipWith (*) [1,2,3] [10,20,30]
[10, 40, 90]
Tutorial.Dependent> zipWith (\x,y => x ++ ": " ++ show y) ["The answer"] [42]
["The answer: 42"]
Tutorial.Dependent> zipWith (*) [1,2,3] [10,20]
... Nasty type error ...
```

#### 简化类型错误

体验 Idris 可以为我们做的大量工作以及当事情进展顺利时它可以自行推断出的事情的数量，真是令人惊叹。然而，当事情进展不顺利时，我们从 Idris 收到的错误消息可能会很长且难以理解，尤其是对于刚接触该语言的程序员而言。例如，上面最后一个 REPL 示例中的错误消息很长，列出了 Idris 尝试做的不同事情以及每件事失败的原因。

如果发生这种情况，通常意味着类型错误和函数名重载导致的歧义在起作用。在上面的示例中，两个向量的长度不同，如果我们将列表字面量解释为向量，则会导致类型错误。但是，列表字面量被重载以使用构造函数 `Nil` 和 `(::)` 的所有数据类型，因此 Idris 现在将尝试除 `Vect` 之外的其他数据构造函数]（在这种情况下，来自 *Prelude* 的 `List` 和 `Stream` ），由于 `zipWith` 需要 `Vect` 类型的参数，所以 `List` 和 `Stream` 都不起作用。

如果发生这种情况，在重载函数名称前加上它们的命名空间通常可以简化事情，因为 Idris 不再需要消除这些函数的歧义：

```repl
Tutorial.Dependent> zipWith (*) (Dependent.(::) 1 Dependent.Nil) Dependent.Nil
Error: When unifying:
    Vect 0 ?c
and:
    Vect 1 ?c
Mismatch between: 0 and 1.
```

在这里，信息更加清晰：Idris 无法 *统一* 两个向量的长度。 *Unification* 表示：Idris 尝试在编译时将两个表达式转换为相同的范式。如果成功，则认为这两个表达式是等价的，否则，Idris 将失败并出现统一错误。

作为使用名称空间作为重载函数前缀的替代方法，我们可以使用 `the` 来帮助进行类型推断：

```repl
Tutorial.Dependent> zipWith (*) (the (Vect 3 _) [1,2,3]) (the (Vect 2 _) [10,20])
Error: When unifying:
    Vect 2 ?c
and:
    Vect 3 ?c
Mismatch between: 0 and 1.
```

有趣的是，上面的错误不是“不匹配：2 和 3”，而是“不匹配：0 和 1”。这是发生了什么：Idris 尝试统一整数字面量 `2` 和 `3`，它们首先转换为相应的 `Nat` 值 `S (S Z)[` 和 `S (S (S Z))`。这两个模式匹配，直到我们到达 `Z` vs `S Z`，对应于值 `0` 和 `1`，这是报告中报告的差异错误信息。

### 创建向量

到目前为止，我们能够通过对向量进行模式匹配来了解向量的长度。在 `Nil` 的情况下，很明显长度为 0，而在 *cons* 的情况下，长度是另一个自然数的后继。当我们要创建一个新向量时，这是不可能的：

```idris
failing "Mismatch between: S ?n and n."
  fill : a -> Vect n a
```

您将很难实现 `fill`。例如，以下内容会导致类型错误：

```idris
  fill va = [va,va]
```

问题是，*我们函数的调用者决定了结果向量的长度*。 `fill`的完整类型其实如下：

```idris
fill' : {0 a : Type} -> {0 n : Nat} -> a -> Vect n a
```

您可以按如下方式阅读此类型：对于每个类型 `a` 和每个自然数 `n` （我知道在运行时 *什么都没有* ，因为它的定量为零)，给定一个 `a` 类型的值，我会给你一个向量，它正好包含 `a` 类型的 `n` 个元素。这就像说：“想想一个自然数 `n`，我会给你 `n` 个苹果，而你却不告诉我 `n` 的值”。Idris 很强大，但不是千里眼。

为了实现 `fill`，我们需要知道 `n` 实际上是什么：我们需要将 `n` 作为显式的、未擦除的参数传递，这将允许我们对其进行模式匹配并决定 - 基于此模式匹配 - 使用 `Vect` 的哪些构造函数：

```idris
replicate : (n : Nat) -> a -> Vect n a
```

现在，`replicate` 是一个 *依赖函数类型 *：输出类型 *取决于* 参数的一个值。通过 `n` 上的模式匹配来实现 `replicate` 很简单：

```idris
replicate 0     _  = []
replicate (S k) va = va :: replicate k va
```

这是使用索引类型时经常出现的模式：我们可以通过对类型族的值进行模式匹配来了解索引的值。但是，为了从函数返回类型族的值，我们需要在编译时知道索引的值（参见常量 `ex1` 或 `ex3`，例如)，或者我们需要在运行时访问索引的值，在这种情况下，我们可以对它们进行模式匹配并从中学习使用类型族的构造函数。

### 练习第 1 部分

1. 为非空向量实现函数 `head`：


   ```idris
   head : Vect (S n) a -> a
   ```

   请注意，我们如何使用 *模式* 来描述在 `Vect` 的长度上的非空性。这排除了 `Nil` 的情况，我们可以返回一个 `a` 类型的值，而不必将其包装在一个`Maybe` 中！确保为 `Nil` 添加一个 `impossible` 子句分支（尽管这不是绝对必要的）。

2. 以 `head` 为参考，为非空向量声明并实现函数 `tail`。类型应该反映输出恰好比输入短一个元素。


3. 实现 `zipWith3`。如果可能，请尝试在不查看 `zipWith` 的实现的情况下这样做：


   ```idris
   zipWith3 : (a -> b -> c -> d) -> Vect n a -> Vect n b -> Vect n c -> Vect n d
   ```

4. 声明并实现一个函数 `foldSemi` 用于通过 `Semigroup` 的附加运算符 (`(<+>)`) 累加存储在 `List` 中的值. （确保只使用 `Semigroup` 约束，而不是 `Monoid` 约束。）


5. 做与练习 4 相同的操作，但对于非空向量。向量的非空性如何影响输出类型？


6. 给定 `a` 类型的初始值和函数 `a -> a`，我们想生成 `a`s 的 `Vect`s ，其中第一个值为 `a`，第二个值为 `f a`，第三个值为 `f (fa)`，以此类推。


   例如，如果 `a` 是 1 并且 `f` 是 `(* 2)`，我们希望
   获得类似于以下的结果：`[1,2,4,8,16,...]`。

   声明并实现函数 `iterate`，它应该封装这种行为。如果你不知道从哪里开始，可以从 `replicate` 中获得一些灵感。

7. 给定状态类型 `s` 的初始值和函数 `fun : s -> (s,a)`，我们希望生成 `a` 的 `Vect`。声明并实现函数 `generate`，它应该封装这个行为。确保在每次新调用 `fun` 时使用更新后的状态。


   这是一个示例，它被用来生成前 `n` 个斐波那契数列：

   ```repl
   generate 10 (\(x,y) => let z = x + y in ((y,z),z)) (0,1)
   [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
   ```

8. 实现函数 `fromList`，它将值列表转换为相同长度的 `Vect`。如果卡住，请使用孔：


   ```idris
   fromList : (as : List a) -> Vect (length as) a
   ```

   请注意，在 `fromList` 的类型中，我们如何通过 `length` 函数*计算* list 参数得到向量的长度。

9. 考虑以下声明：


   ```idris
   maybeSize : Maybe a -> Nat

   fromMaybe : (m : Maybe a) -> Vect (maybeSize m) a
   ```

   为 `maybeSize` 选择一个合理的实现，
   然后执行 `fromMaybe` 。

## `Fin`：向量的安全索引

考虑函数 `index`，它试图从给定位置的 `List` 中提取一个值：

```idris
indexList : (pos : Nat) -> List a -> Maybe a
indexList _     []        = Nothing
indexList 0     (x :: _)  = Just x
indexList (S k) (_ :: xs) = indexList k xs
```

现在，在编写 `indexList` 之类的函数时要考虑的一点是：我们是要表达输出类型失败的可能性，还是要限制接受的参数，所以函数不能再失败？这些都是重要的设计决策，尤其是在较大的应用程序中。从函数返回 `Maybe` 或 `Either` 会强制客户端代码最终处理 `Nothing` 或 `Left` 情况，直到发生这种情况，所有中间结果都将带有 `Maybe` 或 `Either` 污点，这将使使用这些中间结果运行计算变得更加麻烦。另一方面，限制作为输入接受的值会使参数类型复杂化，并将输入验证的负担放在我们函数的调用者身上，（尽管在编译时我们可以从 Idris 获得帮助，正如我们将在讨论时看到的那样关于自动隐式），同时保持输出纯净和干净。

没有依赖类型的语言（如 Haskell）通常只能采用上述路线：将结果包装在 `Maybe` 或 `Either` 中。但是，在 Idris 中，我们通常可以 *细化* 输入类型以限制接受值的集合，从而排除失败的可能性。

假设，作为一个例子，我们想从 `Vect n a` 的（从零开始的）索引 `k` 处的中提取一个值。当然，当且仅当 `k` 是一个严格小于向量长度 `n` 的自然数时，这才能成功。幸运的是，我们可以用索引类型来表达这个前提条件：

```idris
data Fin : (n : Nat) -> Type where
  FZ : {0 n : Nat} -> Fin (S n)
  FS : (k : Fin n) -> Fin (S n)
```

`Fin n` 是严格小于 `n` 的自然数类型。它是归纳定义的：`FZ` 对应于自然数 *0*，从其类型中可以看出，对于任何自然数，`n` 都严格小于 `S n`。 `FS` 是归纳情况：如果 `k` 严格小于 `n` （`k` 属于 `Fin n` 类型)，则 `FS k` 严格小于 `S n`。

让我们想出一些 `Fin` 类型的值：

```idris
fin0_5 : Fin 5
fin0_5 = FZ

fin0_7 : Fin 7
fin0_7 = FZ

fin1_3 : Fin 3
fin1_3 = FS FZ

fin4_5 : Fin 5
fin4_5 = FS (FS (FS (FS FZ)))
```

请注意，没有 `Fin 0` 类型的值。我们将在后面的课程中学习，如何在类型中表达“没有类型 `x` 的值”。

现在让我们检查一下，是否可以使用 `Fin` 安全地索引到 `Vect`：

```idris
index : Fin n -> Vect n a -> a
```

在继续之前，请尝试自己实现 `index`，如果遇到困难，请充分利用孔。

```idris
index FZ     (x :: _) = x
index (FS k) (_ :: xs) = index k xs
```

请注意，如何没有 `Nil` 分支，并且总体检查器仍然很高兴。那是因为 `Nil` 的类型是 `Vect 0 a`，但是没有 `Fin 0` 类型的值！我们可以通过添加缺失的不可能子句来验证这一点：

```idris
index FZ     Nil impossible
index (FS _) Nil impossible
```

### 练习第 2 部分

1. 实现函数 `update`，给定一个类型为 `a -> a` 的函数，在 `Vect n a` 中 `k < n` 处的位置更新值。


2. 实现函数 `insert`，它在 `Vect n a` 中的 `k <= n` 位置插入 `a` 类型的值。请注意，`k` 是新插入值的索引，因此以下成立：


   ```repl
   index k (insert k v vs) = v
   ```

3. 实现函数 `delete`，它从向量中的给定索引处删除一个值。


   这比练习 1 和练习 2 更棘手，因为我们必须正确编码向量正在缩短一个元素的类型。

4. 我们也可以使用 `Fin` 来实现对 `List` 的安全索引。尝试为 `safeIndexList` 提出一个类型和实现。


   注意：如果不知道怎么下手，看`fromList`的类型找一些灵感。您可能还需要与 `index`  不同的顺序给出参数。

5. 实现函数 `finToNat`，将一个`Fin n`转换为对应的自然数，并用它来声明和实现函数 `take` ，通过对 `Vect n a` 的前 `k` 个元素进行拆分 ，其中 `k <= n`。


6. 实现函数 `minus` 用于从 `k <= n` 的自然数 `n` 中减去值 `k`。


7. 使用练习 6 中的 `minus` 声明和实现函数 `drop`，用于从 `Vect n a` 中删除第一个 `k` 值，其中 `k <= n`。


8. 实现函数 `splitAt` 用于在位置 `k <= n` 处拆分 `Vect n a`，返回包装成对的向量的前缀和后缀。


   提示：在你的实现中使用 `take` 和 `drop`。

提示：由于 `Fin n` 由严格小于 `n` 的值组成，因此 `Fin (S n)` 由小于或等于 `n 的值组成`。

注意：函数 `take`、`drop` 和 `splitAt` 虽然正确且可证明是完全的，但键入起来相当麻烦。正如我们将在下一节中看到的，还有另一种声明它们的类型的方法。

## 编译时计算

在上一节中——尤其是在一些练习中——我们开始越来越多地使用编译时计算来描述函数和值的类型。这是一个非常强大的概念，因为它允许我们根据输入类型计算输出类型。这是一个例子：

可以使用 `(++)` 运算符连接两个 `List`。当然，这对于 `Vect` 也应该是可能的。但是 `Vect` 是由它的长度索引的，所以我们必须在类型中准确地反映输入的长度如何影响输出的长度。以下是如何执行此操作：

```idris
(++) : Vect m a -> Vect n a -> Vect (m + n) a
(++) []        ys = ys
(++) (x :: xs) ys = x :: (xs ++ ys)
```

请注意，我们如何在类型级别跟踪长度，再次排除某些常见的编程错误，例如无意中删除某些值。

我们还可以使用类型级计算作为输入类型的模式。这是 `drop` 的另一种类型和实现，您在练习中使用 `Fin n` 参数实现了它：

```idris
drop' : (m : Nat) -> Vect (m + n) a -> Vect n a
drop' 0     xs        = xs
drop' (S k) (_ :: xs) = drop' k xs
```

### 限制

在本节中的所有示例和练习之后，您可能已经得出结论，我们可以在类型中使用任意表达式，并且 Idris 会很乐意为我们评估和统一所有这些表达式。

恐怕这甚至不接近事实。本节中的示例是精心挑选的，因为它们已知 *可以正常工作*。原因是，我们自己的模式匹配和我们在编译时使用的函数的实现之间总是存在直接联系。

例如，这里是自然数加法的实现：

```idris
add : Nat -> Nat -> Nat
add Z     n = n
add (S k) n = S $ add k n
```

如您所见， `add` 是通过对其 *第一个* 参数的模式匹配来实现的，而第二个参数从未被检查过。请注意，这正是 `(++)` 在 `Vect` 上的实现方式：在那里，我们还对第一个参数进行模式匹配，在 `Nil` 分支中返回未修改的第二个参数，并将头部添加到 *cons* 分支中追加尾部的结果。由于两个模式匹配之间存在直接对应关系，因此 Idris 可以在 `Nil` 的情况下将 `0 + n` 与 `n` 统一起来，而在 *cons* 的情况下 `(S k) + n` 与 `S (k + n)` 统一起来。

这是一个简单的例子，如果没有我们的帮助，Idris 将不再相信：

```idris
failing "Can't solve constraint"
  reverse : Vect n a -> Vect n a
  reverse []        = []
  reverse (x :: xs) = reverse xs ++ [x]
```

当我们对上述内容进行类型检查时，Idris 将失败并显示以下错误消息：“无法解决之间的约束：加plus n 1 和 S n。”这是发生了什么：从左侧的模式匹配中，Idris 知道向量的长度是 `S n`，对于某个自然数 `n` 对应于 `xs`。右边向量的长度是`n + 1`，根据 `(++)` 的类型和 `xs` 和 `[x]` 的长度。重载运算符 `(+)` 是通过函数 `Prelude.plus` 实现的，这就是 Idris 在错误消息中将 `(+)` 替换为 `plus` 的原因.

从上面可以看出，Idris 自己无法验证 `1 + n` 与 `n + 1` 是一回事。不过，它可以接受我们的一些帮助。如果我们提出上述等式成立的 *证明*（或者更一般地说，我们对自然数加法的实现是 *可交换的*），我们可以将此证明用于 *重写* `reverse` 右侧的类型。编写证明和使用 `rewrite` 需要一些深入的解释和示例。所以，这些事情还得等到下一章再说。

### 不受限制的隐式

在像 `replicate` 这样的函数中，我们传递一个自然数 `n` 作为一个明确的、不受限制的参数，我们从中推断要返回的向量的长度。在某些情况下，可以从上下文中推断出 `n`。例如，在以下示例中，显式传递 `n` 是很乏味的：

```idris
ex4 : Vect 3 Integer
ex4 = zipWith (*) (replicate 3 10) (replicate 3 11)
```

`n` 的值显然可以从上下文中推导出来，可以通过将其替换为下划线来确认：

```idris
ex5 : Vect 3 Integer
ex5 = zipWith (*) (replicate _ 10) (replicate _ 11)
```

因此，我们可以实现 `replicate` 的替代版本，其中我们将 `n` 作为 *无限制* 定量的隐式参数传递：

```idris
replicate' : {n : _} -> a -> Vect n a
replicate' = replicate n
```

请注意，在 `replicate'` 的实现中，我们可以引用 `n` 并将其作为显式参数传递给 `replicate`。

决定是否将潜在的可推断参数隐式或显式传递给函数是一个问题，即 Idris 实际 *是* 可推断参数的使用频率。有时，同时拥有一个函数的两个版本甚至可能很有用。但是请记住，即使是隐式参数，我们仍然可以显式传递值：

```idris
ex6 : Vect ? Bool
ex6 = replicate' {n = 2} True
```

在上面的类型签名中，问号 (`?`) 的意思是，Idris 应该尝试通过统一自己找出值。这迫使我们在 `ex6` 的右侧明确指定 `n`。

#### 隐式模式匹配

`replicate'` 的实现使用了函数 `replicate`，我们可以在显式参数 `n` 上进行模式匹配。但是，也可以对非零数量的隐式命名参数进行模式匹配：

```idris
replicate'' : {n : _} -> a -> Vect n a
replicate'' {n = Z}   _ = Nil
replicate'' {n = S _} v = v :: replicate'' v
```

### 练习第 3 部分

1. 这是一个用于扁平化 `List` 中的 `List` 的函数声明：


   ```idris
   flattenList : List (List a) -> List a
   ```

   实现 `flattenList` 并声明和实现一个类似的函数 `flattenVect` 用于扁平化向量的向量。

2. 像上一节的练习一样实现函数 `take'` 和 `splitAt'`，但使用 `drop'` 所示的技术。


3. 实现函数 `transpose` 用于将 `m x n` 矩阵（表示为 `Vect m (Vect n a)`）转换为 `n x m` 矩阵。


   注意：这可能是一项具有挑战性的练习，但请确保试一试。像往常一样，如果你被卡住了，就利用洞！

   这是一个示例，它应该如何在行动中发挥作用：

   ```repl
   Solutions.Dependent> transpose [[1,2,3],[4,5,6]]
   [[1, 4], [2, 5], [3, 6]]
   ```

## 结论

* 依赖类型允许我们根据值计算类型。这使得在类型级别对值的属性进行编码并在编译时验证这些属性成为可能。


* 长度索引列表（向量）通过强制我们准确了解输入和输出向量的长度，让我们排除了某些实现错误。


* 我们可以在类型签名中使用模式，例如表示向量的长度非零，因此向量非空。


* 创建类型族的值时，索引的值需要在编译时知道，或者它们需要作为参数传递给创建值的函数，我们可以对它们进行模式匹配以确定哪些构造函数利用。


* 我们可以使用严格小于 `n` 的自然数类型 `Fin n` 来安全地索引长度为 `n` 的向量。


* 有时，将可推断参数作为非擦除隐式传递很方便，在这种情况下，我们仍然可以通过模式匹配检查它们或将它们传递给其他函数，而 Idris 会尝试为我们填充值。


请注意，数据类型 `Vect` 以及我们在此处实现的许多功能可从 *base* 库中的模块 `Data.Vect` 获得。同样，`Fin` 可从 `Data.Fin` 从 *base* 获得。

### 下一步是什么

在 [next section](IO.md) 中，是时候学习如何编写有效的程序以及如何在保持 * 纯 * 的同时做到这一点。

<!-- vi: filetype=idris2
-->
