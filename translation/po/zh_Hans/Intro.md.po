# Chinese translations for idris package
# Copyright (C) 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the idris package.
# Automatically generated, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: idris 2-tutorial\n"
"POT-Creation-Date: 2022-08-03 00:18+0800\n"
"PO-Revision-Date: 2022-08-03 05:18+0000\n"
"Last-Translator: admin <467195537@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://weblate.grass.work:30443/"
"projects/idris2-tutorial/intro/zh_Hans/>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.13.1\n"

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:16 ../src/Tutorial/DataTypes.md:25
#: ../src/Tutorial/DataTypes.md:60 ../src/Tutorial/DataTypes.md:112
#: ../src/Tutorial/DataTypes.md:130 ../src/Tutorial/DataTypes.md:152
#: ../src/Tutorial/DataTypes.md:163 ../src/Tutorial/DataTypes.md:184
#: ../src/Tutorial/DataTypes.md:215 ../src/Tutorial/DataTypes.md:253
#: ../src/Tutorial/DataTypes.md:283 ../src/Tutorial/DataTypes.md:327
#: ../src/Tutorial/DataTypes.md:348 ../src/Tutorial/DataTypes.md:359
#: ../src/Tutorial/DataTypes.md:378 ../src/Tutorial/DataTypes.md:408
#: ../src/Tutorial/DataTypes.md:415 ../src/Tutorial/DataTypes.md:441
#: ../src/Tutorial/DataTypes.md:449 ../src/Tutorial/DataTypes.md:482
#: ../src/Tutorial/DataTypes.md:505 ../src/Tutorial/DataTypes.md:518
#: ../src/Tutorial/DataTypes.md:546 ../src/Tutorial/DataTypes.md:559
#: ../src/Tutorial/DataTypes.md:587 ../src/Tutorial/DataTypes.md:598
#: ../src/Tutorial/DataTypes.md:617 ../src/Tutorial/DataTypes.md:628
#: ../src/Tutorial/DataTypes.md:638 ../src/Tutorial/DataTypes.md:654
#: ../src/Tutorial/DataTypes.md:667 ../src/Tutorial/DataTypes.md:681
#: ../src/Tutorial/DataTypes.md:693 ../src/Tutorial/DataTypes.md:701
#: ../src/Tutorial/DataTypes.md:716 ../src/Tutorial/DataTypes.md:729
#: ../src/Tutorial/DataTypes.md:804 ../src/Tutorial/DataTypes.md:828
#: ../src/Tutorial/DataTypes.md:861 ../src/Tutorial/DataTypes.md:897
#: ../src/Tutorial/DataTypes.md:908 ../src/Tutorial/DataTypes.md:942
#: ../src/Tutorial/DataTypes.md:957 ../src/Tutorial/DataTypes.md:967
#: ../src/Tutorial/DataTypes.md:992 ../src/Tutorial/DataTypes.md:1069
#: ../src/Tutorial/DataTypes.md:1081 ../src/Tutorial/DataTypes.md:1105
#: ../src/Tutorial/DataTypes.md:1143 ../src/Tutorial/DataTypes.md:1178
#: ../src/Tutorial/DataTypes.md:1208 ../src/Tutorial/DataTypes.md:1246
#: ../src/Tutorial/DataTypes.md:1269 ../src/Tutorial/DataTypes.md:1291
#: ../src/Tutorial/Dependent.md:10 ../src/Tutorial/Dependent.md:18
#: ../src/Tutorial/Dependent.md:42 ../src/Tutorial/Dependent.md:62
#: ../src/Tutorial/Dependent.md:70 ../src/Tutorial/Dependent.md:81
#: ../src/Tutorial/Dependent.md:111 ../src/Tutorial/Dependent.md:125
#: ../src/Tutorial/Dependent.md:136 ../src/Tutorial/Dependent.md:155
#: ../src/Tutorial/Dependent.md:174 ../src/Tutorial/Dependent.md:182
#: ../src/Tutorial/Dependent.md:227 ../src/Tutorial/Dependent.md:266
#: ../src/Tutorial/Dependent.md:278 ../src/Tutorial/Dependent.md:296
#: ../src/Tutorial/Dependent.md:388 ../src/Tutorial/Dependent.md:396
#: ../src/Tutorial/Dependent.md:404 ../src/Tutorial/Dependent.md:421
#: ../src/Tutorial/Dependent.md:429 ../src/Tutorial/Dependent.md:448
#: ../src/Tutorial/Dependent.md:465 ../src/Tutorial/Dependent.md:507
#: ../src/Tutorial/Dependent.md:517 ../src/Tutorial/Dependent.md:531
#: ../src/Tutorial/Dependent.md:564 ../src/Tutorial/Dependent.md:579
#: ../src/Tutorial/Dependent.md:600 ../src/Tutorial/Dependent.md:607
#: ../src/Tutorial/Dependent.md:617 ../src/Tutorial/Dependent.md:690
#: ../src/Tutorial/Dependent.md:705 ../src/Tutorial/Dependent.md:727
#: ../src/Tutorial/Dependent.md:748 ../src/Tutorial/Dependent.md:789
#: ../src/Tutorial/Dependent.md:797 ../src/Tutorial/Dependent.md:806
#: ../src/Tutorial/Dependent.md:820 ../src/Tutorial/Dependent.md:836
#: ../src/Tutorial/Dependent.md:846 ../src/Tutorial/DPair.md:19
#: ../src/Tutorial/DPair.md:47 ../src/Tutorial/DPair.md:76
#: ../src/Tutorial/DPair.md:93 ../src/Tutorial/DPair.md:116
#: ../src/Tutorial/DPair.md:132 ../src/Tutorial/DPair.md:148
#: ../src/Tutorial/DPair.md:165 ../src/Tutorial/DPair.md:174
#: ../src/Tutorial/DPair.md:203 ../src/Tutorial/DPair.md:216
#: ../src/Tutorial/DPair.md:226 ../src/Tutorial/DPair.md:243
#: ../src/Tutorial/DPair.md:255 ../src/Tutorial/DPair.md:266
#: ../src/Tutorial/DPair.md:285 ../src/Tutorial/DPair.md:298
#: ../src/Tutorial/DPair.md:307 ../src/Tutorial/DPair.md:315
#: ../src/Tutorial/DPair.md:327 ../src/Tutorial/DPair.md:339
#: ../src/Tutorial/DPair.md:373 ../src/Tutorial/DPair.md:405
#: ../src/Tutorial/DPair.md:416 ../src/Tutorial/DPair.md:428
#: ../src/Tutorial/DPair.md:459 ../src/Tutorial/DPair.md:481
#: ../src/Tutorial/DPair.md:498 ../src/Tutorial/DPair.md:513
#: ../src/Tutorial/DPair.md:532 ../src/Tutorial/DPair.md:545
#: ../src/Tutorial/DPair.md:555 ../src/Tutorial/DPair.md:584
#: ../src/Tutorial/DPair.md:631 ../src/Tutorial/DPair.md:781
#: ../src/Tutorial/DPair.md:792 ../src/Tutorial/DPair.md:808
#: ../src/Tutorial/DPair.md:824 ../src/Tutorial/DPair.md:840
#: ../src/Tutorial/DPair.md:911 ../src/Tutorial/DPair.md:930
#: ../src/Tutorial/DPair.md:991 ../src/Tutorial/DPair.md:1019
#: ../src/Tutorial/DPair.md:1053 ../src/Tutorial/DPair.md:1068
#: ../src/Tutorial/DPair.md:1088 ../src/Tutorial/Eq.md:10
#: ../src/Tutorial/Eq.md:27 ../src/Tutorial/Eq.md:56 ../src/Tutorial/Eq.md:115
#: ../src/Tutorial/Eq.md:129 ../src/Tutorial/Eq.md:135
#: ../src/Tutorial/Eq.md:144 ../src/Tutorial/Eq.md:173
#: ../src/Tutorial/Eq.md:181 ../src/Tutorial/Eq.md:204
#: ../src/Tutorial/Eq.md:222 ../src/Tutorial/Eq.md:254
#: ../src/Tutorial/Eq.md:316 ../src/Tutorial/Eq.md:337
#: ../src/Tutorial/Eq.md:347 ../src/Tutorial/Eq.md:358
#: ../src/Tutorial/Eq.md:374 ../src/Tutorial/Eq.md:388
#: ../src/Tutorial/Eq.md:423 ../src/Tutorial/Eq.md:454
#: ../src/Tutorial/Eq.md:495 ../src/Tutorial/Eq.md:531
#: ../src/Tutorial/Eq.md:544 ../src/Tutorial/Eq.md:577
#: ../src/Tutorial/Eq.md:587 ../src/Tutorial/Eq.md:618
#: ../src/Tutorial/Eq.md:634 ../src/Tutorial/Eq.md:643
#: ../src/Tutorial/Eq.md:652 ../src/Tutorial/Eq.md:668
#: ../src/Tutorial/Eq.md:711 ../src/Tutorial/Eq.md:753
#: ../src/Tutorial/Eq.md:798 ../src/Tutorial/Eq.md:810
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Eq.md:889
#: ../src/Tutorial/Eq.md:900 ../src/Tutorial/Eq.md:924
#: ../src/Tutorial/Eq.md:941 ../src/Tutorial/Eq.md:961
#: ../src/Tutorial/Eq.md:1002 ../src/Tutorial/Eq.md:1033
#: ../src/Tutorial/Eq.md:1074 ../src/Tutorial/Folds.md:23
#: ../src/Tutorial/Folds.md:51 ../src/Tutorial/Folds.md:64
#: ../src/Tutorial/Folds.md:74 ../src/Tutorial/Folds.md:89
#: ../src/Tutorial/Folds.md:104 ../src/Tutorial/Folds.md:118
#: ../src/Tutorial/Folds.md:134 ../src/Tutorial/Folds.md:188
#: ../src/Tutorial/Folds.md:205 ../src/Tutorial/Folds.md:216
#: ../src/Tutorial/Folds.md:230 ../src/Tutorial/Folds.md:254
#: ../src/Tutorial/Folds.md:282 ../src/Tutorial/Folds.md:303
#: ../src/Tutorial/Folds.md:320 ../src/Tutorial/Folds.md:384
#: ../src/Tutorial/Folds.md:393 ../src/Tutorial/Folds.md:400
#: ../src/Tutorial/Folds.md:406 ../src/Tutorial/Folds.md:429
#: ../src/Tutorial/Folds.md:438 ../src/Tutorial/Folds.md:446
#: ../src/Tutorial/Folds.md:452 ../src/Tutorial/Folds.md:458
#: ../src/Tutorial/Folds.md:465 ../src/Tutorial/Folds.md:495
#: ../src/Tutorial/Folds.md:521 ../src/Tutorial/Folds.md:544
#: ../src/Tutorial/Folds.md:609 ../src/Tutorial/Folds.md:621
#: ../src/Tutorial/Folds.md:638 ../src/Tutorial/Folds.md:656
#: ../src/Tutorial/Folds.md:720 ../src/Tutorial/Folds.md:737
#: ../src/Tutorial/Folds.md:766 ../src/Tutorial/Folds.md:847
#: ../src/Tutorial/Folds.md:869 ../src/Tutorial/Folds.md:892
#: ../src/Tutorial/Folds.md:935 ../src/Tutorial/Folds.md:951
#: ../src/Tutorial/Folds.md:996 ../src/Tutorial/Folds.md:1006
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/Folds.md:1040
#: ../src/Tutorial/Functions1.md:17 ../src/Tutorial/Functions1.md:29
#: ../src/Tutorial/Functions1.md:80 ../src/Tutorial/Functions1.md:96
#: ../src/Tutorial/Functions1.md:109 ../src/Tutorial/Functions1.md:127
#: ../src/Tutorial/Functions1.md:158 ../src/Tutorial/Functions1.md:178
#: ../src/Tutorial/Functions1.md:221 ../src/Tutorial/Functions1.md:246
#: ../src/Tutorial/Functions1.md:292 ../src/Tutorial/Functions1.md:349
#: ../src/Tutorial/Functions1.md:391 ../src/Tutorial/Functions1.md:472
#: ../src/Tutorial/Functions1.md:505 ../src/Tutorial/Functions2.md:16
#: ../src/Tutorial/Functions2.md:94 ../src/Tutorial/Functions2.md:164
#: ../src/Tutorial/Functions2.md:203 ../src/Tutorial/Functions2.md:220
#: ../src/Tutorial/Functions2.md:249 ../src/Tutorial/Functions2.md:277
#: ../src/Tutorial/Functions2.md:319 ../src/Tutorial/Functions2.md:372
#: ../src/Tutorial/Functions2.md:391 ../src/Tutorial/Functions2.md:408
#: ../src/Tutorial/Functions2.md:426 ../src/Tutorial/Functions2.md:440
#: ../src/Tutorial/Functions2.md:447 ../src/Tutorial/Functions2.md:455
#: ../src/Tutorial/Functions2.md:472 ../src/Tutorial/Functions2.md:510
#: ../src/Tutorial/Functions2.md:624 ../src/Tutorial/Functions2.md:634
#: ../src/Tutorial/Functions2.md:646 ../src/Tutorial/Functions2.md:659
#: ../src/Tutorial/Functions2.md:670 ../src/Tutorial/Functions2.md:707
#: ../src/Tutorial/Functions2.md:780 ../src/Tutorial/Functions2.md:869
#: ../src/Tutorial/Functions2.md:880 ../src/Tutorial/Functor.md:18
#: ../src/Tutorial/Functor.md:54 ../src/Tutorial/Functor.md:63
#: ../src/Tutorial/Functor.md:73 ../src/Tutorial/Functor.md:84
#: ../src/Tutorial/Functor.md:95 ../src/Tutorial/Functor.md:111
#: ../src/Tutorial/Functor.md:126 ../src/Tutorial/Functor.md:139
#: ../src/Tutorial/Functor.md:167 ../src/Tutorial/Functor.md:236
#: ../src/Tutorial/Functor.md:260 ../src/Tutorial/Functor.md:270
#: ../src/Tutorial/Functor.md:285 ../src/Tutorial/Functor.md:298
#: ../src/Tutorial/Functor.md:314 ../src/Tutorial/Functor.md:340
#: ../src/Tutorial/Functor.md:351 ../src/Tutorial/Functor.md:392
#: ../src/Tutorial/Functor.md:408 ../src/Tutorial/Functor.md:417
#: ../src/Tutorial/Functor.md:429 ../src/Tutorial/Functor.md:442
#: ../src/Tutorial/Functor.md:456 ../src/Tutorial/Functor.md:479
#: ../src/Tutorial/Functor.md:494 ../src/Tutorial/Functor.md:512
#: ../src/Tutorial/Functor.md:531 ../src/Tutorial/Functor.md:551
#: ../src/Tutorial/Functor.md:576 ../src/Tutorial/Functor.md:622
#: ../src/Tutorial/Functor.md:651 ../src/Tutorial/Functor.md:660
#: ../src/Tutorial/Functor.md:676 ../src/Tutorial/Functor.md:693
#: ../src/Tutorial/Functor.md:704 ../src/Tutorial/Functor.md:750
#: ../src/Tutorial/Functor.md:761 ../src/Tutorial/Functor.md:773
#: ../src/Tutorial/Functor.md:784 ../src/Tutorial/Functor.md:828
#: ../src/Tutorial/Functor.md:842 ../src/Tutorial/Functor.md:860
#: ../src/Tutorial/Functor.md:872 ../src/Tutorial/Functor.md:888
#: ../src/Tutorial/Functor.md:926 ../src/Tutorial/Functor.md:945
#: ../src/Tutorial/Functor.md:971 ../src/Tutorial/Functor.md:1082
#: ../src/Tutorial/Functor.md:1122 ../src/Tutorial/Functor.md:1135
#: ../src/Tutorial/Functor.md:1199 ../src/Tutorial/Functor.md:1257
#: ../src/Tutorial/Functor.md:1268 ../src/Tutorial/Functor.md:1278
#: ../src/Tutorial/Functor.md:1285 ../src/Tutorial/Interfaces.md:10
#: ../src/Tutorial/Interfaces.md:43 ../src/Tutorial/Interfaces.md:62
#: ../src/Tutorial/Interfaces.md:71 ../src/Tutorial/Interfaces.md:100
#: ../src/Tutorial/Interfaces.md:117 ../src/Tutorial/Interfaces.md:159
#: ../src/Tutorial/Interfaces.md:234 ../src/Tutorial/Interfaces.md:255
#: ../src/Tutorial/Interfaces.md:274 ../src/Tutorial/Interfaces.md:296
#: ../src/Tutorial/Interfaces.md:321 ../src/Tutorial/Interfaces.md:333
#: ../src/Tutorial/Interfaces.md:341 ../src/Tutorial/Interfaces.md:362
#: ../src/Tutorial/Interfaces.md:456 ../src/Tutorial/Interfaces.md:466
#: ../src/Tutorial/Interfaces.md:475 ../src/Tutorial/Interfaces.md:498
#: ../src/Tutorial/Interfaces.md:534 ../src/Tutorial/Interfaces.md:552
#: ../src/Tutorial/Interfaces.md:561 ../src/Tutorial/Interfaces.md:650
#: ../src/Tutorial/Interfaces.md:661 ../src/Tutorial/Interfaces.md:677
#: ../src/Tutorial/Interfaces.md:695 ../src/Tutorial/Interfaces.md:716
#: ../src/Tutorial/Interfaces.md:727 ../src/Tutorial/Intro.md:20
#: ../src/Tutorial/Intro.md:191 ../src/Tutorial/Intro.md:252
#: ../src/Tutorial/Intro.md:287 ../src/Tutorial/Intro.md:312
#: ../src/Tutorial/IO.md:8 ../src/Tutorial/IO.md:25 ../src/Tutorial/IO.md:84
#: ../src/Tutorial/IO.md:121 ../src/Tutorial/IO.md:217
#: ../src/Tutorial/IO.md:232 ../src/Tutorial/IO.md:240
#: ../src/Tutorial/IO.md:255 ../src/Tutorial/IO.md:299
#: ../src/Tutorial/IO.md:334 ../src/Tutorial/IO.md:342
#: ../src/Tutorial/IO.md:352 ../src/Tutorial/IO.md:374
#: ../src/Tutorial/IO.md:405 ../src/Tutorial/IO.md:417
#: ../src/Tutorial/IO.md:472 ../src/Tutorial/IO.md:493
#: ../src/Tutorial/IO.md:506 ../src/Tutorial/IO.md:517
#: ../src/Tutorial/IO.md:528 ../src/Tutorial/IO.md:563
#: ../src/Tutorial/IO.md:581 ../src/Tutorial/IO.md:650
#: ../src/Tutorial/IO.md:689 ../src/Tutorial/IO.md:696
#: ../src/Tutorial/IO.md:705 ../src/Tutorial/IO.md:713
#: ../src/Tutorial/IO.md:734 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/IO.md:875 ../src/Tutorial/IO.md:920
#: ../src/Tutorial/IO.md:960 ../src/Tutorial/IO.md:984
#: ../src/Tutorial/IO.md:997 ../src/Tutorial/Predicates.md:13
#: ../src/Tutorial/Predicates.md:108 ../src/Tutorial/Predicates.md:118
#: ../src/Tutorial/Predicates.md:139 ../src/Tutorial/Predicates.md:153
#: ../src/Tutorial/Predicates.md:165 ../src/Tutorial/Predicates.md:191
#: ../src/Tutorial/Predicates.md:203 ../src/Tutorial/Predicates.md:212
#: ../src/Tutorial/Predicates.md:224 ../src/Tutorial/Predicates.md:235
#: ../src/Tutorial/Predicates.md:252 ../src/Tutorial/Predicates.md:259
#: ../src/Tutorial/Predicates.md:277 ../src/Tutorial/Predicates.md:288
#: ../src/Tutorial/Predicates.md:352 ../src/Tutorial/Predicates.md:359
#: ../src/Tutorial/Predicates.md:368 ../src/Tutorial/Predicates.md:387
#: ../src/Tutorial/Predicates.md:406 ../src/Tutorial/Predicates.md:416
#: ../src/Tutorial/Predicates.md:447 ../src/Tutorial/Predicates.md:475
#: ../src/Tutorial/Predicates.md:493 ../src/Tutorial/Predicates.md:532
#: ../src/Tutorial/Predicates.md:550 ../src/Tutorial/Predicates.md:568
#: ../src/Tutorial/Predicates.md:603 ../src/Tutorial/Predicates.md:620
#: ../src/Tutorial/Predicates.md:639 ../src/Tutorial/Predicates.md:658
#: ../src/Tutorial/Predicates.md:719 ../src/Tutorial/Predicates.md:747
#: ../src/Tutorial/Predicates.md:768 ../src/Tutorial/Predicates.md:784
#: ../src/Tutorial/Predicates.md:798 ../src/Tutorial/Predicates.md:812
#: ../src/Tutorial/Predicates.md:821 ../src/Tutorial/Predicates.md:835
#: ../src/Tutorial/Predicates.md:850 ../src/Tutorial/Predicates.md:862
#: ../src/Tutorial/Predicates.md:872 ../src/Tutorial/Predicates.md:951
#: ../src/Tutorial/Predicates.md:963 ../src/Tutorial/Predicates.md:983
#: ../src/Tutorial/Predicates.md:999 ../src/Tutorial/Predicates.md:1024
#: ../src/Tutorial/Predicates.md:1035 ../src/Tutorial/Predicates.md:1044
#: ../src/Tutorial/Predicates.md:1066 ../src/Tutorial/Predicates.md:1080
#: ../src/Tutorial/Predicates.md:1094 ../src/Tutorial/Predicates.md:1105
#: ../src/Tutorial/Predicates.md:1113 ../src/Tutorial/Predicates.md:1121
#: ../src/Tutorial/Predicates.md:1134 ../src/Tutorial/Predicates.md:1163
#: ../src/Tutorial/Predicates.md:1199 ../src/Tutorial/Predicates.md:1236
#: ../src/Tutorial/Predicates.md:1287 ../src/Tutorial/Prim.md:8
#: ../src/Tutorial/Prim.md:164 ../src/Tutorial/Prim.md:175
#: ../src/Tutorial/Prim.md:190 ../src/Tutorial/Prim.md:201
#: ../src/Tutorial/Prim.md:210 ../src/Tutorial/Prim.md:218
#: ../src/Tutorial/Prim.md:232 ../src/Tutorial/Prim.md:246
#: ../src/Tutorial/Prim.md:263 ../src/Tutorial/Prim.md:271
#: ../src/Tutorial/Prim.md:324 ../src/Tutorial/Prim.md:346
#: ../src/Tutorial/Prim.md:357 ../src/Tutorial/Prim.md:389
#: ../src/Tutorial/Prim.md:399 ../src/Tutorial/Prim.md:412
#: ../src/Tutorial/Prim.md:425 ../src/Tutorial/Prim.md:672
#: ../src/Tutorial/Prim.md:684 ../src/Tutorial/Prim.md:757
#: ../src/Tutorial/Prim.md:768 ../src/Tutorial/Prim.md:780
#: ../src/Tutorial/Prim.md:801 ../src/Tutorial/Prim.md:809
#: ../src/Tutorial/Prim.md:818 ../src/Tutorial/Prim.md:840
#: ../src/Tutorial/Prim.md:892 ../src/Tutorial/Prim.md:911
#: ../src/Tutorial/Prim.md:926 ../src/Tutorial/Prim.md:984
#: ../src/Tutorial/Prim.md:1026 ../src/Tutorial/Prim.md:1046
#: ../src/Tutorial/Prim.md:1064 ../src/Tutorial/Prim.md:1073
#: ../src/Tutorial/Prim.md:1087 ../src/Tutorial/Prim.md:1101
#: ../src/Tutorial/Prim.md:1118 ../src/Tutorial/Prim.md:1176
#: ../src/Tutorial/Prim.md:1208 ../src/Tutorial/Traverse.md:17
#: ../src/Tutorial/Traverse.md:52 ../src/Tutorial/Traverse.md:62
#: ../src/Tutorial/Traverse.md:82 ../src/Tutorial/Traverse.md:105
#: ../src/Tutorial/Traverse.md:140 ../src/Tutorial/Traverse.md:173
#: ../src/Tutorial/Traverse.md:183 ../src/Tutorial/Traverse.md:194
#: ../src/Tutorial/Traverse.md:203 ../src/Tutorial/Traverse.md:267
#: ../src/Tutorial/Traverse.md:276 ../src/Tutorial/Traverse.md:285
#: ../src/Tutorial/Traverse.md:295 ../src/Tutorial/Traverse.md:308
#: ../src/Tutorial/Traverse.md:325 ../src/Tutorial/Traverse.md:332
#: ../src/Tutorial/Traverse.md:370 ../src/Tutorial/Traverse.md:388
#: ../src/Tutorial/Traverse.md:398 ../src/Tutorial/Traverse.md:406
#: ../src/Tutorial/Traverse.md:414 ../src/Tutorial/Traverse.md:463
#: ../src/Tutorial/Traverse.md:471 ../src/Tutorial/Traverse.md:489
#: ../src/Tutorial/Traverse.md:497 ../src/Tutorial/Traverse.md:506
#: ../src/Tutorial/Traverse.md:514 ../src/Tutorial/Traverse.md:525
#: ../src/Tutorial/Traverse.md:543 ../src/Tutorial/Traverse.md:591
#: ../src/Tutorial/Traverse.md:605 ../src/Tutorial/Traverse.md:771
#: ../src/Tutorial/Traverse.md:831 ../src/Tutorial/Traverse.md:852
#: ../src/Tutorial/Traverse.md:867 ../src/Tutorial/Traverse.md:899
#: ../src/Tutorial/Traverse.md:909 ../src/Tutorial/Traverse.md:929
#: ../src/Tutorial/Traverse.md:939 ../src/Tutorial/Traverse.md:975
#: ../src/Tutorial/Traverse.md:1030 ../src/Tutorial/Traverse.md:1056
#: ../src/Tutorial/Traverse.md:1067 ../src/Tutorial/Traverse.md:1077
#: ../src/Tutorial/Traverse.md:1095
#, no-wrap
msgid "idris"
msgstr "idris"

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:39 ../src/Tutorial/DataTypes.md:234
#: ../src/Tutorial/DataTypes.md:241 ../src/Tutorial/DataTypes.md:310
#: ../src/Tutorial/DataTypes.md:337 ../src/Tutorial/DataTypes.md:390
#: ../src/Tutorial/DataTypes.md:427 ../src/Tutorial/DataTypes.md:494
#: ../src/Tutorial/DataTypes.md:646 ../src/Tutorial/DataTypes.md:840
#: ../src/Tutorial/DataTypes.md:1009 ../src/Tutorial/DataTypes.md:1016
#: ../src/Tutorial/DataTypes.md:1024 ../src/Tutorial/DataTypes.md:1031
#: ../src/Tutorial/DataTypes.md:1038 ../src/Tutorial/DataTypes.md:1045
#: ../src/Tutorial/Dependent.md:197 ../src/Tutorial/Dependent.md:204
#: ../src/Tutorial/Dependent.md:239 ../src/Tutorial/Dependent.md:245
#: ../src/Tutorial/Dependent.md:309 ../src/Tutorial/Dependent.md:346
#: ../src/Tutorial/Dependent.md:364 ../src/Tutorial/Dependent.md:631
#: ../src/Tutorial/Dependent.md:866 ../src/Tutorial/DPair.md:66
#: ../src/Tutorial/DPair.md:234 ../src/Tutorial/DPair.md:713
#: ../src/Tutorial/Eq.md:74 ../src/Tutorial/Eq.md:93 ../src/Tutorial/Eq.md:153
#: ../src/Tutorial/Eq.md:397 ../src/Tutorial/Eq.md:404
#: ../src/Tutorial/Eq.md:436 ../src/Tutorial/Eq.md:505
#: ../src/Tutorial/Eq.md:518 ../src/Tutorial/Eq.md:679
#: ../src/Tutorial/Eq.md:778 ../src/Tutorial/Eq.md:984
#: ../src/Tutorial/Eq.md:1014 ../src/Tutorial/Folds.md:198
#: ../src/Tutorial/Folds.md:787 ../src/Tutorial/Folds.md:798
#: ../src/Tutorial/Folds.md:822 ../src/Tutorial/Folds.md:839
#: ../src/Tutorial/Folds.md:880 ../src/Tutorial/Folds.md:904
#: ../src/Tutorial/Functions1.md:37 ../src/Tutorial/Functions1.md:143
#: ../src/Tutorial/Functions1.md:165 ../src/Tutorial/Functions1.md:204
#: ../src/Tutorial/Functions1.md:228 ../src/Tutorial/Functions1.md:253
#: ../src/Tutorial/Functions1.md:261 ../src/Tutorial/Functions1.md:312
#: ../src/Tutorial/Functions1.md:333 ../src/Tutorial/Functions1.md:358
#: ../src/Tutorial/Functions1.md:366 ../src/Tutorial/Functions1.md:378
#: ../src/Tutorial/Functions1.md:488 ../src/Tutorial/Functions1.md:519
#: ../src/Tutorial/Functions1.md:568 ../src/Tutorial/Functions2.md:42
#: ../src/Tutorial/Functions2.md:63 ../src/Tutorial/Functions2.md:74
#: ../src/Tutorial/Functions2.md:114 ../src/Tutorial/Functions2.md:528
#: ../src/Tutorial/Functions2.md:541 ../src/Tutorial/Functions2.md:553
#: ../src/Tutorial/Functions2.md:560 ../src/Tutorial/Functions2.md:567
#: ../src/Tutorial/Functions2.md:719 ../src/Tutorial/Functions2.md:726
#: ../src/Tutorial/Functions2.md:735 ../src/Tutorial/Functions2.md:755
#: ../src/Tutorial/Functions2.md:763 ../src/Tutorial/Functions2.md:787
#: ../src/Tutorial/Functions2.md:811 ../src/Tutorial/Functions2.md:819
#: ../src/Tutorial/Functions2.md:835 ../src/Tutorial/Functions2.md:848
#: ../src/Tutorial/Functions2.md:899 ../src/Tutorial/Functor.md:187
#: ../src/Tutorial/Functor.md:201 ../src/Tutorial/Functor.md:216
#: ../src/Tutorial/Functor.md:610 ../src/Tutorial/Functor.md:801
#: ../src/Tutorial/Functor.md:903 ../src/Tutorial/Functor.md:1001
#: ../src/Tutorial/Functor.md:1100 ../src/Tutorial/Functor.md:1167
#: ../src/Tutorial/Functor.md:1219 ../src/Tutorial/Interfaces.md:36
#: ../src/Tutorial/Interfaces.md:140 ../src/Tutorial/Interfaces.md:505
#: ../src/Tutorial/Intro.md:122 ../src/Tutorial/Intro.md:134
#: ../src/Tutorial/Intro.md:148 ../src/Tutorial/Intro.md:158
#: ../src/Tutorial/Intro.md:167 ../src/Tutorial/Intro.md:227
#: ../src/Tutorial/Intro.md:270 ../src/Tutorial/Intro.md:279
#: ../src/Tutorial/Intro.md:300 ../src/Tutorial/Intro.md:326
#: ../src/Tutorial/Intro.md:337 ../src/Tutorial/Intro.md:349
#: ../src/Tutorial/IO.md:33 ../src/Tutorial/IO.md:94 ../src/Tutorial/IO.md:433
#: ../src/Tutorial/IO.md:442 ../src/Tutorial/IO.md:539
#: ../src/Tutorial/IO.md:621 ../src/Tutorial/IO.md:634
#: ../src/Tutorial/IO.md:1020 ../src/Tutorial/IO.md:1040
#: ../src/Tutorial/IO.md:1050 ../src/Tutorial/IO.md:1060
#: ../src/Tutorial/Predicates.md:428 ../src/Tutorial/Predicates.md:462
#: ../src/Tutorial/Predicates.md:926 ../src/Tutorial/Predicates.md:1337
#: ../src/Tutorial/Prim.md:124 ../src/Tutorial/Prim.md:312
#: ../src/Tutorial/Prim.md:527 ../src/Tutorial/Prim.md:550
#: ../src/Tutorial/Prim.md:574 ../src/Tutorial/Prim.md:584
#: ../src/Tutorial/Prim.md:596 ../src/Tutorial/Prim.md:611
#: ../src/Tutorial/Prim.md:622 ../src/Tutorial/Prim.md:638
#: ../src/Tutorial/Prim.md:647 ../src/Tutorial/Prim.md:703
#: ../src/Tutorial/Prim.md:1129 ../src/Tutorial/Traverse.md:38
#: ../src/Tutorial/Traverse.md:123 ../src/Tutorial/Traverse.md:158
#: ../src/Tutorial/Traverse.md:421 ../src/Tutorial/Traverse.md:737
#: ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid "repl"
msgstr "repl"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:1 ../src/Tutorial/Intro.md:76
#, no-wrap
msgid "Dependent Types"
msgstr "依赖类型"

#. type: Code fence info string
#: ../src/Tutorial/Folds.md:145 ../src/Tutorial/Folds.md:241
#: ../src/Tutorial/Folds.md:326 ../src/Tutorial/Folds.md:582
#: ../src/Tutorial/Intro.md:199 ../src/Tutorial/Intro.md:208
#: ../src/Tutorial/Intro.md:223 ../src/Tutorial/Prim.md:38
#, no-wrap
msgid "sh"
msgstr "sh"

#. type: Title ###
#: ../src/Tutorial/Functor.md:1420 ../src/Tutorial/Intro.md:430
#, no-wrap
msgid "What's next?"
msgstr "下一步是什么？"

#. type: Title #
#: ../src/Tutorial/Intro.md:1
#, no-wrap
msgid "Introduction"
msgstr "介绍"

#. type: Plain text
#: ../src/Tutorial/Intro.md:15
msgid ""
"Welcome to my Idris 2 tutorial. I'll try and treat as many aspects of the "
"Idris 2 programming language as possible here.  All `.md` files in here a "
"literate Idris files: They consist of Markdown (hence the `.md` ending), "
"which is being pretty printed by GitHub together with Idris code blocks, "
"which can be type checked and built by the Idris compiler (more on this "
"later).  Note, however, that regular Idris source files use an `.idr` "
"ending, and that you go with that file type unless you end up writing much "
"more prose than code as I do at the moment. Later in this tutorial, you'll "
"have to solve some exercises, the solutions of which can be found in the "
"`src/Solutions` subfolder. There, I use regular `.idr` files."
msgstr ""
"欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方"
"面。这里的所有 `.md` 文件都是一个识字的 Idris 文件：它们由 Markdown 组成（因"
"此以 `.md` 结尾），由 GitHub 与 Idris 代码块一起打印出来，可以由 Idris 编译器"
"进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `."
"idr` 结尾，并且除非您最终编写的代码比我现在所做的更啰嗦，否则您将使用该文件类"
"型。在本教程的后面，您将需要解决一些练习，这些练习的答案可以在 `src/"
"Solutions` 子文件夹中找到。在那里，我使用常规的 `.idr` 文件。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:19
msgid ""
"Every Idris source file should typically start with a module name plus some "
"necessary imports, and this document is no exception:"
msgstr ""
"每个 Idris 源文件通常应该以模块名称和一些必要的导入开头，本文档也不例外："

#. type: Plain text
#: ../src/Tutorial/Intro.md:20
#, no-wrap
msgid "module Tutorial.Intro\n"
msgstr "module Tutorial.Intro\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:27
msgid ""
"A module name consists of a list of identifiers separated by dots and must "
"reflect the folder structure plus the module file's name."
msgstr ""
"模块名称由以点分隔的标识符列表组成，并且必须反映文件夹结构加上模块文件的名"
"称。"

#. type: Title ##
#: ../src/Tutorial/Intro.md:28
#, no-wrap
msgid "About the Idris Programming Language"
msgstr "关于 Idris 编程语言"

#. type: Plain text
#: ../src/Tutorial/Intro.md:33
msgid ""
"Idris is a *pure*, *dependently typed*, *total* *functional* programming "
"language. I'll quickly explain each of these adjectives in this section."
msgstr ""
"Idris 是一种*纯的*、*依赖类型*、具有*完全**函数* 的编程语言。我将在本节中快速"
"解释这些形容词。"

#. type: Title ###
#: ../src/Tutorial/Intro.md:34
#, no-wrap
msgid "Functional Programming"
msgstr "函数式编程"

#. type: Plain text
#: ../src/Tutorial/Intro.md:42
msgid ""
"In functional programming languages, functions are first-class constructs, "
"meaning that they can be assigned to variables, passed as arguments to other "
"functions, and returned as results from functions. Unlike for instance in "
"object-oriented programming languages, in functional programming, functions "
"are the main form of abstraction."
msgstr ""
"在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递"
"给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，"
"函数是抽象的主要形式。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:46
msgid ""
"Functional programming languages are concerned with the evaluation of "
"functions, unlike classical imperative languages, which are concerned with "
"the execution of statements."
msgstr "函数式编程语言关注函数的求值，不像经典的命令式语言关注语句的执行。"

#. type: Title ###
#: ../src/Tutorial/Intro.md:47
#, no-wrap
msgid "Pure Functional Programming"
msgstr "纯函数式编程"

#. type: Plain text
#: ../src/Tutorial/Intro.md:57
msgid ""
"Pure functional programming languages come with an additional important "
"guarantee: Functions don't have side effects like writing to a file or "
"mutating global state. They can only compute a result from their arguments "
"possibly by invoking other pure functions, *and nothing else*. As a "
"consequence, given the same input, they will *always* generate the same "
"output.  This property is known as [referential transparency](https://en."
"wikipedia.org/wiki/Referential_transparency)."
msgstr ""
"纯函数式编程语言有一个额外的重要保证：函数不会产生像写入文件或改变全局状态这"
"样的副作用。他们只能通过调用其他纯函数，给定参数来获取计算结果，*而没有其他获"
"取数据的途径*。因此，给定相同的输入，它们将*总是*生成相同的输出。此属性称为 "
"[引用透明](https://en.wikipedia.org/wiki/Referential_transparency)。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:59
msgid "Pure functions have several advantages:"
msgstr "纯函数有几个优点："

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:62
msgid ""
"They can easily be tested by specifying (possibly randomly generated)  sets "
"of input arguments together with the expected results."
msgstr "它们可以通过指定（可能是随机生成的）输入参数集以及预期结果来轻松测试。"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:66
msgid ""
"They are thread-safe, since the don't mutate global state, and as such can "
"be freely used in several computations running in parallel."
msgstr ""
"它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使"
"用。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:68
msgid "There are, of course, also some disadvantages:"
msgstr "当然，也有一些缺点："

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:71
msgid ""
"Some algorithms are hard to implement efficiently using only pure functions."
msgstr "仅使用纯函数很难有效地实现某些算法。"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:75
msgid ""
"Writing programs that actually *do* something (have some observable effect) "
"is a bit trickier but certainly possible."
msgstr ""
"编写实际上*做*某些事情（具有一些可观察到的效果）的程序有点棘手，但肯定是可能"
"的。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:83
msgid ""
"Idris is a strongly, statically typed programming language. This means, that "
"ever Idris expression is given a *type* (for instance: integer, list of "
"strings, boolean, function from integer to boolean, etc.)  and types are "
"verified at compile time to rule out certain common programming errors."
msgstr ""
"Idris 是一种强静态类型的编程语言。这意味着，给 Idris 表达式一个*类型*（例如："
"整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排"
"除某些常见的编程错误。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:89
msgid ""
"For instance, if a function expects an argument of type `String` (a sequence "
"of unicode characters, such as `\"Hello123\"`), it is a *type error* to "
"invoke this function with an argument of type `Integer`, and the Idris "
"compiler will refuse to generate an executable from such an ill-typed "
"program."
msgstr ""
"例如，如果一个函数需要 `String` 类型的参数（Unicode 字符序列，例如 `"
"\"Hello123\"`），使用 `Integer` 类型的参数调用此函数则它是*类型错误*的，"
"Idris 编译器将拒绝从此类错误类型的程序生成可执行文件。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:97
msgid ""
"Even more, Idris is *dependently typed*, which is one of its most "
"characteristic properties in the landscape of programming languages. In "
"Idris, types are *first class*: Types can be passed as arguments to "
"functions, and functions can return types as their results. Even more, types "
"can *depend* on other *values*.  What this means, and why this is incredibly "
"useful, we'll explore in due time."
msgstr ""
"更重要的是，Idris 具有*依赖类型*，这是它在编程语言领域中最具特色的属性之一。"
"在 Idris 中，类型是* 一等*的：类型可以作为参数传递给函数，函数可以返回类型作"
"为结果。更重要的是，类型可以*依赖于*其他*值*。这意味着什么，以及为什么这非常"
"有用，我们将在适当的时候进行探索。"

#. type: Title ###
#: ../src/Tutorial/Intro.md:98
#, no-wrap
msgid "Total Functions"
msgstr "完全函数"

#. type: Plain text
#: ../src/Tutorial/Intro.md:104
msgid ""
"A *total* function is a pure function, that is guaranteed to return a value "
"of the expected return type for every possible input in a finite amount of "
"time. A total function will never fail with an exception or loop infinitely."
msgstr ""
"*完全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回"
"类型的值。一个完全函数永远不会因异常或无限循环而失败。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:113
msgid ""
"Idris comes with a totality checker built in, which enables us to verify the "
"functions we write to be provably total. Totality in Idris is opt-in, as in "
"general, checking the totality of an arbitrary computer program is "
"undecidable (see also the [halting problem](https://en.wikipedia.org/wiki/"
"Halting_problem)).  However, if we annotate a function with the `total` "
"keyword, Idris will fail with a type error, if its totality checker cannot "
"verify that the function in question is indeed total."
msgstr ""
"Idris 内置了一个完全性检查器，它使我们能够验证我们编写的函数是否是可证明的完"
"全性。 Idris 中的完全性是可选的，因为一般来说，检查任意计算机程序的完全性是无"
"法确定的（另请参见 [停机问题](https://en.wikipedia.org/wiki/"
"Halting_problem)）。但是，如果我们使用 `total` 关键字注释函数，如果 Idris 的"
"完全性检查器无法验证所讨论的函数确实是完全的，则 Idris 将失败并出现类型错误。"

#. type: Title ##
#: ../src/Tutorial/Intro.md:114
#, no-wrap
msgid "Using the REPL"
msgstr "使用 REPL"

#. type: Plain text
#: ../src/Tutorial/Intro.md:121
msgid ""
"Idris comes with a useful REPL (an acronym for *Read Evaluate Print Loop*), "
"which we will use for tinkering with small ideas, and for quickly "
"experimenting with the code we just wrote.  In order to start a REPL "
"session, run the following command in a terminal."
msgstr ""
"Idris 附带了一个有用的 REPL（*Read Evaluate Print Loop* 的首字母缩写词），我"
"们将使用它来修补小想法，并快速试验我们刚刚编写的代码。要启动 REPL 会话，请在"
"终端中运行以下命令。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:122
#, no-wrap
msgid "rlwrap idris2\n"
msgstr "rlwrap idris2\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:131
msgid ""
"(Using command-line utility `rlwrap` is optional. It leads to a somewhat "
"nicer user experience, as it allows us to use the up and down arrow keys to "
"scroll through a history of commands and expressions we entered. It should "
"be available for most Linux distributions.)"
msgstr ""
"（使用命令行实用程序 `rlwrap` 是可选的。它带来了更好的用户体验，因为它允许我"
"们使用向上和向下箭头键滚动浏览我们输入的命令和表达式的历史记录。它应该适用于"
"大多数 Linux 发行版。）"

#. type: Plain text
#: ../src/Tutorial/Intro.md:133
msgid "Idris should now be ready to accept you commands:"
msgstr "Idris 现在应该准备好接受你的命令了："

#. type: Plain text
#: ../src/Tutorial/Intro.md:134
#, no-wrap
msgid ""
"     ____    __     _         ___\n"
"    /  _/___/ /____(_)____   |__ \\\n"
"    / // __  / ___/ / ___/   __/ /     Version 0.5.1-3c532ea35\n"
"  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org\n"
" /___/\\__,_/_/  /_/____/   /____/      Type :? for help\n"
"\n"
"Welcome to Idris 2.  Enjoy yourself!\n"
"Main>\n"
msgstr ""
"     ____    __     _         ___\n"
"    /  _/___/ /____(_)____   |__ \\\n"
"    / // __  / ___/ / ___/   __/ /     Version 0.5.1-3c532ea35\n"
"  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org\n"
" /___/\\__,_/_/  /_/____/   /____/      Type :? for help\n"
"\n"
"Welcome to Idris 2.  Enjoy yourself!\n"
"Main>\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:147
msgid ""
"We can go ahead and enter some simple arithmetic expressions. Idris will "
"*evaluate* these and print the result:"
msgstr "我们可以继续输入一些简单的算术表达式。 Idris 将进行*求值*并打印结果："

#. type: Plain text
#: ../src/Tutorial/Intro.md:148
#, no-wrap
msgid ""
"Main> 2 * 4\n"
"8\n"
"Main> 3 * (7 + 100)\n"
"321\n"
msgstr ""
"Main> 2 * 4\n"
"8\n"
"Main> 3 * (7 + 100)\n"
"321\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:157
msgid ""
"Since every expression in Idris has an associated *type*, we might want to "
"inspect these as well:"
msgstr ""
"由于 Idris 中的每个表达式都有一个关联的* 类型 *，我们可能还想检查这些："

#. type: Plain text
#: ../src/Tutorial/Intro.md:158
#, no-wrap
msgid ""
"Main> :t 2\n"
"2 : Integer\n"
msgstr ""
"Main> :t 2\n"
"2 : Integer\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:166
msgid ""
"Here `:t` is a command of the Idris REPL (it is not part of the Idris "
"programming language), and it is used to inspect the type of an expression."
msgstr ""
"这里的 `:t` 是 Idris REPL 的命令（它不是 Idris 编程语言的一部分），它用于检查"
"表达式的类型。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:167
#, no-wrap
msgid ""
"Main> :t 2 * 4\n"
"2 * 4 : Integer\n"
msgstr ""
"Main> :t 2 * 4\n"
"2 * 4 : Integer\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:182
msgid ""
"Whenever we perform calculations with integer literals without being "
"explicit about the types we want to use, Idris will use `Integer` as a "
"default. `Integer` is an arbitrary precision signed integer type. It is one "
"of the *primitive types* built into the language. Other primitives include "
"fixed precision signed and unsigned integral types (`Bits8`, `Bits16`, "
"`Bits32` `Bits64`, `Int8`, `Int16`, `Int32`, and `Int64`), double precision "
"(64 bit) floating point numbers (`Double`), unicode characters (`Char`) and "
"strings of unicode characters (`String`).  We will use many of these in due "
"time."
msgstr ""
"每当我们使用整数字面量执行计算而没有明确说明我们想要使用的类型时，Idris 将使"
"用 `Integer` 作为默认值。 `Integer` 是任意精度的有符号整数类型。它是语言中内"
"置的*原语类型*之一。其他原语包括固定精度有符号和无符号整数类型（`Bits8`、"
"`Bits16`、`Bits32` `Bits64`、`Int8`、 `Int16`、`Int32` 和 `Int64`）、双精度"
"（64 位）浮点数（`Double`）、Unicode 字符（`Char`) 和 unicode 字符串 "
"(`String`)。我们将在适当的时候使用其中的大多数。"

#. type: Title ##
#: ../src/Tutorial/Intro.md:183
#, no-wrap
msgid "A First Idris Program"
msgstr "第一个 Idris 程序"

#. type: Plain text
#: ../src/Tutorial/Intro.md:190
msgid ""
"We will often start up a REPL for tinkering with small parts of the Idris "
"language, for reading some documentation, or for inspecting the content of "
"an Idris module, but now we will write a minimal Idris program to get "
"started with the language. Here comes the mandatory *Hello World*:"
msgstr ""
"我们经常会启动一个 REPL 来修补 Idris 语言的一小部分，阅读一些文档，或检查 "
"Idris 模块的内容，但现在我们将编写一个最小的 Idris 程序来开始使用该语言。这是"
"强制性的 *Hello World*："

#. type: Plain text
#: ../src/Tutorial/Intro.md:191
#, no-wrap
msgid ""
"main : IO ()\n"
"main = putStrLn \"Hello World!\"\n"
msgstr ""
"main : IO ()\n"
"main = putStrLn \"Hello World!\"\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:199
msgid ""
"We will inspect the code above in some detail in a moment, but first we'd "
"like to compile and run it. From this project's root directory, run the "
"following:"
msgstr ""
"稍后我们将详细检查上面的代码，但首先我们要编译并运行它。在此项目的根目录中，"
"运行以下命令："

#. type: Plain text
#: ../src/Tutorial/Intro.md:199
#, no-wrap
msgid "idris2 --find-ipkg -o hello src/Tutorial/Intro.md\n"
msgstr "idris2 --find-ipkg -o hello src/Tutorial/Intro.md\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:207
msgid ""
"This will create executable `hello` in directory `build/exec`, which can be "
"invoked from the command-line like so (without the dollar prefix; this is "
"used here to distinguish the terminal command from its output):"
msgstr ""
"这将在目录 `build/exec` 中创建可执行文件 `hello`，可以像这样从命令行调用它"
"（没有美元前缀；这里用来区分终端命令和它的输出）："

#. type: Plain text
#: ../src/Tutorial/Intro.md:208
#, no-wrap
msgid ""
"$ build/exec/hello\n"
"Hello World!\n"
msgstr ""
"$ build/exec/hello\n"
"Hello World!\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:219
msgid ""
"The `--find-ipkg` option will look for an `.ipkg` file in the current "
"directory or one of its parent directories, from which it will get other "
"settings like the source directory to use (`src` in our case). The `-o` "
"option gives the name of the executable to be generated. Type `idris2 --"
"help` for a list of available command-line options and environment variables."
msgstr ""
"`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他"
"设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可"
"执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:222
msgid ""
"As an alternative, you can also load this source file in a REPL session and "
"invoke function `main` from there:"
msgstr ""
"作为替代方案，您还可以在 REPL 会话中加载此源文件并从那里调用函数 `main`："

#. type: Plain text
#: ../src/Tutorial/Intro.md:223
#, no-wrap
msgid "rlwrap idris2 --find-ipkg src/Tutorial/Intro.md\n"
msgstr "rlwrap idris2 --find-ipkg src/Tutorial/Intro.md\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:227
#, no-wrap
msgid ""
"Tutorial.Intro> :exec main\n"
"Hello World!\n"
msgstr ""
"Tutorial.Intro> :exec main\n"
"Hello World!\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:234
msgid ""
"Go ahead and try both ways of building and running function `main` on your "
"system!"
msgstr "继续尝试在您的系统上构建和运行函数 `main` 的两种方法！"

#. type: Plain text
#: ../src/Tutorial/Intro.md:239
msgid ""
"Note: It might be instructive to omit the `--find-ipkg` option.  You will "
"get an error message about the module name `Tutorial.Intro` not matching the "
"file path `src/Tutorial/Intro.md`. You can also use option `--source-dir "
"src` to silence this error."
msgstr ""
"注意：省略 `--find-ipkg` 选项可能是有益的。您将收到有关模块名称 `Tutorial."
"Intro` 与文件路径 `src/Tutorial/Intro.md` 不匹配的错误消息。您还可以使用选项 "
"`--source-dir src` 来消除此错误。"

#. type: Title ##
#: ../src/Tutorial/Intro.md:240
#, no-wrap
msgid "The Shape of an Idris Definition"
msgstr "一个 Idris 定义包含什么"

#. type: Plain text
#: ../src/Tutorial/Intro.md:244
msgid ""
"Now that we executed our first Idris program, we will talk a bit more about "
"the code we had to write to define it."
msgstr ""
"现在我们执行了第一个 Idris 程序，我们将更多地讨论我们必须编写的代码来定义它。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:251
msgid ""
"A typical top level function in Idris consists of three things: The "
"function's name (`main` in our case), its type (`IO ()`)  plus its "
"implementation (`putStrLn \"Hello World\"`). It is easier to explain these "
"things with a couple of simple examples. Below, we define a top level "
"constant for the largest unsigned eight bit integer:"
msgstr ""
"Idris 中一个典型的顶级函数由三部分组成：函数的名称（在我们的例子中是 "
"`main`），它的类型（`IO ()`）加上它的实现（`putStrLn \"你好世界”`）。用几个简"
"单的例子来解释这些事情会更容易。下面，我们为最大的无符号八位整数定义一个顶级"
"常量："

#. type: Plain text
#: ../src/Tutorial/Intro.md:252
#, no-wrap
msgid ""
"maxBits8 : Bits8\n"
"maxBits8 = 255\n"
msgstr ""
"maxBits8 : Bits8\n"
"maxBits8 = 255\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:266
msgid ""
"The first line can be read as: \"We'd like to declare (nullary)  function "
"`maxBits8`. It is of type `Bits8`\". This is called the *function "
"declaration*: We declare, that there shall be a function of the given name "
"and type. The second line reads: \"The result of invoking `maxBits8` should "
"be `255`.\" (As you can see, we can use integer literals for other integral "
"types than just `Integer`.) This is called the *function definition*: "
"Function `maxBits8` should behave as described here when being evaluated."
msgstr ""
"第一行可以读作：“我们想声明（空）函数 `maxBits8`。它的类型是 `Bits8`”。这称为"
"*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行显示：“调用 "
"`maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数"
"类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：函数 `maxBits8` 应该在求"
"值时的表现在此处描述。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:269
msgid ""
"We can inspect this at the REPL. Load this source file into an Idris REPL "
"(as described above), and run the following tests."
msgstr ""
"我们可以在 REPL 进行检查。将此源文件加载到 Idris REPL（如上所述）中，然后运行"
"以下测试。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:270
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8\n"
"255\n"
"Tutorial.Intro> :t maxBits8\n"
"Tutorial.Intro.maxBits8 : Bits8\n"
msgstr ""
"Tutorial.Intro> maxBits8\n"
"255\n"
"Tutorial.Intro> :t maxBits8\n"
"Tutorial.Intro.maxBits8 : Bits8\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:278
msgid "We can also use `maxBits8` as part of another expression:"
msgstr "我们也可以使用 `maxBits8` 作为另一个表达式的一部分："

#. type: Plain text
#: ../src/Tutorial/Intro.md:279
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8 - 100\n"
"155\n"
msgstr ""
"Tutorial.Intro> maxBits8 - 100\n"
"155\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:286
msgid ""
"I called `maxBits8` a *nullary function*, which is just a fancy word for "
"*constant*. Let's write and test our first *real* function:"
msgstr ""
"我将 `maxBits8` 称为 *空函数*，它只是 *常量* 的一个花哨的同义词。让我们编写并"
"测试我们的第一个 *real* 函数："

#. type: Plain text
#: ../src/Tutorial/Intro.md:287
#, no-wrap
msgid ""
"distanceToMax : Bits8 -> Bits8\n"
"distanceToMax n = maxBits8 - n\n"
msgstr ""
"distanceToMax：Bits8 -> Bits8\n"
"distanceToMax n = maxBits8 - n\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:299
#, no-wrap
msgid ""
"This introduces some new syntax and a new kind of type: Function\n"
"types. `distanceToMax : Bits8 -> Bits8` can be read as follows:\n"
"\"`distanceToMax` is a function of one argument of type `Bits8`, which\n"
"returns a result of type `Bits8`\". In the implementation, the argument\n"
"is given a local identifier `n`, which is then used in the\n"
"calculation on the right hand side. Again, go ahead and try this\n"
"function at the REPL:\n"
msgstr "这引入了一些新语法和一种新类型：函数类型。 `distanceToMax : Bits8 -> Bits8` 可以这样读：“`distanceToMax` 是 具有一个`Bits8` 类型参数的函数，它返回 `Bits8`\" 类型的结果。在实现中，参数给定一个本地标识符 `n`，然后在右侧计算。再次继续尝试 REPL 的功能：\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:300
#, no-wrap
msgid ""
"Tutorial.Intro> distanceToMax 12\n"
"243\n"
"Tutorial.Intro> :t distanceToMax\n"
"Tutorial.Intro.distanceToMax : Bits8 -> Bits8\n"
"Tutorial.Intro> :t distanceToMax 12\n"
"distanceToMax 12 : Bits8\n"
msgstr ""
"Tutorial.Intro> distanceToMax 12\n"
"243\n"
"Tutorial.Intro> :t distanceToMax\n"
"Tutorial.Intro.distanceToMax : Bits8 -> Bits8\n"
"Tutorial.Intro> :t distanceToMax 12\n"
"distanceToMax 12 : Bits8\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:311
msgid ""
"As a final example, let's implement a function to calculate the square of an "
"integer:"
msgstr "作为最后一个例子，让我们实现一个计算整数平方的函数："

#. type: Plain text
#: ../src/Tutorial/Intro.md:312
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
msgstr ""
"square : Integer -> Integer\n"
"square n = n * n\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:325
msgid ""
"We now learn a very important aspect of programming in Idris: Idris is a "
"*statically typed* programming language. We are not allowed to freely mix "
"types as we please. Doing so will result in an error message from the type "
"checker (which is part of the compilation process of Idris).  For instance, "
"if we try the following at the REPL, we will get a type error:"
msgstr ""
"我们现在学习 Idris 编程的一个非常重要的方面：Idris 是一种 *静态类型* 编程语"
"言。我们不允许随意混合类型。这样做会导致来自类型检查器的错误消息（这是 Idris "
"编译过程的一部分）。例如，如果我们在 REPL 中尝试以下操作，我们将收到类型错"
"误："

#. type: Plain text
#: ../src/Tutorial/Intro.md:326
#, no-wrap
msgid ""
"Tutorial.Intro> square maxBits8\n"
"Error: ...\n"
msgstr ""
"Tutorial.Intro> square maxBits8\n"
"Error: ...\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:336
msgid ""
"The reason: `square` expects an argument of type `Integer`, but `maxBits8` "
"is of type `Bits8`. Many primitive types are interconvertible (sometimes "
"with the risk of loss of precision) using function `cast` (more on the "
"details later):"
msgstr ""
"原因：`square` 需要 `Integer` 类型的参数，但 `maxBits8` 的类型是 `Bits8`。许"
"多原语类型可以使用函数 `cast` 相互转换（有时会有精度损失的风险）（稍后会详细"
"介绍）："

#. type: Plain text
#: ../src/Tutorial/Intro.md:337
#, no-wrap
msgid ""
"Tutorial.Intro> square (cast maxBits8)\n"
"65025\n"
msgstr ""
"Tutorial.Intro> square (cast maxBits8)\n"
"65025\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:348
msgid ""
"Note, that in the example above the result is much larger that `maxBits8`. "
"The reason is, that `maxBits8` is first converted to an `Integer` of the "
"same value, which is then squared. If on the other hand we squared "
"`maxBits8` directly, the result would be truncated to still fit the valid "
"range of `Bits8`:"
msgstr ""
"请注意，在上面的示例中，结果比 `maxBits8` 大得多。原因是，首先将 `maxBits8` "
"转换为相同值的 `Integer`，然后对其进行平方。另一方面，如果我们直接将 "
"`maxBits8` 平方，结果将被截断以仍然适合 `Bits8` 的有效范围："

#. type: Plain text
#: ../src/Tutorial/Intro.md:349
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8 * maxBits8\n"
"1\n"
msgstr ""
"Tutorial.Intro> maxBits8 * maxBits8\n"
"1\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:354
#, no-wrap
msgid "Where to get Help"
msgstr "在哪里可以获得帮助"

#. type: Plain text
#: ../src/Tutorial/Intro.md:359
msgid ""
"There are several resources available online and in print, where you can "
"find help and documentation about the Idris programming language. Here is a "
"non-comprehensive list of them:"
msgstr ""
"有多种在线资源和印刷资源，您可以在其中找到有关 Idris 编程语言的帮助和文档。以"
"下是它们的非全面列表："

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:361
msgid ""
"[Type-Driven Development with Idris](https://www.manning.com/books/type-"
"driven-development-with-idris)"
msgstr ""
"[使用 Idris 进行类型驱动开发](https://www.manning.com/books/type-driven-"
"development-with-idris)"

#. type: Plain text
#: ../src/Tutorial/Intro.md:368
#, no-wrap
msgid ""
"  *The* Idris book! This describes in great detail\n"
"  the core concepts for using Idris and dependent types\n"
"  to write robust and concise code. It uses Idris 1 in\n"
"  its examples, so parts of it have to be slightly adjusted\n"
"  when using Idris 2. There is also a\n"
"  [list of required updates](https://idris2.readthedocs.io/en/latest/typedd/typedd.html).\n"
msgstr "  *专门*讲 Idris 的书！这描述得很详细。使用 Idris 和依赖类型的核心概念编写健壮和简洁的代码。它使用 Idris 1 实现书中的例子，所以使用 Idris 2 时它的一部分必须稍微调整，有一个[所需更新列表](https://idris2.readthedocs.io/en/latest/typedd/typedd.html)。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:370
msgid ""
"[A Crash Course in Idris 2](https://idris2.readthedocs.io/en/latest/tutorial/"
"index.html)"
msgstr ""
"[Idris 2 速成课程](https://idris2.readthedocs.io/en/latest/tutorial/index."
"html)"

#. type: Plain text
#: ../src/Tutorial/Intro.md:375
#, no-wrap
msgid ""
"  The official Idris 2 tutorial. A comprehensive but dense explanation of\n"
"  all features of Idris 2. I find this to be useful as a reference, and as such\n"
"  it is highly accessible. However, it is not an introduction to functional\n"
"  programming or type-driven development in general.\n"
msgstr "  Idris 2 官方教程。全面而密集的解释 Idris 2 的所有功能。我发现这作为参考很有用，因此它是高度可访问的。但是，它不是函数式编程或类型驱动开发的入门介绍\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:377
msgid "[The Idris 2 GitHub Repository](https://github.com/idris-lang/Idris2)"
msgstr "[Idris 2 GitHub 存储库](https://github.com/idris-lang/Idris2)"

#. type: Plain text
#: ../src/Tutorial/Intro.md:384
#, no-wrap
msgid ""
"  Look here for detailed installation instructions and some\n"
"  introductory material. There is also a [wiki](https://github.com/idris-lang/Idris2/wiki),\n"
"  where you can find a [list of editor plugins](https://github.com/idris-lang/Idris2/wiki/The-Idris-editor-experience),\n"
"  a [list of community libraries](https://github.com/idris-lang/Idris2/wiki/Libraries),\n"
"  a [list of external backends](https://github.com/idris-lang/Idris2/wiki/External-backends),\n"
"  and other useful information.\n"
msgstr ""
"  在这里查看详细的安装说明和一些介绍材料。还有一个[wiki](https://github.com/idris-lang/Idris2/wiki)，\n"
"  在这里你可以找到[编辑器插件列表](https://github.com/idris-lang/Idris2/wiki/The-Idris-editor-experience)，\n"
"  [社区库列表](https://github.com/idris-lang/Idris2/wiki/Libraries),\n"
"  [外部后端列表](https://github.com/idris-lang/Idris2/wiki/External-backends),\n"
"和其他有用的信息。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:386
msgid "[The Idris 2 Discord Channel](https://discord.gg/UX68fDs2jc)"
msgstr "[Idris 2 Discord 频道](https://discord.gg/UX68fDs2jc)"

#. type: Plain text
#: ../src/Tutorial/Intro.md:392
#, no-wrap
msgid ""
"  If you get stuck with a piece of code, want to ask about some\n"
"  obscure language feature, want to promote your new library,\n"
"  or want to just hang out with other Idris programmers, this\n"
"  is the place to go. The discord channel is pretty active and\n"
"  *very* friendly towards newcomers.\n"
msgstr ""
"  如果你被一段代码卡住了，想问一些晦涩的语言功能，想推广你的新库，"
"或者想和其他 Idris 程序员一起出去玩，可以来这个地方。Discord "
"频道非常活跃且对新人*非常*友好。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:394
msgid "The Idris REPL"
msgstr "The Idris REPL"

#. type: Plain text
#: ../src/Tutorial/Intro.md:400
#, no-wrap
msgid ""
"  Finally, a lot of useful information can be provided by\n"
"  Idris itself. I tend to have at least one REPL session open all the\n"
"  time when programming in Idris. My editor (neovim) is set up\n"
"  to use the [language server for Idris 2](https://github.com/idris-community/idris2-lsp),\n"
"  which is incredibly useful. In the REPL,\n"
msgstr "  最后，Idris 本身可以提供很多有用的信息。在 Idris 编程的时间我倾向于至少打开一个 REPL 会话。我的编辑器（neovim）已设置使用 [Idris 2 的语言服务器](https://github.com/idris-community/idris2-lsp)，在 REPL 中这非常有用。\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:t` to inspect the type of an expression or meta variable (hole): `:t "
"foldl`,"
msgstr "使用 `:t` 检查表达式或元变量（孔）的类型：`:t foldl`,"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:ti` to inspect the type of a function including implicit arguments: `:"
"ti foldl`,"
msgstr "使用 `:ti` 检查包含隐式参数的函数类型：`:ti foldl`,"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid "use `:m` to list all meta variables (holes) in scope,"
msgstr "使用 `:m` 列出范围内的所有元变量（孔），"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:doc` to access the documentation of a top level function (`:doc the`), "
"a data type plus all its constructors and available hints (`:doc Bool`), a "
"language feature (`:doc case`, `:doc let`, `:doc interface`, `:doc record`, "
"or even `:doc ?`), or an interface (`:doc Uninhabited`),"
msgstr ""
"使用 `:doc` 访问顶级函数 (`:doc the`) 的文档，一种数据类型及其所有构造函数和"
"可用提示 (`:doc Bool` )，语言特征（`:doc case`, `:doc let`, `:doc "
"interface`, `:doc record`，甚至 `:doc ?`)，或者一个接口（`:doc "
"Uninhabited`），"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:module` to import a module from one of the available packages: `:"
"module Data.Vect`,"
msgstr "使用 `:module` 从可用包之一导入模块：`:module Data.Vect`,"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:browse` to list the names and types of all functions exported by a "
"loaded module: `:browse Data.Vect`,"
msgstr ""
"使用 `:browse` 列出加载模块导出的所有函数的名称和类型： `:browse Data.Vect`,"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:help` to get a list of other commands plus a short description for "
"each."
msgstr "使用 `:help` 获取其他命令的列表以及每个命令的简短描述。"

#. type: Title ##
#: ../src/Tutorial/Intro.md:418
#, no-wrap
msgid "Summary"
msgstr "概括"

#. type: Plain text
#: ../src/Tutorial/Intro.md:425
msgid ""
"In this introduction we learned about the most basic features of the Idris "
"programming language. We used the REPL to tinker with our ideas and inspect "
"the types of things in our code, and we used the Idris compiler to compile "
"an Idris source file to an executable."
msgstr ""
"在本介绍中，我们了解了 Idris 编程语言的最基本功能。我们使用 REPL 来修改我们的"
"想法并检查代码中事物的类型，我们使用 Idris 编译器将 Idris 源文件编译为可执行"
"文件。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:429
msgid ""
"We also learned about the basic shape of a top level definition in Idris, "
"which always consists of an identifier (its name), a type, and an "
"implementation."
msgstr ""
"我们还了解了 Idris 中顶级定义的基本形式，它始终由标识符（其名称）、类型和实现"
"组成。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:436
msgid ""
"In the [next chapter](Functions1.md), we start programming in Idris for "
"real. We learn how to write our own pure functions, how functions compose, "
"and how we can treat functions just like other values and pass them around "
"as arguments to other functions."
msgstr ""
"在[下一章](Functions1.md)中，我们开始在 Idris 中进行真正的编程。我们学习如何"
"编写我们自己的纯函数，函数如何组合，以及我们如何像对待其他值一样对待函数并将"
"它们作为参数传递给其他函数。"
