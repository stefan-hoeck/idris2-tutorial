# Chinese translations for idris package
# Copyright (C) 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the idris package.
# Automatically generated, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: idris 2-tutorial\n"
"POT-Creation-Date: 2022-12-06 11:32+0000\n"
"PO-Revision-Date: 2022-12-08 01:35+0000\n"
"Last-Translator: grass <467195537@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://weblate.grass.work:30443/"
"projects/idris-lang/idris2-tutorial/zh_Hans/>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.14.2\n"

#. type: Plain text
#: ../README.md:2
#, no-wrap
msgid "> [Chinese Translation](translation/README.md)\n"
msgstr "> 这里是中文版！\n"

#. type: Title #
#: ../README.md:3
#, no-wrap
msgid "Functional Programming in Idris 2"
msgstr "Idris 2 中的函数式编程"

#. type: Plain text
#: ../README.md:11
#, no-wrap
msgid ""
"The goal of this project is quickly explained: To become a more\n"
"or less comprehensive guide to the Idris programming language,\n"
"with a lot of introductory material targeted at newcomers to\n"
"functional programming.\n"
msgstr "这个项目的目标是：要成为 Idris 编程语言的全面指南，其中包含大量针对函数式编程新手的介绍性材料。\n"

#. type: Plain text
#: ../README.md:19
#, no-wrap
msgid ""
"The content will be organized in several parts, with the part\n"
"about the core language features being the main guide to\n"
"functional programming in Idris. Every part consists of several\n"
"chapters, each trying to cover in depth a certain aspect\n"
"of the Idris programming language and its core libraries. Most\n"
"chapters come with (sometimes lots of) exercises, with\n"
"solutions available in directory `src/Solutions`.\n"
msgstr "内容将分为几个部分，其中关于核心语言特性的部分是 Idris 函数式编程主要指南。每个部分都由几个章节组成，每个章节都试图深入介绍 Idris 编程语言及其核心库的某个方面。大多数章节都附带（有时很多）练习，在目录 `src/Solutions` 中提供了解决方案。\n"

#. type: Plain text
#: ../README.md:24
#, no-wrap
msgid ""
"Right now, even the part about core language features is not\n"
"yet finished, but is being actively developed and tried on\n"
"several of my own students, some of which are completely\n"
"new to functional programming.\n"
msgstr "目前，虽然关于核心语言特性的部分还没有完成，但正在积极开发中，并在我自己的几个学生身上进行尝试，其中一些甚至是函数式编程的萌新。\n"

#. type: Title ##
#: ../README.md:25
#, no-wrap
msgid "Table of Contents"
msgstr "目录"

#. type: Title ###
#: ../README.md:27
#, no-wrap
msgid "Part 1: Core Language Features"
msgstr "第 1 部分：核心语言特性"

#. type: Plain text
#: ../README.md:33
#, no-wrap
msgid ""
"This part tries to give a solid introduction to the\n"
"Idris programming language. If you are new to functional programming,\n"
"make sure to follow these chapters in order and *solve all the\n"
"exercises*.\n"
msgstr "这部分试图对 Idris 编程语言进行深入的介绍。如果您是函数式编程的新手，请确保按顺序阅读这些章节并*解决所有练习*。\n"

#. type: Plain text
#: ../README.md:38
#, no-wrap
msgid ""
"If you already used other pure functional programming languages like\n"
"Haskell, you might go through the introductory material (Functions Part 1,\n"
"Algebraic Data Types, and Interfaces) pretty quickly, as most of this\n"
"stuff will already be familiar to you.\n"
msgstr "如果您已经使用过其他纯函数式编程语言，例如 Haskell，那么您可能会很快完成介绍性材料（函数第 1 部分，代数数据类型和接口），因为这些内容中的大部分内容您已经很熟悉了。\n"

#. type: Bullet: '1. '
#: ../README.md:107
#, no-wrap
msgid "[Introduction](src/Tutorial/Intro.md)\n"
msgstr "[介绍](src/Tutorial/Intro.md)\n"

#. type: Bullet: '   1. '
#: ../README.md:107
#, no-wrap
msgid "[About the Idris Programming Language](src/Tutorial/Intro.md#about-the-idris-programming-language)\n"
msgstr "[关于 Idris 编程语言](src/Tutorial/Intro.md#关于-Idris-编程语言)\n"

#. type: Bullet: '   2. '
#: ../README.md:107
#, no-wrap
msgid "[Using the REPL](src/Tutorial/Intro.md#using-the-repl)\n"
msgstr "[使用 REPL](src/Tutorial/Intro.md#使用-REPL)\n"

#. type: Bullet: '   3. '
#: ../README.md:107
#, no-wrap
msgid "[A First Idris Program](src/Tutorial/Intro.md#a-first-idris-program)\n"
msgstr "[第一个 Idris 程序](src/Tutorial/Intro.md#第一个-Idris-程序)\n"

#. type: Bullet: '   4. '
#: ../README.md:107
#, no-wrap
msgid "[The Shape of an Idris Definition](src/Tutorial/Intro.md#the-shape-of-an-idris-definition)\n"
msgstr "[如何声明一个 Idris 定义](src/Tutorial/Intro.md#如何声明一个-Idris-定义)\n"

#. type: Bullet: '   5. '
#: ../README.md:107
#, no-wrap
msgid "[Where to get Help](src/Tutorial/Intro.md#where-to-get-help)\n"
msgstr "[在哪里可以获得帮助](src/Tutorial/Intro.md#在哪里可以获得帮助)\n"

#. type: Bullet: '2. '
#: ../README.md:107
#, no-wrap
msgid "[Functions Part 1](src/Tutorial/Functions1.md)\n"
msgstr "[函数第 1 部分](src/Tutorial/Functions1.md)\n"

#. type: Bullet: '   1. '
#: ../README.md:107
#, no-wrap
msgid "[Functions with more that one Argument](src/Tutorial/Functions1.md#functions-with-more-that-one-argument)\n"
msgstr "[多参函数](src/Tutorial/Functions1.md#多参函数)\n"

#. type: Bullet: '   2. '
#: ../README.md:107
#, no-wrap
msgid "[Function Composition](src/Tutorial/Functions1.md#function-composition)\n"
msgstr "[函数组合](src/Tutorial/Functions1.md#函数组合])\n"

#. type: Bullet: '   3. '
#: ../README.md:107
#, no-wrap
msgid "[Higher-order Functions](src/Tutorial/Functions1.md#higher-order-functions)\n"
msgstr "[高阶函数](src/Tutorial/Functions1.md#高阶函数)\n"

#. type: Bullet: '   4. '
#: ../README.md:107
#, no-wrap
msgid "[Currying](src/Tutorial/Functions1.md#currying)\n"
msgstr "[柯里化](src/Tutorial/Functions1.md#柯里化)\n"

#. type: Bullet: '   5. '
#: ../README.md:107
#, no-wrap
msgid "[Anonymous Functions](src/Tutorial/Functions1.md#anonymous-functions)\n"
msgstr "[匿名函数](src/Tutorial/Functions1.md#匿名函数)\n"

#. type: Bullet: '   6. '
#: ../README.md:107
#, no-wrap
msgid "[Operators](src/Tutorial/Functions1.md#operators)\n"
msgstr "[运算符](src/Tutorial/Functions1.md#运算符)\n"

#. type: Bullet: '3. '
#: ../README.md:107
#, no-wrap
msgid "[Algebraic Data Types](src/Tutorial/DataTypes.md)\n"
msgstr "[代数数据类型](src/Tutorial/DataTypes.md)\n"

#. type: Bullet: '   1. '
#: ../README.md:107
#, no-wrap
msgid "[Enumerations](src/Tutorial/DataTypes.md#enumerations)\n"
msgstr "[枚举](src/Tutorial/DataTypes.md#枚举)\n"

#. type: Bullet: '   2. '
#: ../README.md:107
#, no-wrap
msgid "[Sum Types](src/Tutorial/DataTypes.md#sum-types)\n"
msgstr "[和类型](src/Tutorial/DataTypes.md#和类型)\n"

#. type: Bullet: '   3. '
#: ../README.md:107
#, no-wrap
msgid "[Records](src/Tutorial/DataTypes.md#records)\n"
msgstr "[记录](src/Tutorial/DataTypes.md#记录)\n"

#. type: Bullet: '   4. '
#: ../README.md:107
#, no-wrap
msgid "[Generic Data Types](src/Tutorial/DataTypes.md#generic-data-types)\n"
msgstr "[泛型数据类型](src/Tutorial/DataTypes.md#泛型数据类型)\n"

#. type: Bullet: '   5. '
#: ../README.md:107
#, no-wrap
msgid "[Alternative Syntax for Data Definitions](src/Tutorial/DataTypes.md#alternative-syntax-for-data-definitions)\n"
msgstr "[数据定义的替代语法](src/Tutorial/DataTypes.md#数据定义的替代语法)\n"

#. type: Bullet: '4. '
#: ../README.md:107
#, no-wrap
msgid "[Interfaces](src/Tutorial/Interfaces.md)\n"
msgstr "[接口](src/Tutorial/Interfaces.md)\n"

#. type: Bullet: '   1. '
#: ../README.md:107
#, no-wrap
msgid "[Interface Basics](src/Tutorial/Interfaces.md#interface-basics)\n"
msgstr "[接口基础](src/Tutorial/Interfaces.md#接口基础)\n"

#. type: Bullet: '   2. '
#: ../README.md:107
#, no-wrap
msgid "[More about Interfaces](src/Tutorial/Interfaces.md#more-about-interfaces)\n"
msgstr "[接口的更多内容](src/Tutorial/Interfaces.md#接口的更多内容)\n"

#. type: Bullet: '   3. '
#: ../README.md:107
#, no-wrap
msgid "[Interfaces in the Prelude](src/Tutorial/Interfaces.md#interfaces-in-the-prelude)\n"
msgstr "[Prelude 中的接口](src/Tutorial/Interfaces.md#Prelude-中的接口)\n"

#. type: Bullet: '5. '
#: ../README.md:107
#, no-wrap
msgid "[Functions Part 2](src/Tutorial/Functions2.md)\n"
msgstr "[函数第 2 部分](src/Tutorial/Functions2.md)\n"

#. type: Bullet: '   1. '
#: ../README.md:107
#, no-wrap
msgid "[Let Bindings and Local Definitions](src/Tutorial/Functions2.md#let-bindings-and-local-definitions)\n"
msgstr "[绑定和局部定义](src/Tutorial/Functions2.md#绑定和局部定义)\n"

#. type: Bullet: '   2. '
#: ../README.md:107
#, no-wrap
msgid "[The Truth about Function Arguments](src/Tutorial/Functions2.md#the-truth-about-function-arguments)\n"
msgstr "[函数参数的真相](src/Tutorial/Functions2.md#函数参数的真相)\n"

#. type: Bullet: '   3. '
#: ../README.md:107
#, no-wrap
msgid "[Programming with Holes](src/Tutorial/Functions2.md#programming-with-holes)\n"
msgstr "[使用孔编程](src/Tutorial/Functions2.md#使用孔编程)\n"

#. type: Bullet: '6. '
#: ../README.md:107
#, no-wrap
msgid "[Dependent Types](src/Tutorial/Dependent.md)\n"
msgstr "[依赖类型](src/Tutorial/Dependent.md)\n"

#. type: Bullet: '   1. '
#: ../README.md:107
#, no-wrap
msgid "[Length-Indexed Lists](src/Tutorial/Dependent.md#length-indexed-lists)\n"
msgstr "[长度索引列表](src/Tutorial/Dependent.md#长度索引列表)\n"

#. type: Bullet: '   2. '
#: ../README.md:107
#, no-wrap
msgid "[Fin: Safe Indexing into Vectors](src/Tutorial/Dependent.md#fin-safe-indexing-into-vectors)\n"
msgstr "[Fin: 向量的安全索引](src/Tutorial/Dependent.md#Fin:-向量的安全索引)\n"

#. type: Bullet: '   3. '
#: ../README.md:107
#, no-wrap
msgid "[Compile-Time Computations](src/Tutorial/Dependent.md#compile-time-computations)\n"
msgstr "[编译期计算](src/Tutorial/Dependent.md#编译期计算)\n"

#. type: Bullet: '7. '
#: ../README.md:107
#, no-wrap
msgid "[IO: Programming with Side Effects](src/Tutorial/IO.md)\n"
msgstr "[IO：带有副作用的编程](src/Tutorial/IO.md)\n"

#. type: Bullet: '   1. '
#: ../README.md:107
#, no-wrap
msgid "[Pure Side Effects?](src/Tutorial/IO.md#pure-side-effects)\n"
msgstr "[纯的副作用？](src/Tutorial/IO.md#纯的副作用？)\n"

#. type: Bullet: '   2. '
#: ../README.md:107
#, no-wrap
msgid "[Do Blocks, Desugared](src/Tutorial/IO.md#do-blocks-desugared)\n"
msgstr "[Do 块，脱糖](src/Tutorial/IO.md#Do-块，脱糖)\n"

#. type: Bullet: '   3. '
#: ../README.md:107
#, no-wrap
msgid "[Working with Files](src/Tutorial/IO.md#working-with-files)\n"
msgstr "[使用文件](src/Tutorial/IO.md#使用文件)\n"

#. type: Bullet: '   4. '
#: ../README.md:107
#, no-wrap
msgid "[How IO is Implemented](src/Tutorial/IO.md#how-io-is-implemented)\n"
msgstr "[IO 是如何实现的](src/Tutorial/IO.md#IO-是如何实现的)\n"

#. type: Bullet: '8. '
#: ../README.md:107
#, no-wrap
msgid "[Functor and Friends](src/Tutorial/Functor.md)\n"
msgstr "[函子和它的伙伴们](src/Tutorial/Functor.md)\n"

#. type: Bullet: '   1. '
#: ../README.md:107
#, no-wrap
msgid "[Functor](src/Tutorial/Functor.md#functor)\n"
msgstr "[函子](src/Tutorial/Functor.md#函子)\n"

#. type: Bullet: '   2. '
#: ../README.md:107
#, no-wrap
msgid "[Applicative](src/Tutorial/Functor.md#applicative)\n"
msgstr "[应用函子](src/Tutorial/Functor.md#应用函子)\n"

#. type: Bullet: '   3. '
#: ../README.md:107
#, no-wrap
msgid "[Monad](src/Tutorial/Functor.md#monad)\n"
msgstr "[单子](src/Tutorial/Functor.md#单子)\n"

#. type: Bullet: '   4. '
#: ../README.md:107
#, no-wrap
msgid "[Background and further Reading](src/Tutorial/Functor.md#background-and-further-reading)\n"
msgstr "[背景与延伸阅读](src/Tutorial/Functor.md#背景与延伸阅读)\n"

#. type: Bullet: '9. '
#: ../README.md:107
#, no-wrap
msgid "[Recursion and Folds](src/Tutorial/Folds.md)\n"
msgstr "[递归与折叠](src/Tutorial/Folds.md)\n"

#. type: Bullet: '   1. '
#: ../README.md:107
#, no-wrap
msgid "[Recursion](src/Tutorial/Folds.md#recursion)\n"
msgstr "[递归](src/Tutorial/Folds.md#递归)\n"

#. type: Bullet: '   2. '
#: ../README.md:107
#, no-wrap
msgid "[A few Notes on Totality Checking](src/Tutorial/Folds.md#a-few-notes-on-totality-checking)\n"
msgstr "[关于完全性检查的一些注意事项](src/Tutorial/Folds.md#关于完全性检查的一些注意事项)\n"

#. type: Bullet: '   3. '
#: ../README.md:107
#, no-wrap
msgid "[Interface Foldable](src/Tutorial/Folds.md#interface-foldable)\n"
msgstr "[Foldable 接口](src/Tutorial/Folds.md#Foldable-接口)\n"

#. type: Bullet: '10. '
#: ../README.md:107
#, no-wrap
msgid "[Effectful Traversals](src/Tutorial/Traverse.md)\n"
msgstr "[带副作用的遍历](src/Tutorial/Traverse.md)\n"

#. type: Bullet: '    1. '
#: ../README.md:107
#, no-wrap
msgid "[Reading CSV Tables](src/Tutorial/Traverse.md#reading-csv-tables)\n"
msgstr "[阅读 CSV 表格](src/Tutorial/Traverse.md#阅读-CSV-表格)\n"

#. type: Bullet: '    2. '
#: ../README.md:107
#, no-wrap
msgid "[Programming with State](src/Tutorial/Traverse.md#programming-with-state)\n"
msgstr "[使用状态编程](src/Tutorial/Traverse.md#使用状态编程)\n"

#. type: Bullet: '    3. '
#: ../README.md:107
#, no-wrap
msgid "[The Power of Composition](src/Tutorial/Traverse.md#the-power-of-composition)\n"
msgstr "[组合的力量](src/Tutorial/Traverse.md#组合的力量)\n"

#. type: Bullet: '11. '
#: ../README.md:107
#, no-wrap
msgid "[Sigma Types](src/Tutorial/DPair.md)\n"
msgstr "[Sigma 类型](src/Tutorial/DPair.md)\n"

#. type: Bullet: '    1. '
#: ../README.md:107
#, no-wrap
msgid "[Dependent Pairs](src/Tutorial/DPair.md#dependent-pairs)\n"
msgstr "[依赖对](src/Tutorial/DPair.md#依赖对)\n"

#. type: Bullet: '    2. '
#: ../README.md:107
#, no-wrap
msgid "[Use Case: Nucleic Acids](src/Tutorial/DPair.md#use-case-nucleic-acids)\n"
msgstr "[用例：核酸](src/Tutorial/DPair.md#用例：核酸)\n"

#. type: Bullet: '    3. '
#: ../README.md:107
#, no-wrap
msgid "[Use Case: CSV Files with a Schema](src/Tutorial/DPair.md#use-case-csv-files-with-a-schema)\n"
msgstr "[用例：带有模式的 CSV 文件](src/Tutorial/DPair.md#用例：带有模式的-CSV-文件)\n"

#. type: Bullet: '12. '
#: ../README.md:107
#, no-wrap
msgid "[Propositional Equality](src/Tutorial/Eq.md)\n"
msgstr "[命题等式 Equality](src/Tutorial/Eq.md)\n"

#. type: Bullet: '    1. '
#: ../README.md:107
#, no-wrap
msgid "[Equality as a Type](src/Tutorial/Eq.md#equality-as-a-type)\n"
msgstr "[相等作为类型](src/Tutorial/Eq.md#相等作为类型)\n"

#. type: Bullet: '    2. '
#: ../README.md:107
#, no-wrap
msgid "[Programs as Proofs](src/Tutorial/Eq.md#programs-as-proofs)\n"
msgstr "[程序作为证明](src/Tutorial/Eq.md#程序作为证明)\n"

#. type: Bullet: '    3. '
#: ../README.md:107
#, no-wrap
msgid "[Into the Void](src/Tutorial/Eq.md#into-the-void)\n"
msgstr "[遁入虚无](src/Tutorial/Eq.md#遁入虚无)\n"

#. type: Bullet: '    4. '
#: ../README.md:107
#, no-wrap
msgid "[Rewrite Rules](src/Tutorial/Eq.md#rewrite-rules)\n"
msgstr "[重写规则](src/Tutorial/Eq.md#重写规则)\n"

#. type: Bullet: '13. '
#: ../README.md:107
#, no-wrap
msgid "[Predicates and Proof Search](src/Tutorial/Predicates.md)\n"
msgstr "[谓词和证明搜索](src/Tutorial/Predicates.md)\n"

#. type: Bullet: '    1. '
#: ../README.md:107
#, no-wrap
msgid "[Preconditions](src/Tutorial/Predicates.md#preconditions)\n"
msgstr "[前置条件](src/Tutorial/Predicates.md#前置条件)\n"

#. type: Bullet: '    2. '
#: ../README.md:107
#, no-wrap
msgid "[Contracts between Values](src/Tutorial/Predicates.md#contracts-between-values)\n"
msgstr "[值之间的契约](src/Tutorial/Predicates.md#值之间的契约)\n"

#. type: Bullet: '    3. '
#: ../README.md:107
#, no-wrap
msgid "[Use Case: Flexible Error Handling](src/Tutorial/Predicates.md#use-case-flexible-error-handling)\n"
msgstr "[用例：灵活的错误处理](src/Tutorial/Predicates.md#用例：灵活的错误处理)\n"

#. type: Bullet: '    4. '
#: ../README.md:107
#, no-wrap
msgid "[The Truth about Interfaces](src/Tutorial/Predicates.md#the-truth-about-interfaces)\n"
msgstr "[接口的真相](src/Tutorial/Predicates.md#接口的真相)\n"

#. type: Bullet: '14. '
#: ../README.md:107
#, no-wrap
msgid "[Primitives](src/Tutorial/Prim.md)\n"
msgstr "[原语](src/Tutorial/Prim.md)\n"

#. type: Bullet: '    1. '
#: ../README.md:107
#, no-wrap
msgid "[How Primitives are Implemented](src/Tutorial/Prim.md#how-primitives-are-implemented)\n"
msgstr "[原语的实现](src/Tutorial/Prim.md#原语的实现)\n"

#. type: Bullet: '    2. '
#: ../README.md:107
#, no-wrap
msgid "[Working with Strings](src/Tutorial/Prim.md#working-with-strings)\n"
msgstr "[使用字符串](src/Tutorial/Prim.md#使用字符串)\n"

#. type: Bullet: '    3. '
#: ../README.md:107
#, no-wrap
msgid "[Integers](src/Tutorial/Prim.md#integers)\n"
msgstr "[整数](src/Tutorial/Prim.md#整数)\n"

#. type: Bullet: '    4. '
#: ../README.md:107
#, no-wrap
msgid "[Refined Primitives](src/Tutorial/Prim.md#refined-primitives)\n"
msgstr "[细化原语](src/Tutorial/Prim.md#细化原语)\n"

#. type: Title ###
#: ../README.md:108
#, no-wrap
msgid "Part 2: Appendices"
msgstr "第 2 部分：附录"

#. type: Plain text
#: ../README.md:114
#, no-wrap
msgid ""
"The appendices can be used as references for the topics at\n"
"hand. I plan to eventually have a concise reference on Idris\n"
"syntax, typical error messages, the module system, interactive\n"
"editing and possibly others.\n"
msgstr "附录可用作手头主题的参考。我计划最终对 Idris 语法、典型错误消息、模块系统、交互式编辑以及可能的其他内容有一个简明的参考。\n"

#. type: Bullet: '1. '
#: ../README.md:116
#, no-wrap
msgid "[Interactive Editing in Neovim](src/Appendices/Neovim.md)\n"
msgstr "[Neovim 中的交互式编辑](src/Appendices/Neovim.md)\n"

#. type: Title ##
#: ../README.md:117
#, no-wrap
msgid "Prerequisites"
msgstr "前置条件"

#. type: Plain text
#: ../README.md:123
#, no-wrap
msgid ""
"At the moment, this project is being actively developed and\n"
"evolved against the main branch of the Idris 2 repository.\n"
"It is being tested nightly on GitHub and built against\n"
"the latest commit of the Idris 2 main branch as well as the\n"
"Idris 2 commit listed in file `.idris-version`.\n"
msgstr "目前，该项目正在针对 Idris 2 存储库的主要分支进行积极开发和演进。它每晚在 GitHub 上进行测试，并针对 Idris 2 主分支的最新提交以及文件 `.idris-version` 中列出的 Idris 2 提交进行构建。\n"

#. type: Title #
#: ../src/Tutorial/DataTypes.md:1
#, no-wrap
msgid "Algebraic Data Types"
msgstr "代数数据类型"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:8
#, no-wrap
msgid ""
"In the [previous chapter](Functions1.md),\n"
"we learned how to write our own functions and combine\n"
"them to create more complex functionality. Of equal importance\n"
"is the ability to define our own data types and use them\n"
"as arguments and results in functions.\n"
msgstr "在[上一章](Functions1.md)中，我们学会了如何编写自己的函数并组合他们来创建更复杂的函数。同等重要的是定义我们自己的数据类型并使用它们作为参数和函数结果。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:15
#, no-wrap
msgid ""
"This is a lengthy chapter, densely packed with information.\n"
"If you are new to Idris and functional programming, make\n"
"sure to follow along slowly, experimenting with the examples,\n"
"and possibly coming up with your own. Make sure to try\n"
"and solve *all* exercises. The solutions to the exercises\n"
"can be found [here](../Solutions/DataTypes.idr).\n"
msgstr ""
"这是一个冗长的章节，信息密集。\n"
"如果您不熟悉 Idris 和函数式编程，请一定要慢慢来，用例子做实验，并可能想出你自己的示例。确保尝试并解决*所有*练习。练习题的答案可以在 [这里](../Solutions/DataTypes.idr) 找到。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:16
#, no-wrap
msgid "module Tutorial.DataTypes\n"
msgstr "module Tutorial.DataTypes\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:20
#, no-wrap
msgid "Enumerations"
msgstr "枚举"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:24
#, no-wrap
msgid ""
"Let's start with a data type for the days of the week as an\n"
"example.\n"
msgstr ""
"让我们从一个星期几的数据类型开始"
"例子。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:25
#, no-wrap
msgid ""
"data Weekday = Monday\n"
"             | Tuesday\n"
"             | Wednesday\n"
"             | Thursday\n"
"             | Friday\n"
"             | Saturday\n"
"             | Sunday\n"
msgstr ""
"data Weekday = Monday\n"
"             | Tuesday\n"
"             | Wednesday\n"
"             | Thursday\n"
"             | Friday\n"
"             | Saturday\n"
"             | Sunday\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:38
#, no-wrap
msgid ""
"The declaration above defines a new *type* (`Weekday`) and\n"
"several new *values* (`Monday` to `Sunday`) of the given\n"
"type. Go ahead, and verify this at the REPL:\n"
msgstr ""
"上面的声明定义了一个新的*类型*(`Weekday`)和"
"该类型给定的几个*值*(`Monday` 到 `Sunday`)。接下来在 REPL 上验证这一点：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:39
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Monday\n"
"Tutorial.DataTypes.Monday : Weekday\n"
"Tutorial.DataTypes> :t Weekday\n"
"Tutorial.DataTypes.Weekday : Type\n"
msgstr ""
"Tutorial.DataTypes> :t Monday\n"
"Tutorial.DataTypes.Monday : Weekday\n"
"Tutorial.DataTypes> :t Weekday\n"
"Tutorial.DataTypes.Weekday : Type\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:48
#, no-wrap
msgid ""
"So, `Monday` is of type `Weekday`, while `Weekday` itself is of\n"
"type `Type`.\n"
msgstr "所以，`Monday` 是 `Weekday` 类型，而 `Weekday` 本身是 `Type` 类型。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:52
#, no-wrap
msgid ""
"It is important to note, that a value of type `Weekday` can only\n"
"ever be one of the values listed above. It is a *type error* to\n"
"use anything else where a `Weekday` is expected.\n"
msgstr "需要注意的是，`Weekday` 类型的值只能是上面列出的值之一。在需要 `Weekday` 的地方使用其他任何值都会产生一个*类型错误*。\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:53
#, no-wrap
msgid "Pattern Matching"
msgstr "模式匹配"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:59
#, no-wrap
msgid ""
"In order to use our new data type as a function argument, we\n"
"need to learn about an important concept in functional programming\n"
"languages: Pattern matching. Let's implement a function, which calculates\n"
"the successor of a weekday:\n"
msgstr "为了使用我们的新数据类型作为函数参数，我们需要了解函数式编程语言中的一个重要概念：模式匹配。让我们实现一个函数，它计算一个星期几的后继：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:60
#, no-wrap
msgid ""
"total\n"
"next : Weekday -> Weekday\n"
"next Monday    = Tuesday\n"
"next Tuesday   = Wednesday\n"
"next Wednesday = Thursday\n"
"next Thursday  = Friday\n"
"next Friday    = Saturday\n"
"next Saturday  = Sunday\n"
"next Sunday    = Monday\n"
msgstr ""
"total\n"
"next : Weekday -> Weekday\n"
"next Monday    = Tuesday\n"
"next Tuesday   = Wednesday\n"
"next Wednesday = Thursday\n"
"next Thursday  = Friday\n"
"next Friday    = Saturday\n"
"next Saturday  = Sunday\n"
"next Sunday    = Monday\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:81
#, no-wrap
msgid ""
"In order to inspect a `Weekday` argument, we match on the\n"
"different possible values and return a result for each of them.\n"
"This is a very powerful concept, as it allows us to match\n"
"on and extract values from deeply nested data structures.\n"
"The different cases in a pattern match are inspected from\n"
"top to bottom, each being compared against the current\n"
"function argument. Once a matching pattern is found, the\n"
"computation on the right hand side of this pattern is\n"
"evaluated. Later patterns are then ignored.\n"
msgstr ""
"为了检查 `Weekday` 参数，我们匹配"
"不同的可能值并为每个值返回一个结果。"
"这是一个非常强大的概念，因为它允许我们匹配并从深度嵌套的数据结构中提取值。从上到下检查模式匹配中的不同情况"
"，每个都与当前函数参数进行比较。一旦找到匹配的模式，该模式右侧的计算是会求值。后面的模式将被忽略。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:89
#, no-wrap
msgid ""
"For instance, if we invoke `next` with argument `Thursday`,\n"
"the first three patterns (`Monday`, `Tuesday`, and `Wednesday`)\n"
"will be checked against the argument, but they do not match.\n"
"The fourth pattern is a match, and result `Friday` is being\n"
"returned. Later patterns are then ignored, even if they would\n"
"also match the input (this becomes relevant with catch-all patterns,\n"
"which we will talk about in a moment).\n"
msgstr ""
"例如，如果我们使用参数 `Thursday` 调用 "
"`next`，前三个模式（`Monday`、`Tuesday` 和 "
"`Wednesday`）将根据参数进行检查，但它们不匹配。第四个模式是匹配的，结果 "
"`Friday` 被返回。然后忽略后面的模式，即使它们还会匹配输入（这与全捕获模式有关，"
"我们稍后会谈到）。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:98
#, no-wrap
msgid ""
"The function above is provably total. Idris knows about the\n"
"possible values of type `Weekday`, and can therefore figure\n"
"out that our pattern match covers all possible cases. We can\n"
"therefore annotate the function with the `total` keyword, and\n"
"Idris will answer with a type error, if it can't verify the\n"
"function's totality. (Go ahead, and try removing one of\n"
"the clauses in `next` to get an idea about how an error\n"
"message from the coverage checker looks like.)\n"
msgstr ""
"上面的函数可以证明是完全的。Idris 知道"
"`Weekday` 类型的可能值，因此可以计算"
"我们的模式匹配涵盖了所有可能的情况。我们可以使用 `total` 关键字注释函数，如果 Idris 无法验证函数的完全性，会得到一个类型错误。 （继续，并尝试删除其中一个 `next` 中的子句来了解错误是如何产生的，并且可以看看来自覆盖性检查器的错误消息长什么样。）\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:105
#, no-wrap
msgid ""
"Please remember, that these are very strong guarantees from\n"
"the type checker: Given enough resources,\n"
"a provably total function will *always* return\n"
"a result of the given type in a finite amount of time\n"
"(*resources* here meaning computational resources like\n"
"memory or, in case of recursive functions, stack space).\n"
msgstr "请记住，这些来自类型检查器：给定足够的资源，一个可证明的全函数在有限时间内将*总是*返回给定类型的结果（*资源*的意思是计算资源，比如内存，或者，在递归函数情况下的堆栈空间）。\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:106
#, no-wrap
msgid "Catch-all Patterns"
msgstr "全捕获模式"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:111
#, no-wrap
msgid ""
"Sometimes, it is convenient to only match on a subset\n"
"of the possible values and collect the remaining possibilities\n"
"in a catch-all clause:\n"
msgstr "有时比较实用的是只匹配一个可能子集的值，并收集剩余的可能性到全捕获模式中：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:112
#, no-wrap
msgid ""
"total\n"
"isWeekend : Weekday -> Bool\n"
"isWeekend Saturday = True\n"
"isWeekend Sunday   = True\n"
"isWeekend _        = False\n"
msgstr ""
"total\n"
"isWeekend : Weekday -> Bool\n"
"isWeekend Saturday = True\n"
"isWeekend Sunday   = True\n"
"isWeekend _        = False\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:125
#, no-wrap
msgid ""
"The final line with the catch-all pattern is only invoked,\n"
"if the argument is not equal to `Saturday` or `Sunday`.\n"
"Remember: Patterns in a pattern match are matched against\n"
"the input from top to bottom and the first match decides,\n"
"which path on the right hand side will be taken.\n"
msgstr ""
"如果参数不等于 `Saturday` 或 `Sunday`，仅调用具有全捕获模式的最后一行。记住：模式匹配中的模式匹配\n"
"从上到下的输入和第一个匹配决定将采用右侧的哪条路径。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:129
#, no-wrap
msgid ""
"We can use catch-all patterns to implement an equality test for\n"
"`Weekday` (we will not yet use the `==` operator for this; this will\n"
"have to wait until we learn about *interfaces*):\n"
msgstr ""
"我们可以使用全捕获模式来实现等式测试"
"`Weekday`（我们还不会为此使用 `==` 运算符；这将必须等到我们了解*接口*以后）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:130
#, no-wrap
msgid ""
"total\n"
"eqWeekday : Weekday -> Weekday -> Bool\n"
"eqWeekday Monday Monday        = True\n"
"eqWeekday Tuesday Tuesday      = True\n"
"eqWeekday Wednesday Wednesday  = True\n"
"eqWeekday Thursday Thursday    = True\n"
"eqWeekday Friday Friday        = True\n"
"eqWeekday Saturday Saturday    = True\n"
"eqWeekday Sunday Sunday        = True\n"
"eqWeekday _ _                  = False\n"
msgstr ""
"total\n"
"eqWeekday : Weekday -> Weekday -> Bool\n"
"eqWeekday Monday Monday        = True\n"
"eqWeekday Tuesday Tuesday      = True\n"
"eqWeekday Wednesday Wednesday  = True\n"
"eqWeekday Thursday Thursday    = True\n"
"eqWeekday Friday Friday        = True\n"
"eqWeekday Saturday Saturday    = True\n"
"eqWeekday Sunday Sunday        = True\n"
"eqWeekday _ _                  = False\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:143
#, no-wrap
msgid "Enumeration Types in the Prelude"
msgstr "Prelude 中的枚举类型"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:151
#, no-wrap
msgid ""
"Data types like `Weekday` consisting of a finite set\n"
"of values are sometimes called *enumerations*. The Idris\n"
"*Prelude* defines some common enumerations for us, for\n"
"instance `Bool` and `Ordering`. As with `Weekday`,\n"
"we can use pattern matching when implementing functions\n"
"on these types:\n"
msgstr "`Weekday` 等数据类型由有限集组成的值有时称为*枚举*。Idris 的 *Prelude* 为我们定义了一些常见的枚举，例如 `Bool` 和 `Ordering`。与 `Weekday` 一样，我们可以在实现函数时使用模式匹配在这些类型上：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:152
#, no-wrap
msgid ""
"-- this is how `not` is implemented in the *Prelude*\n"
"total\n"
"negate : Bool -> Bool\n"
"negate False = True\n"
"negate True  = False\n"
msgstr ""
"-- 这个是 *Prelude* 中的 `not` 函数的实现\n"
"negate : Bool -> Bool\n"
"negate False = True\n"
"negate True  = False\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:162
#, no-wrap
msgid ""
"The `Ordering` data type describes an ordering relation\n"
"between two values. For instance:\n"
msgstr "`Ordering` 数据类型描述了两个值之间的顺序关系。例如：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:163
#, no-wrap
msgid ""
"total\n"
"compareBool : Bool -> Bool -> Ordering\n"
"compareBool False False = EQ\n"
"compareBool False True  = LT\n"
"compareBool True True   = EQ\n"
"compareBool True False  = GT\n"
msgstr ""
"total\n"
"compareBool : Bool -> Bool -> Ordering\n"
"compareBool False False = EQ\n"
"compareBool False True  = LT\n"
"compareBool True True   = EQ\n"
"compareBool True False  = GT\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:176
#, no-wrap
msgid ""
"Here, `LT` means that the first argument is *less than*\n"
"the second, `EQ` means that the two arguments are *equal*\n"
"and `GT` means, that the first argument is *greater than*\n"
"the second.\n"
msgstr ""
"这里，`LT` 表示第一个参数是*小于*"
"第二个，`EQ`表示两个参数是*相等*，"
"`GT` 表示第一个参数是*大于*"
"第二个。\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:177
#, no-wrap
msgid "Case Expressions"
msgstr "Case 表达式"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:183
#, no-wrap
msgid ""
"Sometimes we need to perform a computation with one\n"
"of the arguments and want to pattern match on the result\n"
"of this computation. We can use *case expressions* in this\n"
"situation:\n"
msgstr "有时我们需要对参数执行计算并希望对结果进行模式匹配。这种情况下我们可以使用 *case 表达式*：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:184
#, no-wrap
msgid ""
"-- returns the larger of the two arguments\n"
"total\n"
"maxBits8 : Bits8 -> Bits8 -> Bits8\n"
"maxBits8 x y =\n"
"  case compare x y of\n"
"    LT => y\n"
"    _  => x\n"
msgstr ""
"-- 返回两个参数中的最大值\n"
"total\n"
"maxBits8 : Bits8 -> Bits8 -> Bits8\n"
"maxBits8 x y =\n"
"  case compare x y of\n"
"    LT => y\n"
"    _  => x\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:202
#, no-wrap
msgid ""
"The first line of the case expression (`case compare x y of`)\n"
"will invoke function `compare` with arguments `x` and `y`. On\n"
"the following (indented) lines, we pattern match on the result\n"
"of this computation. This is of type `Ordering`, so we expect\n"
"one of the three constructors `LT`, `EQ`, or `GT` as the result.\n"
"On the first line, we handle the `LT` case explicitly, while\n"
"the other two cases are handled with an underscore as a catch-all\n"
"pattern.\n"
msgstr "case 表达式的第一行(`case compare x y of`)将使用参数 `x` 和 `y` 调用函数`compare`。后面的（缩进）行，我们对结果进行模式匹配。compare的返回类型为 `Ordering`，所以我们期望结果是三个构造函数 `LT`、`EQ` 或 `GT` 之一。在第一行，我们明确地处理 `LT` 的情况，而其他两种情况下划线作为全捕获模式处理。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:206
#, no-wrap
msgid ""
"Note, that indentation matters here: The case block as a whole\n"
"must be indented (if it starts on a new line), and the different\n"
"cases must also be indented by the same amount of whitespace.\n"
msgstr "请注意，缩进在这里很重要：整个 Case 块必须缩进（如果它从新行开始），并且不同的 Case 也必须缩进相同数量的空格。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:209
#, no-wrap
msgid ""
"Function `compare` is overloaded for many data types. We will\n"
"learn how this works when we talk about interfaces.\n"
msgstr "函数 `compare` 对许多数据类型进行了重载。当我们谈论接口时，我们将了解它是如何工作的。\n"

#. type: Title ####
#: ../src/Tutorial/DataTypes.md:210
#, no-wrap
msgid "If Then Else"
msgstr "If Then Else"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:214
#, no-wrap
msgid ""
"When working with `Bool`, there is an alternative to pattern matching\n"
"common to most programming languages:\n"
msgstr "使用 `Bool` 时，可以使用模式匹配的替代方法，同时也是大多数编程语言的共同点：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:215
#, no-wrap
msgid ""
"total\n"
"maxBits8' : Bits8 -> Bits8 -> Bits8\n"
"maxBits8' x y = if compare x y == LT then y else x\n"
msgstr ""
"total\n"
"maxBits8' : Bits8 -> Bits8 -> Bits8\n"
"maxBits8' x y = if compare x y == LT then y else x\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:225
#, no-wrap
msgid ""
"Note, that the `if then else` expression always returns a value\n"
"and therefore, the `else` branch cannot be dropped. This is different\n"
"from the behavior in typical imperative languages, where `if` is\n"
"a statement with possible side effects.\n"
msgstr "请注意，`if then else` 表达式总是返回一个值。因此，不能删除 `else` 分支。这是和典型的命令式语言中的行为所不同的，其中 `if` 是可能产生副作用的声明。\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:226
#, no-wrap
msgid "Naming Conventions: Identifiers"
msgstr "命名约定：标识符"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:233
#, no-wrap
msgid ""
"While we are free to use lower-case and upper-case identifiers for\n"
"function names, type- and data constructors must be given upper-case\n"
"identifiers in order not to confuse Idris (operators are also fine).\n"
"For instance, the following data definition is not valid, and Idris\n"
"will complain that it expected upper-case identifiers:\n"
msgstr ""
"虽然我们可以自由使用小写和大写函数名标识符，"
"但是类型和数据构造函数必须为大写标识符，以免对 Idris 产生混淆（运算符也可以）。例如，以下数据定义无效，并且 Idris会抱怨它需要大写的标识符：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:234
#, no-wrap
msgid "data foo = bar | baz\n"
msgstr "data foo = bar | baz\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:240
#, no-wrap
msgid ""
"The same goes for similar data definitions like records and sum types\n"
"(both will be explained below):\n"
msgstr "类似的数据定义（如记录与和类型）也是如此（两者都将在下面解释）：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:241
#, no-wrap
msgid ""
"-- not valid Idris\n"
"record Foo where\n"
"  constructor mkfoo\n"
msgstr ""
"-- 非法的 Idris 定义\n"
"record Foo where\n"
"  constructor mkfoo\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:252
#, no-wrap
msgid ""
"On the other hand, we typically use lower-case identifiers for function\n"
"names, unless we plan to use them mostly during type checking (more on this\n"
"later). This is not enforced by Idris, however, so if you are working in\n"
"a domain where upper-case identifiers are preferable, feel free to use\n"
"those:\n"
msgstr "另一方面，我们通常使用小写的函数标识符名称，除非我们计划主要在类型检查期间使用它们（之后会有更多关于这个的讨论）。然而，这不是 Idris 强制执行的，所以如果你在首选大写标识符的地方，请随意使用他们：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:253
#, no-wrap
msgid ""
"foo : Bits32 -> Bits32\n"
"foo = (* 2)\n"
"\n"
"Bar : Bits32 -> Bits32\n"
"Bar = foo\n"
msgstr ""
"foo : Bits32 -> Bits32\n"
"foo = (* 2)\n"
"\n"
"Bar : Bits32 -> Bits32\n"
"Bar = foo\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr "练习第 1 部分"

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:267
#, no-wrap
msgid ""
"Use pattern matching to implement your own\n"
"versions of boolean operators\n"
"`(&&)` and `(||)` calling them `and` and `or`\n"
"respectively.\n"
msgstr "使用模式匹配来实现您自己版本的布尔运算符 `(&&)` 和 `(||)` ，分别称为 `and` "
"和 `or`。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:274
#, no-wrap
msgid ""
"   Note: One way to go about this is to enumerate\n"
"   all four possible combinations of two boolean\n"
"   values and give the result for each. However, there\n"
"   is a shorter, more clever way,\n"
"   requiring only two pattern matches for each of the\n"
"   two functions.\n"
msgstr "   注意：解决此问题的一种方法是枚举两个布尔值的所有四种可能组合值并给出每个结果。然而，有一种更短、更聪明的方式，两个函数每个只需要两个模式匹配。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:282
#, no-wrap
msgid ""
"Define your own data type representing different\n"
"units of time (seconds, minutes,\n"
"hours, days, weeks), and implement the following\n"
"functions for converting between time spans using\n"
"different units. Hint: Use integer division (`div`)\n"
"when going from seconds to some larger unit like\n"
"hours).\n"
msgstr ""
"定义您自己的数据类型来表示不同的时间单位（秒、分钟、小时、天、周），并实现以"
"下函数以使用不同的单位在时间跨度之间进行转换。提示：当从秒到一些更大的单位（"
"如小时）时，使用整数除法（`div`）。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:283
#, no-wrap
msgid ""
"   data UnitOfTime = Second -- add additional values\n"
"\n"
"   -- calculate the number of seconds from a\n"
"   -- number of steps in the given unit of time\n"
"   total\n"
"   toSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- Given a number of seconds, calculate the\n"
"   -- number of steps in the given unit of time\n"
"   total\n"
"   fromSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- convert the number of steps in a given unit of time\n"
"   -- to the number of steps in another unit of time.\n"
"   -- use `fromSeconds` and `toSeconds` in your implementation\n"
"   total\n"
"   convert : UnitOfTime -> Integer -> UnitOfTime -> Integer\n"
msgstr ""
"   data UnitOfTime = Second -- 添加剩余的值\n"
"\n"
"   -- 给定一个数字及时间单位，计算出对应的秒数\n"
"   toSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- 给定一个秒数和时间单位，计算出对应的数字\n"
"   total\n"
"   fromSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- 给出待转换的时间单位及数字，然后给出要转换的时间单位，计算出结果数字\n"
"   -- 在实现中使用 `fromSeconds` 和 `toSeconds`\n"
"   total\n"
"   convert : UnitOfTime -> Integer -> UnitOfTime -> Integer\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:306
#, no-wrap
msgid ""
"Define a data type for representing a subset of the\n"
"chemical elements: Hydrogen (H), Carbon (C), Nitrogen (N),\n"
"Oxygen (O), and Fluorine (F).\n"
msgstr "定义用于表示化学元素子集的数据类型：氢 (H)、碳 (C)、氮 (N)、氧 (O) 和氟 (F)。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:309
#, no-wrap
msgid ""
"   Declare and implement function `atomicMass`, which for each element\n"
"   returns its atomic mass in dalton:\n"
msgstr "   声明并实现函数 `atomicMass`，它对每个元素返回以道尔顿为单位的原子质量：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:310
#, no-wrap
msgid ""
"   Hydrogen : 1.008\n"
"   Carbon : 12.011\n"
"   Nitrogen : 14.007\n"
"   Oxygen : 15.999\n"
"   Fluorine : 18.9984\n"
msgstr ""
"   Hydrogen : 1.008\n"
"   Carbon : 12.011\n"
"   Nitrogen : 14.007\n"
"   Oxygen : 15.999\n"
"   Fluorine : 18.9984\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:318
#, no-wrap
msgid "Sum Types"
msgstr "和类型"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:326
#, no-wrap
msgid ""
"Assume we'd like to write some web form, where users of our\n"
"web application can decide how they like to be addressed.\n"
"We give them a choice between two common predefined\n"
"forms of address (Mr and Mrs), but also allow them to\n"
"decide on a customized form. The possible\n"
"choices can be encapsulated in an Idris data type:\n"
msgstr ""
"假设我们想写一些 web 表单，我们的 Web 应用程序用户可以决定他们喜欢如何处理。我们让他们在两个常见的预定义之间进行选择地址形式（先生和夫人），但也允许他们决定一个定制的表格。可能的\n"
"选择可以封装在 Idris 数据类型中：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:327
#, no-wrap
msgid "data Title = Mr | Mrs | Other String\n"
msgstr "data Title = Mr | Mrs | Other String\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:336
#, no-wrap
msgid ""
"This looks almost like an enumeration type, with the exception\n"
"that there is a new thing, called a *data constructor*,\n"
"which accepts a `String` argument (actually, the values\n"
"in an enumeration are also called (nullary) data constructors).\n"
"If we inspect the types at the REPL, we learn the following:\n"
msgstr ""
"这看起来几乎像一个枚举类型，除了\n"
"有一个新东西，叫做*数据构造函数*，\n"
"它接受一个 `String` 参数（实际上，值\n"
"在枚举中也称为（空）数据构造函数）。\n"
"如果我们检查 REPL 中的类型，我们会了解到以下内容：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:337
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Mr\n"
"Tutorial.DataTypes.Mr : Title\n"
"Tutorial.DataTypes> :t Other\n"
"Tutorial.DataTypes.Other : String -> Title\n"
msgstr ""
"Tutorial.DataTypes> :t Mr\n"
"Tutorial.DataTypes.Mr : Title\n"
"Tutorial.DataTypes> :t Other\n"
"Tutorial.DataTypes.Other : String -> Title\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:347
#, no-wrap
msgid ""
"So, `Other` is a *function* from `String` to `Title`. This\n"
"means, that we can pass `Other` a `String` argument and get\n"
"a `Title` as the result:\n"
msgstr "所以，`Other` 是从 `String` 到 `Title` 的*函数*。这意味着，我们可以传递给 `Other` 一个 `String` 参数并得到结果 `Title`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:348
#, no-wrap
msgid ""
"total\n"
"dr : Title\n"
"dr = Other \"Dr.\"\n"
msgstr ""
"total\n"
"dr : Title\n"
"dr = Other \"Dr.\"\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:358
#, no-wrap
msgid ""
"Again, a value of type `Title` can only consist of one\n"
"of the three choices listed above, and again,\n"
"we can use pattern matching to implement functions\n"
"on the `Title` data type in a provably total way:\n"
msgstr ""
"同样，`Title` 类型的值只能包含一个\n"
"在上面列出的三个选择中的一个，再一次，我们可以使用模式匹配来实现函数\n"
"在 `Title` 数据类型上以可证明的全部方式：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:359
#, no-wrap
msgid ""
"total\n"
"showTitle : Title -> String\n"
"showTitle Mr        = \"Mr.\"\n"
"showTitle Mrs       = \"Mrs.\"\n"
"showTitle (Other x) = x\n"
msgstr ""
"total\n"
"showTitle : Title -> String\n"
"showTitle Mr        = \"Mr.\"\n"
"showTitle Mrs       = \"Mrs.\"\n"
"showTitle (Other x) = x\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:372
#, no-wrap
msgid ""
"Note, how in the last pattern match, the string value stored\n"
"in the `Other` data constructor is *bound* to local variable `x`.\n"
"Also, the `Other x` pattern has to be wrapped in parentheses,\n"
"as otherwise Idris would think `Other` and `x` were to\n"
"distinct function arguments.\n"
msgstr "注意，在最后一个模式匹配中，存储在 `Other` 数据构造函数中字符串值被 *绑定* 到局部变量 `x`。此外，`Other x` 模式必须用括号括起来，否则 Idris 会认为 `Other` 和 `x` 是不同的函数参数。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:377
#, no-wrap
msgid ""
"This is a very common way to extract the values from\n"
"data constructors.\n"
"We can use `showTitle` to implement a function for creating\n"
"a courteous greeting:\n"
msgstr "这是从数据构造函数中提取值的通用方式。我们可以使用 `showTitle` 来实现创建礼貌问候的函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:378
#, no-wrap
msgid ""
"total\n"
"greet : Title -> String -> String\n"
"greet t name = \"Hello, \" ++ showTitle t ++ \" \" ++ name ++ \"!\"\n"
msgstr ""
"total\n"
"greet : Title -> String -> String\n"
"greet t name = \"Hello, \" ++ showTitle t ++ \" \" ++ name ++ \"!\"\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:387
#, no-wrap
msgid ""
"In the implementation of `greet`, we use string literals\n"
"and the string concatenation operator `(++)` to\n"
"assemble the greeting from its parts.\n"
msgstr "在 `greet` 的实现中，我们使用字符串字面量和字符串连接运算符 `(++)` 从各个部分组装问候语。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:389
#, no-wrap
msgid "At the REPL:\n"
msgstr "在 REPL 中：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:390
#, no-wrap
msgid ""
"Tutorial.DataTypes> greet dr \"Höck\"\n"
"\"Hello, Dr. Höck!\"\n"
"Tutorial.DataTypes> greet Mrs \"Smith\"\n"
"\"Hello, Mrs. Smith!\"\n"
msgstr ""
"Tutorial.DataTypes> greet dr \"Höck\"\n"
"\"Hello, Dr. Höck!\"\n"
"Tutorial.DataTypes> greet Mrs \"Smith\"\n"
"\"Hello, Mrs. Smith!\"\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:400
#, no-wrap
msgid ""
"Data types like `Title` are called *sum types* as they consist\n"
"of the sum of their different parts: A value of type `Title`\n"
"is either a `Mr`, a `Mrs`, or a `String` wrapped up in `Other`.\n"
msgstr "像 `Title` 这样的数据类型被称为*和类型* 因为它们由不同部分的和组成：`Title` 类型的值是 `Mr`、`Mrs` 或包裹在 `Other` 中的 `String`。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:407
#, no-wrap
msgid ""
"Here's another (drastically simplified) example of a sum type.\n"
"Assume we allow two forms of authentication in our web application:\n"
"Either by entering a username plus a password (for which we'll use\n"
"an unsigned 64 bit integer here), or by providing user name\n"
"plus a (very complex) secret key.\n"
"Here's a data type to encapsulate this use case:\n"
msgstr ""
"这是 sum 类型的另一个（大大简化的）示例。\n"
"假设我们在 Web 应用程序中允许两种形式的身份验证：\n"
"通过输入用户名和密码（我们将使用\n"
"此处为无符号 64 位整数），或通过提供用户名加上一个（非常复杂的）密钥。\n"
"这是封装此用例的数据类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:408
#, no-wrap
msgid "data Credentials = Password String Bits64 | Key String String\n"
msgstr "data Credentials = Password String Bits64 | Key String String\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:414
#, no-wrap
msgid ""
"As an example of a very primitive login function, we can\n"
"hard-code some known credentials:\n"
msgstr "作为一个非常原始的登录函数的例子，我们可以硬编码一些已知的凭据：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:415
#, no-wrap
msgid ""
"total\n"
"login : Credentials -> String\n"
"login (Password \"Anderson\" 6665443) = greet Mr \"Anderson\"\n"
"login (Key \"Y\" \"xyz\")               = greet (Other \"Agent\") \"Y\"\n"
"login _                             = \"Access denied!\"\n"
msgstr ""
"total\n"
"login : Credentials -> String\n"
"login (Password \"Anderson\" 6665443) = greet Mr \"Anderson\"\n"
"login (Key \"Y\" \"xyz\")               = greet (Other \"Agent\") \"Y\"\n"
"login _                             = \"Access denied!\"\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:426
#, no-wrap
msgid ""
"As can be seen in the example above, we can also pattern\n"
"match against primitive values by using integer and\n"
"string literals. Give `login` a go at the REPL:\n"
msgstr "从上面的例子中可以看出，我们也可以通过使用整数和字符串字面量的原始值进行模式匹配字。在 REPL 中试一试 `login`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:427
#, no-wrap
msgid ""
"Tutorial.DataTypes> login (Password \"Anderson\" 6665443)\n"
"\"Hello, Mr. Anderson!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"xyz\")\n"
"\"Hello, Agent Y!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"foo\")\n"
"\"Access denied!\"\n"
msgstr ""
"Tutorial.DataTypes> login (Password \"Anderson\" 6665443)\n"
"\"Hello, Mr. Anderson!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"xyz\")\n"
"\"Hello, Agent Y!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"foo\")\n"
"\"Access denied!\"\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:962
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:712
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr "练习第 2 部分"

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:440
#, no-wrap
msgid ""
"Implement an equality test for `Title` (you can use the\n"
"equality operator `(==)` for comparing two `String`s):\n"
msgstr "为 `Title` 实现相等测试（您可以使用相等运算符 `(==)` 比较两个 `String`）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:441
#, no-wrap
msgid ""
"   total\n"
"   eqTitle : Title -> Title -> Bool\n"
msgstr ""
"   total\n"
"   eqTitle : Title -> Title -> Bool\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:448
#, no-wrap
msgid ""
"For `Title`, implement a simple test to check, whether\n"
"a custom title is being used:\n"
msgstr "对于 `Title`，实现一个简单的测试来检查是否正在使用自定义标题：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:449
#, no-wrap
msgid ""
"   total\n"
"   isOther : Title -> Bool\n"
msgstr ""
"   total\n"
"   isOther : Title -> Bool\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:456
#, no-wrap
msgid ""
"Given our simple `Credentials` type, there are three\n"
"ways for authentication to fail:\n"
msgstr "鉴于我们简单的 `Credentials` 类型，身份验证失败的三种方式：\n"

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
#, no-wrap
msgid "An unknown username was used.\n"
msgstr "使用了未知的用户名。\n"

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
#, no-wrap
msgid ""
"The password given does not match the one associated with\n"
"the username.\n"
msgstr "给定的密码与与用户名关联的密码不匹配。\n"

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
#, no-wrap
msgid "An invalid key was used.\n"
msgstr "使用了无效的密钥。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:467
#, no-wrap
msgid ""
"   Encapsulate these three possibilities in a sum type\n"
"   called `LoginError`,\n"
"   but make sure not to disclose any confidential information:\n"
"   An invalid username should be stored in the corresponding\n"
"   error value, but an invalid password or key should not.\n"
msgstr "   将这三种可能性封装在叫做 `LoginError` 的和类型中，但请确保不要泄露任何机密信息：无效的用户名应存储相应的错误值，但不应该存储无效的密码或密钥。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:471
#, no-wrap
msgid ""
"Implement function `showError : LoginError -> String`, which\n"
"can be used to display an error message to the user who\n"
"unsuccessfully tried to login into our web application.\n"
msgstr ""
"实现函数 `showError : LoginError -> String`，可用于向尝试登录我们的 Web "
"应用程序失败的用户显示错误消息。\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:472
#, no-wrap
msgid "Records"
msgstr "记录"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:481
#, no-wrap
msgid ""
"It is often useful to group together several values\n"
"as a logical unit. For instance, in our web application\n"
"we might want to group information about a user\n"
"in a single data type. Such data types are often called\n"
"*product types* (see below for an explanation).\n"
"The most common and convenient way to\n"
"define them is the `record` construct:\n"
msgstr ""
"将几个值组合在一起作为一个逻辑单元通常很有用。例如，在我们的 Web 应用程序中，我们可能想要对用户的信息进行分组\n"
"在单一数据类型中。这种数据类型通常被称为*积类型*（见下文解释）。最常见和最方便义方式是通过 `record` 构造进行定义：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:482
#, no-wrap
msgid ""
"record User where\n"
"  constructor MkUser\n"
"  name  : String\n"
"  title : Title\n"
"  age   : Bits8\n"
msgstr ""
"record User where\n"
"  constructor MkUser\n"
"  name  : String\n"
"  title : Title\n"
"  age   : Bits8\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:493
#, no-wrap
msgid ""
"The declaration above creates a new *type* called `User`,\n"
"and a new *data constructor* called `MkUser`. As usual,\n"
"have a look at their types in the REPL:\n"
msgstr "上面的声明创建了一个名为 `User` 的新 *类型*，和一个名为 `MkUser` 的新 *数据构造函数*。照常，看看他们在 REPL 中的类型：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:494
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t User\n"
"Tutorial.DataTypes.User : Type\n"
"Tutorial.DataTypes> :t MkUser\n"
"Tutorial.DataTypes.MkUser : String -> Title -> Bits8 -> User\n"
msgstr ""
"Tutorial.DataTypes> :t User\n"
"Tutorial.DataTypes.User : Type\n"
"Tutorial.DataTypes> :t MkUser\n"
"Tutorial.DataTypes.MkUser : String -> Title -> Bits8 -> User\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:504
#, no-wrap
msgid ""
"We can use `MkUser` (which is a function from\n"
"`String` to `Title` to `Bits8` to `User`)\n"
"to create values of type `User`:\n"
msgstr ""
"我们可以使用 `MkUser` （这会从\n"
"`String` 到 `Title` 到 `Bits8` 到 `User`）\n"
"创建 `User` 类型的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:505
#, no-wrap
msgid ""
"total\n"
"agentY : User\n"
"agentY = MkUser \"Y\" (Other \"Agent\") 51\n"
"\n"
"total\n"
"drNo : User\n"
"drNo = MkUser \"No\" dr 73\n"
msgstr ""
"total\n"
"agentY : User\n"
"agentY = MkUser \"Y\" (Other \"Agent\") 51\n"
"\n"
"total\n"
"drNo : User\n"
"drNo = MkUser \"No\" dr 73\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:517
#, no-wrap
msgid ""
"We can also use pattern matching to extract the fields from\n"
"a `User` value (they can again be bound to local variables):\n"
msgstr "我们还可以使用模式匹配从 `User` 提取值（它们可以再次绑定到局部变量）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:518
#, no-wrap
msgid ""
"total\n"
"greetUser : User -> String\n"
"greetUser (MkUser n t _) = greet t n\n"
msgstr ""
"total\n"
"greetUser : User -> String\n"
"greetUser (MkUser n t _) = greet t n\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:530
#, no-wrap
msgid ""
"In the example above, the `name` and `title` field\n"
"are bound to two new local variables (`n` and `t` respectively),\n"
"which can then be used on the right hand side of `greetUser`'s\n"
"implementation. For the `age` field, which is not used\n"
"on the right hand side, we can use an underscore as a catch-all\n"
"pattern.\n"
msgstr ""
"在上面的示例中，`name` 和 `title` 字段\n"
"绑定到两个新的局部变量（分别为 `n` 和 `t`），\n"
"然后可以在 `greetUser` 的右侧实现使用"
"。对于 `age` 字段，在右侧未使用，我们可以使用下划线作为全捕获模式。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:545
#, no-wrap
msgid ""
"Note, how Idris will prevent us from making\n"
"a common mistake: If we confuse the order of arguments, the\n"
"implementation will no longer type check. We can verify this\n"
"by putting the erroneous code in a `failing` block: This\n"
"is an indented code block, which will lead to an error\n"
"during elaboration (type checking). We can give part\n"
"of the expected error message as an optional string argument to\n"
"a failing block. If this does not match part of\n"
"the error message (or the whole code block does not fail\n"
"to type check) the `failing` block itself fails to type\n"
"check. This is a useful tool to demonstrate that type\n"
"safety works in two directions: We can show that valid\n"
"code type checks but also that invalid code is rejected\n"
"by the Idris elaborator:\n"
msgstr ""
"请注意，如果我们混淆了参数的顺序，Idris 将会阻止我们这个常见的错误：\n"
"实现将不能通过行类型检查。我们可以验证这一点，通过将错误代码放入 `failing` 块中：这是缩进的代码块，在细化过程中（类型检查）会导致错误。我们可以给一部分预期的错误消息作为 failing 块的可选字符串参数。如果这不能匹配部分错误消息（或在类型检查中不会失败的整个代码块类）`failing` 块本身无法通过类型检查。下面是对类型安全有帮助的两个方向：通过 Idris 细化，我们可以证明有效代码类型检查，但拒绝无效代码：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:546
#, no-wrap
msgid ""
"failing \"Mismatch between: String and Title\"\n"
"  greetUser' : User -> String\n"
"  greetUser' (MkUser n t _) = greet n t\n"
msgstr ""
"failing \"Mismatch between: String and Title\"\n"
"  greetUser' : User -> String\n"
"  greetUser' (MkUser n t _) = greet n t\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:558
#, no-wrap
msgid ""
"In addition, for every record field, Idris creates an\n"
"extractor function of the same name. This can either\n"
"be used as a regular function, or it can be used in\n"
"postfix notation by appending it to a variable of\n"
"the record type separated by a dot. Here are two examples\n"
"for extracting the age from a user:\n"
msgstr ""
"此外，对于每个记录字段，Idris 都会创建一个同名提取函数。这既可以可以用作常规函数，也可以用于通过将后缀表示法附加到变量，把记录类型用点作为分隔。\n"
"这里有两个例子，\n"
"从用户那里提取年龄：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:559
#, no-wrap
msgid ""
"getAgeFunction : User -> Bits8\n"
"getAgeFunction u = age u\n"
"\n"
"getAgePostfix : User -> Bits8\n"
"getAgePostfix u = u.age\n"
msgstr ""
"getAgeFunction : User -> Bits8\n"
"getAgeFunction u = age u\n"
"\n"
"getAgePostfix : User -> Bits8\n"
"getAgePostfix u = u.age\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:567
#, no-wrap
msgid "Syntactic Sugar for Records"
msgstr "记录的语法糖"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:581
#, no-wrap
msgid ""
"As was already mentioned in the [intro](Intro.md), Idris\n"
"is a *pure* functional programming language. In pure functions,\n"
"we are not allowed to modify global mutable state. As such,\n"
"if we want to modify a record value, we will always\n"
"create a *new* value with the original value remaining\n"
"unchanged: Records and other Idris values are *immutable*.\n"
"While this *can* have a slight impact on performance, it has\n"
"the benefit that we can freely pass a record value to\n"
"different functions, without fear of the functions modifying\n"
"the value by in-place mutation. These are, again, very strong\n"
"guarantees, which makes it drastically easier to reason\n"
"about our code.\n"
msgstr ""
"正如在 [介绍](Intro.md) 中已经提到的，Idris是一种*纯*函数式编程语言。在纯函数中，\n"
"我们不允许修改全局可变状态。像这样，\n"
"如果我们想修改记录值，我们总是创建一个*新*值，保留原始值不变：记录和其他 Idris 值是*不可变的*。\n"
"虽然这个*可能会*对性能有轻微影响，但我们可以自由地将记录值传递给不同的函数会带来一些好处，不用担心函数会修改参数值。这些是非常强大的保证，这使得对我们的代码推理变得更加容易。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:586
#, no-wrap
msgid ""
"There are several ways to modify a record, the most\n"
"general being to pattern match on the record and\n"
"adjust each field as desired. If, for instance, we'd like\n"
"to increase the age of a `User` by one, we could do the following:\n"
msgstr ""
"有几种方法可以修改记录，最通用的是在记录上进行模式匹配，并且\n"
"根据需要调整每个字段。例如，如果我们想要将 `User` 的年龄增加一，我们可以执行以下操作：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:587
#, no-wrap
msgid ""
"total\n"
"incAge : User -> User\n"
"incAge (MkUser name title age) = MkUser name title (age + 1)\n"
msgstr ""
"total\n"
"incAge : User -> User\n"
"incAge (MkUser name title age) = MkUser name title (age + 1)\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:597
#, no-wrap
msgid ""
"That's a lot of code for such a simple thing, so Idris offers\n"
"several syntactic conveniences for this. For instance,\n"
"using *record* syntax, we can just access and update the `age`\n"
"field of a value:\n"
msgstr ""
"这么简单的事情有很多代码，所以 Idris 为此提供了几种语法糖。例如，\n"
"使用*记录*语法，我们可以访问和更新 `age` 字段的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:598
#, no-wrap
msgid ""
"total\n"
"incAge2 : User -> User\n"
"incAge2 u = { age := u.age + 1 } u\n"
msgstr ""
"total\n"
"incAge2 : User -> User\n"
"incAge2 u = { age := u.age + 1 } u\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:607
#, no-wrap
msgid ""
"Assignment operator `:=` assigns a new value to the `age` field\n"
"in `u`. Remember, that this will create a new `User` value. The original\n"
"value `u` remains unaffected by this.\n"
msgstr "赋值运算符 `:=` 为 在 `u` 中的 `age` 字段分配一个新值。请记住，这将创建一个新的 `User` 值。原本的值 `u` 不受此影响。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:613
#, no-wrap
msgid ""
"We can access a record field, either by using the field name\n"
"as a projection function (`age u`; also have a look at `:t age`\n"
"in the REPL), or by using dot syntax: `u.age`. This is special\n"
"syntax and *not* related to the dot operator for function\n"
"composition (`(.)`).\n"
msgstr ""
"我们可以通过使用字段名称来访问记录字段，\n"
"作为投影函数 (`age u`; 在 REPL 中看看 `:t age`），或使用点语法：`u.age`。这个特殊语法与函数组合的点运算符（`(.)`）*不*相关。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:616
#, no-wrap
msgid ""
"The use case of modifying a record field is so common\n"
"that Idris provides special syntax for this as well:\n"
msgstr ""
"修改记录字段的用例如此普遍，\n"
"Idris 也为此提供了特殊的语法：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:617
#, no-wrap
msgid ""
"total\n"
"incAge3 : User -> User\n"
"incAge3 u = { age $= (+ 1) } u\n"
msgstr ""
"total\n"
"incAge3 : User -> User\n"
"incAge3 u = { age $= (+ 1) } u\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:627
#, no-wrap
msgid ""
"Here, I used an *operator section* (`(+ 1)`) to make\n"
"the code more concise.\n"
"As an alternative to an operator section,\n"
"we could have used an anonymous function like so:\n"
msgstr ""
"在这里，我使用了*运算符块*(`(+ 1)`)来使代码更简洁。\n"
"作为运算符块的替代方案，\n"
"我们可以像这样使用匿名函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:628
#, no-wrap
msgid ""
"total\n"
"incAge4 : User -> User\n"
"incAge4 u = { age $= \\x => x + 1 } u\n"
msgstr ""
"total\n"
"incAge4 : User -> User\n"
"incAge4 u = { age $= \\x => x + 1 } u\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:637
#, no-wrap
msgid ""
"Finally, since our function's argument `u` is only used\n"
"once at the very end, we can drop it altogether,\n"
"to get the following, highly concise version:\n"
msgstr ""
"最后，由于我们函数的参数 `u` 只是在最后被使用一次，我们可以完全放弃它，\n"
"获得以下高度简洁的版本：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:638
#, no-wrap
msgid ""
"total\n"
"incAge5 : User -> User\n"
"incAge5 = { age $= (+ 1) }\n"
msgstr ""
"total\n"
"incAge5 : User -> User\n"
"incAge5 = { age $= (+ 1) }\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:645
#, no-wrap
msgid "As usual, we should have a look at the result at the REPL:\n"
msgstr "像往常一样，我们应该看看 REPL 的结果：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:646
#, no-wrap
msgid ""
"Tutorial.DataTypes> incAge5 drNo\n"
"MkUser \"No\" (Other \"Dr.\") 74\n"
msgstr ""
"Tutorial.DataTypes> incAge5 drNo\n"
"MkUser \"No\" (Other \"Dr.\") 74\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:653
#, no-wrap
msgid ""
"It is possible to use this syntax to set and/or update\n"
"several record fields at once:\n"
msgstr "可以使用此语法来设置或更新一个或多个记录字段：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:654
#, no-wrap
msgid ""
"total\n"
"drNoJunior : User\n"
"drNoJunior = { name $= (++ \" Jr.\"), title := Mr, age := 17 } drNo\n"
msgstr ""
"total\n"
"drNoJunior : User\n"
"drNoJunior = { name $= (++ \" Jr.\"), title := Mr, age := 17 } drNo\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:660
#, no-wrap
msgid "Tuples"
msgstr "元组"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:666
#, no-wrap
msgid ""
"I wrote above that a record is also called a *product type*.\n"
"This is quite obvious when we consider the number\n"
"of possible values inhabiting a given type. For instance, consider\n"
"the following custom record:\n"
msgstr ""
"我在上面写了一条记录也被称为*积类型*。\n"
"当我们考虑存在于给定类型中的可能值数量的时候，这是很显而易见的。例如，考虑以下自定义记录：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:667
#, no-wrap
msgid ""
"record Foo where\n"
"  constructor MkFoo\n"
"  wd   : Weekday\n"
"  bool : Bool\n"
msgstr ""
"record Foo where\n"
"  constructor MkFoo\n"
"  wd   : Weekday\n"
"  bool : Bool\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:678
#, no-wrap
msgid ""
"How many possible values of type `Foo` are there? The answer is `7 * 2 = 14`,\n"
"as we can pair every possible `Weekday` (seven in total) with every possible\n"
"`Bool` (two in total). So, the number of possible values of a record type\n"
"is the *product* of the number of possible values for each field.\n"
msgstr ""
"`Foo` 类型的可能值有多少？答案是`7 * 2 = 14`，\n"
"因为我们可以将所有可能的 `Weekday`（总共七个）与所有可能的\n"
"`Bool`（共两个）相乘。因此，记录类型的可能值的数量是每个字段可能值的数量的*积*。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:680
#, no-wrap
msgid "The canonical product type is the `Pair`, which is available from the *Prelude*:\n"
msgstr "规范的积类型是 `Pair`，可从 *Prelude* 获得：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:681
#, no-wrap
msgid ""
"total\n"
"weekdayAndBool : Weekday -> Bool -> Pair Weekday Bool\n"
"weekdayAndBool wd b = MkPair wd b\n"
msgstr ""
"total\n"
"weekdayAndBool : Weekday -> Bool -> Pair Weekday Bool\n"
"weekdayAndBool wd b = MkPair wd b\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:692
#, no-wrap
msgid ""
"Since it is quite common to return several values from a function\n"
"wrapped in a `Pair` or larger tuple, Idris provides some syntactic\n"
"sugar for working with these. Instead of `Pair Weekday Bool`, we\n"
"can just write `(Weekday, Bool)`. Likewise, instead of `MkPair wd b`,\n"
"we can just write `(wd, b)` (the space is optional):\n"
msgstr "因为通过包裹在 `Pair` 或更大的元组中，从一个函数返回多个值是很常见的，Idris 提供了一些与这些一起工作的语法糖。我们可以只写 `(Weekday, Bool)` 来代替 `Pair Weekday Bool`。同样我们可以只写 `(wd, b)` （空格是可选的）来代替 `MkPair wd b`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:693
#, no-wrap
msgid ""
"total\n"
"weekdayAndBool2 : Weekday -> Bool -> (Weekday, Bool)\n"
"weekdayAndBool2 wd b = (wd, b)\n"
msgstr ""
"total\n"
"weekdayAndBool2 : Weekday -> Bool -> (Weekday, Bool)\n"
"weekdayAndBool2 wd b = (wd, b)\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:700
#, no-wrap
msgid "This works also for nested tuples:\n"
msgstr "这也适用于嵌套元组：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:701
#, no-wrap
msgid ""
"total\n"
"triple : Pair Bool (Pair Weekday String)\n"
"triple = MkPair False (Friday, \"foo\")\n"
"\n"
"total\n"
"triple2 : (Bool, Weekday, String)\n"
"triple2 = (False, Friday, \"foo\")\n"
msgstr ""
"total\n"
"triple : Pair Bool (Pair Weekday String)\n"
"triple = MkPair False (Friday, \"foo\")\n"
"\n"
"total\n"
"triple2 : (Bool, Weekday, String)\n"
"triple2 = (False, Friday, \"foo\")\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:713
#, no-wrap
msgid ""
"In the example above, `triple2` is converted to the form\n"
"used in `triple` by the Idris compiler.\n"
msgstr ""
"在上面的例子中，`triple2` 在\n"
"Idris 编译器中会被转换成 `triple` 的形式来使用。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:715
#, no-wrap
msgid "We can even use tuple syntax in pattern matches:\n"
msgstr "我们甚至可以在模式匹配中使用元组语法：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:716
#, no-wrap
msgid ""
"total\n"
"bar : Bool\n"
"bar = case triple of\n"
"  (b,wd,_) => b && isWeekend wd\n"
msgstr ""
"total\n"
"bar : Bool\n"
"bar = case triple of\n"
"  (b,wd,_) => b && isWeekend wd\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:723
#, no-wrap
msgid "As Patterns"
msgstr "As 模式"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:728
#, no-wrap
msgid ""
"Sometimes, we'd like to take apart a value by pattern matching\n"
"on it but still retain the value as a whole for using it\n"
"in further computations:\n"
msgstr "有时，我们想通过模式匹配来提取它上面的一个值，但仍然保留使用它的整体值在进一步的计算中：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:729
#, no-wrap
msgid ""
"total\n"
"baz : (Bool,Weekday,String) -> (Nat,Bool,Weekday,String)\n"
"baz t@(_,_,s) = (length s, t)\n"
msgstr ""
"total\n"
"baz : (Bool,Weekday,String) -> (Nat,Bool,Weekday,String)\n"
"baz t@(_,_,s) = (length s, t)\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:741
#, no-wrap
msgid ""
"In `baz`, variable `t` is *bound* to the triple as a whole, which\n"
"is then reused to construct the resulting quadruple. Remember,\n"
"that `(Nat,Bool,Weekday,String)` is just sugar for\n"
"`Pair Nat (Bool,Weekday,String)`, and `(length s, t)` is just\n"
"sugar for `MkPair (length s) t`. Hence, the implementation above\n"
"is correct as is confirmed by the type checker.\n"
msgstr ""
"在 `baz` 中，变量 `t` 会 *绑定* 到整个三元组，然后被重用以构造生成的四元组。记住，\n"
"`(Nat,Bool,Weekday,String)` 只是 `Pair Nat (Bool,Weekday,String)` 的糖，而 `(length s, t)` 只是\n"
"`MkPair（length s）t` 的糖。因此，上面的实现是正确的，由类型检查器确认。\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1232
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:936
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr "练习第 3 部分"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:748
#, no-wrap
msgid ""
"1. Define a record type for time spans by pairing a `UnitOfTime`\n"
"with an integer representing the duration of the time span in\n"
"the given unit of time. Define also a function for converting\n"
"a time span to an `Integer` representing the duration in seconds.\n"
msgstr "1. 通过把 `UnitOfTime` 和表示时间跨度的整数配对来定义一个记录类型。再定义一个用于转换的函数来定义时间跨度的记录类型，以秒为单位表示持续时间。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:752
#, no-wrap
msgid ""
"2. Implement an equality check for time spans: Two time spans\n"
"should be considered equal, if and only if they correspond to\n"
"the same number of seconds.\n"
msgstr "2. 对时间跨度实施相等检查：两个时间跨度应该被认为是相等的，当且仅当它们对应于相同的秒数。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:757
#, no-wrap
msgid ""
"3. Implement a function for pretty printing time spans:\n"
"The resulting string should display the time span in its\n"
"given unit, plus show the number of seconds in parentheses,\n"
"if the unit is not already seconds.\n"
msgstr ""
"3.实现美观的打印时间跨度的函数：\n"
"结果字符串应显示其时间跨度的给定单位，如果单位还不是秒，再加上括号中显示的秒数。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:761
#, no-wrap
msgid ""
"4. Implement a function for adding two time spans. If the\n"
"two time spans use different units of time, use the smaller\n"
"unit of time to ensure a lossless conversion.\n"
msgstr ""
"4. 实现两个时间跨度相加的功能。如果\n"
"两个时间跨度使用不同的时间单位，使用较小的时间单位，以确保无损转换。\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:762
#, no-wrap
msgid "Generic Data Types"
msgstr "通用数据类型"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:772
#, no-wrap
msgid ""
"Sometimes, a concept is general enough that we'd like\n"
"to apply it not only to a single type, but to all\n"
"kinds of types. For instance, we might not want to define\n"
"data types for lists of integers, lists of strings, and lists\n"
"of booleans, as this would lead to a lot of code duplication.\n"
"Instead, we'd like to have a single generic list type *parameterized*\n"
"by the type of values it stores. This section explains how\n"
"to define and use generic types.\n"
msgstr ""
"有时，我们会喜欢一个概念足够笼统，不仅适用于单一类型，而且适用于所有类型。例如，我们可能不想定义整数列表、字符串列表和布尔列表，因为这会导致大量代码重复。\n"
"相反，我们希望有一个通用列表类型，根据它存储的值的类型*参数化*。本节说明如何定义和使用泛型类型。\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:773
#, no-wrap
msgid "Maybe"
msgstr "Maybe"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:786
#, no-wrap
msgid ""
"Consider the case of parsing\n"
"a `Weekday` from user input. Surely, such\n"
"a function should return `Saturday`, if the\n"
"string input was `\"Saturday\"`, but what if the\n"
"input was `\"sdfkl332\"`? We have several options here.\n"
"For instance, we could just return a default result\n"
"(`Sunday` perhaps?). But is this the behavior\n"
"programmers expect when using our library? Maybe not. To silently\n"
"continue with a default value in the face of invalid user input\n"
"is hardly ever the best choice and may lead to a lot of\n"
"confusion.\n"
msgstr ""
"考虑解析来自用户输入的 `Weekday` 的情况。如果\n"
"字符串输入是 `\"Saturday\"`，一个函数的确应该返回 `Saturday`，但如果\n"
"输入是 `\"sdfkl332\"` 呢？我们在这里有几个选择。\n"
"例如，我们可以只返回一个默认结果\n"
"（也许是 `Sunday` ？）。但这是程序员在使用我们的库时期望行为吗？也许不吧。默默地面对无效的用户输入，继续使用默认值不是最好的选择，可能会导致很多混乱。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:792
#, no-wrap
msgid ""
"In an imperative language, our function would probably\n"
"throw an exception. We could do this in Idris as\n"
"well (there is function `idris_crash` in the *Prelude* for\n"
"this), but doing so, we would abandon totality! A high\n"
"price to pay for such a common thing as a parsing error.\n"
msgstr ""
"在命令式语言中，我们的函数可能会\n"
"抛出异常。我们可以在 Idris 中这样做（*Prelude* 中有功能 `idris_crash`\n"
"这），好吧，但这样做，我们会放弃完全性！为解析错误等常见问题付出过高的代价。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:803
#, no-wrap
msgid ""
"In languages like Java, our function might also return some\n"
"kind of `null` value (leading to the dreaded `NullPointerException`s if\n"
"not handled properly in client code). Our solution will\n"
"be similar, but instead of silently returning `null`,\n"
"we will make the possibility of failure visible in the types!\n"
"We define a custom data type, which encapsulates the possibility\n"
"of failure. Defining new data types in Idris is very cheap\n"
"(in terms of the amount of code needed), therefore this is\n"
"often the way to go in order to increase type safety.\n"
"Here's an example how to do this:\n"
msgstr ""
"在像 Java 这样的语言中，我们的函数也可能返回一种 `null` 值（如果\n"
"未在客户端代码中正确处理，会导致可怕的 `NullPointerException` ）。我们的解决方案将很相似，但不是默默地返回 `null`，我们将在类型中显示失败的可能性！\n"
"我们定义了一个自定义的数据类型，它封装了可能的失败。在 Idris 中定义新的数据类型非常廉价（就所需的代码量而言），因此这通常是为了增加类型安全性。\n"
"这是一个如何执行此操作的示例：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:804
#, no-wrap
msgid ""
"data MaybeWeekday = WD Weekday | NoWeekday\n"
"\n"
"total\n"
"readWeekday : String -> MaybeWeekday\n"
"readWeekday \"Monday\"    = WD Monday\n"
"readWeekday \"Tuesday\"   = WD Tuesday\n"
"readWeekday \"Wednesday\" = WD Wednesday\n"
"readWeekday \"Thursday\"  = WD Thursday\n"
"readWeekday \"Friday\"    = WD Friday\n"
"readWeekday \"Saturday\"  = WD Saturday\n"
"readWeekday \"Sunday\"    = WD Sunday\n"
"readWeekday _           = NoWeekday\n"
msgstr ""
"data MaybeWeekday = WD Weekday | NoWeekday\n"
"\n"
"total\n"
"readWeekday : String -> MaybeWeekday\n"
"readWeekday \"Monday\"    = WD Monday\n"
"readWeekday \"Tuesday\"   = WD Tuesday\n"
"readWeekday \"Wednesday\" = WD Wednesday\n"
"readWeekday \"Thursday\"  = WD Thursday\n"
"readWeekday \"Friday\"    = WD Friday\n"
"readWeekday \"Saturday\"  = WD Saturday\n"
"readWeekday \"Sunday\"    = WD Sunday\n"
"readWeekday _           = NoWeekday\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:823
#, no-wrap
msgid ""
"But assume now, we'd also like to read `Bool` values from\n"
"user input. We'd now have to write a custom data type\n"
"`MaybeBool` and so on for all types we'd like to read\n"
"from `String`, and the conversion of which might fail.\n"
msgstr "但假设现在，我们还想从用户输入读取 `Bool` 值。我们现在必须编写一个自定义数据类型 `MaybeBool` ，还有其他任何我们想从 `String` 中读取的类型，并且转换可能会失败。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:827
#, no-wrap
msgid ""
"Idris, like many other programming languages, allows us\n"
"to generalize this behavior by using *generic data\n"
"types*. Here's an example:\n"
msgstr ""
"与许多其他编程语言一样，Idris 允许我们\n"
"通过使用*泛型数据类型*来概括此行为。这是一个例子：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:828
#, no-wrap
msgid ""
"data Option a = Some a | None\n"
"\n"
"total\n"
"readBool : String -> Option Bool\n"
"readBool \"True\"    = Some True\n"
"readBool \"False\"   = Some False\n"
"readBool _         = None\n"
msgstr ""
"data Option a = Some a | None\n"
"\n"
"total\n"
"readBool : String -> Option Bool\n"
"readBool \"True\"    = Some True\n"
"readBool \"False\"   = Some False\n"
"readBool _         = None\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:839
#, no-wrap
msgid "It is important to go to the REPL and look at the types:\n"
msgstr "重要的是去 REPL 并查看类型：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:840
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Some\n"
"Tutorial.DataTypes.Some : a -> Option a\n"
"Tutorial.DataTypes> :t None\n"
"Tutorial.DataTypes.None : Option a\n"
"Tutorial.DataTypes> :t Option\n"
"Tutorial.DataTypes.Option : Type -> Type\n"
msgstr ""
"Tutorial.DataTypes> :t Some\n"
"Tutorial.DataTypes.Some : a -> Option a\n"
"Tutorial.DataTypes> :t None\n"
"Tutorial.DataTypes.None : Option a\n"
"Tutorial.DataTypes> :t Option\n"
"Tutorial.DataTypes.Option : Type -> Type\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:857
#, no-wrap
msgid ""
"We need to introduce some jargon here. `Option` is what we call\n"
"a *type constructor*. It is not yet a saturated type: It is\n"
"a function from `Type` to `Type`.\n"
"However, `Option Bool` is a type, as is `Option Weekday`.\n"
"Even `Option (Option Bool)` is a valid type. `Option` is\n"
"a type constructor *parameterized* over a *parameter* of type `Type`.\n"
"`Some` and `None` are `Option`s *data constructors*: The functions\n"
"used to create values of type `Option a` for a type `a`.\n"
msgstr ""
"我们需要在这里介绍一些行话。 `Option`就是我们所说的 *类型构造函数*。它还不是饱和类型：它是从 `Type` 到 `Type` 的函数。\n"
"但是，`Option Bool` 是一种类型，`Option Weekday` 也是一种类型。\n"
"甚至 `Option (Option Bool)` 也是有效类型。\n"
"`Option`是\n"
"`Type` 类型的*参数*上的*参数化*类型构造函数。\n"
"`Some` 和 `None` 是 `Option` 的 *数据构造函数*：用于为类型 `a` 创建 `Option a` 类型值的函数。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:860
#, no-wrap
msgid ""
"Let's see some other use cases for `Option`. Below is a safe\n"
"division operation:\n"
msgstr "让我们看看 `Option` 的一些其他用例。下面是安全除法运算：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:861
#, no-wrap
msgid ""
"total\n"
"safeDiv : Integer -> Integer -> Option Integer\n"
"safeDiv n 0 = None\n"
"safeDiv n k = Some (n `div` k)\n"
msgstr ""
"total\n"
"safeDiv : Integer -> Integer -> Option Integer\n"
"safeDiv n 0 = None\n"
"safeDiv n k = Some (n `div` k)\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:872
#, no-wrap
msgid ""
"The possibility of returning some kind of *null* value in the\n"
"face of invalid input is so common, that there is a data type\n"
"like `Option` already in the *Prelude*: `Maybe`, with\n"
"data constructors `Just` and `Nothing`.\n"
msgstr "面对无效输入返回某种 *null* 值的可能性是如此普遍，以至于有一种类似 `Option` 的数据类型已经在 *Prelude* 中了: `Maybe`，它的数据构造函数是 `Just` 和 `Nothing`。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:884
#, no-wrap
msgid ""
"It is important to understand the difference between returning `Maybe Integer`\n"
"in a function, which might fail, and returning\n"
"`null` in languages like Java: In the former case, the\n"
"possibility of failure is visible in the types. The type checker\n"
"will force us to treat `Maybe Integer` differently than\n"
"`Integer`: Idris will *not* allow us to forget to\n"
"eventually handle the failure case.\n"
"Not so, if `null` is silently returned without adjusting the\n"
"types. Programmers may (and often *will*) forget to handle the\n"
"`null` case, leading to unexpected and sometimes\n"
"hard to debug runtime exceptions.\n"
msgstr ""
"了解在一个函数中返回 `Maybe Integer` 之间的区别很重要，它可能会失败，并返回 Java 等语言中的 `null`：在前一种情况下，\n"
"失败的可能性在类型中是可见的。类型检查器将迫使我们不同于 `Integer` 对待 `Maybe Integer` ：Idris 将 *不会* 让我们忘记最终处理失败的情况。\n"
"如果不这样， `null` 被静默返回而不调整\n"
"类型。程序员可能（并且经常 *会*）忘记处理 `null` 的情况，导致意外，有时\n"
"难以调试运行时异常。\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:885
#, no-wrap
msgid "Either"
msgstr "Either"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:896
#, no-wrap
msgid ""
"While `Maybe` is very useful to quickly provide a default\n"
"value to signal some kind of failure, this value (`Nothing`) is\n"
"not very informative. It will not tell us *what exactly*\n"
"went wrong. For instance, in case of our `Weekday`\n"
"reading function, it might be interesting later on to know\n"
"the value of the invalid input string. And just like with\n"
"`Maybe` and `Option` above, this concept is general enough\n"
"that we might encounter other types of invalid values.\n"
"Here's a data type to encapsulate this:\n"
msgstr ""
"虽然 `Maybe` 对于快速提供默认值非常有用\n"
"表示某种故障的值，这个值 (`Nothing`) 是\n"
"不是很丰富。它不会告诉我们*到底是什么*出错。例如，如果我们的 `Weekday`\n"
"解析功能，无效输入字符串的值知道以后可能会很有趣。就像上面的`Maybe`和`Option`，这个概念够笼统，我们可能会遇到其他类型的无效值。这是一个封装它的数据类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:897
#, no-wrap
msgid "data Validated e a = Invalid e | Valid a\n"
msgstr "data Validated e a = Invalid e | Valid a\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:907
#, no-wrap
msgid ""
"`Validated` is a type constructor parameterized over two\n"
"type parameters `e` and `a`. It's data constructors\n"
"are `Invalid` and `Valid`,\n"
"the former holding a value describing some error condition,\n"
"the latter the result in case of a successful computation.\n"
"Let's see this in action:\n"
msgstr ""
"`Validated` 是一个通过两个类型参数 `e` 和 `a` 进行参数化的类型构造函数。它的数据构造函数是`Invalid`和`Valid`，\n"
"前者持有一个描述某些错误条件的值，\n"
"后者是计算成功的结果。让我们看看它的实际效果：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:908
#, no-wrap
msgid ""
"total\n"
"readWeekdayV : String -> Validated String Weekday\n"
"readWeekdayV \"Monday\"    = Valid Monday\n"
"readWeekdayV \"Tuesday\"   = Valid Tuesday\n"
"readWeekdayV \"Wednesday\" = Valid Wednesday\n"
"readWeekdayV \"Thursday\"  = Valid Thursday\n"
"readWeekdayV \"Friday\"    = Valid Friday\n"
"readWeekdayV \"Saturday\"  = Valid Saturday\n"
"readWeekdayV \"Sunday\"    = Valid Sunday\n"
"readWeekdayV s           = Invalid (\"Not a weekday: \" ++ s)\n"
msgstr ""
"total\n"
"readWeekdayV : String -> Validated String Weekday\n"
"readWeekdayV \"Monday\"    = Valid Monday\n"
"readWeekdayV \"Tuesday\"   = Valid Tuesday\n"
"readWeekdayV \"Wednesday\" = Valid Wednesday\n"
"readWeekdayV \"Thursday\"  = Valid Thursday\n"
"readWeekdayV \"Friday\"    = Valid Friday\n"
"readWeekdayV \"Saturday\"  = Valid Saturday\n"
"readWeekdayV \"Sunday\"    = Valid Sunday\n"
"readWeekdayV s           = Invalid (\"Not a weekday: \" ++ s)\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:929
#, no-wrap
msgid ""
"Again, this is such a general concept that a data type\n"
"similar to `Validated` is already available from the\n"
"*Prelude*: `Either` with data constructors `Left` and `Right`.\n"
"It is very common for functions to encapsulate the possibility\n"
"of failure by returning an `Either err val`, where `err`\n"
"is the error type and `val` is the desired return type. This\n"
"is the type safe (and total!) alternative to throwing a catchable\n"
"exception in an imperative language.\n"
msgstr ""
"同样，这是一个通用的概念，类似于 `Validated` 的数据类型已经存在于\n"
"*Prelude*：`Either` 和数据构造函数 `Left` 和 `Right`。\n"
"对可能导致失败的函数封装是很常见的，\n"
"通过返回 `Either err val` 类型，其中 `err` 是错误类型，`val` 是所需的返回类型。这个是命令式语言中抛出异常的替代品，（并且完全）类型安全。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:934
#, no-wrap
msgid ""
"Note, however, that the semantics of `Either` are not always \"`Left` is\n"
"an error and `Right` a success\". A function returning an `Either` just\n"
"means that it can have to different types of results, each of which\n"
"are *tagged* with the corresponding data constructor.\n"
msgstr "但是请注意，`Either` 的语义并不总是“`Left` 错误和 `Right` 成功”。返回 `Either` 的函数只是意味着它可以有不同类型的结果，是 * 被标记* 相应的数据构造函数之一。\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:935
#, no-wrap
msgid "List"
msgstr "列表"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:941
#, no-wrap
msgid ""
"One of the most important data structures in pure functional\n"
"programming is the singly linked list. Here is its definition\n"
"(called `Seq` in order for it not to collide with `List`,\n"
"which is of course already available from the Prelude):\n"
msgstr ""
"纯函数编程中最重要的数据结构之一是单链表。这是它的定义\n"
"（称为 `Seq` 是为了不与 `List` 冲突，\n"
"这当然可以从 Prelude 中获得）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:942
#, no-wrap
msgid "data Seq a = Nil | (::) a (Seq a)\n"
msgstr "data Seq a = Nil | (::) a (Seq a)\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:953
#, no-wrap
msgid ""
"This calls for some explanations. `Seq` consists of two *data constructors*:\n"
"`Nil` (representing an empty sequence of values) and `(::)` (also\n"
"called the *cons operator*), which prepends a new value of type `a` to\n"
"an already existing list of values of the same type. As you can see,\n"
"we can also use operators as data constructors, but please do not overuse\n"
"this. Use clear names for your functions and data constructors and only\n"
"introduce new operators when it truly helps readability!\n"
msgstr ""
"这需要一些解释。 `Seq` 由两个 *数据构造函数* 组成：\n"
"`Nil` （表示一个空的值序列）和 `(::)` （也称为 *cons 运算符*)，它将 `a` 类型的新值添加到已经存在的相同类型的值列表。如你看到的，\n"
"我们也可以使用运算符作为数据构造函数，但请不要过度使用。为您的函数和数据构造函数使用清晰的名称，并且仅当它真正有助于可读性时，再引入新的运算符！\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:956
#, no-wrap
msgid ""
"Here is an example of how to use the `List` constructors\n"
"(I use `List` here, as this is what you should use in your own code):\n"
msgstr ""
"下面是如何使用 `List` 构造函数的示例\n"
"（我在这里使用 `List`，因为这是您应该在自己的代码中使用的内容）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:957
#, no-wrap
msgid ""
"total\n"
"ints : List Int64\n"
"ints = 1 :: 2 :: -3 :: Nil\n"
msgstr ""
"total\n"
"ints : List Int64\n"
"ints = 1 :: 2 :: -3 :: Nil\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:966
#, no-wrap
msgid ""
"However, there is a more concise way of writing the above. Idris\n"
"accepts special syntax for constructing data types consisting\n"
"exactly of the two constructors `Nil` and `(::)`:\n"
msgstr "但是，有一种更简洁的方式来编写上述内容。Idris 接受用于两个构造函数恰好是 `Nil` 和 `(::)`的数据类型的特殊语法，：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:967
#, no-wrap
msgid ""
"total\n"
"ints2 : List Int64\n"
"ints2 = [1, 2, -3]\n"
"\n"
"total\n"
"ints3 : List Int64\n"
"ints3 = []\n"
msgstr ""
"total\n"
"ints2 : List Int64\n"
"ints2 = [1, 2, -3]\n"
"\n"
"total\n"
"ints3 : List Int64\n"
"ints3 = []\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:980
#, no-wrap
msgid ""
"The two definitions `ints` and `ints2`\n"
"are treated identically by the compiler.\n"
"Note, that list syntax can also be used in pattern matches.\n"
msgstr ""
"两个定义 `ints` 和 `ints2` 会被编译器同等对待。\n"
"请注意，该列表语法也可用于模式匹配。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:991
#, no-wrap
msgid ""
"There is another thing that's special about\n"
"`Seq` and `List`: Each of them is defined\n"
"in terms of itself (the cons operator accepts a value\n"
"and another `Seq` as arguments). We call such data types\n"
"*recursive* data types, and their recursive nature means, that in order to\n"
"decompose or consume them, we typically require recursive\n"
"functions. In an imperative language, we might use a for loop or\n"
"similar construct to iterate over the values of a `List` or a `Seq`,\n"
"but these things do not exist in a language without in-place\n"
"mutation. Here's how to sum a list of integers:\n"
msgstr ""
"`Seq`和`List` 之间还有一些特别的：分别用自身来定义（cons 运算符接受一个值\n"
"和另一个 `Seq` 作为参数）。我们称这样的数据类型为 *递归* 数据类型，它们的递归性质意味着，为了分解或消耗它们，我们通常需要递归函数。在命令式语言中，我们可能会使用 for 循环或类似的结构来迭代 `List` 或 `Seq` 的值，\n"
"但是这些东西不存在于不可变数据的语言中。以下是对整数列表求和的方法：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:992
#, no-wrap
msgid ""
"total\n"
"intSum : List Integer -> Integer\n"
"intSum Nil       = 0\n"
"intSum (n :: ns) = n + intSum ns\n"
msgstr ""
"total\n"
"intSum : List Integer -> Integer\n"
"intSum Nil       = 0\n"
"intSum (n :: ns) = n + intSum ns\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1004
#, no-wrap
msgid ""
"Recursive functions can be hard to grasp at first, so I'll break\n"
"this down a bit. If we invoke `intSum` with the empty list,\n"
"the first pattern matches and the function returns zero immediately.\n"
"If, however, we invoke `intSum` with a non-empty list - `[7,5,9]`\n"
"for instance - the following happens:\n"
msgstr ""
"递归函数一开始可能很难掌握，所以我会把他分解一下。如果我们用空列表调用 `intSum`，\n"
"第一个模式被匹配并且函数立即返回零。\n"
"但是，如果我们使用非空列表调用 `intSum` - `[7,5,9]` - 会发生以下情况：\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:1008
#, no-wrap
msgid ""
"The second pattern matches and splits the list into two\n"
"parts: Its head (`7`) is bound to variable `n` and its tail\n"
"(`[5,9]`) is bound to `ns`:\n"
msgstr "第二个模式被匹配并将列表分成两部分：它的头部（`7`）绑定到变量 `n` "
"和它的尾部（`[5,9]`）绑定到 `ns`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1009
#, no-wrap
msgid "   7 + intSum [5,9]\n"
msgstr "   7 + intSum [5,9]\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:1015
#, no-wrap
msgid ""
"In a second invocation, `intSum` is called with a new list: `[5,9]`.\n"
"The second pattern matches and `n` is bound to `5` and `ns` is bound\n"
"to `[9]`:\n"
msgstr ""
"在第二次调用中，`intSum` 被一个新列表调用：`[5,9]`。第二个模式被匹配并且 `n` "
"绑定到 `5` 并且 `ns` 绑定到 `[9]`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1016
#, no-wrap
msgid "   7 + (5 + intSum [9])\n"
msgstr "   7 + (5 + intSum [9])\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:1023
#, no-wrap
msgid ""
"In a third invocation `intSum` is called with list `[9]`.\n"
"The second pattern matches and `n` is bound to `9` and `ns` is bound\n"
"to `[]`:\n"
msgstr ""
"在第三次调用中，`intSum` 用列表 `[9]` 调用。第二个模式被匹配并且 `n` 绑定到 "
"`9` 并且 `ns` 绑定到 `[]`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1024
#, no-wrap
msgid "   7 + (5 + (9 + intSum [])\n"
msgstr "   7 + (5 + (9 + intSum [])\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:1030
#, no-wrap
msgid ""
"In a fourth invocation, `intSum` is called with list `[]` and\n"
"returns `0` immediately:\n"
msgstr "在第四次调用中，使用列表 `[]` 调用 `intSum` 并立即返回 `0`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1031
#, no-wrap
msgid "   7 + (5 + (9 + 0)\n"
msgstr "   7 + (5 + (9 + 0)\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/DataTypes.md:1037
#, no-wrap
msgid ""
"In the third invocation, `9` and `0` are added and `9` is\n"
"returned:\n"
msgstr "在第三次调用中，累加 `9` 和 `0` 并返回 `9`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1038
#, no-wrap
msgid "   7 + (5 + 9)\n"
msgstr "   7 + (5 + 9)\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/DataTypes.md:1044
#, no-wrap
msgid ""
"In the second invocation, `5` and `9` are added and `14` is\n"
"returned:\n"
msgstr "在第二次调用中，累加 `5` 和 `9` 并返回 `14`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1045
#, no-wrap
msgid "   7 + 14\n"
msgstr "   7 + 14\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/DataTypes.md:1051
#, no-wrap
msgid ""
"Finally, our initial invocation of `intSum` adds `7` and `14`\n"
"and returns `21`.\n"
msgstr "最后，我们对 `intSum` 的初始调用累加 `7` 和 `14` 并返回 `21`。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1055
#, no-wrap
msgid ""
"Thus, the recursive implementation of `intSum` leads to a sequence of\n"
"nested calls to `intSum`, which terminates once the argument is the\n"
"empty list.\n"
msgstr ""
"因此，`intSum` 的递归实现导致了一个嵌套调用 `intSum` 的序列，一旦参数是\n"
"空列表也会终止嵌套。\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1056
#, no-wrap
msgid "Generic Functions"
msgstr "通用函数"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1062
#, no-wrap
msgid ""
"In order to fully appreciate the versatility that comes with\n"
"generic data types, we also need to talk about generic functions.\n"
"Like generic types, these are parameterized over one or more\n"
"type parameters.\n"
msgstr ""
"为了充分体会泛型数据类型所带来的多功能性，我们还需要谈谈泛型函数。\n"
"与泛型类型一样，它们通过一个或多个参数化类型参数来实现。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1068
#, no-wrap
msgid ""
"Consider for instance the case of breaking out of the\n"
"`Option` data type. In case of a `Some`, we'd like to return\n"
"the stored value, while for the `None` case we provide\n"
"a default value. Here's how to do this, specialized to\n"
"`Integer`s:\n"
msgstr ""
"考虑展开`Option` 数据类型的情况。如果是 `Some`，我们希望返回存储的值，而对于 `None` 的情况，我们提供默认值。这里展示如何做到这一点，专门用于\n"
"`Integer` 的函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1069
#, no-wrap
msgid ""
"total\n"
"integerFromOption : Integer -> Option Integer -> Integer\n"
"integerFromOption _ (Some y) = y\n"
"integerFromOption x None     = x\n"
msgstr ""
"total\n"
"integerFromOption : Integer -> Option Integer -> Integer\n"
"integerFromOption _ (Some y) = y\n"
"integerFromOption x None     = x\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1080
#, no-wrap
msgid ""
"It's pretty obvious that this, again, is not general enough.\n"
"Surely, we'd also like to break out of `Option Bool` or\n"
"`Option String` in a similar fashion. That's exactly\n"
"what the generic function `fromOption` does:\n"
msgstr ""
"很明显，这又不够普遍。\n"
"当然，我们也想展开 `Option Bool` 或\n"
"`Option String` 以类似的方式。这正是\n"
"通用函数 `fromOption` 做的事情：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1081
#, no-wrap
msgid ""
"total\n"
"fromOption : a -> Option a -> a\n"
"fromOption _ (Some y) = y\n"
"fromOption x None     = x\n"
msgstr ""
"total\n"
"fromOption : a -> Option a -> a\n"
"fromOption _ (Some y) = y\n"
"fromOption x None     = x\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1095
#, no-wrap
msgid ""
"The lower-case `a` is again a *type parameter*. You can read\n"
"the type signature as follows: \"For any type `a`, given a *value*\n"
"of type `a`, and an `Option a`, we can return a value of\n"
"type `a`.\" Note, that `fromOption` knows nothing else about\n"
"`a`, other than it being a type. It is therefore not possible,\n"
"to conjure a value of type `a` out of thin air. We *must* have\n"
"a value available to deal with the `None` case.\n"
msgstr "小写的 `a` 又是一个 * 类型化参数 *。你可以这样读他的类型签名：“对于任何类型 `a`，给定一个 `a` 类型的 * 值 * 和 `Option a`，我们可以返回一个类型 `a` 的值。”请注意，`fromOption` 对 `a` 一无所知，除了它是一个类型。因此不可能凭空变出一个 `a` 类型的值。我们*必须*有可用于处理 `None` 情况的值。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1098
#, no-wrap
msgid ""
"The pendant to `fromOption` for `Maybe` is called `fromMaybe`\n"
"and is available from module `Data.Maybe` from the *base* library.\n"
msgstr "`Maybe` 的 `fromOption` 挂件称为 `fromMaybe`，并且可从 *base* 库中的模块 `Data.Maybe` 获得。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1104
#, no-wrap
msgid ""
"Sometimes, `fromOption` is not general enough. Assume we'd like to\n"
"print the value of a freshly parsed `Bool`, giving some generic\n"
"error message in case of a `None`. We can't use `fromOption`\n"
"for this, as we have an `Option Bool` and we'd like to\n"
"return a `String`. Here's how to do this:\n"
msgstr "有时，`fromOption` 不够通用。假设我们想打印新解析的 `Bool` 的值，给出一些通用的 `None` 的情况下的错误消息。我们不能使用 `fromOption`，为此，我们有一个 `Option Bool` 并且我们想返回一个 `String`。以下是如何执行此操作：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1105
#, no-wrap
msgid ""
"total\n"
"option : b -> (a -> b) -> Option a -> b\n"
"option _ f (Some y) = f y\n"
"option x _ None     = x\n"
"\n"
"total\n"
"handleBool : Option Bool -> String\n"
"handleBool = option \"Not a boolean value.\" show\n"
msgstr ""
"total\n"
"option : b -> (a -> b) -> Option a -> b\n"
"option _ f (Some y) = f y\n"
"option x _ None     = x\n"
"\n"
"total\n"
"handleBool : Option Bool -> String\n"
"handleBool = option \"Not a boolean value.\" show\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1121
#, no-wrap
msgid ""
"Function `option` is parameterized over *two* type parameters:\n"
"`a` represents the type of values stored in the `Option`,\n"
"while `b` is the return type. In case of a `Just`, we need\n"
"a way to convert the stored `a` to a `b`, an that's done\n"
"using the function argument of type `a -> b`.\n"
msgstr ""
"函数 `option` 通过 * 两个* 类型参数进行参数化：\n"
"`a`表示`Option`中存储的值的类型，\n"
"而 `b` 是返回类型。如果是 `Just`，我们需要一种将存储的 `a` 转换为 `b` 的方法，使用 `a -> b` 类型的函数参数就可以咯。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1126
#, no-wrap
msgid ""
"In Idris, lower-case identifiers in function types are\n"
"treated as *type parameters*, while upper-case identifiers\n"
"are treated as types or type constructors that must\n"
"be in scope.\n"
msgstr ""
"在 Idris 中，函数类型中的小写标识符是\n"
"被视为*类型参数*，而大写标识符\n"
"被视为类型或类型构造函数，且必须\n"
"在作用域内。\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1127 ../src/Tutorial/Eq.md:1056
#, no-wrap
msgid "Exercises part 4"
msgstr "练习第 4 部分"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1137
#, no-wrap
msgid ""
"If this is your first time programming in a purely\n"
"functional language, the exercises below are *very*\n"
"important. Do not skip any of them! Take your time and\n"
"work through them all. In most cases,\n"
"the types should be enough to explain what's going\n"
"on, even though they might appear cryptic in the\n"
"beginning. Otherwise, have a look at the comments (if any)\n"
"of each exercise.\n"
msgstr ""
"如果这是你第一次使用纯编函数式语言进行编程，下面的练习是*非常*重要的。不要跳过任何一个！\n"
"花点时间和通过他们所有的工作。在大多数情况下，类型应该足以解释发生了什么\n"
"开，即使它们在一开始看起来很神秘。否则，请查看每次练习的评论（如果有）。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1140
#, no-wrap
msgid ""
"Remember, that lower-case identifiers in a function\n"
"signature are treated as type parameters.\n"
msgstr ""
"请记住，函数中的小写标识符\n"
"签名被视为类型参数。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:1142
#, no-wrap
msgid "Implement the following generic functions for `Maybe`:\n"
msgstr "为 `Maybe` 实现以下通用函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1143
#, no-wrap
msgid ""
"   -- make sure to map a `Just` to a `Just`.\n"
"   total\n"
"   mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- Example: `appMaybe (Just (+2)) (Just 20) = Just 22`\n"
"   total\n"
"   appMaybe : Maybe (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- Example: `bindMaybe (Just 12) Just = Just 12`\n"
"   total\n"
"   bindMaybe : Maybe a -> (a -> Maybe b) -> Maybe b\n"
"\n"
"   -- keep the value in a `Just` only if the given predicate holds\n"
"   total\n"
"   filterMaybe : (a -> Bool) -> Maybe a -> Maybe a\n"
"\n"
"   -- keep the first value that is not a `Nothing` (if any)\n"
"   total\n"
"   first : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- keep the last value that is not a `Nothing` (if any)\n"
"   total\n"
"   last : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- this is another general way to extract a value from a `Maybe`.\n"
"   -- Make sure the following holds:\n"
"   -- `foldMaybe (+) 5 Nothing = 5`\n"
"   -- `foldMaybe (+) 5 (Just 12) = 17`\n"
"   total\n"
"   foldMaybe : (acc -> el -> acc) -> acc -> Maybe el -> acc\n"
msgstr ""
"   -- make sure to map a `Just` to a `Just`.\n"
"   total\n"
"   mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- Example: `appMaybe (Just (+2)) (Just 20) = Just 22`\n"
"   total\n"
"   appMaybe : Maybe (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- Example: `bindMaybe (Just 12) Just = Just 12`\n"
"   total\n"
"   bindMaybe : Maybe a -> (a -> Maybe b) -> Maybe b\n"
"\n"
"   -- keep the value in a `Just` only if the given predicate holds\n"
"   total\n"
"   filterMaybe : (a -> Bool) -> Maybe a -> Maybe a\n"
"\n"
"   -- keep the first value that is not a `Nothing` (if any)\n"
"   total\n"
"   first : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- keep the last value that is not a `Nothing` (if any)\n"
"   total\n"
"   last : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- this is another general way to extract a value from a `Maybe`.\n"
"   -- Make sure the following holds:\n"
"   -- `foldMaybe (+) 5 Nothing = 5`\n"
"   -- `foldMaybe (+) 5 (Just 12) = 17`\n"
"   total\n"
"   foldMaybe : (acc -> el -> acc) -> acc -> Maybe el -> acc\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:1177
#, no-wrap
msgid "Implement the following generic functions for `Either`:\n"
msgstr "为 `Either` 实现以下通用函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1178
#, no-wrap
msgid ""
"   total\n"
"   mapEither : (a -> b) -> Either e a -> Either e b\n"
"\n"
"   -- In case of both `Either`s being `Left`s, keep the\n"
"   -- value stored in the first `Left`.\n"
"   total\n"
"   appEither : Either e (a -> b) -> Either e a -> Either e b\n"
"\n"
"   total\n"
"   bindEither : Either e a -> (a -> Either e b) -> Either e b\n"
"\n"
"   -- Keep the first value that is not a `Left`\n"
"   -- If both `Either`s are `Left`s, use the given accumulator\n"
"   -- for the error values\n"
"   total\n"
"   firstEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   -- Keep the last value that is not a `Left`\n"
"   -- If both `Either`s are `Left`s, use the given accumulator\n"
"   -- for the error values\n"
"   total\n"
"   lastEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   total\n"
"   fromEither : (e -> c) -> (a -> c) -> Either e a -> c\n"
msgstr ""
"   total\n"
"   mapEither : (a -> b) -> Either e a -> Either e b\n"
"\n"
"   -- In case of both `Either`s being `Left`s, keep the\n"
"   -- value stored in the first `Left`.\n"
"   total\n"
"   appEither : Either e (a -> b) -> Either e a -> Either e b\n"
"\n"
"   total\n"
"   bindEither : Either e a -> (a -> Either e b) -> Either e b\n"
"\n"
"   -- Keep the first value that is not a `Left`\n"
"   -- If both `Either`s are `Left`s, use the given accumulator\n"
"   -- for the error values\n"
"   total\n"
"   firstEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   -- Keep the last value that is not a `Left`\n"
"   -- If both `Either`s are `Left`s, use the given accumulator\n"
"   -- for the error values\n"
"   total\n"
"   lastEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   total\n"
"   fromEither : (e -> c) -> (a -> c) -> Either e a -> c\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:1207
#, no-wrap
msgid "Implement the following generic functions for `List`:\n"
msgstr "为 `List` 实现以下通用函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1208
#, no-wrap
msgid ""
"   total\n"
"   mapList : (a -> b) -> List a -> List b\n"
"\n"
"   total\n"
"   filterList : (a -> Bool) -> List a -> List a\n"
"\n"
"   -- return the first value of a list, if it is non-empty\n"
"   total\n"
"   headMaybe : List a -> Maybe a\n"
"\n"
"   -- return everything but the first value of a list, if it is non-empty\n"
"   total\n"
"   tailMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- return the last value of a list, if it is non-empty\n"
"   total\n"
"   lastMaybe : List a -> Maybe a\n"
"\n"
"   -- return everything but the last value of a list,\n"
"   -- if it is non-empty\n"
"   total\n"
"   initMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- accumulate the values in a list using the given\n"
"   -- accumulator function and initial value\n"
"   --\n"
"   -- Examples:\n"
"   -- `foldList (+) 10 [1,2,7] = 20`\n"
"   -- `foldList String.(++) \"\" [\"Hello\",\"World\"] = \"HelloWorld\"`\n"
"   -- `foldList last Nothing (mapList Just [1,2,3]) = Just 3`\n"
"   total\n"
"   foldList : (acc -> el -> acc) -> acc -> List el -> acc\n"
msgstr ""
"   total\n"
"   mapList : (a -> b) -> List a -> List b\n"
"\n"
"   total\n"
"   filterList : (a -> Bool) -> List a -> List a\n"
"\n"
"   -- return the first value of a list, if it is non-empty\n"
"   total\n"
"   headMaybe : List a -> Maybe a\n"
"\n"
"   -- return everything but the first value of a list, if it is non-empty\n"
"   total\n"
"   tailMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- return the last value of a list, if it is non-empty\n"
"   total\n"
"   lastMaybe : List a -> Maybe a\n"
"\n"
"   -- return everything but the last value of a list,\n"
"   -- if it is non-empty\n"
"   total\n"
"   initMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- accumulate the values in a list using the given\n"
"   -- accumulator function and initial value\n"
"   --\n"
"   -- Examples:\n"
"   -- `foldList (+) 10 [1,2,7] = 20`\n"
"   -- `foldList String.(++) \"\" [\"Hello\",\"World\"] = \"HelloWorld\"`\n"
"   -- `foldList last Nothing (mapList Just [1,2,3]) = Just 3`\n"
"   total\n"
"   foldList : (acc -> el -> acc) -> acc -> List el -> acc\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:1245
#, no-wrap
msgid ""
"Assume we store user data for our web application in\n"
"the following record:\n"
msgstr "假设我们将 Web 应用程序的用户数据存储在以下记录中：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1246
#, no-wrap
msgid ""
"   record Client where\n"
"     constructor MkClient\n"
"     name          : String\n"
"     title         : Title\n"
"     age           : Bits8\n"
"     passwordOrKey : Either Bits64 String\n"
msgstr ""
"   record Client where\n"
"     constructor MkClient\n"
"     name          : String\n"
"     title         : Title\n"
"     age           : Bits8\n"
"     passwordOrKey : Either Bits64 String\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1260
#, no-wrap
msgid ""
"   Using `LoginError` from an earlier exercise,\n"
"   implement function `login`, which, given a list of `Client`s\n"
"   plus a value of type `Credentials` will return either a `LoginError`\n"
"   in case no valid credentials where provided, or the first `Client`\n"
"   for whom the credentials match.\n"
msgstr ""
"   使用前面练习中的 `LoginError` 实现函数 `login`，给定 `Client` 的列表加上 `Credentials` 类型的值。如果没有提供有效凭据将会返回 `LoginError`，\n"
"   ，或者第一个凭据匹配的 `Client` 对象。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/DataTypes.md:1264
#, no-wrap
msgid ""
"Using your data type for chemical elements from an\n"
"earlier exercise, implement a function for calculating\n"
"the molar mass of a molecular formula.\n"
msgstr "使用前面练习中化学元素的数据类型，实现一个计算分子式摩尔质量的函数。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1268
#, no-wrap
msgid ""
"   Use a list of elements each paired with its count\n"
"   (a natural number) for representing formulae. For\n"
"   instance:\n"
msgstr "   使用一个元素列表，每个元素都与其计数（自然数）对「pair」用于表示公式。例如：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1269
#, no-wrap
msgid ""
"   ethanol : List (Element,Nat)\n"
"   ethanol = [(C,2),(H,6),(O,1)]\n"
msgstr ""
"   ethanol : List (Element,Nat)\n"
"   ethanol = [(C,2),(H,6),(O,1)]\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1276
#, no-wrap
msgid ""
"   Hint: You can use function `cast` to convert a natural\n"
"   number to a `Double`.\n"
msgstr "   提示：您可以使用函数 `cast` 转换自然数为 `Double`。\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1277
#, no-wrap
msgid "Alternative Syntax for Data Definitions"
msgstr "数据定义的替代语法"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1285
#, no-wrap
msgid ""
"While the examples in the section about parameterized\n"
"data types are short and concise, there is a slightly\n"
"more verbose but much more general form for writing such\n"
"definitions, which makes it much clearer what's going on.\n"
"In my opinion, this more general form should be preferred\n"
"in all but the most simple data definitions.\n"
msgstr ""
"虽然关于参数化的部分中的示例数据类型短小精悍，有一种写这样的更冗长但更一般的形式定义，这使得正在发生的事情变得更加清晰。\n"
"在我看来，除了最简单的数据定义之外应该首选这种更一般的形式。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1290
#, no-wrap
msgid ""
"Here are the definitions of `Option`, `Validated`, and `Seq` again,\n"
"using this more general form (I put them in their own *namespace*,\n"
"so Idris will not complain about identical names in\n"
"the same source file):\n"
msgstr ""
"下面是 `Option`、`Validated` 和 `Seq` 的定义，\n"
"使用这种更通用的形式（我将它们放在自己的 *命名空间* 中，\n"
"所以 Idris 不会抱怨同一个源文件中具有不同的名称）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1291
#, no-wrap
msgid ""
"-- GADT is an acronym for \"generalized algebraic data type\"\n"
"namespace GADT\n"
"  data Option : Type -> Type where\n"
"    Some : a -> Option a\n"
"    None : Option a\n"
"\n"
"  data Validated : Type -> Type -> Type where\n"
"    Invalid : e -> Validated e a\n"
"    Valid   : a -> Validated e a\n"
"\n"
"  data Seq : Type -> Type where\n"
"    Nil  : Seq a\n"
"    (::) : a -> GADT.Seq a -> Seq a\n"
msgstr ""
"-- GADT is an acronym for \"generalized algebraic data type\"\n"
"namespace GADT\n"
"  data Option : Type -> Type where\n"
"    Some : a -> Option a\n"
"    None : Option a\n"
"\n"
"  data Validated : Type -> Type -> Type where\n"
"    Invalid : e -> Validated e a\n"
"    Valid   : a -> Validated e a\n"
"\n"
"  data Seq : Type -> Type where\n"
"    Nil  : Seq a\n"
"    (::) : a -> GADT.Seq a -> Seq a\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1318
#, no-wrap
msgid ""
"Here, `Option` is clearly declared as a type constructor\n"
"(a function of type `Type -> Type`), while `Some`\n"
"is a generic function of type `a -> Option a` (where `a` is\n"
"a *type parameter*)\n"
"and `None` is a nullary generic function of type `Option a`\n"
"(`a` again being a type parameter).\n"
"Likewise for `Validated` and `Seq`. Note, that in case\n"
"of `Seq` we had to disambiguate between the different\n"
"`Seq` definitions in the recursive case. Since we will\n"
"usually not define several data types with the same name in\n"
"a source file, this is not necessary most of the time.\n"
msgstr ""
"这里， `Option` 明确声明为类型构造函数（类型 `Type -> Type` 的函数），而 `Some` 是 `a > Option a` 类型的通用函数（其中 `a` 是 *类型参数*）， `None` 是 `Option a` 类型的空泛型函数\n"
"（`a` 又是一个类型参数）。\n"
"同样适用于 `Validated` 和 `Seq`。请注意，以防万一 `Seq` 我们必须区分不同的\n"
"递归情况下的 `Seq` 定义。既然我们\n"
"通常不会定义多个同名的数据类型在同一个源文件，大多数时候这不是必需的。\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1395
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#: ../src/Appendices/Neovim.md:364
#, no-wrap
msgid "Conclusion"
msgstr "结论"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1323
#, no-wrap
msgid ""
"We covered a lot of ground in this chapter,\n"
"so I'll summarize the most important points below:\n"
msgstr ""
"我们在本章中涵盖了很多内容，\n"
"所以我将总结以下最重要的几点：\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1326
#, no-wrap
msgid ""
"* Enumerations are data types consisting of a finite\n"
"number of possible *values*.\n"
msgstr "* 枚举是由有限个可能的 *值* 组成的数据类型。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1330
#, no-wrap
msgid ""
"* Sum types are data types with more than one data\n"
"constructor, where each constructor describes a\n"
"*choice* that can be made.\n"
msgstr "* 和类型是具有多个数据构造函数的数据类型，其中每个构造函数描述一个可以做出的*选择*。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1333
#, no-wrap
msgid ""
"* Product types are data types with a single constructor\n"
"used to group several values of possibly different types.\n"
msgstr "* 积类型是具有单个构造函数的数据类型，用于对可能不同类型的多个值进行分组。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1337
#, no-wrap
msgid ""
"* We use pattern matching to deconstruct immutable\n"
"values in Idris. The possible patterns correspond to\n"
"a data type's data constructors.\n"
msgstr "* 我们在 Idris 中使用模式匹配来解构不可变的值。可能的模式对应于数据类型的数据构造函数。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1341
#, no-wrap
msgid ""
"* We can *bind* variables to values in a pattern or\n"
"use an underscore as a placeholder for a value that's\n"
"not needed on the right hand side of an implementation.\n"
msgstr ""
"* 我们可以将变量*绑定*到模式中的值或\n"
"使用下划线作为值的占位符，在实现的右侧不需要。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1344
#, no-wrap
msgid ""
"* We can pattern match on an intermediary result by introducing\n"
"a *case block*.\n"
msgstr "* 我们可以通过引入 *Case 块* 对中间结果进行模式匹配。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1349
#, no-wrap
msgid ""
"* The preferred way to define new product types is\n"
"to define them as *records*, since these come with\n"
"additional syntactic conveniences for setting and\n"
"modifying individual *record fields*.\n"
msgstr "* 定义新的积类型的首选方法是将它们定义为 *记录*，因为它们带有额外的语法糖用来更新和设置单个 *记录字段*。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1354
#, no-wrap
msgid ""
"* Generic types and functions allow us generalize\n"
"certain concepts and make them available for many\n"
"types by using *type parameters* instead of\n"
"concrete types in function and type signatures.\n"
msgstr "* 泛型类型和函数允许我们泛化某些概念并使它们可供许多人使用，通过使用*类型参数*而不是函数和类型签名中的具体类型。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1361
#, no-wrap
msgid ""
"* Common concepts like *nullary values* (`Maybe`),\n"
"computations that might fail with some error\n"
"condition (`Either`), and handling collections\n"
"of values of the same type at once (`List`) are\n"
"example use cases of generic types and functions\n"
"already provided by the *Prelude*.\n"
msgstr ""
"* 常见概念，如 * 空值 * (`Maybe`)，\n"
"可能因某些错误条件而失败的计算（`Either`），和处理包含相同类型的值的集合（`List`）是泛型类型和函数的示例用例，他们已由 *Prelude* 提供。\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/Interfaces.md:813 ../src/Tutorial/IO.md:1118
#, no-wrap
msgid "What's next"
msgstr "下一步是什么"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1366
#, no-wrap
msgid ""
"In the [next section](Interfaces.md), we will introduce\n"
"*interfaces*, another approach to *function overloading*.\n"
msgstr "在 [下一节](Interfaces.md) 中，我们将介绍*接口*，这是*函数重载*的另一种方法。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1098
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Predicates.md:1369 ../src/Tutorial/Prim.md:1411
#: ../src/Tutorial/Traverse.md:1148 ../src/Appendices/Neovim.md:374
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2\n"
"-->\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:1 ../src/Tutorial/Intro.md:76
#, no-wrap
msgid "Dependent Types"
msgstr "依赖类型"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:9
#, no-wrap
msgid ""
"The ability to calculate types from values, pass them as arguments\n"
"to functions, and return them as results from functions - in\n"
"short, being a dependently typed language - is one of the\n"
"most distinguishing features of Idris. Many of the more advanced\n"
"type level extensions of languages like Haskell (and quite a\n"
"bit more) can be treated in one fell swoop with dependent types.\n"
msgstr "从值计算类型、将它们作为参数传递给函数并将它们作为函数结果返回的能力——简而言之，作为一种依赖类型的语言——是 Idris 最显着的特征之一。许多更高级的语言的类型级别扩展，如 Haskell（以及更多）都可以使用依赖类型来处理。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:10
#, no-wrap
msgid ""
"module Tutorial.Dependent\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Dependent\n"
"\n"
"%default total\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:17
#, no-wrap
msgid "Consider the following functions:\n"
msgstr "考虑以下函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:18
#, no-wrap
msgid ""
"bogusMapList : (a -> b) -> List a -> List b\n"
"bogusMapList _ _ = []\n"
"\n"
"bogusZipList : (a -> b -> c) -> List a -> List b -> List c\n"
"bogusZipList _ _ _ = []\n"
msgstr ""
"bogusMapList : (a -> b) -> List a -> List b\n"
"bogusMapList _ _ = []\n"
"\n"
"bogusZipList : (a -> b -> c) -> List a -> List b -> List c\n"
"bogusZipList _ _ _ = []\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:35
#, no-wrap
msgid ""
"The implementations type check, and still, they are obviously not\n"
"what users of our library would expect. In the first example, we'd expect\n"
"the implementation to apply the function argument to all values stored\n"
"in the list, without dropping any of them or changing their order.\n"
"The second is trickier: The two list arguments might be of different length.\n"
"What are we supposed to do when that's the case? Return a list of the same\n"
"length as the smaller of the two? Return an empty list? Or shouldn't\n"
"we in most use cases expect the two lists to be of the same length?\n"
"How could we even describe such a precondition?\n"
msgstr "实现可以通过类型检查，但它们显然不是我们库的用户所期望的。在第一个示例中，我们希望实现将函数参数应用于存储在列表中的所有值，而不会删除它们中的任何一个或更改它们的顺序。第二个比较棘手：两个列表参数的长度可能不同。遇到这种情况我们该怎么办？返回与两者中较小的长度相同的列表？返回一个空列表？或者在大多数用例中我们不应该期望两个列表具有相同的长度吗？我们怎么能描述这样的前提条件呢？\n"

#. type: Title ##
#: ../src/Tutorial/Dependent.md:36
#, no-wrap
msgid "Length-Indexed Lists"
msgstr "长度索引列表"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:41
#, no-wrap
msgid ""
"The answer to the issues described above is of course: Dependent types.\n"
"And the most common introductory example is the *vector*: A list indexed\n"
"by its length:\n"
msgstr "上述问题的答案当然是：依赖类型。最常见的介绍性示例是 *向量*：按长度索引的列表：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:42
#, no-wrap
msgid ""
"data Vect : (len : Nat) -> (a : Type) -> Type where\n"
"  Nil  : Vect 0 a\n"
"  (::) : (x : a) -> (xs : Vect n a) -> Vect (S n) a\n"
msgstr ""
"data Vect : (len : Nat) -> (a : Type) -> Type where\n"
"  Nil  : Vect 0 a\n"
"  (::) : (x : a) -> (xs : Vect n a) -> Vect (S n) a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:58
#, no-wrap
msgid ""
"Before we move on, please compare this with the implementation of `Seq` in\n"
"the [section about algebraic data types](DataTypes.md). The constructors\n"
"are exactly the same: `Nil` and `(::)`. But there is an important difference:\n"
"`Vect`, unlike `Seq` or `List`, is not a function from `Type` to `Type`, it is\n"
"a function from `Nat` to `Type` to `Type`. Go ahead! Open the REPL and\n"
"verify this! The `Nat` argument (also called an *index*) represents\n"
"the *length* of the vector here.\n"
"`Nil` has type `Vect 0 a`: A vector of length\n"
"zero. *Cons* has type `a -> Vect n a -> Vect (S n) a`: It is exactly one\n"
"element longer (`S n`) than its second argument, which is of length `n`.\n"
msgstr "在我们继续之前，请将此与 [关于代数数据类型的部分](DataTypes.md) 中的 `Seq` 的实现进行比较。构造函数完全相同：`Nil` 和 `(::)`。但是有一个重要的区别：`Vect` 不像`Seq`或`List`，不是从`Type`到`Type` 的函数，它是从 `Nat` 到 `Type` 到 `Type` 的函数。前进！打开 REPL 并验证这一点！ `Nat` 参数（也称为 *索引*）在这里表示向量的 *长度*。 `Nil` 的类型为 `Vect 0 a`：长度为零的向量。 `Cons` 的类型为 `a -> Vect n a -> Vect (S n) a`：它恰好比其长度为 `n` 的第二个参数多一个元素 (`S n`)，。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:61
#, no-wrap
msgid ""
"Let's experiment with this idea to gain a better understanding.\n"
"There is only one way to come up with a vector of length zero:\n"
msgstr "让我们尝试这个想法以获得更好的理解。只有一种方法可以得出长度为零的向量：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:62
#, no-wrap
msgid ""
"ex1 : Vect 0 Integer\n"
"ex1 = Nil\n"
msgstr ""
"ex1 : Vect 0 Integer\n"
"ex1 = Nil\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:69
#, no-wrap
msgid ""
"The following, on the other hand, leads to a type error (a pretty complicated\n"
"one, actually):\n"
msgstr "另一方面，以下会导致类型错误（实际上是一个非常复杂的错误）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:70
#, no-wrap
msgid ""
"failing \"Mismatch between: S ?n and 0.\"\n"
"  ex2 : Vect 0 Integer\n"
"  ex2 = [12]\n"
msgstr ""
"failing \"Mismatch between: S ?n and 0.\"\n"
"  ex2 : Vect 0 Integer\n"
"  ex2 = [12]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:80
#, no-wrap
msgid ""
"The problem: `[12]` gets desugared to `12 :: Nil`, but this has the wrong\n"
"type! Since `Nil` has type `Vect 0 Integer` here, `12 :: Nil` has type\n"
"`Vect (S 0) Integer`, which is identical to `Vect 1 Integer`. Idris verifies,\n"
"at compile time, that our vector is of the correct length!\n"
msgstr "问题：`[12]` 被脱糖为 `12 :: Nil`，但这类型错误！由于此处 `Nil` 的类型为 `Vect 0 Integer`，因此 `12 :: Nil` 的类型为 `Vect (S 0) Integer`，也就是 `Vect 1 Integer `。 Idris 在编译时验证我们的向量的长度是否正确！\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:81
#, no-wrap
msgid ""
"ex3 : Vect 1 Integer\n"
"ex3 = [12]\n"
msgstr ""
"ex3 : Vect 1 Integer\n"
"ex3 = [12]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:93
#, no-wrap
msgid ""
"So, we found a way to encode the *length* of a list-like data structure in\n"
"its *type*, and it is a *type error* if the number of elements in\n"
"a vector does not agree with then length given in its type. We will\n"
"shortly see several use cases, where this additional piece of information\n"
"allows us to be more precise in the types and rule out additional\n"
"programming mistakes. But first, we need to quickly clarify some\n"
"terminology.\n"
msgstr "因此，我们找到了一种方法，将类列表数据结构的 *长度* 编码为 *类型*，如果在向量中的元素个数与其类型中给出的长度不一致，会得到一个 *类型错误*，我们很快就会看到几个用例，这些额外的信息使我们能够更精确地确定类型并排除额外的编程错误。但首先，我们需要快速澄清一些术语。\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:94
#, no-wrap
msgid "Type Indices versus Type Parameters"
msgstr "类型索引与类型参数"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:101
#, no-wrap
msgid ""
"`Vect` is not only a generic type, parameterized over the type\n"
"of elements it holds, it is actually a *family of types*, each\n"
"of them associated with a natural number representing it's\n"
"length. We also say, the type family `Vect` is *indexed* by\n"
"its length.\n"
msgstr "`Vect` 不仅是一个泛型类型，参数化了它所拥有的元素的类型，它实际上是一个 *类型族*，它们中的每一个都与一个代表它的长度的自然数相关联。我们也说，类型族 `Vect` 按其长度 *被索引*。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:108
#, no-wrap
msgid ""
"The difference between a type parameter and an index is, that\n"
"the latter can and does change across data constructors, while\n"
"the former is the same for all data constructors. Or, put differently,\n"
"we can learn about the *value* of an index by pattern matching\n"
"on a *value* of the type family, while this is not possible\n"
"with a type parameter.\n"
msgstr "类型参数和索引之间的区别在于，后者可以并且确实在数据构造函数中发生变化，而前者对于所有数据构造函数都是相同的。或者，换句话说，我们可以通过对类型族的*值*进行模式匹配来了解索引的*值*，而对于类型参数，这是不可能的。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:110
#, no-wrap
msgid "Let's demonstrate this with a contrived example:\n"
msgstr "让我们用一个人为的例子来证明这一点：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:111
#, no-wrap
msgid ""
"data Indexed : Nat -> Type where\n"
"  I0 : Indexed 0\n"
"  I3 : Indexed 3\n"
"  I4 : String -> Indexed 4\n"
msgstr ""
"data Indexed : Nat -> Type where\n"
"  I0 : Indexed 0\n"
"  I3 : Indexed 3\n"
"  I4 : String -> Indexed 4\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:124
#, no-wrap
msgid ""
"Here, `Indexed` is indexed over its `Nat` argument, as\n"
"values of the index changes across constructors (I chose some\n"
"arbitrary value for each constructor), and we\n"
"can learn about these values by pattern matching on `Indexed` values.\n"
"We can use this, for instance, to create a `Vect` of the same length\n"
"as the index of `Indexed`:\n"
msgstr "在这里，`Indexed` 在它的 `Nat` 参数上进行索引，因为索引的值在构造函数之间发生变化（我为每个构造函数选择了一些任意值），我们可以通过模式匹配了解这些 `Indexed` 值。例如，我们可以使用它来创建与 `Indexed` 的索引长度相同的 `Vect`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:125
#, no-wrap
msgid "fromIndexed : Indexed n -> a -> Vect n a\n"
msgstr "fromIndexed : Indexed n -> a -> Vect n a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:133
#, no-wrap
msgid ""
"Go ahead, and try implementing this yourself! Work with\n"
"holes, pattern match on the `Indexed` argument, and\n"
"learn about the expected output type in each case by\n"
"inspecting the holes and their context.\n"
msgstr "来吧，尝试自己实现它！使用孔，对 `Indexed` 参数进行模式匹配，并通过检查孔及其上下文了解每种情况下的预期输出类型。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:135
#, no-wrap
msgid "Here is my implementation:\n"
msgstr "这是我的实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:136
#, no-wrap
msgid ""
"fromIndexed I0     va = []\n"
"fromIndexed I3     va = [va, va, va]\n"
"fromIndexed (I4 _) va = [va, va, va, va]\n"
msgstr ""
"fromIndexed I0     va = []\n"
"fromIndexed I3     va = [va, va, va]\n"
"fromIndexed (I4 _) va = [va, va, va, va]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:146
#, no-wrap
msgid ""
"As you can see, by pattern matching on the value of the\n"
"`Indexed n` argument, we learned about the value of\n"
"the `n` index itself, which was necessary to return a\n"
"`Vect` of the correct length.\n"
msgstr "如您所见，通过对 `Indexed n` 参数的值进行模式匹配，我们了解了 `n` 索引本身的值，这是返回 `Vect` 所必需的正确长度。\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:147
#, no-wrap
msgid "Length-Preserving `map`"
msgstr "长度保持的 `map`"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:154
#, no-wrap
msgid ""
"Function `bogusMapList` behaved unexpectedly, because it always\n"
"returned the empty list. With `Vect`, we need to be true to the\n"
"types here. If we map over a `Vect`, the argument *and* output type\n"
"contain a length index, and these length indices will tell us\n"
"*exactly*, if and how the lengths of our vectors are modified:\n"
msgstr "函数 `bogusMapList` 表现异常，因为它总是返回空列表。对于 `Vect`，我们需要忠实于这里的类型。如果我们在 `Vect` 上映射，参数 *和* 输出类型包含一个长度索引，这些长度索引将*确切的* 告诉我们，我们的向量长度如何被修改：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:155
#, no-wrap
msgid ""
"map3_1 : (a -> b) -> Vect 3 a -> Vect 1 b\n"
"map3_1 f [_,y,_] = [f y]\n"
"\n"
"map5_0 : (a -> b) -> Vect 5 a -> Vect 0 b\n"
"map5_0 f _ = []\n"
"\n"
"map5_10 : (a -> b) -> Vect 5 a -> Vect 10 b\n"
"map5_10 f [u,v,w,x,y] = [f u, f u, f v, f v, f w, f w, f x, f x, f y, f y]\n"
msgstr ""
"map3_1 : (a -> b) -> Vect 3 a -> Vect 1 b\n"
"map3_1 f [_,y,_] = [f y]\n"
"\n"
"map5_0 : (a -> b) -> Vect 5 a -> Vect 0 b\n"
"map5_0 f _ = []\n"
"\n"
"map5_10 : (a -> b) -> Vect 5 a -> Vect 10 b\n"
"map5_10 f [u,v,w,x,y] = [f u, f u, f v, f v, f w, f w, f x, f x, f y, f y]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:173
#, no-wrap
msgid ""
"While these examples are quite interesting,\n"
"they are not really useful, are they? That's because they are too\n"
"specialized. We'd like to have a *general* function for mapping\n"
"vectors of any length.\n"
"Instead of using concrete lengths in type signatures,\n"
"we can also use *variables* as already seen in the definition of `Vect`.\n"
"This allows us to declare the general case:\n"
msgstr "虽然这些例子很有趣，但它们并不是真的有用，不是吗？那是因为他们太专业了。我们想要一个 *通用* 函数来映射任意长度的向量。除了在类型签名中使用具体的长度，我们还可以使用*变量*，正如在 `Vect` 的定义中已经看到的那样。这允许我们声明一般情况：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:174
#, no-wrap
msgid "mapVect' : (a -> b) -> Vect n a -> Vect n b\n"
msgstr "mapVect' : (a -> b) -> Vect n a -> Vect n b\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:181
#, no-wrap
msgid ""
"This type describes a length-preserving map. It is actually\n"
"more instructive (but not necessary) to include the\n"
"implicit arguments as well:\n"
msgstr "这种类型描述了一个长度保持映射。包含隐式参数实际上更有指导意义（但不是必需的）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:182
#, no-wrap
msgid "mapVect : {0 a,b : _} -> {0 n : Nat} -> (a -> b) -> Vect n a -> Vect n b\n"
msgstr "mapVect : {0 a,b : _} -> {0 n : Nat} -> (a -> b) -> Vect n a -> Vect n b\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:196
#, no-wrap
msgid ""
"We ignore the two type parameters `a`, and `b`, as these just\n"
"describe a generic function (note, however, that we can group arguments\n"
"of the same type and quantity in a single pair of curly braces; this\n"
"is optional, but it sometimes helps making type signatures a bit\n"
"shorter). The implicit argument of type `Nat`, however, tells us that the\n"
"input and output `Vect` are of the same length. It is a type error\n"
"to not uphold to this contract. When implementing `mapVect`, it\n"
"is very instructive to follow along and use some holes. In order\n"
"to get *any* information about the length of the `Vect` argument,\n"
"we need to pattern match on it:\n"
msgstr "我们忽略了两个类型参数 `a` 和 `b`，因为它们只是描述了一个泛型函数（但是请注意，我们可以将相同类型和定量的参数组合成一对大括号；这是可选的，但有时有助于使类型签名更短）。然而，`Nat` 类型的隐式参数告诉我们输入和输出 `Vect` 的长度相同。不遵守本合约属于类型错误。在实现 `mapVect` 时，遵循并使用一些孔非常有指导意义。为了获得关于 `Vect` 参数长度的 *任何* 信息，我们需要对其进行模式匹配：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:197
#, no-wrap
msgid ""
"mapVect _ Nil       = ?impl_0\n"
"mapVect f (x :: xs) = ?impl_1\n"
msgstr ""
"mapVect _ Nil       = ?impl_0\n"
"mapVect f (x :: xs) = ?impl_1\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:203
#, no-wrap
msgid "At the REPL, we learn the following:\n"
msgstr "在 REPL，我们学到以下内容：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:204
#, no-wrap
msgid ""
"Tutorial.Dependent> :t impl_0\n"
" 0 a : Type\n"
" 0 b : Type\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_0 : Vect 0 b\n"
"\n"
"\n"
"Tutorial.Dependent> :t impl_1\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_1 : Vect (S n) b\n"
msgstr ""
"Tutorial.Dependent> :t impl_0\n"
" 0 a : Type\n"
" 0 b : Type\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_0 : Vect 0 b\n"
"\n"
"\n"
"Tutorial.Dependent> :t impl_1\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_1 : Vect (S n) b\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:226
#, no-wrap
msgid ""
"The first hole, `impl_0` is of type `Vect 0 b`. There is only one such\n"
"value, as discussed above:\n"
msgstr "第一个孔 `impl_0` 的类型为 `Vect 0 b`。如上所述，只有一个这样的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:227
#, no-wrap
msgid "mapVect _ Nil       = Nil\n"
msgstr "mapVect _ Nil       = Nil\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:238
#, no-wrap
msgid ""
"The second case is again more interesting. We note, that `xs` is\n"
"of type `Vect n a`, for an arbitrary length `n` (given as an erased\n"
"argument), while the result is of type `Vect (S n) b`. So, the\n"
"result has to be one element longer than `xs`. Luckily, we already\n"
"have a value of type `a` (bound to variable `x`) and a function\n"
"from `a` to `b` (bound to variable `f`), so we can apply `f`\n"
"to `x` and prepend the result to a yet unknown remainder:\n"
msgstr "第二种情况更有趣。我们注意到，`xs` 是 `Vect n a` 类型，对于任意长度 `n`（作为已擦除参数给出），而结果是类型 `Vect (S n) b`。因此，结果必须比 `xs` 长一个元素。幸运的是，我们已经有了一个 `a` 类型的值（绑定到变量 `x`）和一个从 `a` 到 `b` 的函数（绑定到变量 `f`)，因此我们可以将 `f` 应用于 `x` 并将结果添加到未知的余数：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:239
#, no-wrap
msgid "mapVect f (x :: xs) = f x :: ?rest\n"
msgstr "mapVect f (x :: xs) = f x :: ?rest\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:244
#, no-wrap
msgid "Let's inspect the new hole at the REPL:\n"
msgstr "让我们在 REPL 检查一下新的孔：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:245
#, no-wrap
msgid ""
"Tutorial.Dependent> :t rest\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"rest : Vect n b\n"
msgstr ""
"Tutorial.Dependent> :t rest\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"rest : Vect n b\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:265
#, no-wrap
msgid ""
"Now, we have a `Vect n a` and need a `Vect n b`, without knowing anything\n"
"else about `n`. We *could* learn more about `n` by pattern matching further\n"
"on `xs`, but this would quickly lead us down a rabbit hole, since after\n"
"such a pattern match, we'd end up with another `Nil` case and another\n"
"*cons* case, with a new tail of unknown length. Instead, we can invoke\n"
"`mapVect` recursively to convert the remainder (`xs`) to a `Vect n b`.\n"
"The type checker guarantees, that the lengths of `xs` and `mapVect f xs`\n"
"are the same, so the whole expression type checks and we are done:\n"
msgstr "现在，我们有一个 `Vect n a` 并且需要一个 `Vect n b`，而不知道关于 `n` 的任何其他信息。我们 *可以* 通过在 `xs` 上进一步进行模式匹配来了解更多关于 `n` 的信息，但这会很快将我们引向一个兔子洞，因为在这样的模式匹配之后，我们'最终会出现另一个 `Nil` 分支和另一个 `cons` 分支，新的尾巴长度未知。相反，我们可以递归调用 `mapVect` 以将余数 (`xs`) 转换为 `Vect n b`。类型检查器保证 `xs` 和 `mapVect f xs` 的长度是相同的，所以整个表达式类型检查，我们就完成了：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:266
#, no-wrap
msgid "mapVect f (x :: xs) = f x :: mapVect f xs\n"
msgstr "mapVect f (x :: xs) = f x :: mapVect f xs\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:270
#, no-wrap
msgid "Zipping Vectors"
msgstr "向量压缩"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:277
#, no-wrap
msgid ""
"Let us now have a look at `bogusZipList`: We'd like to pairwise merge\n"
"two lists holding elements of (possibly) distinct types through a\n"
"given binary function. As discussed above, the most reasonable thing\n"
"to do is to expect the two lists as well as the result to be of equal length.\n"
"With `Vect`, this can be expressed and implemented as follows:\n"
msgstr "现在让我们看一下 `bogusZipList`：我们希望通过给定的二元函数成对合并两个包含（可能）不同类型的元素的列表。如上所述，最合理的做法是期望两个列表以及结果的长度相等。使用 `Vect` 可以表达和实现如下：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:278
#, no-wrap
msgid ""
"zipWith : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"zipWith f []        []         = Nil\n"
"zipWith f (x :: xs) (y :: ys)  = f x y :: zipWith f xs ys\n"
msgstr ""
"zipWith : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"zipWith f []        []         = Nil\n"
"zipWith f (x :: xs) (y :: ys)  = f x y :: zipWith f xs ys\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:295
#, no-wrap
msgid ""
"Now, here is an interesting thing: The totality checker (activated\n"
"throughout this source file due to the initial `%default total` pragma)\n"
"accepts the above implementation as being total, although it is\n"
"missing two more cases. This works, because Idris\n"
"can figure out on its own, that the other two cases are *impossible*.\n"
"From the pattern match on the first `Vect` argument, Idris learns\n"
"whether `n` is zero or the successor of another natural number. But\n"
"from this it can derive, whether the second vector, being also\n"
"of length `n`, is a `Nil` or a *cons*. Still, it can be informative to add the\n"
"impossible cases explicitly. We can use keyword `impossible` to\n"
"do so:\n"
msgstr "现在，这是一件有趣的事情：完全性检查器（由于初始 `%default total` 杂注而在整个源文件中激活）接受上述实现作为全函数，尽管它缺少另外两个分支。这行得通，因为 Idris 可以自己弄清楚，其他两种情况是 *不可能的*。从第一个 `Vect` 参数的模式匹配中，Idris 了解 `n` 是零还是另一个自然数的后继。但由此可以得出，长度也为 `n` 的第二个向量是 `Nil` 还是 `cons`。尽管如此，明确添加不可能的情况仍然可以提供信息。我们可以使用关键字 `impossible` 来做到这一点：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:296
#, no-wrap
msgid ""
"zipWith _ [] (_ :: _) impossible\n"
"zipWith _ (_ :: _) [] impossible\n"
msgstr ""
"zipWith _ [] (_ :: _) impossible\n"
"zipWith _ (_ :: _) [] impossible\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:306
#, no-wrap
msgid ""
"It is - of course - a type error to annotate a case in a pattern\n"
"match with `impossible`, if Idris cannot verify that this case is\n"
"indeed impossible. We will learn in a later section what to do,\n"
"when we think we are right about an impossible case\n"
"and Idris is not.\n"
msgstr "如果 Idris 无法验证这种情况确实是不可能的，那么用 `impossible` 注释模式匹配中的情况当然是类型错误。当我们认为我们对不可能的情况是正确的而 Idris 不是时，我们将在后面的部分中学习该怎么做。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:308
#, no-wrap
msgid "Let's give `zipWith` a spin at the REPL:\n"
msgstr "让我们在 REPL 上给 `zipWith` 一个旋转：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:309
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20,30]\n"
"[10, 40, 90]\n"
"Tutorial.Dependent> zipWith (\\x,y => x ++ \": \" ++ show y) [\"The answer\"] [42]\n"
"[\"The answer: 42\"]\n"
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20]\n"
"... Nasty type error ...\n"
msgstr ""
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20,30]\n"
"[10, 40, 90]\n"
"Tutorial.Dependent> zipWith (\\x,y => x ++ \": \" ++ show y) [\"The answer\"] [42]\n"
"[\"The answer: 42\"]\n"
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20]\n"
"... Nasty type error ...\n"

#. type: Title ####
#: ../src/Tutorial/Dependent.md:318
#, no-wrap
msgid "Simplifying Type Errors"
msgstr "简化类型错误"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:329
#, no-wrap
msgid ""
"It is amazing to experience the amount of work Idris can do\n"
"for us and the amount of things it can infer on its own when\n"
"things go well. When things don't go well, however, the\n"
"error messages we get from Idris can\n"
"be quite long and hard to understand, especially\n"
"for programmers new to the language. For instance, the error\n"
"message in the last REPL example above was pretty long, listing\n"
"different things Idris tried to do together with the reason\n"
"why each of them failed.\n"
msgstr "体验 Idris 可以为我们做的大量工作以及当事情进展顺利时它可以自行推断出的事情的数量，真是令人惊叹。然而，当事情进展不顺利时，我们从 Idris 收到的错误消息可能会很长且难以理解，尤其是对于刚接触该语言的程序员而言。例如，上面最后一个 REPL 示例中的错误消息很长，列出了 Idris 尝试做的不同事情以及每件事失败的原因。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:341
#, no-wrap
msgid ""
"If this happens, it often means that a combination of a type error\n"
"and an ambiguity resulting from overloaded function names is\n"
"at work. In the example above, the two vectors are of distinct\n"
"length, which leads to a type error if we interpret the list\n"
"literals as vectors. However, list literals are overloaded to work\n"
"with all data types with constructors `Nil` and `(::)`, so Idris\n"
"will now try other data constructors than those of `Vect` (the\n"
"ones of `List` and `Stream` from the *Prelude* in this case),\n"
"each of which will again fail with a type error since `zipWith`\n"
"expects arguments of type `Vect`, and neither `List` nor `Stream`\n"
"will work.\n"
msgstr "如果发生这种情况，通常意味着类型错误和函数名重载导致的歧义在起作用。在上面的示例中，两个向量的长度不同，如果我们将列表字面量解释为向量，则会导致类型错误。但是，列表字面量被重载以使用构造函数 `Nil` 和 `(::)` 的所有数据类型，因此 Idris 现在将尝试除 `Vect` 之外的其他数据构造函数]（在这种情况下，来自 *Prelude* 的 `List` 和 `Stream` ），由于 `zipWith` 需要 `Vect` 类型的参数，所以 `List` 和 `Stream` 都不起作用。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:345
#, no-wrap
msgid ""
"If this happens, prefixing overloaded function names with\n"
"their namespaces can often simplify things, as Idris no\n"
"longer needs to disambiguate these functions:\n"
msgstr "如果发生这种情况，在重载函数名称前加上它们的命名空间通常可以简化事情，因为 Idris 不再需要消除这些函数的歧义：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:346
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) (Dependent.(::) 1 Dependent.Nil) Dependent.Nil\n"
"Error: When unifying:\n"
"    Vect 0 ?c\n"
"and:\n"
"    Vect 1 ?c\n"
"Mismatch between: 0 and 1.\n"
msgstr ""
"Tutorial.Dependent> zipWith (*) (Dependent.(::) 1 Dependent.Nil) Dependent.Nil\n"
"Error: When unifying:\n"
"    Vect 0 ?c\n"
"and:\n"
"    Vect 1 ?c\n"
"Mismatch between: 0 and 1.\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:360
#, no-wrap
msgid ""
"Here, the message is much clearer: Idris can't *unify* the lengths of the\n"
"two vectors. *Unification* means: Idris tries to at compile time convert\n"
"two expressions to the same normal form. If this succeeds,\n"
"the two expressions are considered to be equivalent,\n"
"if it doesn't, Idris fails with a unification error.\n"
msgstr "在这里，信息更加清晰：Idris 无法 *统一* 两个向量的长度。 *Unification* 表示：Idris 尝试在编译时将两个表达式转换为相同的范式。如果成功，则认为这两个表达式是等价的，否则，Idris 将失败并出现统一错误。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:363
#, no-wrap
msgid ""
"As an alternative to prefixing overloaded functions with their\n"
"namespace, we can use `the` to help with type inference:\n"
msgstr "作为使用名称空间作为重载函数前缀的替代方法，我们可以使用 `the` 来帮助进行类型推断：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:364
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) (the (Vect 3 _) [1,2,3]) (the (Vect 2 _) [10,20])\n"
"Error: When unifying:\n"
"    Vect 2 ?c\n"
"and:\n"
"    Vect 3 ?c\n"
"Mismatch between: 0 and 1.\n"
msgstr ""
"Tutorial.Dependent> zipWith (*) (the (Vect 3 _) [1,2,3]) (the (Vect 2 _) [10,20])\n"
"Error: When unifying:\n"
"    Vect 2 ?c\n"
"and:\n"
"    Vect 3 ?c\n"
"Mismatch between: 0 and 1.\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:379
#, no-wrap
msgid ""
"It is interesting to note, that the error above is not \"Mismatch between: 2 and 3\"\n"
"but \"Mismatch between: 0 and 1\" instead. Here's what's going on: Idris tries to\n"
"unify integer literals `2` and `3`, which are first converted to the\n"
"corresponding `Nat` values `S (S Z)` and `S (S (S Z))`, respectively.\n"
"The two patterns match until we arrive at `Z` vs `S Z`, corresponding\n"
"to values `0` and `1`, which is the discrepancy reported in the error message.\n"
msgstr "有趣的是，上面的错误不是“不匹配：2 和 3”，而是“不匹配：0 和 1”。这是发生了什么：Idris 尝试统一整数字面量 `2` 和 `3`，它们首先转换为相应的 `Nat` 值 `S (S Z)[` 和 `S (S (S Z))`。这两个模式匹配，直到我们到达 `Z` vs `S Z`，对应于值 `0` 和 `1`，这是报告中报告的差异错误信息。\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:380
#, no-wrap
msgid "Creating Vectors"
msgstr "创建向量"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:387
#, no-wrap
msgid ""
"So far, we were able to learn something about the lengths\n"
"of vectors by pattern matching on them. In the `Nil`\n"
"case, it was clear that the length is 0, while in the *cons*\n"
"case the length was the successor of another natural number.\n"
"This is not possible when we want to create a new vector:\n"
msgstr "到目前为止，我们能够通过对向量进行模式匹配来了解向量的长度。在 `Nil` 的情况下，很明显长度为 0，而在 *cons* 的情况下，长度是另一个自然数的后继。当我们要创建一个新向量时，这是不可能的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:388
#, no-wrap
msgid ""
"failing \"Mismatch between: S ?n and n.\"\n"
"  fill : a -> Vect n a\n"
msgstr ""
"failing \"Mismatch between: S ?n and n.\"\n"
"  fill : a -> Vect n a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:395
#, no-wrap
msgid ""
"You will have a hard time implementing `fill`. The following,\n"
"for instance, leads to a type error:\n"
msgstr "您将很难实现 `fill`。例如，以下内容会导致类型错误：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:396
#, no-wrap
msgid "  fill va = [va,va]\n"
msgstr "  fill va = [va,va]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:403
#, no-wrap
msgid ""
"The problem is, that *the callers of our function decide about\n"
"the length of the resulting vector*. The full type of `fill` is\n"
"actually the following:\n"
msgstr "问题是，*我们函数的调用者决定了结果向量的长度*。 `fill`的完整类型其实如下：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:404
#, no-wrap
msgid "fill' : {0 a : Type} -> {0 n : Nat} -> a -> Vect n a\n"
msgstr "fill' : {0 a : Type} -> {0 n : Nat} -> a -> Vect n a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:415
#, no-wrap
msgid ""
"You can read this type as follows: For every type `a` and for\n"
"every natural number `n` (about which I know *nothing* at runtime,\n"
"since it has quantity zero), given a value of type `a`, I'll give\n"
"you a vector holding exactly `n` elements of type `a`. This is\n"
"like saying: \"Think about a natural number `n`, and\n"
"I'll give you `n` apples without you telling me the value of `n`\".\n"
"Idris is powerful, but it is not a clairvoyant.\n"
msgstr "您可以按如下方式阅读此类型：对于每个类型 `a` 和每个自然数 `n` （我知道在运行时 *什么都没有* ，因为它的定量为零)，给定一个 `a` 类型的值，我会给你一个向量，它正好包含 `a` 类型的 `n` 个元素。这就像说：“想想一个自然数 `n`，我会给你 `n` 个苹果，而你却不告诉我 `n` 的值”。Idris 很强大，但不是千里眼。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:420
#, no-wrap
msgid ""
"In order to implement `fill`, we need to know what\n"
"`n` actually is: We need to pass `n` as an explicit, unerased argument, which\n"
"will allow us to pattern match on it and decide - based on this pattern\n"
"match - which constructors of `Vect` to use:\n"
msgstr "为了实现 `fill`，我们需要知道 `n` 实际上是什么：我们需要将 `n` 作为显式的、未擦除的参数传递，这将允许我们对其进行模式匹配并决定 - 基于此模式匹配 - 使用 `Vect` 的哪些构造函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:421
#, no-wrap
msgid "replicate : (n : Nat) -> a -> Vect n a\n"
msgstr "replicate : (n : Nat) -> a -> Vect n a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:428
#, no-wrap
msgid ""
"Now, `replicate` is a *dependent function type*: The output type\n"
"*depends* on the value of one of the arguments. It is straight forward\n"
"to implement `replicate` by pattern matching on `n`:\n"
msgstr "现在，`replicate` 是一个 *依赖函数类型 *：输出类型 *取决于* 参数的一个值。通过 `n` 上的模式匹配来实现 `replicate` 很简单：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:429
#, no-wrap
msgid ""
"replicate 0     _  = []\n"
"replicate (S k) va = va :: replicate k va\n"
msgstr ""
"replicate 0     _  = []\n"
"replicate (S k) va = va :: replicate k va\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:443
#, no-wrap
msgid ""
"This is a pattern that comes up often when working with\n"
"indexed types: We can learn about the values of the indices\n"
"by pattern matching on the values of the type family. However,\n"
"in order to return a value of the type family from a function,\n"
"we need to either know the values of the indices at compile\n"
"time (see constants `ex1` or `ex3`, for instance), or we\n"
"need to have access to the values of the indices at runtime, in\n"
"which case we can pattern match on them and learn from\n"
"this, which constructor(s) of the type family to use.\n"
msgstr "这是使用索引类型时经常出现的模式：我们可以通过对类型族的值进行模式匹配来了解索引的值。但是，为了从函数返回类型族的值，我们需要在编译时知道索引的值（参见常量 `ex1` 或 `ex3`，例如)，或者我们需要在运行时访问索引的值，在这种情况下，我们可以对它们进行模式匹配并从中学习使用类型族的构造函数。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:447
#, no-wrap
msgid "Implement function `head` for non-empty vectors:\n"
msgstr "为非空向量实现函数 `head`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:448
#, no-wrap
msgid "   head : Vect (S n) a -> a\n"
msgstr "   head : Vect (S n) a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:457
#, no-wrap
msgid ""
"   Note, how we can describe non-emptiness by using a *pattern*\n"
"   in the length of `Vect`. This rules out the `Nil` case, and we can\n"
"   return a value of type `a`, without having to wrap it in\n"
"   a `Maybe`! Make sure to add an `impossible` clause for the `Nil`\n"
"   case (although this is not strictly necessary here).\n"
msgstr "   请注意，我们如何使用 *模式* 来描述在 `Vect` 的长度上的非空性。这排除了 `Nil` 的情况，我们可以返回一个 `a` 类型的值，而不必将其包装在一个`Maybe` 中！确保为 `Nil` 添加一个 `impossible` 子句分支（尽管这不是绝对必要的）。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:461
#, no-wrap
msgid ""
"Using `head` as a reference, declare and implement function `tail`\n"
"for non-empty vectors. The types should reflect that the output\n"
"is exactly one element shorter than the input.\n"
msgstr "以 `head` 为参考，为非空向量声明并实现函数 "
"`tail`。类型应该反映输出恰好比输入短一个元素。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:464
#, no-wrap
msgid ""
"Implement `zipWith3`. If possible, try to doing so without looking at\n"
"the implementation of `zipWith`:\n"
msgstr "实现 `zipWith3`。如果可能，请尝试在不查看 `zipWith` 的实现的情况下这样做：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:465
#, no-wrap
msgid "   zipWith3 : (a -> b -> c -> d) -> Vect n a -> Vect n b -> Vect n c -> Vect n d\n"
msgstr "   zipWith3 : (a -> b -> c -> d) -> Vect n a -> Vect n b -> Vect n c -> Vect n d\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Dependent.md:474
#, no-wrap
msgid ""
"Declare and implement a function `foldSemi`\n"
"for accumulating the values stored\n"
"in a `List` through `Semigroup`s append operator (`(<+>)`).\n"
"(Make sure to only use a `Semigroup` constraint, as opposed to\n"
"a `Monoid` constraint.)\n"
msgstr ""
"声明并实现一个函数 `foldSemi` 用于通过 `Semigroup` 的附加运算符 (`(<+>)`) "
"累加存储在 `List` 中的值. （确保只使用 `Semigroup` 约束，而不是 `Monoid` "
"约束。）\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Dependent.md:477
#, no-wrap
msgid ""
"Do the same as in Exercise 4, but for non-empty vectors. How\n"
"does a vector's non-emptiness affect the output type?\n"
msgstr "做与练习 4 相同的操作，但对于非空向量。向量的非空性如何影响输出类型？\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Dependent.md:482
#, no-wrap
msgid ""
"Given an initial value of type `a` and a function `a -> a`,\n"
"we'd like to generate `Vect`s of `a`s, the first value of\n"
"which is `a`, the second value being `f a`, the third\n"
"being `f (f a)` and so on.\n"
msgstr ""
"给定 `a` 类型的初始值和函数 `a -> a`，我们想生成 `a`s 的 `Vect`s ，"
"其中第一个值为 `a`，第二个值为 `f a`，第三个值为 `f (fa)`，以此类推。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:485
#, no-wrap
msgid ""
"   For instance, if `a` is 1 and `f` is `(* 2)`, we'd like\n"
"   to get results similar to the following: `[1,2,4,8,16,...]`.\n"
msgstr ""
"   例如，如果 `a` 是 1 并且 `f` 是 `(* 2)`，我们希望\n"
"   获得类似于以下的结果：`[1,2,4,8,16,...]`。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:489
#, no-wrap
msgid ""
"   Declare and implement function `iterate`, which should\n"
"   encapsulate this behavior. Get some inspiration from `replicate`\n"
"   if you don't know where to start.\n"
msgstr "   声明并实现函数 `iterate`，它应该封装这种行为。如果你不知道从哪里开始，可以从 `replicate` 中获得一些灵感。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Dependent.md:495
#, no-wrap
msgid ""
"Given an initial value of a state type `s` and\n"
"a function `fun : s -> (s,a)`,\n"
"we'd like to generate `Vect`s of `a`s. Declare and implement\n"
"function `generate`, which should encapsulate this behavior. Make sure to use\n"
"the updated state in every new invocation of `fun`.\n"
msgstr ""
"给定状态类型 `s` 的初始值和函数 `fun : s -> (s,a)`，我们希望生成 `a` 的 "
"`Vect`。声明并实现函数 `generate`，它应该封装这个行为。确保在每次新调用 `fun`"
" 时使用更新后的状态。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:498
#, no-wrap
msgid ""
"   Here's an example how this can be used to generate the first\n"
"   `n` Fibonacci numbers:\n"
msgstr "   这是一个示例，它被用来生成前 `n` 个斐波那契数列：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:499
#, no-wrap
msgid ""
"   generate 10 (\\(x,y) => let z = x + y in ((y,z),z)) (0,1)\n"
"   [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n"
msgstr ""
"   generate 10 (\\(x,y) => let z = x + y in ((y,z),z)) (0,1)\n"
"   [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Dependent.md:507
#, no-wrap
msgid ""
"Implement function `fromList`, which converts a list of\n"
"values to a `Vect` of the same length. Use holes if you\n"
"get stuck:\n"
msgstr "实现函数 `fromList`，它将值列表转换为相同长度的 `Vect`。如果卡住，请使用孔："
"\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:508
#, no-wrap
msgid "   fromList : (as : List a) -> Vect (length as) a\n"
msgstr "   fromList : (as : List a) -> Vect (length as) a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:515
#, no-wrap
msgid ""
"   Note how, in the type of `fromList`, we can *calculate* the\n"
"   length of the resulting vector by passing the list argument\n"
"   to function *length*.\n"
msgstr "   请注意，在 `fromList` 的类型中，我们如何通过 `length` 函数*计算* list 参数得到向量的长度。\n"

#. type: Bullet: '9. '
#: ../src/Tutorial/Dependent.md:517
#, no-wrap
msgid "Consider the following declarations:\n"
msgstr "考虑以下声明：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:518
#, no-wrap
msgid ""
"   maybeSize : Maybe a -> Nat\n"
"\n"
"   fromMaybe : (m : Maybe a) -> Vect (maybeSize m) a\n"
msgstr ""
"   maybeSize : Maybe a -> Nat\n"
"\n"
"   fromMaybe : (m : Maybe a) -> Vect (maybeSize m) a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:526
#, no-wrap
msgid ""
"   Choose a reasonable implementation for `maybeSize` and\n"
"   implement `fromMaybe` afterwards.\n"
msgstr ""
"   为 `maybeSize` 选择一个合理的实现，\n"
"   然后执行 `fromMaybe` 。\n"

#. type: Title ##
#: ../src/Tutorial/Dependent.md:527
#, no-wrap
msgid "`Fin`: Safe Indexing into Vectors"
msgstr "`Fin`：向量的安全索引"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:531
#, no-wrap
msgid ""
"Consider function `index`, which tries to extract a value from\n"
"a `List` at the given position:\n"
msgstr "考虑函数 `index`，它试图从给定位置的 `List` 中提取一个值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:532
#, no-wrap
msgid ""
"indexList : (pos : Nat) -> List a -> Maybe a\n"
"indexList _     []        = Nothing\n"
"indexList 0     (x :: _)  = Just x\n"
"indexList (S k) (_ :: xs) = indexList k xs\n"
msgstr ""
"indexList : (pos : Nat) -> List a -> Maybe a\n"
"indexList _     []        = Nothing\n"
"indexList 0     (x :: _)  = Just x\n"
"indexList (S k) (_ :: xs) = indexList k xs\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:553
#, no-wrap
msgid ""
"Now, here is a thing to consider when writing functions like `indexList`:\n"
"Do we want to express the possibility of failure in the output type,\n"
"or do we want to restrict the accepted arguments,\n"
"so the function can no longer fail? These are important design decisions,\n"
"especially in larger applications.\n"
"Returning a `Maybe` or `Either` from a function forces client code to eventually\n"
"deal with the `Nothing` or `Left` case, and until this happens, all intermediary\n"
"results will carry the `Maybe` or `Either` stain, which will make it more\n"
"cumbersome to run calculations with these intermediary results.\n"
"On the other hand, restricting the\n"
"values accepted as input will complicate the argument types\n"
"and will put the burden of input validation on our functions' callers,\n"
"(although, at compile time we can get help from Idris, as we will\n"
"see when we talk about auto implicits) while keeping the output pure and clean.\n"
msgstr "现在，在编写 `indexList` 之类的函数时要考虑的一点是：我们是要表达输出类型失败的可能性，还是要限制接受的参数，所以函数不能再失败？这些都是重要的设计决策，尤其是在较大的应用程序中。从函数返回 `Maybe` 或 `Either` 会强制客户端代码最终处理 `Nothing` 或 `Left` 情况，直到发生这种情况，所有中间结果都将带有 `Maybe` 或 `Either` 污点，这将使使用这些中间结果运行计算变得更加麻烦。另一方面，限制作为输入接受的值会使参数类型复杂化，并将输入验证的负担放在我们函数的调用者身上，（尽管在编译时我们可以从 Idris 获得帮助，正如我们将在讨论时看到的那样关于自动隐式），同时保持输出纯净和干净。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:558
#, no-wrap
msgid ""
"Languages without dependent types (like Haskell), can often only take\n"
"the route described above: To wrap the result in a `Maybe` or `Either`.\n"
"However, in Idris we can often *refine* the input types to restrict the\n"
"set of accepted values, thus ruling out the possibility of failure.\n"
msgstr "没有依赖类型的语言（如 Haskell）通常只能采用上述路线：将结果包装在 `Maybe` 或 `Either` 中。但是，在 Idris 中，我们通常可以 *细化* 输入类型以限制接受值的集合，从而排除失败的可能性。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:564
#, no-wrap
msgid ""
"Assume, as an example, we'd like to extract a value from a `Vect n a`\n"
"at (zero-based) index `k`. Surely, this can succeed if and only if\n"
"`k` is a natural number strictly smaller than the length `n` of\n"
"the vector. Luckily, we can express this precondition in an indexed\n"
"type:\n"
msgstr "假设，作为一个例子，我们想从 `Vect n a` 的（从零开始的）索引 `k` 处的中提取一个值。当然，当且仅当 `k` 是一个严格小于向量长度 `n` 的自然数时，这才能成功。幸运的是，我们可以用索引类型来表达这个前提条件：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:565
#, no-wrap
msgid ""
"data Fin : (n : Nat) -> Type where\n"
"  FZ : {0 n : Nat} -> Fin (S n)\n"
"  FS : (k : Fin n) -> Fin (S n)\n"
msgstr ""
"data Fin : (n : Nat) -> Type where\n"
"  FZ : {0 n : Nat} -> Fin (S n)\n"
"  FS : (k : Fin n) -> Fin (S n)\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:577
#, no-wrap
msgid ""
"`Fin n` is the type of natural numbers strictly smaller than `n`.\n"
"It is defined inductively: `FZ` corresponds to natural number *zero*,\n"
"which, as can be seen in its type, is strictly smaller than\n"
"`S n` for any natural number `n`. `FS` is the inductive case:\n"
"If `k` is strictly smaller than `n` (`k` being of type `Fin n`),\n"
"then `FS k` is strictly smaller than `S n`.\n"
msgstr "`Fin n` 是严格小于 `n` 的自然数类型。它是归纳定义的：`FZ` 对应于自然数 *0*，从其类型中可以看出，对于任何自然数，`n` 都严格小于 `S n`。 `FS` 是归纳情况：如果 `k` 严格小于 `n` （`k` 属于 `Fin n` 类型)，则 `FS k` 严格小于 `S n`。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:579
#, no-wrap
msgid "Let's come up with some values of type `Fin`:\n"
msgstr "让我们想出一些 `Fin` 类型的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:580
#, no-wrap
msgid ""
"fin0_5 : Fin 5\n"
"fin0_5 = FZ\n"
"\n"
"fin0_7 : Fin 7\n"
"fin0_7 = FZ\n"
"\n"
"fin1_3 : Fin 3\n"
"fin1_3 = FS FZ\n"
"\n"
"fin4_5 : Fin 5\n"
"fin4_5 = FS (FS (FS (FS FZ)))\n"
msgstr ""
"fin0_5 : Fin 5\n"
"fin0_5 = FZ\n"
"\n"
"fin0_7 : Fin 7\n"
"fin0_7 = FZ\n"
"\n"
"fin1_3 : Fin 3\n"
"fin1_3 = FS FZ\n"
"\n"
"fin4_5 : Fin 5\n"
"fin4_5 = FS (FS (FS (FS FZ)))\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:597
#, no-wrap
msgid ""
"Note, that there is no value of type `Fin 0`. We will learn\n"
"in a later session, how to express \"there is no value of type `x`\"\n"
"in a type.\n"
msgstr "请注意，没有 `Fin 0` 类型的值。我们将在后面的课程中学习，如何在类型中表达“没有类型 `x` 的值”。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:600
#, no-wrap
msgid ""
"Let us now check, whether we can use `Fin` to safely index\n"
"into a `Vect`:\n"
msgstr "现在让我们检查一下，是否可以使用 `Fin` 安全地索引到 `Vect`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:601
#, no-wrap
msgid "index : Fin n -> Vect n a -> a\n"
msgstr "index : Fin n -> Vect n a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:607
#, no-wrap
msgid ""
"Before you continue, try to implement `index` yourself, making use\n"
"of holes if you get stuck.\n"
msgstr "在继续之前，请尝试自己实现 `index`，如果遇到困难，请充分利用孔。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:608
#, no-wrap
msgid ""
"index FZ     (x :: _) = x\n"
"index (FS k) (_ :: xs) = index k xs\n"
msgstr ""
"index FZ     (x :: _) = x\n"
"index (FS k) (_ :: xs) = index k xs\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:617
#, no-wrap
msgid ""
"Note, how there is no `Nil` case and the totality checker is still\n"
"happy. That's because `Nil` is of type `Vect 0 a`, but there is no\n"
"value of type `Fin 0`! We can verify this by adding the missing\n"
"impossible clauses:\n"
msgstr "请注意，如何没有 `Nil` 分支，并且总体检查器仍然很高兴。那是因为 `Nil` 的类型是 `Vect 0 a`，但是没有 `Fin 0` 类型的值！我们可以通过添加缺失的不可能子句来验证这一点：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:618
#, no-wrap
msgid ""
"index FZ     Nil impossible\n"
"index (FS _) Nil impossible\n"
msgstr ""
"index FZ     Nil impossible\n"
"index (FS _) Nil impossible\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:627
#, no-wrap
msgid ""
"Implement function `update`, which, given a function of\n"
"type `a -> a`, updates the value in a`Vect n a` at position `k < n`.\n"
msgstr "实现函数 `update`，给定一个类型为 `a -> a` 的函数，在 `Vect n a` 中 `k < n` "
"处的位置更新值。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:631
#, no-wrap
msgid ""
"Implement function `insert`, which inserts a value of type `a`\n"
"at position `k <= n` in a `Vect n a`. Note, that `k` is the\n"
"index of the freshly inserted value, so that the following holds:\n"
msgstr ""
"实现函数 `insert`，它在 `Vect n a` 中的 `k <= n` 位置插入 `a` "
"类型的值。请注意，`k` 是新插入值的索引，因此以下成立：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:632
#, no-wrap
msgid "   index k (insert k v vs) = v\n"
msgstr "   index k (insert k v vs) = v\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:638
#, no-wrap
msgid ""
"Implement function `delete`, which deletes a value from a\n"
"vector at the given index.\n"
msgstr "实现函数 `delete`，它从向量中的给定索引处删除一个值。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:641
#, no-wrap
msgid ""
"   This is trickier than Exercises 1 and 2, as we have to properly\n"
"   encode in the types that the vector is getting one element shorter.\n"
msgstr "   这比练习 1 和练习 2 更棘手，因为我们必须正确编码向量正在缩短一个元素的类型。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Dependent.md:644
#, no-wrap
msgid ""
"We can use `Fin` to implement safe indexing into `List`s as well. Try to\n"
"come up with a type and implementation for `safeIndexList`.\n"
msgstr "我们也可以使用 `Fin` 来实现对 `List` 的安全索引。尝试为 `safeIndexList` "
"提出一个类型和实现。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:648
#, no-wrap
msgid ""
"   Note: If you don't know how to start, look at the type of `fromList`\n"
"   for some inspiration. You might also need give the arguments in\n"
"   a different order than for `index`.\n"
msgstr "   注意：如果不知道怎么下手，看`fromList`的类型找一些灵感。您可能还需要与 `index`  不同的顺序给出参数。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Dependent.md:653
#, no-wrap
msgid ""
"Implement function `finToNat`, which converts a `Fin n` to the\n"
"corresponding natural number, and use this to declare and\n"
"implement function `take` for splitting of the first `k`\n"
"elements of a `Vect n a` with `k <= n`.\n"
msgstr ""
"实现函数 `finToNat`，将一个`Fin n`转换为对应的自然数，并用它来声明和实现函数 "
"`take` ，通过对 `Vect n a` 的前 `k` 个元素进行拆分 ，其中 `k <= n`。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Dependent.md:656
#, no-wrap
msgid ""
"Implement function `minus` for subtracting a value `k` from\n"
"a natural number `n` with `k <= n`.\n"
msgstr "实现函数 `minus` 用于从 `k <= n` 的自然数 `n` 中减去值 `k`。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Dependent.md:660
#, no-wrap
msgid ""
"Use `minus` from Exercise 6 to declare and implement function\n"
"`drop`, for dropping the first `k` values from a `Vect n a`,\n"
"with `k <= n`.\n"
msgstr ""
"使用练习 6 中的 `minus` 声明和实现函数 `drop`，用于从 `Vect n a` "
"中删除第一个 `k` 值，其中 `k <= n`。\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Dependent.md:664
#, no-wrap
msgid ""
"Implement function `splitAt` for splitting a `Vect n a` at\n"
"position `k <= n`, returning the prefix and suffix of the\n"
"vector wrapped in a pair.\n"
msgstr "实现函数 `splitAt` 用于在位置 `k <= n` 处拆分 `Vect n "
"a`，返回包装成对的向量的前缀和后缀。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:666
#, no-wrap
msgid "   Hint: Use `take` and `drop` in your implementation.\n"
msgstr "   提示：在你的实现中使用 `take` 和 `drop`。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:670
#, no-wrap
msgid ""
"Hint: Since `Fin n` consists of the values strictly smaller\n"
"than `n`, `Fin (S n)` consists of the values smaller than\n"
"or equal to `n`.\n"
msgstr "提示：由于 `Fin n` 由严格小于 `n` 的值组成，因此 `Fin (S n)` 由小于或等于 `n 的值组成`。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:675
#, no-wrap
msgid ""
"Note: Functions `take`, `drop`, and `splitAt`, while correct and\n"
"provably total, are rather cumbersome to type.\n"
"There is an alternative way to declare their types,\n"
"as we will see in the next section.\n"
msgstr "注意：函数 `take`、`drop` 和 `splitAt` 虽然正确且可证明是完全的，但键入起来相当麻烦。正如我们将在下一节中看到的，还有另一种声明它们的类型的方法。\n"

#. type: Title ##
#: ../src/Tutorial/Dependent.md:676
#, no-wrap
msgid "Compile-Time Computations"
msgstr "编译时计算"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:683
#, no-wrap
msgid ""
"In the last section - especially in some of the exercises - we\n"
"started more and more to use compile time computations to\n"
"describe the types of our functions and values.\n"
"This is a very powerful concept, as it allows us to\n"
"compute output types from input types. Here's an example:\n"
msgstr "在上一节中——尤其是在一些练习中——我们开始越来越多地使用编译时计算来描述函数和值的类型。这是一个非常强大的概念，因为它允许我们根据输入类型计算输出类型。这是一个例子：\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:690
#, no-wrap
msgid ""
"It is possible to concatenate two `List`s with the `(++)`\n"
"operator. Surely, this should also be possible for\n"
"`Vect`. But `Vect` is indexed by its length, so we have\n"
"to reflect in the types exactly how the lengths of the\n"
"inputs affect the lengths of the output. Here's how to\n"
"do this:\n"
msgstr "可以使用 `(++)` 运算符连接两个 `List`。当然，这对于 `Vect` 也应该是可能的。但是 `Vect` 是由它的长度索引的，所以我们必须在类型中准确地反映输入的长度如何影响输出的长度。以下是如何执行此操作：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:691
#, no-wrap
msgid ""
"(++) : Vect m a -> Vect n a -> Vect (m + n) a\n"
"(++) []        ys = ys\n"
"(++) (x :: xs) ys = x :: (xs ++ ys)\n"
msgstr ""
"(++) : Vect m a -> Vect n a -> Vect (m + n) a\n"
"(++) []        ys = ys\n"
"(++) (x :: xs) ys = x :: (xs ++ ys)\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:700
#, no-wrap
msgid ""
"Note, how we keep track of the lengths at the type-level, again\n"
"ruling out certain common programming errors like inadvertently dropping\n"
"some values.\n"
msgstr "请注意，我们如何在类型级别跟踪长度，再次排除某些常见的编程错误，例如无意中删除某些值。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:705
#, no-wrap
msgid ""
"We can also use type-level computations as patterns\n"
"on the input types. Here is an alternative type and implementation\n"
"for `drop`, which you implemented in the exercises by\n"
"using a `Fin n` argument:\n"
msgstr "我们还可以使用类型级计算作为输入类型的模式。这是 `drop` 的另一种类型和实现，您在练习中使用 `Fin n` 参数实现了它：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:706
#, no-wrap
msgid ""
"drop' : (m : Nat) -> Vect (m + n) a -> Vect n a\n"
"drop' 0     xs        = xs\n"
"drop' (S k) (_ :: xs) = drop' k xs\n"
msgstr ""
"drop' : (m : Nat) -> Vect (m + n) a -> Vect n a\n"
"drop' 0     xs        = xs\n"
"drop' (S k) (_ :: xs) = drop' k xs\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:712
#, no-wrap
msgid "Limitations"
msgstr "限制"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:718
#, no-wrap
msgid ""
"After all the examples and exercises in this section\n"
"you might have come to the conclusion that we can\n"
"use arbitrary expressions in the types and Idris\n"
"will happily evaluate and unify all of them for us.\n"
msgstr "在本节中的所有示例和练习之后，您可能已经得出结论，我们可以在类型中使用任意表达式，并且 Idris 会很乐意为我们评估和统一所有这些表达式。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:724
#, no-wrap
msgid ""
"I'm afraid that's not even close to the truth. The examples\n"
"in this section were hand-picked because they are known\n"
"to *just work*. The reason being, that there was always\n"
"a direct link between our own pattern matches and the\n"
"implementations of functions we used at compile time.\n"
msgstr "恐怕这甚至不接近事实。本节中的示例是精心挑选的，因为它们已知 *可以正常工作*。原因是，我们自己的模式匹配和我们在编译时使用的函数的实现之间总是存在直接联系。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:727
#, no-wrap
msgid ""
"For instance, here is the implementation of addition of\n"
"natural numbers:\n"
msgstr "例如，这里是自然数加法的实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:728
#, no-wrap
msgid ""
"add : Nat -> Nat -> Nat\n"
"add Z     n = n\n"
"add (S k) n = S $ add k n\n"
msgstr ""
"add : Nat -> Nat -> Nat\n"
"add Z     n = n\n"
"add (S k) n = S $ add k n\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:745
#, no-wrap
msgid ""
"As you can see, `add` is implemented via a pattern match\n"
"on its *first* argument, while the second argument is never\n"
"inspected. Note, how this is exactly how `(++)` for `Vect`\n"
"is implemented: There, we also pattern match on the first\n"
"argument, returning the second unmodified in the `Nil`\n"
"case, and prepending the head to the result of appending\n"
"the tail in the *cons* case. Since there is a direct\n"
"correspondence between the two pattern matches, it\n"
"is possible for Idris to unify `0 + n` with `n` in the\n"
"`Nil` case, and `(S k) + n` with `S (k + n)` in the\n"
"*cons* case.\n"
msgstr "如您所见， `add` 是通过对其 *第一个* 参数的模式匹配来实现的，而第二个参数从未被检查过。请注意，这正是 `(++)` 在 `Vect` 上的实现方式：在那里，我们还对第一个参数进行模式匹配，在 `Nil` 分支中返回未修改的第二个参数，并将头部添加到 *cons* 分支中追加尾部的结果。由于两个模式匹配之间存在直接对应关系，因此 Idris 可以在 `Nil` 的情况下将 `0 + n` 与 `n` 统一起来，而在 *cons* 的情况下 `(S k) + n` 与 `S (k + n)` 统一起来。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:748
#, no-wrap
msgid ""
"Here is a simple example, where Idris will not longer\n"
"be convinced without some help from us:\n"
msgstr "这是一个简单的例子，如果没有我们的帮助，Idris 将不再相信：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:749
#, no-wrap
msgid ""
"failing \"Can't solve constraint\"\n"
"  reverse : Vect n a -> Vect n a\n"
"  reverse []        = []\n"
"  reverse (x :: xs) = reverse xs ++ [x]\n"
msgstr ""
"failing \"Can't solve constraint\"\n"
"  reverse : Vect n a -> Vect n a\n"
"  reverse []        = []\n"
"  reverse (x :: xs) = reverse xs ++ [x]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:768
#, no-wrap
msgid ""
"When we type-check the above,\n"
"Idris will fail with the following error message:\n"
"\"Can't solve constraint between: plus n 1 and S n.\"\n"
"Here's what's going on: From the pattern match on the\n"
"left hand side, Idris knows that the length of the\n"
"vector is `S n`, for some natural number `n`\n"
"corresponding to the length of `xs`. The length\n"
"of the vector on the right hand side is `n + 1`,\n"
"according to the type of `(++)` and the lengths\n"
"of `xs` and `[x]`. Overloaded operator `(+)`\n"
"is implemented via function `Prelude.plus`, that's\n"
"why Idris replaces `(+)` with `plus` in the error message.\n"
msgstr "当我们对上述内容进行类型检查时，Idris 将失败并显示以下错误消息：“无法解决之间的约束：加plus n 1 和 S n。”这是发生了什么：从左侧的模式匹配中，Idris 知道向量的长度是 `S n`，对于某个自然数 `n` 对应于 `xs`。右边向量的长度是`n + 1`，根据 `(++)` 的类型和 `xs` 和 `[x]` 的长度。重载运算符 `(+)` 是通过函数 `Prelude.plus` 实现的，这就是 Idris 在错误消息中将 `(+)` 替换为 `plus` 的原因.\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:780
#, no-wrap
msgid ""
"As you can see from the above, Idris can't verify on\n"
"its own that `1 + n` is the same thing as `n + 1`.\n"
"It can accept some help from us, though. If we come\n"
"up with a *proof* that the above equality holds\n"
"(or - more generally - that our implementation of\n"
"addition for natural numbers is *commutative*),\n"
"we can use this proof to *rewrite* the types on\n"
"the right hand side of `reverse`. Writing proofs and\n"
"using `rewrite` will require some in-depth explanations\n"
"and examples. Therefore, these things will have to wait\n"
"until another chapter.\n"
msgstr "从上面可以看出，Idris 自己无法验证 `1 + n` 与 `n + 1` 是一回事。不过，它可以接受我们的一些帮助。如果我们提出上述等式成立的 *证明*（或者更一般地说，我们对自然数加法的实现是 *可交换的*），我们可以将此证明用于 *重写* `reverse` 右侧的类型。编写证明和使用 `rewrite` 需要一些深入的解释和示例。所以，这些事情还得等到下一章再说。\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:781
#, no-wrap
msgid "Unrestricted Implicits"
msgstr "不受限制的隐式"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:789
#, no-wrap
msgid ""
"In functions like `replicate`, we pass a natural number `n`\n"
"as an explicit, unrestricted argument from which we infer\n"
"the length of the vector to return.\n"
"In some circumstances, `n` can be inferred from the context.\n"
"For instance, in the following example it is tedious to\n"
"pass `n` explicitly:\n"
msgstr "在像 `replicate` 这样的函数中，我们传递一个自然数 `n` 作为一个明确的、不受限制的参数，我们从中推断要返回的向量的长度。在某些情况下，可以从上下文中推断出 `n`。例如，在以下示例中，显式传递 `n` 是很乏味的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:790
#, no-wrap
msgid ""
"ex4 : Vect 3 Integer\n"
"ex4 = zipWith (*) (replicate 3 10) (replicate 3 11)\n"
msgstr ""
"ex4 : Vect 3 Integer\n"
"ex4 = zipWith (*) (replicate 3 10) (replicate 3 11)\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:797
#, no-wrap
msgid ""
"The value `n` is clearly derivable from the context, which\n"
"can be confirmed by replacing it with underscores:\n"
msgstr "`n` 的值显然可以从上下文中推导出来，可以通过将其替换为下划线来确认：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:798
#, no-wrap
msgid ""
"ex5 : Vect 3 Integer\n"
"ex5 = zipWith (*) (replicate _ 10) (replicate _ 11)\n"
msgstr ""
"ex5 : Vect 3 Integer\n"
"ex5 = zipWith (*) (replicate _ 10) (replicate _ 11)\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:806
#, no-wrap
msgid ""
"We therefore can implement an alternative version of `replicate`,\n"
"where we pass `n` as an implicit argument of *unrestricted*\n"
"quantity:\n"
msgstr "因此，我们可以实现 `replicate` 的替代版本，其中我们将 `n` 作为 *无限制* 定量的隐式参数传递：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:807
#, no-wrap
msgid ""
"replicate' : {n : _} -> a -> Vect n a\n"
"replicate' = replicate n\n"
msgstr ""
"replicate' : {n : _} -> a -> Vect n a\n"
"replicate' = replicate n\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:814
#, no-wrap
msgid ""
"Note how, in the implementation of `replicate'`, we can refer to `n`\n"
"and pass it as an explicit argument to `replicate`.\n"
msgstr "请注意，在 `replicate'` 的实现中，我们可以引用 `n` 并将其作为显式参数传递给 `replicate`。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:820
#, no-wrap
msgid ""
"Deciding whether to pass potentially inferable arguments to a function implicitly\n"
"or explicitly is a question of how often the arguments actually *are* inferable\n"
"by Idris. Sometimes it might even be useful to have both verions\n"
"of a function. Remember, however, that even in case of an implicit argument\n"
"we can still pass the value explicitly:\n"
msgstr "决定是否将潜在的可推断参数隐式或显式传递给函数是一个问题，即 Idris 实际 *是* 可推断参数的使用频率。有时，同时拥有一个函数的两个版本甚至可能很有用。但是请记住，即使是隐式参数，我们仍然可以显式传递值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:821
#, no-wrap
msgid ""
"ex6 : Vect ? Bool\n"
"ex6 = replicate' {n = 2} True\n"
msgstr ""
"ex6 : Vect ? Bool\n"
"ex6 = replicate' {n = 2} True\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:829
#, no-wrap
msgid ""
"In the type signature above, the question mark (`?`) means, that Idris\n"
"should try and figure out the value on its own by unification. This\n"
"forces us to specify `n` explicitly on the right hand side of `ex6`.\n"
msgstr "在上面的类型签名中，问号 (`?`) 的意思是，Idris 应该尝试通过统一自己找出值。这迫使我们在 `ex6` 的右侧明确指定 `n`。\n"

#. type: Title ####
#: ../src/Tutorial/Dependent.md:830
#, no-wrap
msgid "Pattern Matching on Implicits"
msgstr "隐式模式匹配"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:836
#, no-wrap
msgid ""
"The implementation of `replicate'` makes use of function `replicate`,\n"
"where we could pattern match on the explicit argument `n`. However, it\n"
"is also possible to pattern match on implicit, named arguments of\n"
"non-zero quantity:\n"
msgstr "`replicate'` 的实现使用了函数 `replicate`，我们可以在显式参数 `n` 上进行模式匹配。但是，也可以对非零数量的隐式命名参数进行模式匹配：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:837
#, no-wrap
msgid ""
"replicate'' : {n : _} -> a -> Vect n a\n"
"replicate'' {n = Z}   _ = Nil\n"
"replicate'' {n = S _} v = v :: replicate'' v\n"
msgstr ""
"replicate'' : {n : _} -> a -> Vect n a\n"
"replicate'' {n = Z}   _ = Nil\n"
"replicate'' {n = S _} v = v :: replicate'' v\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:846
#, no-wrap
msgid "Here is a function declaration for flattening a `List` of `List`s:\n"
msgstr "这是一个用于扁平化 `List` 中的 `List` 的函数声明：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:847
#, no-wrap
msgid "   flattenList : List (List a) -> List a\n"
msgstr "   flattenList : List (List a) -> List a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:853
#, no-wrap
msgid ""
"   Implement `flattenList` and declare and implement a similar\n"
"   function `flattenVect` for flattening vectors of vectors.\n"
msgstr "   实现 `flattenList` 并声明和实现一个类似的函数 `flattenVect` 用于扁平化向量的向量。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:857
#, no-wrap
msgid ""
"Implement functions `take'` and `splitAt'` like in\n"
"the exercises of the previous section but using the\n"
"technique shown for `drop'`.\n"
msgstr "像上一节的练习一样实现函数 `take'` 和 `splitAt'`，但使用 `drop'` 所示的技术。"
"\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:861
#, no-wrap
msgid ""
"Implement function `transpose` for converting an\n"
"`m x n`-matrix (represented as a `Vect m (Vect n a)`)\n"
"to an `n x m`-matrix.\n"
msgstr ""
"实现函数 `transpose` 用于将 `m x n` 矩阵（表示为 `Vect m (Vect n a)`）转换为 "
"`n x m` 矩阵。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:864
#, no-wrap
msgid ""
"   Note: This might be a challenging exercise, but make sure\n"
"   to give it a try. As usual, make use of holes if you get stuck!\n"
msgstr "   注意：这可能是一项具有挑战性的练习，但请确保试一试。像往常一样，如果你被卡住了，就利用洞！\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:866
#, no-wrap
msgid "   Here is an example how this should work in action:\n"
msgstr "   这是一个示例，它应该如何在行动中发挥作用：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:867
#, no-wrap
msgid ""
"   Solutions.Dependent> transpose [[1,2,3],[4,5,6]]\n"
"   [[1, 4], [2, 5], [3, 6]]\n"
msgstr ""
"   Solutions.Dependent> transpose [[1,2,3],[4,5,6]]\n"
"   [[1, 4], [2, 5], [3, 6]]\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:878
#, no-wrap
msgid ""
"Dependent types allow us to calculate types from values.\n"
"This makes it possible to encode properties of values\n"
"at the type-level and verify these properties at compile\n"
"time.\n"
msgstr "依赖类型允许我们根据值计算类型。这使得在类型级别对值的属性进行编码并在编译时"
"验证这些属性成为可能。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:882
#, no-wrap
msgid ""
"Length-indexed lists (vectors) let us rule out certain implementation\n"
"errors, by forcing us to be precise about the lengths of input\n"
"and output vectors.\n"
msgstr "长度索引列表（向量）通过强制我们准确了解输入和输出向量的长度，让我们排除了某"
"些实现错误。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:886
#, no-wrap
msgid ""
"We can use patterns in type signatures, for instance to\n"
"express that the length of a vector is non-zero and therefore,\n"
"the vector is non-empty.\n"
msgstr "我们可以在类型签名中使用模式，例如表示向量的长度非零，因此向量非空。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:891
#, no-wrap
msgid ""
"When creating values of a type family, the values of the indices\n"
"need to be known at compile time, or they need to be passed as\n"
"arguments to the function creating the values, where we can\n"
"pattern match on them to figure out, which constructors to use.\n"
msgstr "创建类型族的值时，索引的值需要在编译时知道，或者它们需要作为参数传递给创建值"
"的函数，我们可以对它们进行模式匹配以确定哪些构造函数利用。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:894
#, no-wrap
msgid ""
"We can use `Fin n`, the type of natural numbers strictly smaller\n"
"than `n`, to safely index into a vector of length `n`.\n"
msgstr "我们可以使用严格小于 `n` 的自然数类型 `Fin n` 来安全地索引长度为 `n` 的向量。"
"\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:899
#, no-wrap
msgid ""
"Sometimes, it is convenient to pass inferable arguments as\n"
"non-erased implicits, in which case we can still inspect them\n"
"by pattern matching or pass them to other functions, while Idris\n"
"will try and fill in the values for us.\n"
msgstr ""
"有时，将可推断参数作为非擦除隐式传递很方便，在这种情况下，我们仍然可以通过模"
"式匹配检查它们或将它们传递给其他函数，而 Idris 会尝试为我们填充值。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:903
#, no-wrap
msgid ""
"Note, that data type `Vect` together with many of the functions we\n"
"implemented here is available from module `Data.Vect` from the *base*\n"
"library. Likewise, `Fin` is available from `Data.Fin` from *base*.\n"
msgstr "请注意，数据类型 `Vect` 以及我们在此处实现的许多功能可从 *base* 库中的模块 `Data.Vect` 获得。同样，`Fin` 可从 `Data.Fin` 从 *base* 获得。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:908
#, no-wrap
msgid ""
"In the [next section](IO.md), it is time to learn how to write effectful programs\n"
"and how to do this while still staying *pure*.\n"
msgstr "在 [next section](IO.md) 中，是时候学习如何编写有效的程序以及如何在保持 * 纯 * 的同时做到这一点。\n"

#. type: Title #
#: ../src/Tutorial/DPair.md:1
#, no-wrap
msgid "Sigma Types"
msgstr "Sigma 类型"

#. type: Plain text
#: ../src/Tutorial/DPair.md:18
#, no-wrap
msgid ""
"So far in our examples of dependently typed programming,\n"
"type indices such as the length of vectors were known at\n"
"compile time or could be calculated from values known at\n"
"compile time. In real applications, however, such information is\n"
"often not available until runtime, where values depend on\n"
"the decisions made by users or the state of the surrounding world.\n"
"For instance, if we store a file's content as a vector of lines\n"
"of text, the length of this vector is in general unknown until\n"
"the file has been loaded into memory.\n"
"As a consequence, the types of values we work with depend on\n"
"other values only known at runtime, and we can often only figure out\n"
"these types by pattern matching on the values they depend on.\n"
"To express these dependencies, we need so called\n"
"[*sigma types*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A3_type):\n"
"Dependent pairs and their generalization, dependent records.\n"
msgstr "到目前为止，在我们的依赖类型编程示例中，类型索引（例如向量的长度）在编译时是已知的，或者可以从编译时已知的值中计算出来。然而，在实际应用中，此类信息通常在运行时才可用，其中值取决于用户做出的决定或周围世界的状态。例如，如果我们将文件的内容存储为文本行向量，则该向量的长度通常在文件加载到内存之前是未知的。因此，我们使用的值的类型依赖于仅在运行时才知道的其他值，并且我们通常只能通过对它们所依赖的值进行模式匹配来找出这些类型。为了表达这些依赖关系，我们需要所谓的 [*sigma types*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A3_type)：依赖对及其泛化，依赖记录。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:19
#, no-wrap
msgid ""
"module Tutorial.DPair\n"
"\n"
"import Control.Monad.State\n"
"\n"
"import Data.DPair\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.List\n"
"import Data.List1\n"
"import Data.Singleton\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import Text.CSV\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.DPair\n"
"\n"
"import Control.Monad.State\n"
"\n"
"import Data.DPair\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.List\n"
"import Data.List1\n"
"import Data.Singleton\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import Text.CSV\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/DPair.md:38
#, no-wrap
msgid "Dependent Pairs"
msgstr "依赖对"

#. type: Plain text
#: ../src/Tutorial/DPair.md:46
#, no-wrap
msgid ""
"We've already seen several examples of how useful the length\n"
"index of a vector is to describe more precisely in the types what\n"
"a function can and can't do. For instance, `map` or `traverse`\n"
"operating on a vector will return a vector of exactly\n"
"the same length. The types guarantee that this is true, therefore\n"
"the following function is perfectly safe and provably total:\n"
msgstr "我们已经看到了几个例子，说明向量的长度索引在更精确地描述函数可以做什么和不能做什么的类型中是多么有用。例如，对向量进行操作的 `map` 或 `traverse` 将返回长度完全相同的向量。这些类型保证这是真的，因此以下函数是完全安全的并且可以证明是完全的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:47
#, no-wrap
msgid ""
"parseAndDrop : Vect (3 + n) String -> Maybe (Vect n Nat)\n"
"parseAndDrop = map (drop 3) . traverse parsePositive\n"
msgstr ""
"parseAndDrop : Vect (3 + n) String -> Maybe (Vect n Nat)\n"
"parseAndDrop = map (drop 3) . traverse parsePositive\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:60
#, no-wrap
msgid ""
"Since the argument of `traverse parsePositive`\n"
"is of type `Vect (3 + n) String`, its result will be of\n"
"type `Maybe (Vect (3 + n) Nat)`. It is therefore\n"
"safe to use this in a call to `drop 3`. Note, how all of this\n"
"is known at compile time: We encoded the prerequisite\n"
"that the first argument is a vector of at least three elements\n"
"in the length index and could derive the length\n"
"of the result from this.\n"
msgstr "由于 `traverse parsePositive` 的参数是 `Vect (3 + n) String` 类型，其结果将是 `Maybe (Vect (3 + n) Nat)` 类型]。因此在调用 `drop 3` 时使用它是安全的。请注意，所有这些在编译时是如何知道的：我们编码的先决条件是第一个参数是长度索引中至少三个元素的向量，并且可以从中得出结果的长度。\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:61
#, no-wrap
msgid "Vectors of Unknown Length"
msgstr "未知长度的向量"

#. type: Plain text
#: ../src/Tutorial/DPair.md:65
#, no-wrap
msgid ""
"However, this is not always possible. Consider the following function,\n"
"defined on `List` and exported by `Data.List`:\n"
msgstr "然而，这并不总是可能的。考虑以下函数，在 `List` 上定义并由 `Data.List` 导出：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DPair.md:66
#, no-wrap
msgid ""
"Tutorial.Relations> :t takeWhile\n"
"Data.List.takeWhile : (a -> Bool) -> List a -> List a\n"
msgstr ""
"Tutorial.Relations> :t takeWhile\n"
"Data.List.takeWhile : (a -> Bool) -> List a -> List a\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:75
#, no-wrap
msgid ""
"This will take the longest prefix of the list argument, for which\n"
"the given predicate returns `True`. In this case, it depends on\n"
"the list elements and the predicate, how long this prefix will be.\n"
"Can we write such a function for vectors? Let's give it a try:\n"
msgstr "这将采用列表参数的最长前缀，给定谓词为此返回 `True`。在这种情况下，它取决于列表元素和谓词，这个前缀有多长。我们可以为向量编写这样的函数吗？试一试吧：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:76
#, no-wrap
msgid "takeWhile' : (a -> Bool) -> Vect n a -> Vect m a\n"
msgstr "takeWhile' : (a -> Bool) -> Vect n a -> Vect m a\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:92
#, no-wrap
msgid ""
"Go ahead, and try to implement this. Don't try too long, as you will not\n"
"be able to do so in a provably total way. The question is: What is the\n"
"problem here?\n"
"In order to understand this, we have to realize what the type of `takeWhile'`\n"
"promises: \"For all predicates operating on values on type `a`, and for\n"
"all vectors holding values of this type, and for all lengths `m`, I\n"
"give you a vector of length `m` holding values of type `a`\".\n"
"All three arguments are said to be\n"
"[*universally quantified*](https://en.wikipedia.org/wiki/Universal_quantification):\n"
"The caller of our function is free to choose the predicate,\n"
"the input vector, the type of values the vector holds,\n"
"and *the length of the output vector*. Don't believe me? See here:\n"
msgstr "继续，并尝试实现这一点。不要尝试太久，因为您将无法以可证明的整体方式这样做。问题是：这里有什么问题？为了理解这一点，我们必须了解 `takeWhile'` 的类型所承诺的内容：“对于所有对 `a` 类型的值进行操作的谓词，以及所有包含此类型值的向量，对于所有长度 `m`，我给你一个长度为 `m` 的向量，其中包含 `a`\" 类型的值。所有三个参数都被称为 [*universally quantified*](https://en.wikipedia.org/wiki/Universal_quantification)：我们函数的调用者可以自由选择谓词、输入向量、向量持有的值的类型，以及 *输出向量的长度*。不相信我？看这里：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:93
#, no-wrap
msgid ""
"-- This looks like trouble: We got a non-empty vector of `Void`...\n"
"voids : Vect 7 Void\n"
"voids = takeWhile' (const True) []\n"
"\n"
"-- ...from which immediately follows a proof of `Void`\n"
"proofOfVoid : Void\n"
"proofOfVoid = head voids\n"
msgstr ""
"-- This looks like trouble: We got a non-empty vector of `Void`...\n"
"voids : Vect 7 Void\n"
"voids = takeWhile' (const True) []\n"
"\n"
"-- ...from which immediately follows a proof of `Void`\n"
"proofOfVoid : Void\n"
"proofOfVoid = head voids\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:108
#, no-wrap
msgid ""
"See how I could freely decide on the value of `m` when invoking `takeWhile'`?\n"
"Although I passed `takeWhile'` an empty vector (the only existing vector\n"
"holding values of type `Void`), the function's type promises me\n"
"to return a possibly non-empty vector holding values of the same\n"
"type, from which I freely extracted the first one.\n"
msgstr "看看我在调用 `takeWhile'` 时如何自由决定 `m` 的值？尽管我将 `takeWhile'` 传递给了一个空向量（唯一的现有向量包含 `Void` 类型的值），但该函数的类型保证我返回一个可能非空的向量，该向量包含相同类型的值，我从中自由地提取了第一个。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:115
#, no-wrap
msgid ""
"Luckily, Idris doesn't allow this: We won't be able to\n"
"implement `takeWhile'` without cheating (for instance, by\n"
"turning totality checking off and looping forever).\n"
"So, the question remains, how to express the result of `takeWhile'`\n"
"in a type. The answer to this is: \"Use a *dependent pair*\", a vector\n"
"paired with a value corresponding to its length.\n"
msgstr "幸运的是，Idris 不允许这样做：我们将无法在不作弊的情况下实现 `takeWhile'`（例如，通过关闭完全性检查并永远循环）。所以，问题仍然存在，如何在一个类型中表达 `takeWhile'` 的结果。对此的答案是：“使用 *依赖对*”，一个向量与与其长度对应的值配对。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:116
#, no-wrap
msgid ""
"record AnyVect a where\n"
"  constructor MkAnyVect\n"
"  length : Nat\n"
"  vect   : Vect length a\n"
msgstr ""
"record AnyVect a where\n"
"  constructor MkAnyVect\n"
"  length : Nat\n"
"  vect   : Vect length a\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:131
#, no-wrap
msgid ""
"This corresponds to [*existential quantification*](https://en.wikipedia.org/wiki/Existential_quantification)\n"
"in predicate logic: There is a natural number, which corresponds to\n"
"the length of the vector I have here. Note, how from the outside\n"
"of `AnyVect a`, the length of the wrapped vector is no longer\n"
"visible at the type level but we can still inspect it and learn\n"
"something about it at runtime, since it is wrapped up together\n"
"with the actual vector. We can implement `takeWhile` in such\n"
"a way that it returns a value of type `AnyVect a`:\n"
msgstr "这对应于谓词逻辑中的[*存在量化*](https://en.wikipedia.org/wiki/Existential_quantification)：有一个自然数，对应于我这里的向量的长度。请注意，从 `AnyVect a` 的外部，包装矢量的长度在类型级别不再可见，但我们仍然可以检查它并在运行时了解它，因为它被包装在一起与实际向量。我们可以实现 `takeWhile`，使其返回 `AnyVect a` 类型的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:132
#, no-wrap
msgid ""
"takeWhile : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile f []        = MkAnyVect 0 []\n"
"takeWhile f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect n ys = takeWhile f xs in MkAnyVect (S n) (x :: ys)\n"
msgstr ""
"takeWhile : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile f []        = MkAnyVect 0 []\n"
"takeWhile f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect n ys = takeWhile f xs in MkAnyVect (S n) (x :: ys)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:147
#, no-wrap
msgid ""
"This works in a provably total way, because callers of this function\n"
"can no longer choose the length of the resulting vector themselves. Our\n"
"function, `takeWhile`, decides on this length and returns it together\n"
"with the vector, and the type checker verifies that we\n"
"make no mistakes when pairing the two values. In fact,\n"
"the length can be inferred automatically by Idris, so we can replace\n"
"it with underscores, if we so desire:\n"
msgstr "这可以证明是完全可行的，因为这个函数的调用者不能再自己选择结果向量的长度。我们的函数 `takeWhile` 决定这个长度并将它与向量一起返回，类型检查器验证我们在配对两个值时没有错误。事实上，长度可以由 Idris 自动推断，所以如果我们愿意，我们可以用下划线替换它：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:148
#, no-wrap
msgid ""
"takeWhile2 : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile2 f []        = MkAnyVect _ []\n"
"takeWhile2 f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect _ ys = takeWhile2 f xs in MkAnyVect _ (x :: ys)\n"
msgstr ""
"takeWhile2 : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile2 f []        = MkAnyVect _ []\n"
"takeWhile2 f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect _ ys = takeWhile2 f xs in MkAnyVect _ (x :: ys)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:161
#, no-wrap
msgid ""
"To summarize: Parameters in generic function types are\n"
"universally quantified, and their values can be decided on at the\n"
"call site of such functions. Dependent record types allow us\n"
"to describe existentially quantified values. Callers cannot choose\n"
"such values freely: They are returned as part of a function's result.\n"
msgstr "总结：泛型函数类型中的参数是通用量化的，它们的值可以在此类函数的调用处确定。依赖记录类型允许我们描述存在量化的值。调用者不能自由选择这些值：它们作为函数结果的一部分返回。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:164
#, no-wrap
msgid ""
"Note, that Idris allows us to be explicit about universal quantification.\n"
"The type of `takeWhile'` can also be written like so:\n"
msgstr "请注意，Idris 允许我们明确地进行全称量化。 `takeWhile'` 的类型也可以这样写：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:165
#, no-wrap
msgid "takeWhile'' : forall a, n, m . (a -> Bool) -> Vect n a -> Vect m a\n"
msgstr "takeWhile'' : forall a, n, m . (a -> Bool) -> Vect n a -> Vect m a\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:173
#, no-wrap
msgid ""
"Universally quantified arguments are desugared to implicit\n"
"erased arguments by Idris. The above is a less verbose version\n"
"of the following function type, the likes of which we have seen\n"
"before:\n"
msgstr "普遍量化的参数被 Idris 脱糖为隐式的已擦除参数。上面是以下函数类型的一个不那么冗长的版本，我们之前已经看到过类似的函数类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:174
#, no-wrap
msgid ""
"takeWhile''' :  {0 a : _}\n"
"             -> {0 n : _}\n"
"             -> {0 m : _}\n"
"             -> (a -> Bool)\n"
"             -> Vect n a\n"
"             -> Vect m a\n"
msgstr ""
"takeWhile''' :  {0 a : _}\n"
"             -> {0 n : _}\n"
"             -> {0 m : _}\n"
"             -> (a -> Bool)\n"
"             -> Vect n a\n"
"             -> Vect m a\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:189
#, no-wrap
msgid ""
"In Idris, we are free to choose whether we want to be explicit\n"
"about universal quantification. Sometimes it can help understanding\n"
"what's going on at the type level. Other languages - for instance\n"
"[PureScript](https://www.purescript.org/) - are more strict about\n"
"this: There, explicit annotations on universally quantified parameters\n"
"are [mandatory](https://github.com/purescript/documentation/blob/master/language/Differences-from-Haskell.md#explicit-forall).\n"
msgstr "在 Idris 中，我们可以自由选择是否要明确全称量化。有时它可以帮助理解在类型级别上发生了什么。其他语言 - 例如 [PureScript](https://www.purescript.org/) - 对此更为严格：在那里，对普遍量化参数的显式注释是 [强制性](https://github.com/purescript/documentation/blob/master/language/Differences-from-Haskell.md#explicit-forall)的。\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:190
#, no-wrap
msgid "The Essence of Dependent Pairs"
msgstr "依赖对的本质"

#. type: Plain text
#: ../src/Tutorial/DPair.md:202
#, no-wrap
msgid ""
"It can take some time and experience to understand what's going on here. At\n"
"least in my case, it took many sessions programming in Idris, before I figured\n"
"out what dependent pairs are about: They pair a *value* of some type with\n"
"a second value of a type calculated from the first value.\n"
"For instance, a natural number `n` (the value)\n"
"paired with a vector of length `n` (the second value, the type\n"
"of which *depends* on the first value).\n"
"This is such a fundamental concept of programming with dependent types, that\n"
"a general dependent pair type is provided by the *Prelude*. Here is its\n"
"implementation (primed for disambiguation):\n"
msgstr "了解这里发生的事情可能需要一些时间和经验。至少在我的情况下，在 Idris 中进行了许多会话编程，然后我才弄清楚依赖对的含义：它们将某种类型的 *value* 与从第一个值计算的类型的第二个值配对。例如，自然数 `n`（值）与长度为 `n` 的向量对（第二个值，其类型 *取决于* 第一个值）。这是使用依赖类型进行编程的基本概念，*Prelude* 提供了一个通用的依赖对类型。这是它的实现（准备消除歧义）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:203
#, no-wrap
msgid ""
"record DPair' (a : Type) (p : a -> Type) where\n"
"  constructor MkDPair'\n"
"  fst : a\n"
"  snd : p fst\n"
msgstr ""
"record DPair' (a : Type) (p : a -> Type) where\n"
"  constructor MkDPair'\n"
"  fst : a\n"
"  snd : p fst\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:215
#, no-wrap
msgid ""
"It is essential to understand what's going on here. There are two\n"
"parameters: A type `a`, and a function `p`, calculating a *type*\n"
"from a *value* of type `a`. Such a value (`fst`) is then used\n"
"to calculate the *type* of the second value (`snd`).\n"
"For instance, here is `AnyVect a` represented as a `DPair`:\n"
msgstr "必须了解这里发生了什么。有两个参数：类型 `a` 和函数 `p`，从类型 `a` 的 *值* 计算出一个 *类型* 。这个值 (`fst`) 被用来计算第二个值 (`snd`) 的 *类型*。例如，这里是 `AnyVect a` 使用 `DPair` 的表示：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:216
#, no-wrap
msgid ""
"AnyVect' : (a : Type) -> Type\n"
"AnyVect' a = DPair Nat (\\n => Vect n a)\n"
msgstr ""
"AnyVect' : (a : Type) -> Type\n"
"AnyVect' a = DPair Nat (\\n => Vect n a)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:225
#, no-wrap
msgid ""
"Note, how `\\n => Vect n a` is a function from `Nat` to `Type`.\n"
"Idris provides special syntax for describing dependent pairs, as\n"
"they are important building blocks for programming in languages\n"
"with first class types:\n"
msgstr "请注意，`\\n => Vect n a` 如何是从 `Nat` 到 `Type` 的函数。 Idris 提供了用于描述依赖对的特殊语法，因为它们是使用一流类型的语言进行编程的重要构建块：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:226
#, no-wrap
msgid ""
"AnyVect'' : (a : Type) -> Type\n"
"AnyVect'' a = (n : Nat ** Vect n a)\n"
msgstr ""
"AnyVect'' : (a : Type) -> Type\n"
"AnyVect'' a = (n : Nat ** Vect n a)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:233
#, no-wrap
msgid ""
"We can inspect at the REPL, that the right hand side of `AnyVect''`\n"
"get's desugared to the right hand side of `AnyVect'`:\n"
msgstr "我们可以在 REPL 中检查，`AnyVect''` 的右侧被脱糖到 `AnyVect'` 的右侧：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DPair.md:234
#, no-wrap
msgid ""
"Tutorial.Relations> (n : Nat ** Vect n Int)\n"
"DPair Nat (\\n => Vect n Int)\n"
msgstr ""
"Tutorial.Relations> (n : Nat ** Vect n Int)\n"
"DPair Nat (\\n => Vect n Int)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:242
#, no-wrap
msgid ""
"Idris can infer, that `n` must be of type `Nat`, so we can drop\n"
"this information. (We still need to put the whole expression in\n"
"parentheses.)\n"
msgstr "Idris 可以推断，`n` 必须是 `Nat` 类型，因此我们可以删除此信息。 （我们仍然需要将整个表达式放在括号中。）\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:243
#, no-wrap
msgid ""
"AnyVect3 : (a : Type) -> Type\n"
"AnyVect3 a = (n ** Vect n a)\n"
msgstr ""
"AnyVect3 : (a : Type) -> Type\n"
"AnyVect3 a = (n ** Vect n a)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:254
#, no-wrap
msgid ""
"This allows us to pair a natural number `n` with a vector of\n"
"length `n`, which is exactly what we did with `AnyVect`. We can\n"
"therefore rewrite `takeWhile` to return a `DPair` instead of\n"
"our custom type `AnyVect`. Note, that like with regular pairs,\n"
"we can use the same syntax `(x ** y)` for creating and\n"
"pattern matching on dependent pairs:\n"
msgstr "这允许我们将自然数 `n` 与长度为 `n` 的向量配对，这正是我们对 `AnyVect` 所做的。因此，我们可以重写 `takeWhile` 以返回 `DPair` 而不是我们的自定义类型 `AnyVect`。请注意，与常规对一样，我们可以使用相同的语法 `(x ** y)` 在依赖对上创建和模式匹配：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:255
#, no-wrap
msgid ""
"takeWhile3 : (a -> Bool) -> Vect m a -> (n ** Vect n a)\n"
"takeWhile3 f []        = (_ ** [])\n"
"takeWhile3 f (x :: xs) = case f x of\n"
"  False => (_ ** [])\n"
"  True  => let (_  ** ys) = takeWhile3 f xs in (_ ** x :: ys)\n"
msgstr ""
"takeWhile3 : (a -> Bool) -> Vect m a -> (n ** Vect n a)\n"
"takeWhile3 f []        = (_ ** [])\n"
"takeWhile3 f (x :: xs) = case f x of\n"
"  False => (_ ** [])\n"
"  True  => let (_  ** ys) = takeWhile3 f xs in (_ ** x :: ys)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:265
#, no-wrap
msgid ""
"Just like with regular pairs, we can use the dependent pair\n"
"syntax to define dependent triples and larger tuples:\n"
msgstr "就像常规对一样，我们可以使用依赖对语法来定义依赖三元组和更大的元组：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:266
#, no-wrap
msgid ""
"AnyMatrix : (a : Type) -> Type\n"
"AnyMatrix a = (m ** n ** Vect m (Vect n a))\n"
msgstr ""
"AnyMatrix : (a : Type) -> Type\n"
"AnyMatrix a = (m ** n ** Vect m (Vect n a))\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:271
#, no-wrap
msgid "Erased Existentials"
msgstr "已删除的存在"

#. type: Plain text
#: ../src/Tutorial/DPair.md:281
#, no-wrap
msgid ""
"Sometimes, it is possible to determine the value of an\n"
"index by pattern matching on a value of the indexed type.\n"
"For instance, by pattern matching on a vector, we can learn\n"
"about its length index. In these cases, it is not strictly\n"
"necessary to carry around the index at runtime,\n"
"and we can write a special version of a dependent pair\n"
"where the first argument has quantity zero. Module `Data.DPair`\n"
"from *base* exports data type `Exists` for this use case.\n"
msgstr "有时，可以通过对索引类型的值进行模式匹配来确定索引的值。例如，通过对向量进行模式匹配，我们可以了解它的长度索引。在这些情况下，不一定要在运行时携带索引，我们可以编写一个特殊版本的依赖对，其中第一个参数的数量为零。 *base* 中的模块 `Data.DPair` 为此用例导出数据类型 `Exists`。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:284
#, no-wrap
msgid ""
"As an example, here is a version of `takeWhile` returning\n"
"a value of type `Exists`:\n"
msgstr "例如，下面是 `takeWhile` 的一个版本，返回一个 `Exists` 类型的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:285
#, no-wrap
msgid ""
"takeWhileExists : (a -> Bool) -> Vect m a -> Exists (\\n => Vect n a)\n"
"takeWhileExists f []        = Evidence _ []\n"
"takeWhileExists f (x :: xs) = case f x of\n"
"  True  => let Evidence _ ys = takeWhileExists f xs\n"
"            in Evidence _ (x :: ys)\n"
"  False => takeWhileExists f xs\n"
msgstr ""
"takeWhileExists : (a -> Bool) -> Vect m a -> Exists (\\n => Vect n a)\n"
"takeWhileExists f []        = Evidence _ []\n"
"takeWhileExists f (x :: xs) = case f x of\n"
"  True  => let Evidence _ ys = takeWhileExists f xs\n"
"            in Evidence _ (x :: ys)\n"
"  False => takeWhileExists f xs\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:297
#, no-wrap
msgid ""
"In order to restore an erased value, data type `Singleton`\n"
"from *base* module `Data.Singleton` can be useful: It is\n"
"parameterized by the *value* it stores:\n"
msgstr "为了恢复已擦除的值，来自 *base* 模块 `Data.Singleton` 的数据类型 `Singleton` 可能很有用：它由参数化 *值* 来存储：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:298
#, no-wrap
msgid ""
"true : Singleton True\n"
"true = Val True\n"
msgstr ""
"true : Singleton True\n"
"true = Val True\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:306
#, no-wrap
msgid ""
"This is called a *singleton* type: A type corresponding to\n"
"exactly one value. It is a type error to return any other\n"
"value for constant `true`, and Idris knows this:\n"
msgstr "这称为 *singleton* 类型：与一个值对应的类型。返回常量 `true` 的任何其他值都是类型错误，Idris 知道这一点：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:307
#, no-wrap
msgid ""
"true' : Singleton True\n"
"true' = Val _\n"
msgstr ""
"true' : Singleton True\n"
"true' = Val _\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:314
#, no-wrap
msgid ""
"We can use this to conjure the (erased!) length of a vector\n"
"out of thin air:\n"
msgstr "我们可以使用它凭空变出一个向量的（擦除的！）长度：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:315
#, no-wrap
msgid ""
"vectLength : Vect n a -> Singleton n\n"
"vectLength []        = Val 0\n"
"vectLength (x :: xs) = let Val k = vectLength xs in Val (S k)\n"
msgstr ""
"vectLength : Vect n a -> Singleton n\n"
"vectLength []        = Val 0\n"
"vectLength (x :: xs) = let Val k = vectLength xs in Val (S k)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:326
#, no-wrap
msgid ""
"This function comes with much stronger guarantees\n"
"than `Data.Vect.length`: The latter claims to just return\n"
"*any* natural number, while `vectLength` *must* return\n"
"exactly `n` in order to type check. As a demonstration,\n"
"here is a well-typed bogus implementation of `length`:\n"
msgstr "此函数提供比 `Data.Vect.length` 更强的保证：后者声称只返回 *任意* 自然数，而 `vectLength` *必须*准确返回 `n` 以便进行类型检查。作为演示，这里是 `length` 的良类型的虚假实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:327
#, no-wrap
msgid ""
"bogusLength : Vect n a -> Nat\n"
"bogusLength = const 0\n"
msgstr ""
"bogusLength : Vect n a -> Nat\n"
"bogusLength = const 0\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:334
#, no-wrap
msgid ""
"This would not be accepted as a valid implementation of\n"
"`vectLength`, as you may quickly verify yourself.\n"
msgstr "这不会被接受为 `vectLength` 的有效实现，因为您可以快速验证自己。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:338
#, no-wrap
msgid ""
"With the help of `vectLength` (but not with `Data.Vect.length`)\n"
"we can convert an erased existential to a proper dependent\n"
"pair:\n"
msgstr "在 `vectLength` 的帮助下（但不是 `Data.Vect.length`），我们可以将已擦除的存在转换为正确的依赖对：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:339
#, no-wrap
msgid ""
"toDPair : Exists (\\n => Vect n a) -> (m ** Vect m a)\n"
"toDPair (Evidence _ as) = let Val m = vectLength as in (m ** as)\n"
msgstr ""
"toDPair : Exists (\\n => Vect n a) -> (m ** Vect m a)\n"
"toDPair (Evidence _ as) = let Val m = vectLength as in (m ** as)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:347
#, no-wrap
msgid ""
"Again, as a quick exercise, try implementing `toDPair` in terms\n"
"of `length`, and note how Idris will fail to unify the\n"
"result of `length` with the actual length of the vector.\n"
msgstr "同样，作为一个快速练习，尝试根据 `length` 实现 `toDPair`，并注意 Idris 无法将 `length` 的结果与实际长度向量统一。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:352
#, no-wrap
msgid ""
"Declare and implement a function for filtering a\n"
"vector similar to `Data.List.filter`.\n"
msgstr "声明并实现一个过滤向量的函数，类似于 `Data.List.filter`。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:356
#, no-wrap
msgid ""
"Declare and implement a function for mapping a partial\n"
"function over the values of a vector similar\n"
"to `Data.List.mapMaybe`.\n"
msgstr "声明并实现一个函数，用于将偏应用函数映射到类似于 `Data.List.mapMaybe` "
"的向量的值上。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:360
#, no-wrap
msgid ""
"Declare and implement a function similar to\n"
"`Data.List.dropWhile` for vectors. Use `Data.DPair.Exists`\n"
"as your return type.\n"
msgstr ""
"为向量声明并实现类似于 `Data.List.dropWhile` 的函数。使用 `Data.DPair.Exists`"
" 作为您的返回类型。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:363
#, no-wrap
msgid ""
"Repeat exercise 3 but return a proper dependent pair. Use\n"
"the function from exercise 3 in your implementation.\n"
msgstr "重复练习 3，但返回正确的依赖对。在您的实现中使用练习 3 中的函数。\n"

#. type: Title ##
#: ../src/Tutorial/DPair.md:364
#, no-wrap
msgid "Use Case: Nucleic Acids"
msgstr "用例：核酸"

#. type: Plain text
#: ../src/Tutorial/DPair.md:372
#, no-wrap
msgid ""
"We'd like to come up with a small, simplified library for running computations\n"
"on nucleic acids: RNA and DNA. These are built from five types of\n"
"nucleobases, three of which are used in both types of nucleic\n"
"acids and two bases specific for each type of acid. We'd like\n"
"to make sure that only valid bases are in strands of nucleic acids.\n"
"Here's a possible encoding:\n"
msgstr "我们想提出一个小型、简化的库，用于运行核酸计算：RNA 和 DNA。它们由五种类型的核碱基构成，其中三种用于两种类型的核酸中，两种碱基对每种类型的酸具有特异性。我们想确保只有有效的碱基存在于核酸链中。这是一种可能的编码：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:373
#, no-wrap
msgid ""
"data BaseType = DNABase | RNABase\n"
"\n"
"data Nucleobase : BaseType -> Type where\n"
"  Adenine  : Nucleobase b\n"
"  Cytosine : Nucleobase b\n"
"  Guanine  : Nucleobase b\n"
"  Thymine  : Nucleobase DNABase\n"
"  Uracile  : Nucleobase RNABase\n"
"\n"
"NucleicAcid : BaseType -> Type\n"
"NucleicAcid = List . Nucleobase\n"
"\n"
"RNA : Type\n"
"RNA = NucleicAcid RNABase\n"
"\n"
"DNA : Type\n"
"DNA = NucleicAcid DNABase\n"
"\n"
"encodeBase : Nucleobase b -> Char\n"
"encodeBase Adenine  = 'A'\n"
"encodeBase Cytosine = 'C'\n"
"encodeBase Guanine  = 'G'\n"
"encodeBase Thymine  = 'T'\n"
"encodeBase Uracile  = 'U'\n"
"\n"
"encode : NucleicAcid b -> String\n"
"encode = pack . map encodeBase\n"
msgstr ""
"data BaseType = DNABase | RNABase\n"
"\n"
"data Nucleobase : BaseType -> Type where\n"
"  Adenine  : Nucleobase b\n"
"  Cytosine : Nucleobase b\n"
"  Guanine  : Nucleobase b\n"
"  Thymine  : Nucleobase DNABase\n"
"  Uracile  : Nucleobase RNABase\n"
"\n"
"NucleicAcid : BaseType -> Type\n"
"NucleicAcid = List . Nucleobase\n"
"\n"
"RNA : Type\n"
"RNA = NucleicAcid RNABase\n"
"\n"
"DNA : Type\n"
"DNA = NucleicAcid DNABase\n"
"\n"
"encodeBase : Nucleobase b -> Char\n"
"encodeBase Adenine  = 'A'\n"
"encodeBase Cytosine = 'C'\n"
"encodeBase Guanine  = 'G'\n"
"encodeBase Thymine  = 'T'\n"
"encodeBase Uracile  = 'U'\n"
"\n"
"encode : NucleicAcid b -> String\n"
"encode = pack . map encodeBase\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:404
#, no-wrap
msgid "It is a type error to use `Uracile` in a strand of DNA:\n"
msgstr "在 DNA 链中使用 `Uracile` 是一个类型错误：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:405
#, no-wrap
msgid ""
"failing \"Mismatch between: RNABase and DNABase.\"\n"
"  errDNA : DNA\n"
"  errDNA = [Uracile, Adenine]\n"
msgstr ""
"failing \"Mismatch between: RNABase and DNABase.\"\n"
"  errDNA : DNA\n"
"  errDNA = [Uracile, Adenine]\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:415
#, no-wrap
msgid ""
"Note, how we used a variable for nucleobases `Adenine`, `Cytosine`, and\n"
"`Guanine`: These are again universally quantified,\n"
"and client code is free to choose a value here. This allows us\n"
"to use these bases in strands of DNA *and* RNA:\n"
msgstr "请注意，我们如何为核碱基 `Adenine`、`Cytosine` 和 `Guanine` 使用变量：这些又是普遍量化的，客户代码可以在这里自由选择一个值.这使我们能够在 DNA *和* RNA 链中使用这些碱基：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:416
#, no-wrap
msgid ""
"dna1 : DNA\n"
"dna1 = [Adenine, Cytosine, Guanine]\n"
"\n"
"rna1 : RNA\n"
"rna1 = [Adenine, Cytosine, Guanine]\n"
msgstr ""
"dna1 : DNA\n"
"dna1 = [Adenine, Cytosine, Guanine]\n"
"\n"
"rna1 : RNA\n"
"rna1 = [Adenine, Cytosine, Guanine]\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:427
#, no-wrap
msgid ""
"With `Thymine` and `Uracile`, we are more restrictive: `Thymine` is only\n"
"allowed in DNA, while `Uracile` is restricted to be used in RNA strands.\n"
"Let's write parsers for strands of DNA and RNA:\n"
msgstr "对于 `Thymine` 和 `Uracile`，我们的限制性更强：`Thymine` 仅允许用于 DNA，而 `Uracile` 仅限用于 RNA。让我们为 DNA 和 RNA 链编写解析器：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:428
#, no-wrap
msgid ""
"readAnyBase : Char -> Maybe (Nucleobase b)\n"
"readAnyBase 'A' = Just Adenine\n"
"readAnyBase 'C' = Just Cytosine\n"
"readAnyBase 'G' = Just Guanine\n"
"readAnyBase _   = Nothing\n"
"\n"
"readRNABase : Char -> Maybe (Nucleobase RNABase)\n"
"readRNABase 'U' = Just Uracile\n"
"readRNABase c   = readAnyBase c\n"
"\n"
"readDNABase : Char -> Maybe (Nucleobase DNABase)\n"
"readDNABase 'T' = Just Thymine\n"
"readDNABase c   = readAnyBase c\n"
"\n"
"readRNA : String -> Maybe RNA\n"
"readRNA = traverse readRNABase . unpack\n"
"\n"
"readDNA : String -> Maybe DNA\n"
"readDNA = traverse readDNABase . unpack\n"
msgstr ""
"readAnyBase : Char -> Maybe (Nucleobase b)\n"
"readAnyBase 'A' = Just Adenine\n"
"readAnyBase 'C' = Just Cytosine\n"
"readAnyBase 'G' = Just Guanine\n"
"readAnyBase _   = Nothing\n"
"\n"
"readRNABase : Char -> Maybe (Nucleobase RNABase)\n"
"readRNABase 'U' = Just Uracile\n"
"readRNABase c   = readAnyBase c\n"
"\n"
"readDNABase : Char -> Maybe (Nucleobase DNABase)\n"
"readDNABase 'T' = Just Thymine\n"
"readDNABase c   = readAnyBase c\n"
"\n"
"readRNA : String -> Maybe RNA\n"
"readRNA = traverse readRNABase . unpack\n"
"\n"
"readDNA : String -> Maybe DNA\n"
"readDNA = traverse readDNABase . unpack\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:454
#, no-wrap
msgid ""
"Again, in case of the bases appearing in both kinds of strands,\n"
"users of the universally quantified `readAnyBase`\n"
"are free to choose what base type they want, but they will\n"
"never get a `Thymine` or `Uracile` value.\n"
msgstr "同样，如果碱基出现在两种链中，通用量化的 `readAnyBase` 的用户可以自由选择他们想要的碱基类型，但他们永远不会得到 `Thymine` 或`Uracile`值。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:458
#, no-wrap
msgid ""
"We can now implement some simple calculations on sequences of\n"
"nucleobases. For instance, we can come up with the complementary\n"
"strand:\n"
msgstr "我们现在可以对核碱基序列进行一些简单的计算。例如，我们可以提出互补链：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:459
#, no-wrap
msgid ""
"complementRNA' : RNA -> RNA\n"
"complementRNA' = map calc\n"
"  where calc : Nucleobase RNABase -> Nucleobase RNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Uracile\n"
"        calc Uracile  = Adenine\n"
"\n"
"complementDNA' : DNA -> DNA\n"
"complementDNA' = map calc\n"
"  where calc : Nucleobase DNABase -> Nucleobase DNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Thymine\n"
"        calc Thymine  = Adenine\n"
msgstr ""
"complementRNA' : RNA -> RNA\n"
"complementRNA' = map calc\n"
"  where calc : Nucleobase RNABase -> Nucleobase RNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Uracile\n"
"        calc Uracile  = Adenine\n"
"\n"
"complementDNA' : DNA -> DNA\n"
"complementDNA' = map calc\n"
"  where calc : Nucleobase DNABase -> Nucleobase DNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Thymine\n"
"        calc Thymine  = Adenine\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:480
#, no-wrap
msgid ""
"Ugh, code repetition! Not too bad here, but imagine there were\n"
"dozens of bases with only few specialized ones. Surely, we can\n"
"do better? Unfortunately, the following won't work:\n"
msgstr "呃，代码重复！这里还不错，但想象一下有几十个基础的，只有几个特殊的。那么，我们可以做得更好吗？不幸的是，以下方法不起作用：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:481
#, no-wrap
msgid ""
"complementBase' : Nucleobase b -> Nucleobase b\n"
"complementBase' Adenine  = ?what_now\n"
"complementBase' Cytosine = Guanine\n"
"complementBase' Guanine  = Cytosine\n"
"complementBase' Thymine  = Adenine\n"
"complementBase' Uracile  = Adenine\n"
msgstr ""
"complementBase' : Nucleobase b -> Nucleobase b\n"
"complementBase' Adenine  = ?what_now\n"
"complementBase' Cytosine = Guanine\n"
"complementBase' Guanine  = Cytosine\n"
"complementBase' Thymine  = Adenine\n"
"complementBase' Uracile  = Adenine\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:497
#, no-wrap
msgid ""
"All goes well with the exception of the `Adenine` case. Remember:\n"
"Parameter `b` is universally quantified, and the *callers* of\n"
"our function can decide what `b` is supposed to\n"
"be. We therefore can't just return `Thymine`: Idris will respond\n"
"with a type error since callers might want a `Nucleobase RNABase` instead.\n"
"One way to go about this is to take an additional unerased argument\n"
"(explicit or implicit) representing the base type:\n"
msgstr "除了 `Adenine` 情况外，一切都很顺利。请记住：参数 `b` 是通用量化的，我们函数的 *callers* 可以决定 `b` 应该是什么。因此，我们不能只返回 `Thymine`：Idris 将响应类型错误，因为调用者可能需要 `Nucleobase RNABase` 代替。解决此问题的一种方法是采用表示基本类型的附加未擦除参数（显式或隐式）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:498
#, no-wrap
msgid ""
"complementBase : (b : BaseType) -> Nucleobase b -> Nucleobase b\n"
"complementBase DNABase Adenine  = Thymine\n"
"complementBase RNABase Adenine  = Uracile\n"
"complementBase _       Cytosine = Guanine\n"
"complementBase _       Guanine  = Cytosine\n"
"complementBase _       Thymine  = Adenine\n"
"complementBase _       Uracile  = Adenine\n"
msgstr ""
"complementBase : (b : BaseType) -> Nucleobase b -> Nucleobase b\n"
"complementBase DNABase Adenine  = Thymine\n"
"complementBase RNABase Adenine  = Uracile\n"
"complementBase _       Cytosine = Guanine\n"
"complementBase _       Guanine  = Cytosine\n"
"complementBase _       Thymine  = Adenine\n"
"complementBase _       Uracile  = Adenine\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:512
#, no-wrap
msgid ""
"This is again an example of a dependent *function* type (also called a\n"
"[*pi type*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A0_type)):\n"
"The input and output types both *depend* on the *value* of the first argument.\n"
"We can now use this to calculate the complement of any nucleic acid:\n"
msgstr "这又是一个依赖 *函数* 类型（也称为 [*pi 类型*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A0_type)）的示例 : 输入和输出类型都 *取决于* 第一个参数的 *值*。我们现在可以使用它来计算任何核酸的互补链：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:513
#, no-wrap
msgid ""
"complement : (b : BaseType) -> NucleicAcid b -> NucleicAcid b\n"
"complement b = map (complementBase b)\n"
msgstr ""
"complement : (b : BaseType) -> NucleicAcid b -> NucleicAcid b\n"
"complement b = map (complementBase b)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:528
#, no-wrap
msgid ""
"Now, here is an interesting use case: We'd like to read a sequence\n"
"of nucleobases from user input, accepting two strings: The first\n"
"telling us, whether the user plans to enter a DNA or RNA sequence,\n"
"the second being the sequence itself. What should be the type of\n"
"such a function? Well, we're describing computations with side effects,\n"
"so something involving `IO` seems about right. User input almost\n"
"always needs to be validated or translated, so something might go wrong\n"
"and we need an error type for this case. Finally, our users can\n"
"decide whether they want to enter a strand of RNA or DNA, so this\n"
"distinction should be encoded as well.\n"
msgstr "现在，这是一个有趣的用例：我们想从用户输入中读取一个核碱基序列，接受两个字符串：第一个告诉我们，用户打算输入 DNA 还是 RNA 序列，第二个是序列本身.这种函数的类型应该是什么？好吧，我们正在描述具有副作用的计算，因此涉及 `IO` 的东西似乎是正确的。用户输入几乎总是需要验证或翻译，因此可能会出现问题，我们需要针对这种情况的错误类型。最后，我们的用户可以决定是否要输入一条 RNA 或 DNA，因此也应该对这种区别进行编码。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:531
#, no-wrap
msgid ""
"Of course, it is always possible to write a custom sum type for\n"
"such a use case:\n"
msgstr "当然，总是可以为这样的用例编写自定义和类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:532
#, no-wrap
msgid ""
"data Result : Type where\n"
"  UnknownBaseType : String -> Result\n"
"  InvalidSequence : String -> Result\n"
"  GotDNA          : DNA -> Result\n"
"  GotRNA          : RNA -> Result\n"
msgstr ""
"data Result : Type where\n"
"  UnknownBaseType : String -> Result\n"
"  InvalidSequence : String -> Result\n"
"  GotDNA          : DNA -> Result\n"
"  GotRNA          : RNA -> Result\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:544
#, no-wrap
msgid ""
"This has all possible outcomes encoded in a single data type.\n"
"However, it is lacking in terms of flexibility. If we want to handle\n"
"errors early on and just extract a strand of RNA or DNA, we need\n"
"yet another data type:\n"
msgstr "这具有以单一数据类型编码的所有可能结果。但是，它缺乏灵活性。如果我们想及早处理错误并只提取一条 RNA 或 DNA，我们需要另一种数据类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:545
#, no-wrap
msgid "data RNAOrDNA = ItsRNA RNA | ItsDNA DNA\n"
msgstr "data RNAOrDNA = ItsRNA RNA | ItsDNA DNA\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:552
#, no-wrap
msgid ""
"This might be the way to go, but for results with many options, this\n"
"can get cumbersome quickly. Also: Why come up with a custom data type when\n"
"we already have the tools to deal with this at our hands?\n"
msgstr "这可能是要走的路，但对于有很多选项的结果，这很快就会变得很麻烦。另外：当我们已经拥有处理这个问题的工具时，为什么还要提出自定义数据类型？\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:554
#, no-wrap
msgid "Here is how we can encode this with a dependent pair:\n"
msgstr "以下是我们如何使用依赖对对其进行编码：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:555
#, no-wrap
msgid ""
"namespace InputError\n"
"  public export\n"
"  data InputError : Type where\n"
"    UnknownBaseType : String -> InputError\n"
"    InvalidSequence : String -> InputError\n"
"\n"
"readAcid : (b : BaseType) -> String -> Either InputError (NucleicAcid b)\n"
"readAcid b str =\n"
"  let err = InvalidSequence str\n"
"   in case b of\n"
"        DNABase => maybeToEither err $ readDNA str\n"
"        RNABase => maybeToEither err $ readRNA str\n"
"\n"
"getNucleicAcid : IO (Either InputError (b ** NucleicAcid b))\n"
"getNucleicAcid = do\n"
"  baseString <- getLine\n"
"  case baseString of\n"
"    \"DNA\" => map (MkDPair _) . readAcid DNABase <$> getLine\n"
"    \"RNA\" => map (MkDPair _) . readAcid RNABase <$> getLine\n"
"    _     => pure $ Left (UnknownBaseType baseString)\n"
msgstr ""
"namespace InputError\n"
"  public export\n"
"  data InputError : Type where\n"
"    UnknownBaseType : String -> InputError\n"
"    InvalidSequence : String -> InputError\n"
"\n"
"readAcid : (b : BaseType) -> String -> Either InputError (NucleicAcid b)\n"
"readAcid b str =\n"
"  let err = InvalidSequence str\n"
"   in case b of\n"
"        DNABase => maybeToEither err $ readDNA str\n"
"        RNABase => maybeToEither err $ readRNA str\n"
"\n"
"getNucleicAcid : IO (Either InputError (b ** NucleicAcid b))\n"
"getNucleicAcid = do\n"
"  baseString <- getLine\n"
"  case baseString of\n"
"    \"DNA\" => map (MkDPair _) . readAcid DNABase <$> getLine\n"
"    \"RNA\" => map (MkDPair _) . readAcid RNABase <$> getLine\n"
"    _     => pure $ Left (UnknownBaseType baseString)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:583
#, no-wrap
msgid ""
"Note, how we paired the type of nucleobases with the nucleic acid\n"
"sequence. Assume now we implement a function for transcribing\n"
"a strand of DNA to RNA, and we'd like to convert a sequence of\n"
"nucleobases from user input to the corresponding RNA sequence.\n"
"Here's how to do this:\n"
msgstr "请注意，我们如何将核碱基类型与核酸序列配对。假设现在我们实现了一个将 DNA 链转录为 RNA 的函数，并且我们希望将用户输入的核碱基序列转换为相应的 RNA 序列。以下是如何执行此操作：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:584
#, no-wrap
msgid ""
"transcribeBase : Nucleobase DNABase -> Nucleobase RNABase\n"
"transcribeBase Adenine  = Uracile\n"
"transcribeBase Cytosine = Guanine\n"
"transcribeBase Guanine  = Cytosine\n"
"transcribeBase Thymine  = Adenine\n"
"\n"
"transcribe : DNA -> RNA\n"
"transcribe = map transcribeBase\n"
"\n"
"printRNA : RNA -> IO ()\n"
"printRNA = putStrLn . encode\n"
"\n"
"transcribeProg : IO ()\n"
"transcribeProg = do\n"
"  Right (b ** seq) <- getNucleicAcid\n"
"    | Left (InvalidSequence str) => putStrLn $ \"Invalid sequence: \" ++ str\n"
"    | Left (UnknownBaseType str) => putStrLn $ \"Unknown base type: \" ++ str\n"
"  case b of\n"
"    DNABase => printRNA $ transcribe seq\n"
"    RNABase => printRNA seq\n"
msgstr ""
"transcribeBase : Nucleobase DNABase -> Nucleobase RNABase\n"
"transcribeBase Adenine  = Uracile\n"
"transcribeBase Cytosine = Guanine\n"
"transcribeBase Guanine  = Cytosine\n"
"transcribeBase Thymine  = Adenine\n"
"\n"
"transcribe : DNA -> RNA\n"
"transcribe = map transcribeBase\n"
"\n"
"printRNA : RNA -> IO ()\n"
"printRNA = putStrLn . encode\n"
"\n"
"transcribeProg : IO ()\n"
"transcribeProg = do\n"
"  Right (b ** seq) <- getNucleicAcid\n"
"    | Left (InvalidSequence str) => putStrLn $ \"Invalid sequence: \" ++ str\n"
"    | Left (UnknownBaseType str) => putStrLn $ \"Unknown base type: \" ++ str\n"
"  case b of\n"
"    DNABase => printRNA $ transcribe seq\n"
"    RNABase => printRNA seq\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:611
#, no-wrap
msgid ""
"By pattern matching on the first value of the dependent pair we could\n"
"determine, whether the second value is an RNA or DNA sequence.\n"
"In the first case, we had to transcribe the\n"
"sequence first, in the second case, we could invoke `printRNA` directly.\n"
msgstr "通过对依赖对的第一个值的模式匹配，我们可以确定第二个值是 RNA 还是 DNA 序列。在第一种情况下，我们必须先转录序列，在第二种情况下，我们可以直接调用 `printRNA`。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:620
#, no-wrap
msgid ""
"In a more interesting scenario, we would *translate* the RNA sequence\n"
"to the corresponding protein sequence. Still, this example shows\n"
"how to deal with a simplified real world scenario: Data may be\n"
"encoded differently and coming from different sources. By using precise\n"
"types, we are forced to first convert values to the correct\n"
"format. Failing to do so leads to a compile time exception instead of\n"
"an error at runtime or - even worse - the program silently running\n"
"a bogus computation.\n"
msgstr "在一个更有趣的场景中，我们将 RNA 序列 *翻译* 成相应的蛋白质序列。尽管如此，这个例子展示了如何处理一个简化的现实世界场景：数据可能以不同的方式编码并且来自不同的来源。通过使用精确类型，我们被迫首先将值转换为正确的格式。不这样做会导致编译时异常，而不是运行时错误，或者 - 更糟糕的是 - 程序静默运行虚假计算。\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:621
#, no-wrap
msgid "Dependent Records vs Sum Types"
msgstr "依赖记录与和类型"

#. type: Plain text
#: ../src/Tutorial/DPair.md:630
#, no-wrap
msgid ""
"Dependent records as shown for `AnyVect a` are a generalization\n"
"of dependent pairs: We can have an arbitrary number of fields\n"
"and use the values stored therein to calculate the types of\n"
"other values. For very simple cases like the example with nucleobases,\n"
"it doesn't matter too much, whether we use a `DPair`, a custom\n"
"dependent record, or even a sum type. In fact, the three encodings\n"
"are equally expressive:\n"
msgstr "`AnyVect a` 所示的依赖记录是依赖对的概括：我们可以有任意数量的字段并使用其中存储的值来计算其他值的类型。对于非常简单的情况，例如带有核碱基的示例，无论我们使用 `DPair`、自定义相关记录还是和类型都没有太大关系。事实上，这三种编码同样具有表现力：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:631
#, no-wrap
msgid ""
"Acid1 : Type\n"
"Acid1 = (b ** NucleicAcid b)\n"
"\n"
"record Acid2 where\n"
"  constructor MkAcid2\n"
"  baseType : BaseType\n"
"  sequence : NucleicAcid baseType\n"
"\n"
"data Acid3 : Type where\n"
"  SomeRNA : RNA -> Acid3\n"
"  SomeDNA : DNA -> Acid3\n"
msgstr ""
"Acid1 : Type\n"
"Acid1 = (b ** NucleicAcid b)\n"
"\n"
"record Acid2 where\n"
"  constructor MkAcid2\n"
"  baseType : BaseType\n"
"  sequence : NucleicAcid baseType\n"
"\n"
"data Acid3 : Type where\n"
"  SomeRNA : RNA -> Acid3\n"
"  SomeDNA : DNA -> Acid3\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:652
#, no-wrap
msgid ""
"It is trivial to write lossless conversions between these\n"
"encodings, and with each encoding we can decide with a simple\n"
"pattern match, whether we currently have a sequence of\n"
"RNA or DNA. However, dependent types can depend on more than\n"
"one value, as we will see in the exercises. In such cases,\n"
"sum types and dependent pairs quickly become unwieldy, and\n"
"you should go for an encoding as a dependent record.\n"
msgstr "在这些编码之间编写无损转换是微不足道的，并且对于每种编码，我们可以通过简单的模式匹配来决定我们当前是否具有 RNA 或 DNA 序列。然而，依赖类型可以依赖多个值，正如我们将在练习中看到的那样。在这种情况下，和类型和依赖对很快就会变得笨拙，您应该将编码作为依赖记录。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:661
#, no-wrap
msgid ""
"Sharpen your skills in using dependent pairs and dependent\n"
"records! In exercises 2 to 7 you have to decide yourself,\n"
"when a function should return a dependent pair or record,\n"
"when a function requires additional arguments, on which you\n"
"can pattern match, and what other utility functions might be\n"
"necessary.\n"
msgstr "提高您使用依赖对和依赖记录的技能！在练习 2 到 7 中，你必须自己决定什么时候函数应该返回一个依赖对或记录，什么时候函数需要额外的参数，你可以在这些参数上进行模式匹配，以及可能需要哪些其他实用函数。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:666
#, no-wrap
msgid ""
"Proof that the three encodings for nucleobases are *isomorphic*\n"
"(meaning: of the same structure) by writing lossless conversion\n"
"functions from `Acid1` to `Acid2` and back. Likewise\n"
"for `Acid1` and `Acid3`.\n"
msgstr ""
"通过编写从 `Acid1` 到 `Acid2` "
"并返回的无损转换函数，证明核碱基的三种编码是*同构的*（意思是：结构相同）。"
"同样适用于 `Acid1` 和 `Acid3`。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:673
#, no-wrap
msgid ""
"Sequences of nucleobases can be encoded in one of two directions:\n"
"[*Sense* and *antisense*](https://en.wikipedia.org/wiki/Sense_(molecular_biology)).\n"
"Declare a new data type to describe\n"
"the sense of a sequence of nucleobases, and add this as an\n"
"additional parameter to type `Nucleobase` and types `DNA` and\n"
"`RNA`.\n"
msgstr ""
"核碱基序列可以在以下两个方向之一编码：[*Sense* 和 *antisense*](https://en."
"wikipedia.org/wiki/"
"Sense_(molecular_biology))。声明一个新的数据类型来描述核碱基序列的意义，"
"并将其作为附加参数添加到类型 `Nucleobase` 、`DNA` 和 `RNA`。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:677
#, no-wrap
msgid ""
"Refine the types of `complement` and `transcribe`, so that they\n"
"reflect the changing of *sense*. In case of `transcribe`, a\n"
"strand of antisense DNA is converted to a strand of sense RNA.\n"
msgstr ""
"细化 `complement` 和 `transcribe` 的类型，使其反映 *sense* 的变化。在 "
"`transcribe` 的情况下，反义 DNA 链被转化为 sense RNA 链。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:680
#, no-wrap
msgid ""
"Define a dependent record storing the base type and sense\n"
"together with a sequence of nucleobases.\n"
msgstr "定义一个依赖记录，将碱基类型和 sense 与一系列核碱基一起存储。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:685
#, no-wrap
msgid ""
"Adjust `readRNA` and `readDNA` in such a way that\n"
"the *sense* of a sequence is read from the input string.\n"
"Sense strands are encoded like so: \"5´-CGGTAG-3´\". Antisense\n"
"strands are encoded like so: \"3´-CGGTAG-5´\".\n"
msgstr ""
"调整 `readRNA` 和 `readDNA` 使得从输入字符串中读取 *sense* 的序列。 Sense "
"链编码如下：\"3´-CGGTAG-5´\"。反义链编码如下：\"3´-CGGTAG-5´\"。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:688
#, no-wrap
msgid ""
"Adjust `encode` in such a way that it includes the sense\n"
"in its output.\n"
msgstr "调整 `encode` 使其在输出中包含 sense。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/DPair.md:693
#, no-wrap
msgid ""
"Enhance `getNucleicAcid` and `transcribeProg` in such a way that\n"
"the sense and base type are stored together with the sequence,\n"
"and that `transcribeProg` always prints the *sense* RNA strand\n"
"(after transcription, if necessary).\n"
msgstr ""
"增强 `getNucleicAcid` 和 `transcribeProg` 以使 sense "
"和碱基类型与序列一起存储，并且 `transcribeProg` 始终打印 *sense* RNA "
"链（转录后，如有必要）。\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/DPair.md:695
#, no-wrap
msgid "Enjoy the fruits of your labour and test your program at the REPL.\n"
msgstr "享受您的劳动成果并在 REPL 测试您的程序。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:703
#, no-wrap
msgid ""
"Note: Instead of using a dependent record, we could again\n"
"have used a sum type of four constructors to encode the different\n"
"types of sequences. However, the number of constructors\n"
"required corresponds to the *product* of the number of values\n"
"of each type level index. Therefore, this number can grow quickly\n"
"and sum type encodings can lead to lengthy blocks of pattern matches\n"
"in these cases.\n"
msgstr "注意：我们可以再次使用四个构造函数的和类型来编码不同类型的序列，而不是使用依赖记录。但是，所需的构造函数数量对应于每个类型级别索引的值数量的 *积*。因此，这个数字会快速增长，并且在这些情况下，和类型编码会导致模式匹配的块很长。\n"

#. type: Title ##
#: ../src/Tutorial/DPair.md:704
#, no-wrap
msgid "Use Case: CSV Files with a Schema"
msgstr "用例：带有模式的 CSV 文件"

#. type: Plain text
#: ../src/Tutorial/DPair.md:712
#, no-wrap
msgid ""
"In this section, we are going to look at an extended example\n"
"based on our previous work on CSV parsers. We'd like to\n"
"write a small command-line program, where users can specify a\n"
"schema for the CSV tables they'd like to parse and load into\n"
"memory. Before we begin, here is a REPL session running\n"
"the final program, which you will complete in the exercises:\n"
msgstr "在本节中，我们将看一个基于我们之前在 CSV 解析器上的工作的扩展示例。我们想编写一个小型命令行程序，用户可以在其中为他们想要解析并加载到内存中的 CSV 表指定模式。在我们开始之前，这是一个运行最终程序的 REPL 会话，您将在练习中完成它：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DPair.md:713
#, no-wrap
msgid ""
"Solutions.DPair> :exec main\n"
"Enter a command: load resources/example\n"
"Table loaded. Schema: str,str,fin2023,str?,boolean?\n"
"Enter a command: get 3\n"
"Row 3:\n"
"\n"
"str   | str    | fin2023 | str? | boolean?\n"
"------------------------------------------\n"
"Floor | Jansen | 1981    |      | t\n"
"\n"
"Enter a command: add Mikael,Stanne,1974,,\n"
"Row prepended:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: delete 1\n"
"Deleted row: 1.\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str | str     | fin2023 | str? | boolean?\n"
"-----------------------------------------\n"
"Rob | Halford | 1951    |      |\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"
msgstr ""
"Solutions.DPair> :exec main\n"
"Enter a command: load resources/example\n"
"Table loaded. Schema: str,str,fin2023,str?,boolean?\n"
"Enter a command: get 3\n"
"Row 3:\n"
"\n"
"str   | str    | fin2023 | str? | boolean?\n"
"------------------------------------------\n"
"Floor | Jansen | 1981    |      | t\n"
"\n"
"Enter a command: add Mikael,Stanne,1974,,\n"
"Row prepended:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: delete 1\n"
"Deleted row: 1.\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str | str     | fin2023 | str? | boolean?\n"
"-----------------------------------------\n"
"Rob | Halford | 1951    |      |\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:754
#, no-wrap
msgid ""
"This example was inspired by a similar program used as an example\n"
"in the [Type-Driven Development with Idris](https://www.manning.com/books/type-driven-development-with-idris)\n"
"book.\n"
msgstr "这个例子的灵感来自于 [Type-Driven Development with Idris](https://www.manning.com/books/type-driven-development-with-idris) 一书中用作示例的类似程序。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:756
#, no-wrap
msgid "We'd like to focus on several things here:\n"
msgstr "我们想在这里重点关注几件事：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
#, no-wrap
msgid ""
"Purity: With the exception of the main program loop, all functions\n"
"used in the implementation should be pure, which in this context\n"
"means \"not running in any monad with side effects such as `IO`\".\n"
msgstr ""
"纯度：除了主程序循环之外，实现中使用的所有函数都应该是纯函数，在这种情况下，"
"这意味着“不在任何具有副作用的 monad 中运行，例如 `IO`”。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
#, no-wrap
msgid ""
"Fail early: With the exception of the command parser, all functions\n"
"updating the table and handling queries should be typed and\n"
"implemented in such a way that they cannot fail.\n"
msgstr "尽早失败：除了命令解析器之外，所有更新表和处理查询的函数都应该以不会失败的方"
"式输入和实现。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:766
#, no-wrap
msgid ""
"We are often well advised to adhere to these two guidelines, as they can\n"
"make the majority of our functions easier to implement and test.\n"
msgstr "我们经常被建议遵守这两个准则，因为它们可以使我们的大多数函数更容易实现和测试。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:772
#, no-wrap
msgid ""
"Since we allow users of our library to specify a schema (order and\n"
"types of columns) for the table they work with, this information is\n"
"not known until runtime. The same goes for the current size of the\n"
"table. We will therefore store both values as fields in a\n"
"dependent record.\n"
msgstr "由于我们允许我们库的用户为他们使用的表指定模式（列的顺序和类型），因此直到运行时才知道此信息。表的当前大小也是如此。因此，我们会将这两个值作为字段存储在依赖记录中。\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:773
#, no-wrap
msgid "Encoding the Schema"
msgstr "为模式编码"

#. type: Plain text
#: ../src/Tutorial/DPair.md:780
#, no-wrap
msgid ""
"We need to inspect the table schema at runtime. Although theoretically\n"
"possible, it is not advisable to operate on Idris types directly here.\n"
"We'd rather use a closed custom data type describing the types of\n"
"columns we understand. In a first try, we only support some Idris\n"
"primitives:\n"
msgstr "我们需要在运行时检查表模式。尽管理论上可行，但不建议在此处直接对 Idris 类型进行操作。我们宁愿使用封闭的自定义数据类型来描述我们理解的列类型。在第一次尝试中，我们只支持一些 Idris 原语：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:781
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
msgstr ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:791
#, no-wrap
msgid ""
"Next, we need a way to convert a `Schema` to a list of Idris\n"
"types, which we will then use as the index of a heterogeneous\n"
"list representing the rows in our table:\n"
msgstr "接下来，我们需要一种将 `Schema` 转换为 Idris 类型列表的方法，然后将其用作表示表中行的异构列表的索引：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:792
#, no-wrap
msgid ""
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
msgstr ""
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:807
#, no-wrap
msgid ""
"We can now describe a table as a dependent record storing\n"
"the table's content as a vector of rows. In order to safely\n"
"index rows of the table and parse new rows to be added, the\n"
"current schema and size of the table must be known at runtime:\n"
msgstr "我们现在可以将表描述为将表内容存储为行向量的依赖记录。为了安全地索引表的行并解析要添加的新行，必须在运行时知道表的当前模式和大小：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:808
#, no-wrap
msgid ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
msgstr ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:823
#, no-wrap
msgid ""
"Finally, we define an indexed data type describing commands\n"
"operating on the current table. Using the current table as\n"
"the command's index allows us to make sure that indices for\n"
"accessing and deleting rows are within bounds and that\n"
"new rows agree with the current schema. This is necessary\n"
"to uphold our second design principle: All functions\n"
"operating on tables must do so without the possibility of failure.\n"
msgstr "最后，我们定义了一个索引数据类型来描述对当前表进行操作的命令。使用当前表作为命令的索引允许我们确保访问和删除行的索引在界限内，并且新行与当前模式一致。这对于维护我们的第二个设计原则是必要的：所有在表上操作的函数都必须这样做，并且没有失败的可能性。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:824
#, no-wrap
msgid ""
"data Command : (t : Table) -> Type where\n"
"  PrintSchema : Command t\n"
"  PrintSize   : Command t\n"
"  New         : (newSchema : Schema) -> Command t\n"
"  Prepend     : Row (schema t) -> Command t\n"
"  Get         : Fin (size t) -> Command t\n"
"  Delete      : Fin (size t) -> Command t\n"
"  Quit        : Command t\n"
msgstr ""
"data Command : (t : Table) -> Type where\n"
"  PrintSchema : Command t\n"
"  PrintSize   : Command t\n"
"  New         : (newSchema : Schema) -> Command t\n"
"  Prepend     : Row (schema t) -> Command t\n"
"  Get         : Fin (size t) -> Command t\n"
"  Delete      : Fin (size t) -> Command t\n"
"  Quit        : Command t\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:839
#, no-wrap
msgid ""
"We can now implement the main application logic: How user\n"
"entered commands affect the application's current state. As promised,\n"
"this comes without the risk of failure, so we don't have to\n"
"wrap the return type in an `Either`:\n"
msgstr "我们现在可以实现主要的应用程序逻辑：用户输入的命令如何影响应用程序的当前状态。正如所承诺的那样，这没有失败的风险，因此我们不必将返回类型包装在 `Either` 中：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:840
#, no-wrap
msgid ""
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"
msgstr ""
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:857
#, no-wrap
msgid ""
"Please understand, that the constructors of `Command t` are typed\n"
"in such a way that indices are always within bounds (constructors\n"
"`Get` and `Delete`), and new rows adhere to the table's\n"
"current schema (constructor `Prepend`).\n"
msgstr "请理解，`Command t` 的构造函数的类型使得索引始终在范围内（构造函数 `Get` 和 `Delete`），并且新行遵循到表的当前模式（构造函数 `Prepend`）。`\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:866
#, no-wrap
msgid ""
"One thing you might not have seen so far is the call to `absurd`\n"
"on the last line. This is a derived function of the\n"
"`Uninhabited` interface, which is used to describe types such\n"
"as `Void` or - in the case above - `Fin 0`, of which there can\n"
"be no value. Function `absurd` is then just another manifestation\n"
"of the principle of explosion. If this doesn't make too much sense\n"
"yet, don't worry. We will look at `Void` and its uses in the\n"
"next chapter.\n"
msgstr "到目前为止你可能没有看到的一件事是最后一行对 `absurd` 的调用。这是 `Uninhabited` 接口的派生函数，用于描述诸如 `Void` 或 - 在上述情况下 - `Fin 0` 等类型，其中有可以没有价值。函数`absurd` 则只是爆炸原理的另一种表现。如果这还没有太大意义，请不要担心。我们将在下一章中介绍 `Void` 及其用法。\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:867
#, no-wrap
msgid "Parsing Commands"
msgstr "解析命令"

#. type: Plain text
#: ../src/Tutorial/DPair.md:879
#, no-wrap
msgid ""
"User input validation is an important topic when writing\n"
"applications. If it happens early, you can keep larger parts\n"
"of your application pure (which - in this context - means:\n"
"\"without the possibility of failure\") and provably total.\n"
"If done properly, this step encodes and handles most if not all\n"
"ways in which things can go wrong in your program, allowing\n"
"you to come up with clear error messages telling users exactly what caused\n"
"an issue. As you surely have experienced yourself, there are few\n"
"things more frustrating than a non-trivial computer program terminating\n"
"with an unhelpful \"There was an error\" message.\n"
msgstr "用户输入验证是编写应用程序时的一个重要主题。如果它发生得早，您可以保持应用程序的大部分纯净（在这种情况下，这意味着：“没有失败的可能性”）并且可以证明是完全的。如果操作正确，此步骤将编码和处理程序中可能出现问题的大部分（可能不是全部）方式，从而使您能够提出明确的错误消息，告诉用户究竟是什么导致了问题。正如您自己所经历的那样，没有什么比一个有意义的计算机程序以无用的“发生错误”消息终止更令人沮丧的了。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:892
#, no-wrap
msgid ""
"So, in order to treat this important topic with all due respect,\n"
"we are first going to implement a custom error type. This is\n"
"not *strictly* necessary for small programs, but once your software\n"
"gets more complex, it can be tremendously helpful for keeping track\n"
"of what can go wrong where. In order to figure out what can possibly\n"
"go wrong, we first need to decide on how the commands should be entered.\n"
"Here, we use a single keyword for each command, together with an\n"
"optional number of arguments separated from the keyword by a single\n"
"space character. For instance: `\"new i64,boolean,str,str\"`,\n"
"for initializing an empty table with a new schema. With this settled,\n"
"here is a list of things that can go wrong, and the messages we'd\n"
"like to print:\n"
msgstr "因此，为了以应有的尊重对待这个重要的话题，我们首先要实现一个自定义错误类型。这对于小程序来说 *严格* 不是所必需的，但是一旦您的软件变得更加复杂，它对于跟踪可能出错的地方非常有帮助。为了找出可能出错的地方，我们首先需要决定如何输入命令。在这里，我们为每个命令使用一个关键字，以及由单个空格字符与关键字分隔的可选数量的参数。例如：`\"new i64,boolean,str,str\"`，用于使用新模式初始化空表。解决了这个问题，这里列出了可能出错的地方，以及我们想要打印的消息：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, no-wrap
msgid ""
"A bogus command is entered. We repeat the input with a message that\n"
"we don't know the command plus a list of commands we know about.\n"
msgstr "输入了虚假命令。我们使用我们不知道命令的消息以及我们知道的命令列表重复输入。"
"\n"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, no-wrap
msgid ""
"An invalid schema was entered. In this case, we list the position\n"
"of the first unknown type, the string we found there, and a list of\n"
"types we know about.\n"
msgstr "输入了无效的模式。在这种情况下，我们列出了第一个未知类型的位置、我们在那里找"
"到的字符串以及我们知道的类型列表。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, no-wrap
msgid ""
"An invalid CSV encoding of a row was entered. We list the erroneous position,\n"
"the string encountered there, plus the expected type. In case\n"
"of a too small or too large number of fields, we also print\n"
"a corresponding error message.\n"
msgstr "输入的行的 CSV 编码无效。我们列出了错误的位置、在那里遇到的字符串以及预期的类"
"型。如果字段数量过少或过多，我们也会打印相应的错误消息。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, no-wrap
msgid ""
"An index was out of bounds. This can happen, when users try to access\n"
"or delete specific rows. We print the current number of rows plus\n"
"the value entered.\n"
msgstr "索引超出范围。当用户尝试访问或删除特定行时，可能会发生这种情况。我们打印当前"
"行数加上输入的值。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, no-wrap
msgid ""
"A value not representing a natural number was entered as an index.\n"
"We print an according error message.\n"
msgstr "输入了不代表自然数的值作为索引。我们打印相应的错误消息。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:910
#, no-wrap
msgid ""
"That's a lot of stuff to keep track off, so let's encode this in\n"
"a sum type:\n"
msgstr "有很多东西需要跟踪，所以让我们将其编码为和类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:911
#, no-wrap
msgid ""
"data Error : Type where\n"
"  UnknownCommand : String -> Error\n"
"  UnknownType    : (pos : Nat) -> String -> Error\n"
"  InvalidField   : (pos : Nat) -> ColType -> String -> Error\n"
"  ExpectedEOI    : (pos : Nat) -> String -> Error\n"
"  UnexpectedEOI  : (pos : Nat) -> String -> Error\n"
"  OutOfBounds    : (size : Nat) -> (index : Nat) -> Error\n"
"  NoNat          : String -> Error\n"
msgstr ""
"data Error : Type where\n"
"  UnknownCommand : String -> Error\n"
"  UnknownType    : (pos : Nat) -> String -> Error\n"
"  InvalidField   : (pos : Nat) -> ColType -> String -> Error\n"
"  ExpectedEOI    : (pos : Nat) -> String -> Error\n"
"  UnexpectedEOI  : (pos : Nat) -> String -> Error\n"
"  OutOfBounds    : (size : Nat) -> (index : Nat) -> Error\n"
"  NoNat          : String -> Error\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:929
#, no-wrap
msgid ""
"In order to conveniently construct our error messages, it is best\n"
"to use Idris' string interpolation facilities: We can enclose\n"
"arbitrary string expressions in a string literal by enclosing\n"
"them in curly braces, the first of which must be escaped with\n"
"a backslash. Like so: `\"foo \\{myExpr a b c}\"`.\n"
"We can pair this with multiline string literals to get\n"
"nicely formatted error messages.\n"
msgstr "为了方便地构造我们的错误消息，最好使用 Idris 的字符串插值工具：我们可以通过将任意字符串表达式括在花括号中，将它们括在字符串文字中，第一个必须用反斜杠转义。像这样：`\"foo \\{myExpr a b c}\"`。我们可以将它与多行字符串文字配对以获得格式良好的错误消息。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:930
#, no-wrap
msgid ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map showColType\n"
"\n"
"allTypes : String\n"
"allTypes = concat\n"
"         . List.intersperse \", \"\n"
"         . map showColType\n"
"         $ [I64,Str,Boolean,Float]\n"
"\n"
"showError : Error -> String\n"
"showError (UnknownCommand x) = \"\"\"\n"
"  Unknown command: \\{x}.\n"
"  Known commands are: clear, schema, size, new, add, get, delete, quit.\n"
"  \"\"\"\n"
"\n"
"showError (UnknownType pos x) = \"\"\"\n"
"  Unknown type at position \\{show pos}: \\{x}.\n"
"  Known types are: \\{allTypes}.\n"
"  \"\"\"\n"
"\n"
"showError (InvalidField pos tpe x) = \"\"\"\n"
"  Invalid value at position \\{show pos}.\n"
"  Expected type: \\{showColType tpe}.\n"
"  Value found: \\{x}.\n"
"  \"\"\"\n"
"\n"
"showError (ExpectedEOI k x) = \"\"\"\n"
"  Expected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (UnexpectedEOI k x) = \"\"\"\n"
"  Unxpected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (OutOfBounds size index) = \"\"\"\n"
"  Index out of bounds.\n"
"  Size of table: \\{show size}\n"
"  Index: \\{show index}\n"
"  Note: Indices start at 1.\n"
"  \"\"\"\n"
"\n"
"showError (NoNat x) = \"Not a natural number: \\{x}\"\n"
msgstr ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map showColType\n"
"\n"
"allTypes : String\n"
"allTypes = concat\n"
"         . List.intersperse \", \"\n"
"         . map showColType\n"
"         $ [I64,Str,Boolean,Float]\n"
"\n"
"showError : Error -> String\n"
"showError (UnknownCommand x) = \"\"\"\n"
"  Unknown command: \\{x}.\n"
"  Known commands are: clear, schema, size, new, add, get, delete, quit.\n"
"  \"\"\"\n"
"\n"
"showError (UnknownType pos x) = \"\"\"\n"
"  Unknown type at position \\{show pos}: \\{x}.\n"
"  Known types are: \\{allTypes}.\n"
"  \"\"\"\n"
"\n"
"showError (InvalidField pos tpe x) = \"\"\"\n"
"  Invalid value at position \\{show pos}.\n"
"  Expected type: \\{showColType tpe}.\n"
"  Value found: \\{x}.\n"
"  \"\"\"\n"
"\n"
"showError (ExpectedEOI k x) = \"\"\"\n"
"  Expected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (UnexpectedEOI k x) = \"\"\"\n"
"  Unxpected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (OutOfBounds size index) = \"\"\"\n"
"  Index out of bounds.\n"
"  Size of table: \\{show size}\n"
"  Index: \\{show index}\n"
"  Note: Indices start at 1.\n"
"  \"\"\"\n"
"\n"
"showError (NoNat x) = \"Not a natural number: \\{x}\"\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:990
#, no-wrap
msgid ""
"We can now write parsers for the different commands. We need facilities\n"
"to parse vector indices, schemata, and CSV rows.\n"
"Since we are using a CSV format for encoding\n"
"and decoding rows, it makes sense to also encode the schema\n"
"as a comma-separated list of values:\n"
msgstr "我们现在可以为不同的命令编写解析器。我们需要工具来解析向量索引、模式和 CSV 行。由于我们使用 CSV 格式对行进行编码和解码，因此也可以将模式编码为逗号分隔的值列表：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:991
#, no-wrap
msgid ""
"zipWithIndex : Traversable t => t a -> t (Nat, a)\n"
"zipWithIndex = evalState 1 . traverse pairWithIndex\n"
"  where pairWithIndex : a -> State Nat (Nat,a)\n"
"        pairWithIndex v = (,v) <$> get <* modify S\n"
"\n"
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"readColType : Nat -> String -> Either Error ColType\n"
"readColType _ \"i64\"      = Right I64\n"
"readColType _ \"str\"      = Right Str\n"
"readColType _ \"boolean\"  = Right Boolean\n"
"readColType _ \"float\"    = Right Float\n"
"readColType n s          = Left $ UnknownType n s\n"
"\n"
"readSchema : String -> Either Error Schema\n"
"readSchema = traverse (uncurry readColType) . zipWithIndex . fromCSV\n"
msgstr ""
"zipWithIndex : Traversable t => t a -> t (Nat, a)\n"
"zipWithIndex = evalState 1 . traverse pairWithIndex\n"
"  where pairWithIndex : a -> State Nat (Nat,a)\n"
"        pairWithIndex v = (,v) <$> get <* modify S\n"
"\n"
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"readColType : Nat -> String -> Either Error ColType\n"
"readColType _ \"i64\"      = Right I64\n"
"readColType _ \"str\"      = Right Str\n"
"readColType _ \"boolean\"  = Right Boolean\n"
"readColType _ \"float\"    = Right Float\n"
"readColType n s          = Left $ UnknownType n s\n"
"\n"
"readSchema : String -> Either Error Schema\n"
"readSchema = traverse (uncurry readColType) . zipWithIndex . fromCSV\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1018
#, no-wrap
msgid ""
"We also need to decode CSV content based on the current schema.\n"
"Note, how we can do so in a type safe manner by pattern matching\n"
"on the schema, which will not be known until runtime. Unfortunately,\n"
"we need to reimplement CSV-parsing, because we want to add the\n"
"expected type to the error messages (a thing that would be\n"
"much harder to do with interface `CSVLine`\n"
"and error type `CSVError`).\n"
msgstr "我们还需要根据当前模式解码 CSV 内容。请注意，我们如何通过模式上的模式匹配以类型安全的方式做到这一点，直到运行时才知道。不幸的是，我们需要重新实现 CSV 解析，因为我们想将预期的类型添加到错误消息中（使用接口 `CSVLine` 和错误类型 `CSVError`）。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1019
#, no-wrap
msgid ""
"decodeField : Nat -> (c : ColType) -> String -> Either Error (IdrisType c)\n"
"decodeField k c s =\n"
"  let err = InvalidField k c s\n"
"   in case c of\n"
"        I64     => maybeToEither err $ read s\n"
"        Str     => maybeToEither err $ read s\n"
"        Boolean => maybeToEither err $ read s\n"
"        Float   => maybeToEither err $ read s\n"
"\n"
"decodeRow : {ts : _} -> String -> Either Error (Row ts)\n"
"decodeRow s = go 1 ts $ fromCSV s\n"
"  where go : Nat -> (cs : Schema) -> List String -> Either Error (Row cs)\n"
"        go k []       []         = Right []\n"
"        go k []       (_ :: _)   = Left $ ExpectedEOI k s\n"
"        go k (_ :: _) []         = Left $ UnexpectedEOI k s\n"
"        go k (c :: cs) (s :: ss) = [| decodeField k c s :: go (S k) cs ss |]\n"
msgstr ""
"decodeField : Nat -> (c : ColType) -> String -> Either Error (IdrisType c)\n"
"decodeField k c s =\n"
"  let err = InvalidField k c s\n"
"   in case c of\n"
"        I64     => maybeToEither err $ read s\n"
"        Str     => maybeToEither err $ read s\n"
"        Boolean => maybeToEither err $ read s\n"
"        Float   => maybeToEither err $ read s\n"
"\n"
"decodeRow : {ts : _} -> String -> Either Error (Row ts)\n"
"decodeRow s = go 1 ts $ fromCSV s\n"
"  where go : Nat -> (cs : Schema) -> List String -> Either Error (Row cs)\n"
"        go k []       []         = Right []\n"
"        go k []       (_ :: _)   = Left $ ExpectedEOI k s\n"
"        go k (_ :: _) []         = Left $ UnexpectedEOI k s\n"
"        go k (c :: cs) (s :: ss) = [| decodeField k c s :: go (S k) cs ss |]\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1040
#, no-wrap
msgid ""
"There is no hard and fast rule about whether to pass an index as an\n"
"implicit argument or not. Some considerations:\n"
msgstr "关于是否将索引作为隐式参数传递没有硬性规定。一些考虑：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
#, no-wrap
msgid "Pattern matching on explicit arguments comes with less syntactic overhead.\n"
msgstr "显式参数的模式匹配具有较少的语法开销。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
#, no-wrap
msgid ""
"If an argument can be inferred from the context most of the time, consider\n"
"passing it as an implicit to make your function nicer to use in client\n"
"code.\n"
msgstr "如果大多数时候可以从上下文中推断出参数，请考虑将其作为隐式传递，以使您的函数"
"更好地在客户端代码中使用。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
#, no-wrap
msgid ""
"Use explicit (possibly erased) arguments for values that can't\n"
"be inferred by Idris most of the time.\n"
msgstr "对于大多数时候 Idris 无法推断的值，请使用显式（可能已删除）参数。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1052
#, no-wrap
msgid ""
"All that is missing now is a way to parse indices for accessing\n"
"the current table's rows. We use the conversion for indices to\n"
"start at one instead of zero, which feels more natural for most\n"
"non-programmers.\n"
msgstr "现在缺少的只是一种解析索引以访问当前表行的方法。我们使用索引的转换从 1 而不是 0 开始，这对于大多数非程序员来说感觉更自然。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1053
#, no-wrap
msgid ""
"readFin : {n : _} -> String -> Either Error (Fin n)\n"
"readFin s = do\n"
"  S k <- maybeToEither (NoNat s) $ parsePositive {a = Nat} s\n"
"    | Z => Left $ OutOfBounds n Z\n"
"  maybeToEither (OutOfBounds n $ S k) $ natToFin k n\n"
msgstr ""
"readFin : {n : _} -> String -> Either Error (Fin n)\n"
"readFin s = do\n"
"  S k <- maybeToEither (NoNat s) $ parsePositive {a = Nat} s\n"
"    | Z => Left $ OutOfBounds n Z\n"
"  maybeToEither (OutOfBounds n $ S k) $ natToFin k n\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1067
#, no-wrap
msgid ""
"We are finally able to implement a parser for user commands.\n"
"Function `Data.String.words` is used for splitting a string\n"
"at space characters. In most cases, we expect the name of\n"
"the command plus a single argument without additional spaces.\n"
"CSV rows can have additional space characters, however, so we\n"
"use `Data.String.unwords` on the split string.\n"
msgstr "我们终于能够为用户命令实现解析器。函数 `Data.String.words` 用于在空格字符处分割字符串。在大多数情况下，我们期望命令的名称加上一个没有额外空格的参数。但是，CSV 行可以有额外的空格字符，因此我们在拆分字符串上使用 `Data.String.unwords`。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1068
#, no-wrap
msgid ""
"readCommand :  (t : Table) -> String -> Either Error (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  _               => Left $ UnknownCommand s\n"
msgstr ""
"readCommand :  (t : Table) -> String -> Either Error (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  _               => Left $ UnknownCommand s\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:1081
#, no-wrap
msgid "Running the Application"
msgstr "运行应用程序"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1087
#, no-wrap
msgid ""
"All that's left to do is to write functions for\n"
"printing the results of commands to users and run\n"
"the application in a loop until command `\"quit\"`\n"
"is entered.\n"
msgstr "剩下要做的就是编写用于向用户打印命令结果的函数并循环运行应用程序，直到输入命令 `\"quit\"`。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1088
#, no-wrap
msgid ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (ts : List ColType) -> Row ts -> String\n"
"encodeRow ts = concat . intersperse \",\" . go ts\n"
"  where go : (cs : List ColType) -> Row cs -> Vect (length cs) String\n"
"        go []        []        = []\n"
"        go (c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize   = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)    = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r) = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)  = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit        = \"Goodbye.\"\n"
"result t (Get x)     =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (showError err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"
msgstr ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (ts : List ColType) -> Row ts -> String\n"
"encodeRow ts = concat . intersperse \",\" . go ts\n"
"  where go : (cs : List ColType) -> Row cs -> Vect (length cs) String\n"
"        go []        []        = []\n"
"        go (c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize   = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)    = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r) = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)  = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit        = \"Goodbye.\"\n"
"result t (Get x)     =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (showError err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1136
#, no-wrap
msgid ""
"The challenges presented here all deal with enhancing our\n"
"table editor in several interesting ways. Some of them are\n"
"more a matter of style and less a matter of learning to write\n"
"dependently typed programs, so feel free to solve these as you\n"
"please. Exercises 1 to 3 should be considered to be\n"
"mandatory.\n"
msgstr "这里提出的挑战都涉及以几种有趣的方式增强我们的表格编辑器。其中一些更多的是风格问题，而不是学习编写依赖类型程序的问题，所以请随意解决这些问题。练习 1 到 3 应该被认为是强制性的。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:1139
#, no-wrap
msgid ""
"Add support for storing Idris types `Integer` and `Nat`\n"
"in CSV columns\n"
msgstr "添加对在 CSV 列中存储 Idris 类型 `Integer` 和 `Nat` 的支持\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:1142
#, no-wrap
msgid ""
"Add support for `Fin n` to CSV columns. Note: We need\n"
"runtime access to `n` in order for this to work.\n"
msgstr "添加对 `Fin n` 到 CSV 列的支持。注意：我们需要运行时访问 `n` 才能使其工作。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:1148
#, no-wrap
msgid ""
"Add support for optional types to CSV columns. Since\n"
"missing values should be encoded by empty strings,\n"
"it makes no sense to allow for nested optional types,\n"
"meaning that types like `Maybe Nat` should be allowed\n"
"while `Maybe (Maybe Nat)` should not.\n"
msgstr ""
"向 CSV 列添加对可选类型的支持。由于缺失值应该由空字符串编码，因此允许嵌套可选"
"类型没有意义，这意味着应该允许 `Maybe Nat` 等类型，而 `Maybe (Maybe Nat)` "
"不被允许.\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1151
#, no-wrap
msgid ""
"   Hint: There are several ways to encode these, one being\n"
"   to add a boolean index to `ColType`.\n"
msgstr ""
"   提示：有几种编码方式，一种是\n"
"   为 `ColType` 添加一个布尔索引。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:1154
#, no-wrap
msgid ""
"Add a command for printing the whole table. Bonus points\n"
"if all columns are properly aligned.\n"
msgstr "添加用于打印整个表格的命令。如果所有列都正确对齐，则加分。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:1158
#, no-wrap
msgid ""
"Add support for simple queries: Given a column number\n"
"and a value, list all rows where entries match the given\n"
"value.\n"
msgstr "添加对简单查询的支持：给定列号和值，列出条目与给定值匹配的所有行。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1160
#, no-wrap
msgid "   This might be a challenge, as the types get pretty interesting.\n"
msgstr "   这可能是一个挑战，因为类型变得非常有趣。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:1164
#, no-wrap
msgid ""
"Add support for loading and saving tables from and to disk.\n"
"A table should be stored in two files: One for the schema\n"
"and one for the CSV content.\n"
msgstr "添加对从磁盘加载和保存表的支持。表应存储在两个文件中：一个用于模式，一个用于 "
"CSV 内容。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1179
#, no-wrap
msgid ""
"   Note: Reading files in a provably total way can be pretty\n"
"   hard and will be a topic for another day. For now,\n"
"   just use function `readFile` exported from\n"
"   `System.File` in base for reading a file as a whole.\n"
"   This function is partial, because\n"
"   it will not terminate when used with an infinite input\n"
"   stream such as `/dev/urandom` or `/dev/zero`.\n"
"   It is important to *not* use `assert_total` here.\n"
"   Using partial functions like `readFile` might well impose\n"
"   a security risk in a real world application, so eventually,\n"
"   we'd have to deal with this and allow for some way to\n"
"   limit the size of accepted input. It is therefore best\n"
"   to make this partiality visible and annotate all downstream\n"
"   functions accordingly.\n"
msgstr ""
"   注意：以可证明的全部方式读取文件可能很困难，这将成为另一天的话题。目前，\n"
"   只需使用从 `System.File` 导出的函数 `readFile`\n"
"   用于读取整个文件。\n"
"   这是一个偏函数，因为\n"
"   与无限输入一起使用时不会终止\n"
"   流，例如 `/dev/urandom` 或 `/dev/zero`。\n"
"   重要的是 *不能* 在此处使用 `assert_total`。\n"
"   使用像 `readFile` 这样的部分函数可能会强加\n"
"   现实世界应用程序中的安全风险，所以最终，\n"
"   我们必须处理这个问题并允许某种方式\n"
"   限制接受输入的大小。因此最好\n"
"   使这种偏见可见并注释所有下游\n"
"   相应地函数。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1183
#, no-wrap
msgid ""
"You can find an implementation of these additions in the\n"
"solutions. A small example table can be found in folder\n"
"`resources`.\n"
msgstr "您可以在解决方案中找到这些添加的实现。可以在文件夹 `resources` 中找到一个小示例表。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1190
#, no-wrap
msgid ""
"Note: There are of course tons of projects to pursue from\n"
"here, such as writing a proper query language, calculating\n"
"new rows from existing ones, accumulating values in a\n"
"column, concatenating and zipping tables, and so on.\n"
"We will stop for now, probably coming back to this in\n"
"later examples.\n"
msgstr "注意：当然还有大量的项目要从这里开始，例如编写适当的查询语言、从现有行计算新行、在列中累积值、连接和压缩表等等。我们现在将停止，可能会在后面的示例中回到这一点。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1198
#, no-wrap
msgid ""
"Dependent pairs and records are necessary to at runtime\n"
"inspect the values defining the types we work with. By pattern\n"
"matching on these values, we learn about the types and\n"
"possible shapes of other values, allowing us to reduce\n"
"the number of potential bugs in our programs.\n"
msgstr "依赖对和记录对于在运行时检查定义我们使用的类型的值是必要的。通过对这些值进行模式匹配，我们可以了解其他值的类型和可能的形状，从而减少程序中潜在错误的数量。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1204
#, no-wrap
msgid ""
"In the [next chapter](Eq.md) we start learning about how\n"
"to write data types, which we use as proofs that certain\n"
"contracts between values hold. These will eventually allow\n"
"us to define pre- and post conditions for our function\n"
"arguments and output types.\n"
msgstr "在[下一章](Eq.md)中，我们开始学习如何编写数据类型，我们将其用作值之间某些契约成立的证据。这些最终将允许我们为函数参数和输出类型定义前置和后置条件。\n"

#. type: Title #
#: ../src/Tutorial/Eq.md:1
#, no-wrap
msgid "Propositional Equality"
msgstr "命题等式"

#. type: Plain text
#: ../src/Tutorial/Eq.md:9
#, no-wrap
msgid ""
"In the [last chapter](DPair.md) we learned, how dependent pairs\n"
"and records can be used to calculate *types* from values only known\n"
"at runtime by pattern matching on these values. We will now look\n"
"at how we can describe relations - or *contracts* - between\n"
"values as types, and how we can use values of these types as\n"
"proofs that the contracts hold.\n"
msgstr "在 [上一章](DPair.md) 中，我们了解了如何使用依赖对和记录来计算 *类型*，这些值仅在运行时通过对这些值进行模式匹配而已知。现在，我们将研究如何将值之间的关系或 *契约* 描述为类型，以及如何使用这些类型的值作为契约持有的证明。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:10
#, no-wrap
msgid ""
"module Tutorial.Eq\n"
"\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.Vect\n"
"import Data.String\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Eq\n"
"\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.Vect\n"
"import Data.String\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Eq.md:21
#, no-wrap
msgid "Equality as a Type"
msgstr "等式作为一种类型"

#. type: Plain text
#: ../src/Tutorial/Eq.md:26
#, no-wrap
msgid ""
"Imagine, we'd like to concatenate the contents of two CSV files,\n"
"both of which we stored on disk as tables together with their schemata\n"
"as shown in our discussion about dependent pairs:\n"
msgstr "想象一下，我们想要连接两个 CSV 文件的内容，我们将这两个文件作为表连同它们的模式一起存储在磁盘上，如我们关于依赖对的讨论中所示：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:27
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
"\n"
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"concatTables1 : Table -> Table -> Maybe Table\n"
msgstr ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
"\n"
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"concatTables1 : Table -> Table -> Maybe Table\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:55
#, no-wrap
msgid ""
"We will not be able to implement `concatTables` by appending the\n"
"two row vectors, unless we can somehow verify that the two schemata\n"
"are identical. \"Well,\" I hear you say, \"that shouldn't be a big issue!\n"
"Just implement `Eq` for `ColType`\". Let's give this a try:\n"
msgstr "我们将无法通过附加两个行向量来实现 `concatTables`，除非我们能够以某种方式验证两个模式是否相同。 “好吧，”我听到你说，“这应该不是什么大问题！只需为 `ColType` 实现 `Eq`”。让我们试一试：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:56
#, no-wrap
msgid ""
"Eq ColType where\n"
"  I64     == I64     = True\n"
"  Str     == Str     = True\n"
"  Boolean == Boolean = True\n"
"  Float   == Float   = True\n"
"  _       == _       = False\n"
"\n"
"concatTables1 (MkTable s1 m rs1) (MkTable s2 n rs2) = case s1 == s2 of\n"
"  True  => ?what_now\n"
"  False => Nothing\n"
msgstr ""
"Eq ColType where\n"
"  I64     == I64     = True\n"
"  Str     == Str     = True\n"
"  Boolean == Boolean = True\n"
"  Float   == Float   = True\n"
"  _       == _       = False\n"
"\n"
"concatTables1 (MkTable s1 m rs1) (MkTable s2 n rs2) = case s1 == s2 of\n"
"  True  => ?what_now\n"
"  False => Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:73
#, no-wrap
msgid ""
"Somehow, this doesn't seem to work. If we inspect the context of hole\n"
"`what_now`, Idris still thinks that `s1` and `s2` are different, and\n"
"if we go ahead and invoke `Vect.(++)` anyway in the `True` case,\n"
"Idris will respond with a type error.\n"
msgstr "不知何故，这似乎不起作用。如果我们检查孔 `what_now` 的上下文，Idris 仍然认为 `s1` 和 `s2` 是不同的，如果我们继续调用 `Vect.( ++)` ，在 `True` 的情况下，Idris 将响应类型错误。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:74
#, no-wrap
msgid ""
"Tutorial.Relations> :t what_now\n"
"   m : Nat\n"
"   s1 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s1))\n"
"   n : Nat\n"
"   s2 : List ColType\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"------------------------------\n"
"what_now : Maybe Table\n"
msgstr ""
"Tutorial.Relations> :t what_now\n"
"   m : Nat\n"
"   s1 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s1))\n"
"   n : Nat\n"
"   s2 : List ColType\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"------------------------------\n"
"what_now : Maybe Table\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:92
#, no-wrap
msgid ""
"The problem is, that there is no reason for Idris to unify the two\n"
"values, even though `(==)` returned `True` because the result of `(==)`\n"
"holds no other information than the type being a `Bool`. *We* think,\n"
"if this is `True` the two values should be identical, but Idris is not\n"
"convinced. In fact, the following implementation of `Eq ColType`\n"
"would be perfectly fine as far as the type checker is concerned:\n"
msgstr "问题是，Idris 没有理由统一这两个值，即使 `(==)` 返回 `True` 因为 `(==)` 的结果除了类型为 `Bool` 之外没有其他信息。 *我们* 认为，如果这是 `True` 那么两个值应该是相同的，但 Idris 不相信。事实上，就类型检查器而言，以下 `Eq ColType` 的实现会非常好：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:93
#, no-wrap
msgid ""
"Eq ColType where\n"
"  _       == _       = True\n"
msgstr ""
"Eq ColType where\n"
"  _       == _       = True\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:106
#, no-wrap
msgid ""
"So Idris is right in not trusting us. You might expect it to inspect the\n"
"implementation of `(==)` and figure out on its own, what the `True` result\n"
"means, but this is not how these things work in general, because most of the\n"
"time the number of computational paths to check would be far too large.\n"
"As a consequence, Idris is able to evaluate functions during\n"
"unification, but it will not trace back information about function\n"
"arguments from a function's result for us. We can do so manually, however,\n"
"as we will see later.\n"
msgstr "所以伊德里斯不信任我们是对的。您可能希望它检查 `(==)` 的实现并自行弄清楚 `True` 结果的含义，但这并不是这些事情通常的工作方式，因为大多数时候，要检查的计算路径的数量会太大。因此，Idris 能够在统一期间求值函数，但它不会为我们从函数结果中追溯有关函数参数的信息。但是，我们可以手动执行此操作，稍后我们将看到。\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:107
#, no-wrap
msgid "A Type for equal Schemata"
msgstr "相等 schemata 的类型"

#. type: Plain text
#: ../src/Tutorial/Eq.md:114
#, no-wrap
msgid ""
"The problem described above is similar to what we saw when\n"
"we talked about the benefit of [singleton types](DPair.md#erased-existentials):\n"
"The types are not precise enough. What we are going to do now,\n"
"is something we'll repeat time again for different use cases:\n"
"We encode a contract between values in an indexed data type:\n"
msgstr "上面描述的问题类似于我们在谈到[singleton types](DPair.md#erased-existentials)的好处时看到的：类型不够精确。我们现在要做的是，我们将针对不同的用例再次重复：我们对索引数据类型中的值之间的契约进行编码：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:115
#, no-wrap
msgid ""
"data SameSchema : (s1 : Schema) -> (s2 : Schema) -> Type where\n"
"  Same : SameSchema s s\n"
msgstr ""
"data SameSchema : (s1 : Schema) -> (s2 : Schema) -> Type where\n"
"  Same : SameSchema s s\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:124
#, no-wrap
msgid ""
"First, note how `SameSchema` is a family of types indexed over two\n"
"values of type `Schema`. But note also that the sole constructor\n"
"restricts the values we allow for `s1` and `s2`: The two indices\n"
"*must* be identical.\n"
msgstr "首先，请注意 `SameSchema` 是通过两个 `Schema` 类型的值索引的类型族。但还要注意，唯一的构造函数限制了我们允许 `s1` 和 `s2` 的值：两个索引 *必须* 相同。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:128
#, no-wrap
msgid ""
"Why is this useful? Well, imagine we had a function for checking\n"
"the equality of two schemata, which would try and return a value\n"
"of type `SameSchema s1 s2`:\n"
msgstr "为什么这很有用？好吧，假设我们有一个检查两个 schemata 是否相等的函数，它会尝试返回一个类型为 `SameSchema s1 s2` 的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:129
#, no-wrap
msgid "sameSchema : (s1, s2 : Schema) -> Maybe (SameSchema s1 s2)\n"
msgstr "sameSchema : (s1, s2 : Schema) -> Maybe (SameSchema s1 s2)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:134
#, no-wrap
msgid "We could then use this function to implement `concatTables`:\n"
msgstr "然后我们可以使用这个函数来实现 `concatTables`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:135
#, no-wrap
msgid ""
"concatTables : Table -> Table -> Maybe Table\n"
"concatTables (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 of\n"
"  Just Same => Just $ MkTable s1 _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"
msgstr ""
"concatTables : Table -> Table -> Maybe Table\n"
"concatTables (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 of\n"
"  Just Same => Just $ MkTable s1 _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:143
#, no-wrap
msgid "It worked! What's going on here? Well, let's inspect the types involved:\n"
msgstr "有效！这里发生了什么？好吧，让我们检查一下所涉及的类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:144
#, no-wrap
msgid ""
"concatTables2 : Table -> Table -> Maybe Table\n"
"concatTables2 (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 of\n"
"  Just Same => ?almost_there\n"
"  Nothing   => Nothing\n"
msgstr ""
"concatTables2 : Table -> Table -> Maybe Table\n"
"concatTables2 (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 of\n"
"  Just Same => ?almost_there\n"
"  Nothing   => Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:152
#, no-wrap
msgid "At the REPL, we get the following context for `almost_there`:\n"
msgstr "在 REPL 中，我们得到 `almost_there` 的以下上下文：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:153
#, no-wrap
msgid ""
"Tutorial.Relations> :t almost_there\n"
"   m : Nat\n"
"   s2 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s2))\n"
"   n : Nat\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"   s1 : List ColType\n"
"------------------------------\n"
"almost_there : Maybe Table\n"
msgstr ""
"Tutorial.Relations> :t almost_there\n"
"   m : Nat\n"
"   s2 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s2))\n"
"   n : Nat\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"   s1 : List ColType\n"
"------------------------------\n"
"almost_there : Maybe Table\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:168
#, no-wrap
msgid ""
"See, how the types of `rs1` and `rs2` unify? Value `Same`, coming as the\n"
"result of `sameSchema s1 s2`, is a *witness* that `s1` and `s2` are actually\n"
"identical, because this is what we specified in the definition of `Same`.\n"
msgstr "看看，`rs1` 和 `rs2` 的类型是怎么统一的？值 `Same`，作为 `sameSchema s1 s2` 的结果， `s1` 和 `s2` 是实际上相同的 *见证*，因为这是我们在 `Same` 的定义中指定的。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:172
#, no-wrap
msgid ""
"All that remains to do is to implement `sameSchema`. For this, we will write\n"
"another data type for specifying when two values of type `ColType` are\n"
"identical:\n"
msgstr "剩下要做的就是实现`sameSchema`。为此，我们将编写另一种数据类型，用于指定 `ColType` 类型的两个值何时相同：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:173
#, no-wrap
msgid ""
"data SameColType : (c1, c2 : ColType) -> Type where\n"
"  SameCT : SameColType c1 c1\n"
msgstr ""
"data SameColType : (c1, c2 : ColType) -> Type where\n"
"  SameCT : SameColType c1 c1\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:180
#, no-wrap
msgid ""
"We can now define several utility functions. First, one for figuring out\n"
"if two column types are identical:\n"
msgstr "我们现在可以定义几个工具函数。首先，用于确定两个列类型是否相同：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:181
#, no-wrap
msgid ""
"sameColType : (c1, c2 : ColType) -> Maybe (SameColType c1 c2)\n"
"sameColType I64     I64     = Just SameCT\n"
"sameColType Str     Str     = Just SameCT\n"
"sameColType Boolean Boolean = Just SameCT\n"
"sameColType Float   Float   = Just SameCT\n"
"sameColType _ _             = Nothing\n"
msgstr ""
"sameColType : (c1, c2 : ColType) -> Maybe (SameColType c1 c2)\n"
"sameColType I64     I64     = Just SameCT\n"
"sameColType Str     Str     = Just SameCT\n"
"sameColType Boolean Boolean = Just SameCT\n"
"sameColType Float   Float   = Just SameCT\n"
"sameColType _ _             = Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:195
#, no-wrap
msgid ""
"This will convince Idris, because in each pattern match, the return\n"
"type will be adjusted according to the values we matched on. For instance,\n"
"on the first line, the output type is `Maybe (SameColType I64 I64)` as\n"
"you can easily verify yourself by inserting a hole and checking its\n"
"type at the REPL.\n"
msgstr "这将说服 Idris，因为在每个模式匹配中，返回类型将根据我们匹配的值进行调整。例如，在第一行，输出类型是 `Maybe (SameColType I64 I64)`，因为您可以自己通过插入一个孔并在 REPL 中检查其类型来轻松验证。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:203
#, no-wrap
msgid ""
"We will need two additional utilities: Functions for creating values\n"
"of type `SameSchema` for the nil and cons cases. Please note, how\n"
"the implementations are trivial. Still, we often have to quickly\n"
"write such small proofs (I'll explain in the next section, why I\n"
"call them *proofs*), which will then be used to convince the\n"
"type checker about some fact we already take for granted but Idris\n"
"does not.\n"
msgstr "我们将需要两个额外的实用程序： 用于为 nil 和 cons 情况创建 `SameSchema` 类型值的函数。请注意，实现是多么微不足道。尽管如此，我们还是经常不得不快速写出这么小的证明（我将在下一节解释，为什么我称它们为 *证明*），然后用来让类型检查器相信我们已经采取的一些事实是理所当然但 Idris 不知道的。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:204
#, no-wrap
msgid ""
"sameNil : SameSchema [] []\n"
"sameNil = Same\n"
"\n"
"sameCons :  SameColType c1 c2\n"
"         -> SameSchema s1 s2\n"
"         -> SameSchema (c1 :: s1) (c2 :: s2)\n"
"sameCons SameCT Same = Same\n"
msgstr ""
"sameNil : SameSchema [] []\n"
"sameNil = Same\n"
"\n"
"sameCons :  SameColType c1 c2\n"
"         -> SameSchema s1 s2\n"
"         -> SameSchema (c1 :: s1) (c2 :: s2)\n"
"sameCons SameCT Same = Same\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:221
#, no-wrap
msgid ""
"As usual, it can help understanding what's going on by replacing\n"
"the right hand side of `sameCons` with a hole an check out its\n"
"type and context at the REPL. The presence of values `SameCT`\n"
"and `Same` on the left hand side forces Idris to unify `c1` and `c2`\n"
"as well as `s1` and `s2`, from which the unification of\n"
"`c1 :: s1` and `c2 :: s2` immediately follows.\n"
"With these, we can finally implement `sameSchema`:\n"
msgstr "像往常一样，它可以通过将 `sameCons` 的右侧替换为一个孔并在 REPL 中检查其类型和上下文来帮助理解发生了什么。左侧存在值 `SameCT` 和 `Same` 迫使 Idris 统一 `c1` 和 `c2` 以及 `s1 ` 和 `s2`，紧接着是 `c1 :: s1` 和 `c2 :: s2` 的统一。有了这些，我们终于可以实现`sameSchema`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:222
#, no-wrap
msgid ""
"sameSchema []        []        = Just sameNil\n"
"sameSchema (x :: xs) (y :: ys) =\n"
"  [| sameCons (sameColType x y) (sameSchema xs ys) |]\n"
"sameSchema (x :: xs) []        = Nothing\n"
"sameSchema []        (x :: xs) = Nothing\n"
msgstr ""
"sameSchema []        []        = Just sameNil\n"
"sameSchema (x :: xs) (y :: ys) =\n"
"  [| sameCons (sameColType x y) (sameSchema xs ys) |]\n"
"sameSchema (x :: xs) []        = Nothing\n"
"sameSchema []        (x :: xs) = Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:238
#, no-wrap
msgid ""
"What we described here is a far stronger form of equality\n"
"than what is provided by interface `Eq` and the `(==)`\n"
"operator: Equality of values that is accepted by the\n"
"type checker when trying to unify type level indices.\n"
"This is also called *propositional equality*: We will see\n"
"below, that we can view types as mathematical *propositions*,\n"
"and values of these types a *proofs* that these propositions\n"
"hold.\n"
msgstr "我们在这里描述的是一种比接口 `Eq` 和 `(==)` 运算符提供的更强大的相等形式：类型检查器在尝试时接受的值相等统一类型级索引。这也称为 *命题等式*：我们将在下面看到，我们可以将类型视为数学 *命题*，这些类型的值是这些命题所持有的 *证明* .\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:239
#, no-wrap
msgid "Type `Equal`"
msgstr "`Equal` 类型"

#. type: Plain text
#: ../src/Tutorial/Eq.md:251
#, no-wrap
msgid ""
"Propositional equality is such a fundamental concept, that the *Prelude*\n"
"exports a general data type for this already: `Equal`, with its only\n"
"data constructor `Refl`. In addition, there is a built-in operator\n"
"for expressing propositional equality, which gets desugared to `Equal`:\n"
"`(=)`. This can sometimes lead to some confusion, because the equals\n"
"symbol is also used for *definitional equality*: Describing in function\n"
"implementations that the left-hand side and right-hand side are\n"
"defined to be equal. If you want to disambiguate propositional from\n"
"definitional equality, you can also use operator `(===)` for the\n"
"former.\n"
msgstr "命题等式是一个基本概念，以至于 *Prelude* 已经为此导出了一个通用数据类型：`Equal`，以及它唯一的数据构造函数 `Refl`。此外，还有一个用于表达命题相等的内置运算符，它被脱糖为 `Equal`：`(=)`。这有时会导致一些混淆，因为等号也用于*相等定义*：在函数实现中描述左侧和右侧被定义为相等。如果您想从定义相等中消除命题的歧义，您还可以使用运算符 `(===)` 来表示前者。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:253
#, no-wrap
msgid "Here is another implementation of `concatTables`:\n"
msgstr "这是 `concatTables` 的另一个实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:254
#, no-wrap
msgid ""
"eqColType : (c1,c2 : ColType) -> Maybe (c1 = c2)\n"
"eqColType I64     I64     = Just Refl\n"
"eqColType Str     Str     = Just Refl\n"
"eqColType Boolean Boolean = Just Refl\n"
"eqColType Float   Float   = Just Refl\n"
"eqColType _ _             = Nothing\n"
"\n"
"eqCons :  {0 c1,c2 : a}\n"
"       -> {0 s1,s2 : List a}\n"
"       -> c1 = c2 -> s1 = s2 ->  c1 :: s1 = c2 :: s2\n"
"eqCons Refl Refl = Refl\n"
"\n"
"eqSchema : (s1,s2 : Schema) -> Maybe (s1 = s2)\n"
"eqSchema []        []        = Just Refl\n"
"eqSchema (x :: xs) (y :: ys) = [| eqCons (eqColType x y) (eqSchema xs ys) |]\n"
"eqSchema (x :: xs) []        = Nothing\n"
"eqSchema []        (x :: xs) = Nothing\n"
"\n"
"concatTables3 : Table -> Table -> Maybe Table\n"
"concatTables3 (MkTable s1 m rs1) (MkTable s2 n rs2) = case eqSchema s1 s2 of\n"
"  Just Refl => Just $ MkTable _ _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"
msgstr ""
"eqColType : (c1,c2 : ColType) -> Maybe (c1 = c2)\n"
"eqColType I64     I64     = Just Refl\n"
"eqColType Str     Str     = Just Refl\n"
"eqColType Boolean Boolean = Just Refl\n"
"eqColType Float   Float   = Just Refl\n"
"eqColType _ _             = Nothing\n"
"\n"
"eqCons :  {0 c1,c2 : a}\n"
"       -> {0 s1,s2 : List a}\n"
"       -> c1 = c2 -> s1 = s2 ->  c1 :: s1 = c2 :: s2\n"
"eqCons Refl Refl = Refl\n"
"\n"
"eqSchema : (s1,s2 : Schema) -> Maybe (s1 = s2)\n"
"eqSchema []        []        = Just Refl\n"
"eqSchema (x :: xs) (y :: ys) = [| eqCons (eqColType x y) (eqSchema xs ys) |]\n"
"eqSchema (x :: xs) []        = Nothing\n"
"eqSchema []        (x :: xs) = Nothing\n"
"\n"
"concatTables3 : Table -> Table -> Maybe Table\n"
"concatTables3 (MkTable s1 m rs1) (MkTable s2 n rs2) = case eqSchema s1 s2 of\n"
"  Just Refl => Just $ MkTable _ _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:285
#, no-wrap
msgid ""
"In the following exercises, you are going to implement\n"
"some very basic properties of equality proofs. You'll\n"
"have to come up with the types of the functions yourself,\n"
"as the implementations will be incredibly simple.\n"
msgstr "在接下来的练习中，您将实现等式证明的一些非常基本的属性。您必须自己提出函数的类型，因为实现将非常简单。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:289
#, no-wrap
msgid ""
"Note: If you can't remember what the terms \"reflexive\",\n"
"\"symmetric\", and \"transitive\" mean, quickly read about\n"
"equivalence relations [here](https://en.wikipedia.org/wiki/Equivalence_relation).\n"
msgstr "注意：如果您不记得术语“自反”、“对称”和“传递”的含义，请快速阅读关于等价关系的内容 [此处](https://en.wikipedia.org/wiki/Equivalence_relation)。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:291
#, no-wrap
msgid "Show that `SameColType` is a reflexive relation.\n"
msgstr "证明 `SameColType` 是自反关系。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:293
#, no-wrap
msgid "Show that `SameColType` is a symmetric relation.\n"
msgstr "证明 `SameColType` 是一个对称关系。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:295
#, no-wrap
msgid "Show that `SameColType` is a transitive relation.\n"
msgstr "证明 `SameColType` 是传递关系。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:299
#, no-wrap
msgid ""
"Let `f` be a function of type `ColType -> a` for an\n"
"arbitrary type `a`. Show that from a value of type\n"
"`SameColType c1 c2` follows that `f c1` and `f c2` are equal.\n"
msgstr ""
"对于任意类型 `a`，令 `f` 为 `ColType -> a` 类型的函数。证明从 `SameColType "
"c1 c2` 类型的值得出 `f c1` 和 `f c2` 相等。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:303
#, no-wrap
msgid ""
"For `(=)` the above properties are available from the *Prelude*\n"
"as functions `sym`, `trans`, and `cong`. Reflexivity comes\n"
"from the data constructor `Refl` itself.\n"
msgstr "对于 `(=)`，上述属性可从 *Prelude* 作为函数 `sym`、`trans` 和 `cong` 获得.自反性来自数据构造函数 `Refl` 本身。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:307
#, no-wrap
msgid ""
"Implement a function for verifying that two natural\n"
"numbers are identical. Try using `cong` in your\n"
"implementation.\n"
msgstr "实现一个函数来验证两个自然数是否相同。尝试在您的实现中使用 `cong`。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:310
#, no-wrap
msgid ""
"Use the function from exercise 5 for zipping two\n"
"`Table`s if they have the same number of rows.\n"
msgstr "如果两个 `Table` 的行数相同，请使用练习 5 中的函数压缩它们。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:315
#, no-wrap
msgid ""
"   Hint: Use `Vect.zipWith`. You will need to implement\n"
"   custom function `appRows` for this, since Idris will\n"
"   not automatically figure out that the types unify when\n"
"   using `HList.(++)`:\n"
msgstr ""
"   提示：使用 `Vect.zipWith`。您将需要为此实现\n"
"   自定义函数 `appRows`，因为使用 `HList.(++)` 时 Idris 将\n"
"   不会自动确定类型何时统一 ：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:316
#, no-wrap
msgid "   appRows : {ts1 : _} -> Row ts1 -> Row ts2 -> Row (ts1 ++ ts2)\n"
msgstr "   appRows : {ts1 : _} -> Row ts1 -> Row ts2 -> Row (ts1 ++ ts2)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:323
#, no-wrap
msgid ""
"We will later learn how to use *rewrite rules* to circumvent\n"
"the need of writing custom functions like `appRows` and use\n"
"`(++)` in `zipWith` directly.\n"
msgstr "稍后我们将学习如何使用 *重写规则* 来规避编写自定义函数的需要，例如 `appRows` ，并在 `zipWith` 中直接使用 `(++)` 。\n"

#. type: Title ##
#: ../src/Tutorial/Eq.md:324
#, no-wrap
msgid "Programs as Proofs"
msgstr "程序作为证明"

#. type: Plain text
#: ../src/Tutorial/Eq.md:333
#, no-wrap
msgid ""
"A famous observation by mathematician *Haskell Curry* and\n"
"logician *William Alvin Howard* leads to the conclusion,\n"
"that we can view a *type* in a programming language with\n"
"a sufficiently rich type system as a mathematical proposition\n"
"and a total program calculating a *value* of this type as a\n"
"proof that the proposition holds. This is also known as the\n"
"[Curry-Howard isomorphism](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence).\n"
msgstr "数学家 *Haskell Curry* 和逻辑学家 *William Alvin Howard* 的著名观察得出的结论是，我们可以在具有足够丰富类型的编程语言中查看 *类型*系统作为一个数学命题和一个计算这种类型的*值*的完全程序作为命题成立的证明。这也称为 [Curry-Howard 同构](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence)。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:336
#, no-wrap
msgid ""
"For instance, here is a simple proof that one plus one\n"
"equals two:\n"
msgstr "例如，这里有一个简单的证明，证明一加一等于二：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:337
#, no-wrap
msgid ""
"onePlusOne : the Nat 1 + 1 = 2\n"
"onePlusOne = Refl\n"
msgstr ""
"onePlusOne : the Nat 1 + 1 = 2\n"
"onePlusOne = Refl\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:346
#, no-wrap
msgid ""
"The above proof is trivial, as Idris solves this by unification.\n"
"But we already stated some more interesting things in the\n"
"exercises. For instance, the symmetry and transitivity of\n"
"`SameColType`:\n"
msgstr "上面的证明是微不足道的，因为 Idris 通过统一解决了这个问题。但是我们已经在练习中陈述了一些更有趣的事情。例如 `SameColType` 的对称性和传递性：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:347
#, no-wrap
msgid ""
"sctSymmetric : SameColType c1 c2 -> SameColType c2 c1\n"
"sctSymmetric SameCT = SameCT\n"
"\n"
"sctTransitive : SameColType c1 c2 -> SameColType c2 c3 -> SameColType c1 c3\n"
"sctTransitive SameCT SameCT = SameCT\n"
msgstr ""
"sctSymmetric : SameColType c1 c2 -> SameColType c2 c1\n"
"sctSymmetric SameCT = SameCT\n"
"\n"
"sctTransitive : SameColType c1 c2 -> SameColType c2 c3 -> SameColType c1 c3\n"
"sctTransitive SameCT SameCT = SameCT\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:357
#, no-wrap
msgid ""
"Note, that a type alone is not a proof. For instance, we are free\n"
"to state that one plus one equals three:\n"
msgstr "请注意，单独的类型不是证明。例如，我们可以自由地说一加一等于三：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:358
#, no-wrap
msgid "onePlusOneWrong : the Nat 1 + 1 = 3\n"
msgstr "onePlusOneWrong : the Nat 1 + 1 = 3\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:365
#, no-wrap
msgid ""
"We will, however, have a hard time implementing this in a provably\n"
"total way. We say: \"The type `the Nat 1 + 1 = 3` is *uninhabited*\",\n"
"meaning, that there is no value of this type.\n"
msgstr "然而，我们将很难以可证明的整体方式实现这一点。我们说：“类型 `the Nat 1 + 1 = 3` 是 *uninhabited*”，意思是这个类型没有值。\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:366
#, no-wrap
msgid "When Proofs replace Tests"
msgstr "当证明取代测试时"

#. type: Plain text
#: ../src/Tutorial/Eq.md:373
#, no-wrap
msgid ""
"We will see several different use cases for compile time proofs, a\n"
"very straight forward one being to show that our functions behave\n"
"as they should by proofing some properties about them. For instance,\n"
"here is a proposition that `map` on list does not change the number of\n"
"elements in the list:\n"
msgstr "我们将看到几个不同的编译时证明用例，一个非常直接的用例是通过证明我们的函数的一些属性来证明我们的函数行为应该如此。例如，这里有一个命题，列表上的 `map` 不会改变列表中元素的数量：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:374
#, no-wrap
msgid "mapListLength : (f : a -> b) -> (as : List a) -> length as = length (map f as)\n"
msgstr "mapListLength : (f : a -> b) -> (as : List a) -> length as = length (map f as)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:381
#, no-wrap
msgid ""
"Read this as a universally quantified statement: For all functions `f`\n"
"from `a` to `b` and for all lists `as` holding values of type `a`,\n"
"the length of `map f as` is the same the as the length of the original list.\n"
msgstr "将此视为一个普遍量化的陈述：对于从 `a` 到 `b` 的所有函数 `f` 以及所有包含 `as` 类型值的列表 `a`，`map f as`的长度与原始列表的长度相同。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:387
#, no-wrap
msgid ""
"We can implement `mapListLength` by pattern matching on `as`. The `Nil` case\n"
"will be trivial: Idris solves this by unification. It knows the value of the\n"
"input list (`Nil`), and since `map` is implemented by pattern matching on\n"
"the input as well, it follows immediately that the result will be `Nil` as\n"
"well:\n"
msgstr "我们可以通过在 `as` 上进行模式匹配来实现 `mapListLength`。 `Nil` 的情况很简单：Idris 通过统一解决了这个问题。它知道输入列表的值 (`Nil`)，并且由于 `map` 也是通过对输入的模式匹配实现的，因此立即得出结果将为 `Nil ` ，所以：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:388
#, no-wrap
msgid "mapListLength f []        = Refl\n"
msgstr "mapListLength f []        = Refl\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:395
#, no-wrap
msgid ""
"The `cons` case is more involved, and we will do this stepwise.\n"
"First, note that we can proof that the length of a map over the\n"
"tail will stay the same by means of recursion:\n"
msgstr "`cons` 的情况比较复杂，我们将逐步进行。首先，请注意，我们可以通过递归证明映射在尾部的长度将保持不变：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:397
#, no-wrap
msgid ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => ?mll1\n"
msgstr ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => ?mll1\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:403
#, no-wrap
msgid "Let's inspect the types and context we have here:\n"
msgstr "让我们检查一下我们在这里拥有的类型和上下文：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:404
#, no-wrap
msgid ""
" 0 b : Type\n"
" 0 a : Type\n"
"   xs : List a\n"
"   f : a -> b\n"
"   x : a\n"
"   prf : length xs = length (map f xs)\n"
"------------------------------\n"
"mll1 : S (length xs) = S (length (map f xs))\n"
msgstr ""
" 0 b : Type\n"
" 0 a : Type\n"
"   xs : List a\n"
"   f : a -> b\n"
"   x : a\n"
"   prf : length xs = length (map f xs)\n"
"------------------------------\n"
"mll1 : S (length xs) = S (length (map f xs))\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:422
#, no-wrap
msgid ""
"So, we have a proof of type `length xs = length (map f xs)`,\n"
"and from the implementation of `map` Idris concludes that what\n"
"we are actually looking for is a result of type\n"
"`S (length xs) = S (length (map f xs))`. This is exactly what\n"
"function `cong` from the *Prelude* is for (\"cong\" is an abbreviation\n"
"for *congruence*). We can thus implement the *cons* case\n"
"concisely like so:\n"
msgstr "所以，我们有一个类型 `length xs = length (map f xs)` 的证明，并且从 `map` 的实现 Idris 得出结论，我们真正要寻找的是类型的结果`S (length xs) = S (length (map f xs))`。这正是 *Prelude* 中的函数 `cong` 的用途（“cong”是 *congruence* 的缩写）。因此，我们可以像这样简洁地实现 *cons* 案例：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:423
#, no-wrap
msgid "mapListLength f (x :: xs) = cong S $ mapListLength f xs\n"
msgstr "mapListLength f (x :: xs) = cong S $ mapListLength f xs\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:431
#, no-wrap
msgid ""
"Please take a moment to appreciate what we achieved here:\n"
"A *proof* in the mathematical sense that our function will not\n"
"affect the length of our list. We no longer need a unit test\n"
"or similar program to verify this.\n"
msgstr "请花点时间欣赏一下我们在这里取得的成就：数学意义上的 *证明*，我们的函数不会影响列表的长度。我们不再需要单元测试或类似程序来验证这一点。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:435
#, no-wrap
msgid ""
"Before we continue, please note an important thing: In our\n"
"case expression, we used a *variable* for the result from the\n"
"recursive call:\n"
msgstr "在我们继续之前，请注意一件重要的事情：在我们的 case 表达式中，我们使用 *变量* 来表示递归调用的结果：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:436
#, no-wrap
msgid ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => cong S prf\n"
msgstr ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => cong S prf\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:448
#, no-wrap
msgid ""
"Here, we did not want the two lengths to unify, because we\n"
"needed the distinction in our call to `cong`. Therefore: If\n"
"you need a proof of type `x = y` in order for two variables\n"
"to unify, use the `Refl` data constructor in the pattern match.\n"
"If, on the other hand, you need to run further computations on\n"
"such a proof, use a variable and the left and right-hand sides\n"
"will remain distinct.\n"
msgstr "在这里，我们不希望这两个长度统一，因为我们需要在调用 `cong` 时加以区分。因此：如果您需要 `x = y` 类型的证明来统一两个变量，请在模式匹配中使用 `Refl` 数据构造函数。另一方面，如果您需要对这样的证明进行进一步的计算，请使用变量，并且左侧和右侧将保持不同。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:453
#, no-wrap
msgid ""
"Here is another example from the last chapter: We want to show\n"
"that parsing and printing column types behaves correctly.\n"
"Writing proofs about parsers can be very hard in general, but\n"
"here it can be done with a mere pattern match:\n"
msgstr "这是上一章的另一个例子：我们想证明解析和打印列类型的行为是正确的。一般来说，编写关于解析器的证明可能非常困难，但在这里可以仅通过模式匹配来完成：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:454
#, no-wrap
msgid ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"readColType : String -> Maybe ColType\n"
"readColType \"i64\"      = Just I64\n"
"readColType \"str\"      = Just Str\n"
"readColType \"boolean\"  = Just Boolean\n"
"readColType \"float\"    = Just Float\n"
"readColType s          = Nothing\n"
"\n"
"showReadColType : (c : ColType) -> readColType (showColType c) = Just c\n"
"showReadColType I64     = Refl\n"
"showReadColType Str     = Refl\n"
"showReadColType Boolean = Refl\n"
"showReadColType Float   = Refl\n"
msgstr ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"readColType : String -> Maybe ColType\n"
"readColType \"i64\"      = Just I64\n"
"readColType \"str\"      = Just Str\n"
"readColType \"boolean\"  = Just Boolean\n"
"readColType \"float\"    = Just Float\n"
"readColType s          = Nothing\n"
"\n"
"showReadColType : (c : ColType) -> readColType (showColType c) = Just c\n"
"showReadColType I64     = Refl\n"
"showReadColType Str     = Refl\n"
"showReadColType Boolean = Refl\n"
"showReadColType Float   = Refl\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:477
#, no-wrap
msgid ""
"Such simple proofs give us quick but strong guarantees\n"
"that we did not make any stupid mistakes.\n"
msgstr "这样简单的证明给了我们快速但有力的保证，我们没有犯任何愚蠢的错误。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:485
#, no-wrap
msgid ""
"The examples we saw so far were very easy to implement. In general,\n"
"this is not the case, and we will have to learn about several\n"
"additional techniques in order to proof interesting things about\n"
"our programs. However, when we use Idris as a general purpose\n"
"programming language and not as a proof assistant, we are free\n"
"to choose whether some aspect of our code needs such strong\n"
"guarantees or not.\n"
msgstr "到目前为止，我们看到的示例非常容易实现。一般来说，情况并非如此，我们将不得不学习一些额外的技术来证明我们程序的有趣之处。但是，当我们将 Idris 用作通用编程语言而不是用作证明助手时，我们可以自由选择代码的某些方面是否需要这种强有力的保证。\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:486
#, no-wrap
msgid "A Note of Caution: Lowercase Identifiers in Function Types"
msgstr "注意事项：函数类型中的小写标识符"

#. type: Plain text
#: ../src/Tutorial/Eq.md:494
#, no-wrap
msgid ""
"When writing down the types of proofs as we did above, one\n"
"has to be very careful not to fall into the following trap:\n"
"In general, Idris will treat lowercase identifiers in\n"
"function types as type parameters (erased implicit arguments).\n"
"For instance, here is a try at proofing the identity functor\n"
"law for `Maybe`:\n"
msgstr "在写下我们上面所做的证明类型时，必须非常小心不要落入以下陷阱：通常，Idris 会将函数类型中的小写标识符视为类型参数（已删除的隐式参数）。例如，这里尝试证明 `Maybe` 的恒等函子定律：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:495
#, no-wrap
msgid ""
"mapMaybeId1 : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
msgstr ""
"mapMaybeId1 : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:504
#, no-wrap
msgid ""
"You will not be able to implement the `Just` case, because\n"
"Idris treats `id` as an implicit argument as can easily be\n"
"seen when inspecting the context of `mapMaybeId1_rhs`:\n"
msgstr "您将无法实现 `Just` 案例，因为 Idris 将 `id` 视为隐式参数，这在检查 `mapMaybeId1_rhs` 的上下文时很容易看出：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:505
#, no-wrap
msgid ""
"Tutorial.Relations> :t mapMaybeId1_rhs\n"
" 0 a : Type\n"
" 0 id : a -> a\n"
"   x : a\n"
"------------------------------\n"
"mapMaybeId1_rhs : Just (id x) = Just x\n"
msgstr ""
"Tutorial.Relations> :t mapMaybeId1_rhs\n"
" 0 a : Type\n"
" 0 id : a -> a\n"
"   x : a\n"
"------------------------------\n"
"mapMaybeId1_rhs : Just (id x) = Just x\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:517
#, no-wrap
msgid ""
"As you can see, `id` is an erased argument of type `a -> a`. And in\n"
"fact, when type-checking this module, Idris will issue a warning that\n"
"parameter `id` is shadowing an existing function:\n"
msgstr "如您所见，`id` 是 `a -> a` 类型的已擦除参数。事实上，在对该模块进行类型检查时，Idris 会发出警告，指出参数 `id` 正在隐藏现有函数：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:518
#, no-wrap
msgid ""
"Warning: We are about to implicitly bind the following lowercase names.\n"
"You may be unintentionally shadowing the associated global definitions:\n"
"  id is shadowing Prelude.Basics.id\n"
msgstr ""
"警告：我们即将隐式绑定以下小写名称。\n"
"您可能无意中隐藏了相关的全局定义：\n"
"  id 正在影响 Prelude.Basics.id\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:527
#, no-wrap
msgid ""
"The same is not true for `map`: Since we explicitly pass arguments\n"
"to `map`, Idris treats this as a function name and not as an\n"
"implicit argument.\n"
msgstr "`map` 的情况并非如此：由于我们将参数显式传递给 `map`，Idris 将其视为函数名而不是隐式参数。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:530
#, no-wrap
msgid ""
"You have several options here. For instance, you could use an uppercase\n"
"identifier, as these will never be treated as implicit arguments:\n"
msgstr "您在这里有几个选择。例如，您可以使用大写标识符，因为这些标识符永远不会被视为隐式参数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:531
#, no-wrap
msgid ""
"Id : a -> a\n"
"Id = id\n"
"\n"
"mapMaybeId2 : (ma : Maybe a) -> map Id ma = ma\n"
"mapMaybeId2 Nothing  = Refl\n"
"mapMaybeId2 (Just x) = Refl\n"
msgstr ""
"Id : a -> a\n"
"Id = id\n"
"\n"
"mapMaybeId2 : (ma : Maybe a) -> map Id ma = ma\n"
"mapMaybeId2 Nothing  = Refl\n"
"mapMaybeId2 (Just x) = Refl\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:543
#, no-wrap
msgid ""
"As an alternative - and this is the preferred way to handle this case -\n"
"you can prefix `id` with part of its namespace, which will immediately\n"
"resolve the issue:\n"
msgstr "作为替代方案 - 这是处理这种情况的首选方式 - 您可以在 `id` 前加上其命名空间的一部分，这将立即解决问题：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:544
#, no-wrap
msgid ""
"mapMaybeId : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId Nothing  = Refl\n"
"mapMaybeId (Just x) = Refl\n"
msgstr ""
"mapMaybeId : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId Nothing  = Refl\n"
"mapMaybeId (Just x) = Refl\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:554
#, no-wrap
msgid ""
"Note: If you have semantic highlighting turned on in your editor\n"
"(for instance, by using the [idris2-lsp plugin](https://github.com/idris-community/idris2-lsp)),\n"
"you will note that `map` and `id` in `mapMaybeId1` get\n"
"highlighted differently: `map` as a function name, `id` as a bound variable.\n"
msgstr "注意：如果您在编辑器中打开了语义突出显示（例如，通过使用 [idris2-lsp 插件](https://github.com/idris-community/idris2-lsp)），您会注意到 `mapMaybeId1` 中的 `map` 和 `id` 以不同的方式突出显示：`map` 作为函数名称，`id` 作为绑定变量。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:562
#, no-wrap
msgid ""
"In these exercises, you are going to proof several simple properties\n"
"of small functions. When writing proofs, it is even more important\n"
"to use holes to figure out what Idris expects from you next. Use\n"
"the tools given to you, instead of trying to find your way in the\n"
"dark!\n"
msgstr "在这些练习中，您将证明小函数的几个简单属性。在编写证明时，更重要的是利用漏洞来弄清楚 Idris 下一步对你的期望。使用提供给您的工具，而不是试图在黑暗中找到自己的方式！\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:564
#, no-wrap
msgid "Proof that `map id` on an `Either e` returns the value unmodified.\n"
msgstr "证明 `Either e` 上的 `map id` 返回未修改的值。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:566
#, no-wrap
msgid "Proof that `map id` on a list returns the list unmodified.\n"
msgstr "证明列表上的 `map id` 返回未修改的列表。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:570
#, no-wrap
msgid ""
"Proof that complementing a strand of a nucleobase\n"
"(see the [previous chapter](DPair.md#use-case-nucleic-acids))\n"
"twice leads to the original strand.\n"
msgstr "证明补充一条核碱基链（参见 [上一章](DPair.md#use-case-nucleic-acids)）两次 "
"leads 为原来的链。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:574
#, no-wrap
msgid ""
"   Hint: Proof this for single bases first, and use `cong2`\n"
"   from the *Prelude* in your implementation for sequences\n"
"   of nucleic acids.\n"
msgstr "   提示：首先对单碱基进行证明，然后在核酸序列的实现中使用 *Prelude* 中的`cong2`。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:576
#, no-wrap
msgid "Implement function `replaceVect`:\n"
msgstr "实现函数 `replaceVect`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:577
#, no-wrap
msgid "   replaceVect : (ix : Fin n) -> a -> Vect n a -> Vect n a\n"
msgstr "   replaceVect : (ix : Fin n) -> a -> Vect n a -> Vect n a\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:584
#, no-wrap
msgid ""
"   Now proof, that after replacing an element in a vector\n"
"   using `replaceAt` accessing the same element using\n"
"   `index` will return the value we just added.\n"
msgstr ""
"   现在证明，在替换向量中的元素之后\n"
"   使用 `replaceAt` 访问相同的元素\n"
"   `index` 将返回我们刚刚添加的值。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:586
#, no-wrap
msgid "Implement function `insertVect`:\n"
msgstr "实现函数 `insertVect`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:587
#, no-wrap
msgid "   insertVect : (ix : Fin (S n)) -> a -> Vect n a -> Vect (S n) a\n"
msgstr "   insertVect : (ix : Fin (S n)) -> a -> Vect n a -> Vect (S n) a\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:593
#, no-wrap
msgid ""
"   Use a similar proof as in exercise 4 to show that this\n"
"   behaves correctly.\n"
msgstr ""
"   使用与练习 4 中类似的证明来证明\n"
"   行为正确。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:596
#, no-wrap
msgid ""
"Note: Functions `replaceVect` and `insertVect` are available\n"
"from `Data.Vect` as `replaceAt` and `insertAt`.\n"
msgstr "注意：函数 `replaceVect` 和 `insertVect` 可从 `Data.Vect` 作为 `replaceAt` 和 `insertAt` 获得。\n"

#. type: Title ##
#: ../src/Tutorial/Eq.md:597
#, no-wrap
msgid "Into the Void"
msgstr "进入虚空"

#. type: Plain text
#: ../src/Tutorial/Eq.md:612
#, no-wrap
msgid ""
"Remember function `onePlusOneWrong` from above? This was definitely\n"
"a wrong statement: One plus one does not equal three. Sometimes,\n"
"we want to express exactly this: That a certain statement is false\n"
"and does not hold. Consider for a moment what it means to proof\n"
"a statement in Idris: Such a statement (or proposition) is a\n"
"type, and a proof of the statement is a value or expression of\n"
"this type: The type is said to be *inhabited*.\n"
"If a statement is not true, there can be no value\n"
"of the given type. We say, the given type is *uninhabited*.\n"
"If we still manage to get our hands on a value of an uninhabited\n"
"type, that is a logical contradiction and from this, anything\n"
"follows (remember\n"
"[ex falso quodlibet](https://en.wikipedia.org/wiki/Principle_of_explosion)).\n"
msgstr "还记得上面的函数 `onePlusOneWrong` 吗？这绝对是一个错误的说法：一加一不等于三。有时，我们想准确地表达这一点：某个陈述是错误的并且不成立。考虑一下在 Idris 中证明一个陈述意味着什么：这样一个陈述（或命题）是一种类型，并且该陈述的证明是这种类型的一个值或表达式：该类型被称为 *有人居住的*。如果陈述不正确，则不能有给定类型的值。我们说，给定的类型是 *无人居住的*。如果我们仍然设法获得一个无人居住类型的值，这是一个逻辑矛盾，因此，任何事情都会随之而来（记住 [ex falso quodlibet](https://en.wikipedia.org/wiki/Principle_of_explosion)） .\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:617
#, no-wrap
msgid ""
"So this is how to express that a proposition does not hold: We\n"
"state that if it *would* hold, this would lead to a contradiction.\n"
"The most natural way to express a contradiction in Idris is\n"
"to return a value of type `Void`:\n"
msgstr "所以这就是如何表达一个命题不成立：我们声明如果它 *会* 成立，这将导致矛盾。在 Idris 中表达矛盾最自然的方式是返回一个 `Void` 类型的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:618
#, no-wrap
msgid ""
"onePlusOneWrongProvably : the Nat 1 + 1 = 3 -> Void\n"
"onePlusOneWrongProvably Refl impossible\n"
msgstr ""
"onePlusOneWrongProvably : the Nat 1 + 1 = 3 -> Void\n"
"onePlusOneWrongProvably Refl impossible\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:628
#, no-wrap
msgid ""
"See how this is a provably total implementation of the\n"
"given type: A function from `1 + 1 = 3` to `Void`. We\n"
"implement this by pattern matching, and there is only\n"
"one constructor to match on, which leads to an impossible\n"
"case.\n"
msgstr "看看这是如何证明给定类型的完整实现：从 `1 + 1 = 3` 到 `Void` 的函数。我们通过模式匹配来实现这一点，并且只有一个构造函数可以匹配，这导致了一种不可能的情况。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:633
#, no-wrap
msgid ""
"We can also use contradictory statements to proof other such\n"
"statements. For instance, here is a proof that if the lengths\n"
"of two lists are not the same, then the two list can't be\n"
"the same either:\n"
msgstr "我们还可以使用相互矛盾的陈述来证明其他此类陈述。例如，这是一个证明，如果两个列表的长度不同，那么这两个列表也不可能相同：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:634
#, no-wrap
msgid ""
"notSameLength1 : (List.length as = length bs -> Void) -> as = bs -> Void\n"
"notSameLength1 f prf = f (cong length prf)\n"
msgstr ""
"notSameLength1 : (List.length as = length bs -> Void) -> as = bs -> Void\n"
"notSameLength1 f prf = f (cong length prf)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:642
#, no-wrap
msgid ""
"This is cumbersome to write and pretty hard to read, so there\n"
"is function `Not` in the prelude to express the same thing\n"
"more naturally:\n"
msgstr "这写起来很麻烦，读起来也很难，所以 prelude 中有函数`Not` 可以更自然地表达同样的事情：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:643
#, no-wrap
msgid ""
"notSameLength : Not (List.length as = length bs) -> Not (as = bs)\n"
"notSameLength f prf = f (cong length prf)\n"
msgstr ""
"notSameLength : Not (List.length as = length bs) -> Not (as = bs)\n"
"notSameLength f prf = f (cong length prf)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:651
#, no-wrap
msgid ""
"Actually, this is just a specialized version of the contraposition of\n"
"`cong`: If from `a = b` follows `f a = f b`, then from\n"
"`not (f a = f b)` follows `not (a = b)`:\n"
msgstr "实际上，这只是 `cong` 对偶的一个特殊版本：如果从 `a = b` 遵循 `f a = f b`，那么从 `not (f a = f b)` 遵循 `not (a = b)`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:652
#, no-wrap
msgid ""
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
msgstr ""
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:657
#, no-wrap
msgid "Interface `Uninhabited`"
msgstr "`Uninhabited` 接口"

#. type: Plain text
#: ../src/Tutorial/Eq.md:664
#, no-wrap
msgid ""
"There is an interface in the *Prelude* for uninhabited types: `Uninhabited`\n"
"with its sole function `uninhabited`. Have a look at its documentation at\n"
"the REPL. You will see, that there is already an impressive number\n"
"of implementations available, many of which involve data type\n"
"`Equal`.\n"
msgstr "*Prelude* 中有一个接口用于无人居住类型：`Uninhabited`，其唯一函数是`uninhabited`。在 REPL 中查看它的文档。您会看到，已经有大量可用的实现，其中许多涉及数据类型 `Equal`。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:667
#, no-wrap
msgid ""
"We can use `Uninhabited`, to for instance express that\n"
"the empty schema is not equal to a non-empty schema:\n"
msgstr "我们可以使用 `Uninhabited`，例如表示空模式不等于非空模式：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:668
#, no-wrap
msgid ""
"Uninhabited (SameSchema [] (h :: t)) where\n"
"  uninhabited Same impossible\n"
"\n"
"Uninhabited (SameSchema (h :: t) []) where\n"
"  uninhabited Same impossible\n"
msgstr ""
"Uninhabited (SameSchema [] (h :: t)) where\n"
"  uninhabited Same impossible\n"
"\n"
"Uninhabited (SameSchema (h :: t) []) where\n"
"  uninhabited Same impossible\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:678
#, no-wrap
msgid ""
"There is a related function you need to know about: `absurd`, which\n"
"combines `uninhabited` with `void`:\n"
msgstr "有一个相关的函数你需要知道：`absurd`，它结合了`uninhabited`和`void`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:679
#, no-wrap
msgid ""
"Tutorial.Eq> :printdef absurd\n"
"Prelude.absurd : Uninhabited t => t -> a\n"
"absurd h = void (uninhabited h)\n"
msgstr ""
"Tutorial.Eq> :printdef absurd\n"
"Prelude.absurd : Uninhabited t => t -> a\n"
"absurd h = void (uninhabited h)\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:685
#, no-wrap
msgid "Decidable Equality"
msgstr "可判定等式"

#. type: Plain text
#: ../src/Tutorial/Eq.md:703
#, no-wrap
msgid ""
"When we implemented `sameColType`, we got a proof that two\n"
"column types are indeed the same, from which we could figure out,\n"
"whether two schemata are identical. The types guarantee\n"
"we do not generate any false positives: If we generate a value\n"
"of type `SameSchema s1 s2`, we have a proof that `s1` and `s2`\n"
"are indeed identical.\n"
"However, `sameColType` and thus `sameSchema` could theoretically\n"
"still produce false negatives by returning `Nothing`\n"
"although the two values are identical. For instance,\n"
"we could implement `sameColType` in such a way that it\n"
"always returns `Nothing`. This would be in agreement with\n"
"the types, but definitely not what we want. So, here is\n"
"what we'd like to do in order to get yet stronger guarantees:\n"
"We'd either want to return a proof that the two schemata\n"
"are the same, or return a proof that the two schemata\n"
"are not the same. (Remember that `Not a` is an alias for `a -> Void`).\n"
msgstr "当我们实现 `sameColType` 时，我们得到了两个列类型确实相同的证据，由此我们可以确定两个模式是否相同。这些类型保证我们不会产生任何误报：如果我们产生一个类型为 `SameSchema s1 s2` 的值，我们就有证据证明 `s1` 和 `s2` 确实是完全相同的。但是，`sameColType` 和 `sameSchema` 理论上仍然可以通过返回 `Nothing` 来产生假阴性，尽管这两个值是相同的。例如，我们可以实现 `sameColType`，使其始终返回 `Nothing`。这将与类型一致，但绝对不是我们想要的。因此，为了获得更强有力的保证，我们想要做以下事情：我们要么想要返回两个模式相同的证明，要么返回两个模式不同的证明。 （记住 `Not a` 是 `a -> Void` 的别名）。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:708
#, no-wrap
msgid ""
"We call a property, which either holds or leads to a\n"
"contradiction a *decidable property*, and the *Prelude*\n"
"exports data type `Dec prop`, which encapsulates this\n"
"distinction.\n"
msgstr "我们将持有或导致矛盾的属性称为 *可判定属性*，而 *Prelude* 导出数据类型 `Dec prop`，它封装了这种区别。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:710
#, no-wrap
msgid "Here is a way to encode this for `ColType`:\n"
msgstr "这是为 `ColType` 编码的一种方法：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:711
#, no-wrap
msgid ""
"decSameColType :  (c1,c2 : ColType) -> Dec (SameColType c1 c2)\n"
"decSameColType I64 I64         = Yes SameCT\n"
"decSameColType I64 Str         = No $ \\case SameCT impossible\n"
"decSameColType I64 Boolean     = No $ \\case SameCT impossible\n"
"decSameColType I64 Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Str I64         = No $ \\case SameCT impossible\n"
"decSameColType Str Str         = Yes SameCT\n"
"decSameColType Str Boolean     = No $ \\case SameCT impossible\n"
"decSameColType Str Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Boolean I64     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Str     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Boolean = Yes SameCT\n"
"decSameColType Boolean Float   = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Float I64       = No $ \\case SameCT impossible\n"
"decSameColType Float Str       = No $ \\case SameCT impossible\n"
"decSameColType Float Boolean   = No $ \\case SameCT impossible\n"
"decSameColType Float Float     = Yes SameCT\n"
msgstr ""
"decSameColType :  (c1,c2 : ColType) -> Dec (SameColType c1 c2)\n"
"decSameColType I64 I64         = Yes SameCT\n"
"decSameColType I64 Str         = No $ \\case SameCT impossible\n"
"decSameColType I64 Boolean     = No $ \\case SameCT impossible\n"
"decSameColType I64 Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Str I64         = No $ \\case SameCT impossible\n"
"decSameColType Str Str         = Yes SameCT\n"
"decSameColType Str Boolean     = No $ \\case SameCT impossible\n"
"decSameColType Str Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Boolean I64     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Str     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Boolean = Yes SameCT\n"
"decSameColType Boolean Float   = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Float I64       = No $ \\case SameCT impossible\n"
"decSameColType Float Str       = No $ \\case SameCT impossible\n"
"decSameColType Float Boolean   = No $ \\case SameCT impossible\n"
"decSameColType Float Float     = Yes SameCT\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:741
#, no-wrap
msgid ""
"First, note how we could use a pattern match in a single\n"
"argument lambda directly. This is sometimes called the\n"
"*lambda case* style, named after an extension of the Haskell\n"
"programming language. If we use the `SameCT` constructor\n"
"in the pattern match, Idris is forced to try and unify for instance\n"
"`Float` with `I64`. This is not possible, so the case as\n"
"a whole is impossible.\n"
msgstr "首先，请注意我们如何直接在单个参数 lambda 中使用模式匹配。这有时被称为 *lambda case* 风格，以 Haskell 编程语言的扩展命名。如果我们在模式匹配中使用 `SameCT` 构造函数，Idris 将被迫尝试将 `Float` 与 `I64` 统一起来。这是不可能的，所以整个案例是不可能的。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:749
#, no-wrap
msgid ""
"Yet, this was pretty cumbersome to implement. In order to\n"
"convince Idris we did not miss a case,\n"
"there is no way around treating every possible pairing\n"
"of constructors explicitly.\n"
"However, we get *much* stronger guarantees out of this: We\n"
"can no longer create false positives *or* false negatives, and\n"
"therefore, `decSameColType` is provably correct.\n"
msgstr "然而，这实现起来相当麻烦。为了让 Idris 相信我们没有遗漏任何一个案例，没有办法明确地处理每个可能的构造函数配对。然而，我们 *必须* 得到更强的保证：我们不能再创建误报 *或* 误报，因此 `decSameColType` 可证明是正确的。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:752
#, no-wrap
msgid ""
"Doing the same thing for schemata requires some utility functions,\n"
"the types of which we can figure out by placing some holes:\n"
msgstr "对模式做同样的事情需要一些实用函数，我们可以通过放置一些孔来找出它们的类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:753
#, no-wrap
msgid ""
"decSameSchema' :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema' []        []        = Yes Same\n"
"decSameSchema' []        (y :: ys) = No ?decss1\n"
"decSameSchema' (x :: xs) []        = No ?decss2\n"
"decSameSchema' (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema' xs ys of\n"
"    Yes Same => Yes Same\n"
"    No  contra => No $ \\prf => ?decss3\n"
"  No  contra => No $ \\prf => ?decss4\n"
msgstr ""
"decSameSchema' :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema' []        []        = Yes Same\n"
"decSameSchema' []        (y :: ys) = No ?decss1\n"
"decSameSchema' (x :: xs) []        = No ?decss2\n"
"decSameSchema' (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema' xs ys of\n"
"    Yes Same => Yes Same\n"
"    No  contra => No $ \\prf => ?decss3\n"
"  No  contra => No $ \\prf => ?decss4\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:770
#, no-wrap
msgid ""
"The first two cases are not too hard. The type of `decss1` is\n"
"`SameSchema [] (y :: ys) -> Void`, which you can easily verify\n"
"at the REPL. But that's just `uninhabited`, specialized to\n"
"`SameSchema [] (y :: ys)`, and this we already implemented\n"
"further above. The same goes for `decss2`.\n"
msgstr "前两种情况并不难。 `decss1` 的类型是 `SameSchema [] (y :: ys) -> Void`，您可以在 REPL 轻松验证。但这只是 `uninhabited`，专门用于 `SameSchema [] (y :: ys)`，我们已经在上面进一步实现了这一点。 `decss2` 也是如此。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:777
#, no-wrap
msgid ""
"The other two cases are harder, so I already filled in as much stuff\n"
"as possible. We know that we want to return a `No`, if either the\n"
"heads or tails are provably distinct. The `No` holds a\n"
"function, so I already added a lambda, leaving a hole only for\n"
"the return value. Here are the type and - more important -\n"
"context of `decss3`:\n"
msgstr "其他两种情况比较难，所以我已经尽可能多地填写了。我们知道我们想要返回一个 `No`，如果可以证明正面或反面是不同的。 `No` 包含一个函数，所以我已经添加了一个 lambda，只为返回值留了一个洞。以下是 `decss3` 的类型和更重要的上下文：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:778
#, no-wrap
msgid ""
"Tutorial.Relations> :t decss3\n"
"   y : ColType\n"
"   xs : List ColType\n"
"   ys : List ColType\n"
"   x : ColType\n"
"   contra : SameSchema xs ys -> Void\n"
"   prf : SameSchema (y :: xs) (y :: ys)\n"
"------------------------------\n"
"decss3 : Void\n"
msgstr ""
"Tutorial.Relations> :t decss3\n"
"   y : ColType\n"
"   xs : List ColType\n"
"   ys : List ColType\n"
"   x : ColType\n"
"   contra : SameSchema xs ys -> Void\n"
"   prf : SameSchema (y :: xs) (y :: ys)\n"
"------------------------------\n"
"decss3 : Void\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:797
#, no-wrap
msgid ""
"The types of `contra` and `prf` are what we need here:\n"
"If `xs` and `ys` are distinct, then `y :: xs` and `y :: ys`\n"
"must be distinct as well. This is the contraposition of the\n"
"following statement: If `x :: xs` is the same as `y :: ys`,\n"
"then `xs` and `ys` are the same as well. We must therefore\n"
"implement a lemma, which proves that the *cons* constructor\n"
"is [*injective*](https://en.wikipedia.org/wiki/Injective_function):\n"
msgstr "`contra` 和 `prf` 的类型是我们这里需要的：如果 `xs` 和 `ys` 是不同的，那么 `y :: xs` 和 `y :: ys` 也必须不同。这是以下语句的对置：如果 `x :: xs` 与 `y :: ys` 相同，则 `xs` 和 `ys` 也一样。因此，我们必须实现一个引理，证明 *cons* 构造函数是 [*injective*](https://en.wikipedia.org/wiki/Injective_function)：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:798
#, no-wrap
msgid ""
"consInjective :  SameSchema (c1 :: cs1) (c2 :: cs2)\n"
"              -> (SameColType c1 c2, SameSchema cs1 cs2)\n"
"consInjective Same = (SameCT, Same)\n"
msgstr ""
"consInjective :  SameSchema (c1 :: cs1) (c2 :: cs2)\n"
"              -> (SameColType c1 c2, SameSchema cs1 cs2)\n"
"consInjective Same = (SameCT, Same)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:809
#, no-wrap
msgid ""
"We can now pass `prf` to `consInjective` to extract a value of\n"
"type `SameSchema xs ys`, which we then pass to `contra` in\n"
"order to get the desired value of type `Void`.\n"
"With these observations and utilities, we can now implement\n"
"`decSameSchema`:\n"
msgstr "我们现在可以将 `prf` 传递给 `consInjective` 以提取 `SameSchema xs ys` 类型的值，然后我们将其传递给 `contra` 以便获取类型 `Void` 的所需值。有了这些观察和实用程序，我们现在可以实现 `decSameSchema`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:810
#, no-wrap
msgid ""
"decSameSchema :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema []        []        = Yes Same\n"
"decSameSchema []        (y :: ys) = No absurd\n"
"decSameSchema (x :: xs) []        = No absurd\n"
"decSameSchema (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema xs ys of\n"
"    Yes Same   => Yes Same\n"
"    No  contra => No $ contra . snd . consInjective\n"
"  No  contra => No $ contra . fst . consInjective\n"
msgstr ""
"decSameSchema :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema []        []        = Yes Same\n"
"decSameSchema []        (y :: ys) = No absurd\n"
"decSameSchema (x :: xs) []        = No absurd\n"
"decSameSchema (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema xs ys of\n"
"    Yes Same   => Yes Same\n"
"    No  contra => No $ contra . snd . consInjective\n"
"  No  contra => No $ contra . fst . consInjective\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:825
#, no-wrap
msgid ""
"There is an interface called `DecEq` exported by module `Decidable.Equality`\n"
"for types for which we can implement a decision procedure for propositional\n"
"equality. We can implement this to figure out if two values are equal or not.\n"
msgstr "有一个名为 `DecEq` 的接口由模块 `Decidable.Equality` 导出，用于我们可以为命题相等性实现决策过程的类型。我们可以实现它来确定两个值是否相等。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:830
#, no-wrap
msgid ""
"Show that there can be no non-empty vector of `Void`\n"
"by writing a corresponding implementation of uninhabited\n"
msgstr "通过编写 uninhabited 的对应实现，证明 `Void` 不存在非空向量\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:832
#, no-wrap
msgid "Generalize exercise 1 for all uninhabited element types.\n"
msgstr "将练习 1 推广到所有无人居住的元素类型。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:835
#, no-wrap
msgid ""
"Show that if `a = b` cannot hold, then `b = a` cannot hold\n"
"either.\n"
msgstr "证明如果 `a = b` 不能成立，那么 `b = a` 也不能成立。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:838
#, no-wrap
msgid ""
"Show that if `a = b` holds, and `b = c` cannot hold, then\n"
"`a = c` cannot hold either.\n"
msgstr "证明如果 `a = b` 成立，而 `b = c` 不能成立，那么 `a = c` 也不能成立。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:841
#, no-wrap
msgid ""
"Implement `Uninhabited` for `Crud i a`. Try to be\n"
"as general as possible.\n"
msgstr "为 `Crud i a` 实现 `Uninhabited`。尽量笼统。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Folds.md:996
#: ../src/Tutorial/Functor.md:417 ../src/Tutorial/Traverse.md:285
#, no-wrap
msgid ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"
msgstr ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:851
#, no-wrap
msgid "Implement `DecEq` for `ColType`.\n"
msgstr "为 `ColType` 实现 `DecEq`。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Eq.md:856
#, no-wrap
msgid ""
"Implementations such as the one from exercise 6 are cumbersome\n"
"to write as they require a quadratic number of pattern matches\n"
"with relation to the number of data constructors. Here is a\n"
"trick how to make this more bearable.\n"
msgstr "练习 6 中的实现这样的实现写起来很麻烦，因为它们需要与数据构造函数的数量相关的"
"二次模式匹配。这是一个技巧，如何使它更容易忍受。\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/Eq.md:859
#, no-wrap
msgid ""
"Implement a function `ctNat`, which assigns every value\n"
"of type `ColType` a unique natural number.\n"
msgstr "实现一个函数 `ctNat`，它为每个 `ColType` 类型的值分配一个唯一的自然数。\n"

#. type: Bullet: '   2. '
#: ../src/Tutorial/Eq.md:864
#, no-wrap
msgid ""
"Proof that `ctNat` is injective.\n"
"Hint: You will need to pattern match on the `ColType`\n"
"values, but four matches should be enough to satisfy the\n"
"coverage checker.\n"
msgstr "证明 `ctNat` 是单射的。提示：您将需要对 `ColType` "
"值进行模式匹配，但四个匹配应该足以满足覆盖检查器的要求。\n"

#. type: Bullet: '   3. '
#: ../src/Tutorial/Eq.md:869
#, no-wrap
msgid ""
"In your implementation of `DecEq` for `ColType`,\n"
"use `decEq` on the result of applying both column\n"
"types to `ctNat`, thus reducing it to only two lines of\n"
"code.\n"
msgstr ""
"在为 `ColType` 实现 `DecEq` 时，在将两种列类型应用于 `ctNat` 的结果上使用 "
"`decEq`，从而将其减少到仅两行代码。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:877
#, no-wrap
msgid ""
"   We will later talk about `with` rules: Special forms of\n"
"   dependent pattern matches, that allow us to learn something\n"
"   about the shape of function arguments by performing\n"
"   computations on them. These will allow us to use\n"
"   a similar technique as shown here to implement `DecEq`\n"
"   requiring only `n` pattern matches\n"
"   for arbitrary sum types with `n` data constructors.\n"
msgstr ""
"   我们稍后会讨论 `with` 规则：\n"
"   依赖模式匹配，让我们学习一些东西\n"
"   通过执行关于函数参数的形状\n"
"   对它们进行计算。这些将允许我们使用\n"
"   与此处所示类似的技术来实现 `DecEq`\n"
"   只需要 `n` 模式匹配\n"
"   对于具有 `n` 数据构造函数的任意和类型。\n"

#. type: Title ##
#: ../src/Tutorial/Eq.md:878
#, no-wrap
msgid "Rewrite Rules"
msgstr "重写规则"

#. type: Plain text
#: ../src/Tutorial/Eq.md:888
#, no-wrap
msgid ""
"One of the most important use cases of propositional equality\n"
"is to replace or *rewrite* existing types, which Idris can't\n"
"unify automatically otherwise. For instance,\n"
"the following is no problem:\n"
"Idris know that `0 + n` equals `n`, because `plus` on\n"
"natural numbers is implemented by pattern matching on the\n"
"first argument. The two vector lengths therefore unify\n"
"just fine.\n"
msgstr "命题等式的最重要用例之一是替换或 *重写* 现有类型，否则 Idris 无法自动统一这些类型。例如，以下是没有问题的： Idris 知道 `0 + n` 等于 `n`，因为自然数上的 `plus` 是通过第一个参数的模式匹配实现的.因此，这两个向量长度可以很好地统一。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:889
#, no-wrap
msgid ""
"leftZero :  List (Vect n Nat)\n"
"         -> List (Vect (0 + n) Nat)\n"
"         -> List (Vect n Nat)\n"
"leftZero = (++)\n"
msgstr ""
"leftZero :  List (Vect n Nat)\n"
"         -> List (Vect (0 + n) Nat)\n"
"         -> List (Vect n Nat)\n"
"leftZero = (++)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:899
#, no-wrap
msgid ""
"However, the example below can't be implemented as easily\n"
"(try id!), because Idris can't figure out on its own\n"
"that the two lengths unify.\n"
msgstr "但是，下面的示例无法轻松实现（尝试 id！），因为 Idris 无法自行确定这两个长度是否统一。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:900
#, no-wrap
msgid ""
"rightZero' :  List (Vect n Nat)\n"
"           -> List (Vect (n + 0) Nat)\n"
"           -> List (Vect n Nat)\n"
msgstr ""
"rightZero' :  List (Vect n Nat)\n"
"           -> List (Vect (n + 0) Nat)\n"
"           -> List (Vect n Nat)\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:909
#, no-wrap
msgid ""
"Probably for the first time we realize, just how little\n"
"Idris knows about the laws of arithmetics. Idris is able\n"
"to unify values when\n"
msgstr "可能是我们第一次意识到，Idris 对算术定律知之甚少。Idris 能够统一值\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Eq.md:913
#, no-wrap
msgid "all values in a computation are known at compile time\n"
msgstr "计算中的所有值在编译期都是已知的\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Eq.md:913
#, no-wrap
msgid ""
"one expression follows directly from the other due\n"
"to the pattern matches used in a function's implementation.\n"
msgstr "由于函数实现中使用的模式匹配，一个表达式直接跟随另一个表达式。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:917
#, no-wrap
msgid ""
"In expression `n + 0`,  not all values are known (`n` is a variable),\n"
"and `(+)` is implemented by pattern matching on the first\n"
"argument, about which we know nothing here.\n"
msgstr "在表达式 `n + 0` 中，并非所有值都是已知的（`n` 是一个变量），并且 `(+)` 是通过第一个参数的模式匹配来实现的，我们在这里一无所知。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:923
#, no-wrap
msgid ""
"However, we can teach Idris. If we can proof that the two\n"
"expressions are equivalent, we can replace one expression\n"
"for the other, so that the two unify again. Here is a lemma\n"
"and its proof, that `n + 0` equals `n`, for all natural\n"
"numbers `n`.\n"
msgstr "但是，我们可以教 Idris 。如果我们可以证明这两个表达式是等价的，我们可以用一个表达式替换另一个表达式，从而使两者再次统一。这是一个引理及其证明，对于所有自然数 `n`，`n + 0` 等于 `n`。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:924
#, no-wrap
msgid ""
"addZeroRight : (n : Nat) -> n + 0 = n\n"
"addZeroRight 0     = Refl\n"
"addZeroRight (S k) = cong S $ addZeroRight k\n"
msgstr ""
"addZeroRight : (n : Nat) -> n + 0 = n\n"
"addZeroRight 0     = Refl\n"
"addZeroRight (S k) = cong S $ addZeroRight k\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:935
#, no-wrap
msgid ""
"Note, how the base case is trivial: Since there are no\n"
"variables left, Idris can immediately figure out that\n"
"`0 + 0 = 0`. In the recursive case, it can be instructive\n"
"to replace `cong S` with a hole and look at its type\n"
"and context to figure out how to proceed.\n"
msgstr "请注意，基本情况是多么微不足道：由于没有剩余变量，Idris 可以立即计算出 `0 + 0 = 0`。在递归的情况下，将 `cong S` 替换为一个孔并查看其类型和上下文以确定如何进行可能是有益的。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:940
#, no-wrap
msgid ""
"The *Prelude* exports function `replace` for substituting one\n"
"variable in a term by another, based on a proof of equality.\n"
"Make sure to inspect its type first before looking at the\n"
"example below:\n"
msgstr "*Prelude* 导出函数 `replace` 用于根据等式证明将一个变量中的一个变量替换为另一个变量。在查看下面的示例之前，请务必先检查其类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:941
#, no-wrap
msgid ""
"replaceVect : Vect (n + 0) a -> Vect n a\n"
"replaceVect as = replace {p = \\k => Vect k a} (addZeroRight n) as\n"
msgstr ""
"replaceVect : Vect (n + 0) a -> Vect n a\n"
"replaceVect as = replace {p = \\k => Vect k a} (addZeroRight n) as\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:952
#, no-wrap
msgid ""
"As you can see, we *replace* a value of type `p x` with a value\n"
"of type `p y` based on a proof that `x = y`,\n"
"where `p` is a function from some type `t` to\n"
"`Type`, and `x` and `y` are values of type `t`. In our\n"
"`replaceVect` example, `t` equals `Nat`, `x` equals `n + 0`,\n"
"`y` equals `n`, and `p` equals `\\k => Vect k a`.\n"
msgstr "如您所见，我们将 `p x` 类型的值 *替换* 为 `p y` 类型的值，基于 `x = y` 的证明, 其中 `p` 是从某种类型 `t` 到 `Type` 的函数，而 `x` 和 `y` 是类型 `t` 的值。在我们的 `replaceVect` 示例中，`t` 等于 `Nat`，`x` 等于 `n + 0`，`y` 等于 `n`，`p` 等于 `\\k => Vect k a`。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:960
#, no-wrap
msgid ""
"Using `replace` directly is not very convenient, because Idris\n"
"can often not infer the value of `p` on its own. Indeed, we\n"
"had to give its type explicitly in `replaceVect`.\n"
"Idris therefore provides special syntax for such *rewrite rules*,\n"
"which will get desugared to calls to `replace` with all the\n"
"details filled in for us. Here is an implementation\n"
"of `replaceVect` with a rewrite rule:\n"
msgstr "直接使用 `replace` 不是很方便，因为 Idris 往往无法自行推断出 `p` 的值。实际上，我们必须在 `replaceVect` 中明确给出它的类型。因此，Idris 为此类 *重写规则* 提供了特殊语法，这将减少对 `replace` 的调用，并为我们填写所有详细信息。这是 `replaceVect` 的实现，带有重写规则：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:961
#, no-wrap
msgid ""
"rewriteVect : Vect (n + 0) a -> Vect n a\n"
"rewriteVect as = rewrite sym (addZeroRight n) in as\n"
msgstr ""
"rewriteVect : Vect (n + 0) a -> Vect n a\n"
"rewriteVect as = rewrite sym (addZeroRight n) in as\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:970
#, no-wrap
msgid ""
"One source of confusion is that *rewrite* uses proofs\n"
"of equality the other way round: Given an `y = x`\n"
"it replaces `p x` with `p y`. Hence the need to call `sym`\n"
"in our implementation above.\n"
msgstr "混淆的一个来源是 *rewrite* 使用相反的相等性证明：给定 `y = x` 它将 `p x` 替换为 `p y` .因此需要在我们上面的实现中调用 `sym`。\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:971
#, no-wrap
msgid "Use Case: Reversing Vectors"
msgstr "用例：反转向量"

#. type: Plain text
#: ../src/Tutorial/Eq.md:982
#, no-wrap
msgid ""
"Rewrite rules are often required when we perform interesting\n"
"type-level computations. For instance,\n"
"we have already seen many interesting examples of functions\n"
"operating on `Vect`, which allowed us to keep track of the\n"
"exact lengths of the vectors involved, but one key\n"
"functionality has been missing from our discussions so far,\n"
"and for good reasons: Function `reverse`. Here is a possible\n"
"implementation, which is how `reverse` is implemented for\n"
"lists:\n"
msgstr "当我们执行有趣的类型级计算时，通常需要重写规则。例如，我们已经看到了许多在 `Vect` 上运行的函数的有趣示例，这使我们能够跟踪所涉及向量的确切长度，但是到目前为止我们的讨论中缺少一个关键函数，并且有充分的理由：函数 `reverse`。这是一个可能的实现，这就是 `reverse` 对列表的实现方式：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:984
#, no-wrap
msgid ""
"revOnto' : Vect m a -> Vect n a -> Vect (m + n) a\n"
"revOnto' xs []        = xs\n"
"revOnto' xs (x :: ys) = revOnto' (x :: xs) ys\n"
"\n"
"\n"
"reverseVect' : Vect n a -> Vect n a\n"
"reverseVect' = revOnto' []\n"
msgstr ""
"revOnto' : Vect m a -> Vect n a -> Vect (m + n) a\n"
"revOnto' xs []        = xs\n"
"revOnto' xs (x :: ys) = revOnto' (x :: xs) ys\n"
"\n"
"\n"
"reverseVect' : Vect n a -> Vect n a\n"
"reverseVect' = revOnto' []\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:997
#, no-wrap
msgid ""
"As you might have guessed, this will not compile as the\n"
"length indices in the two clauses of `revOnto'` do\n"
"not unify.\n"
msgstr "正如您可能已经猜到的那样，这不会通过编译，因为 `revOnto'` "
"的两个子句中的长度索引不统一。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:1001
#, no-wrap
msgid ""
"The *nil* case is a case we've already seen above:\n"
"Here `n` is zero, because the second vector is empty,\n"
"so we have to convince Idris once again that `m + 0 = m`:\n"
msgstr "*nil* 情况是我们在上面已经看到的情况：这里 `n` 为零，因为第二个向量是空的，所以我们必须再次说服 Idris `m + 0 = m`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1002
#, no-wrap
msgid ""
"revOnto : Vect m a -> Vect n a -> Vect (m + n) a\n"
"revOnto xs [] = rewrite addZeroRight m in xs\n"
msgstr ""
"revOnto : Vect m a -> Vect n a -> Vect (m + n) a\n"
"revOnto xs [] = rewrite addZeroRight m in xs\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:1013
#, no-wrap
msgid ""
"The second case is more complex. Here, Idris fails to unify\n"
"`S (m + len)` with `m + S len`, where `len` is the length of\n"
"`ys`, the tail of the second vector. Module `Data.Nat`\n"
"provides many proofs about arithmetic operations on natural\n"
"numbers, one of which is `plusSuccRightSucc`. Here's its\n"
"type:\n"
msgstr "第二种情况更复杂。这里，Idris 无法统一 `S (m + len)` 和 `m + S len`，其中 `len` 是 `ys` 的长度，第二个向量的尾部。模块 `Data.Nat` 提供了许多关于自然数算术运算的证明，其中之一是 `plusSuccRightSucc`。这是它的类型：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:1014
#, no-wrap
msgid ""
"Tutorial.Eq> :t plusSuccRightSucc\n"
"Data.Nat.plusSuccRightSucc :  (left : Nat)\n"
"                           -> (right : Nat)\n"
"                           -> S (left + right) = left + S right\n"
msgstr ""
"Tutorial.Eq> :t plusSuccRightSucc\n"
"Data.Nat.plusSuccRightSucc :  (left : Nat)\n"
"                           -> (right : Nat)\n"
"                           -> S (left + right) = left + S right\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:1032
#, no-wrap
msgid ""
"In our case, we want to replace `S (m + len)` with `m + S len`,\n"
"so we will need the version with arguments flipped. However, there\n"
"is one more obstacle: We need to invoke `plusSuccRightSucc`\n"
"with the length of `ys`, which is not given as an implicit\n"
"function argument of `revOnto`. We therefore need to pattern\n"
"match on `n` (the length of the second vector), in order to\n"
"bind the length of the tail to a variable. Remember, that we\n"
"are allowed to pattern match on an erased argument only if\n"
"the constructor used follows from a match on another, unerased,\n"
"argument (`ys` in this case). Here's the implementation of the\n"
"second case:\n"
msgstr ""
"在我们的例子中，我们想用 `m + S len` 替换 `S (m + "
"len)`，所以我们需要参数翻转的版本。但是，还有一个障碍：我们需要调用长度为 "
"`ys` 的 `plusSuccRightSucc`，它没有作为 `revOnto` 的隐式函数参数给出。因此，"
"我们需要对 `n`（第二个向量的长度）进行模式匹配，以便将尾部的长度绑定到一个变"
"量。请记住，只有当使用的构造函数遵循另一个未擦除参数（在本例中为 "
"`ys`）的匹配时，我们才允许对已擦除参数进行模式匹配。下面是第二种情况的实现："
"\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1033
#, no-wrap
msgid ""
"revOnto {n = S len} xs (x :: ys) =\n"
"  rewrite sym (plusSuccRightSucc m len) in revOnto (x :: xs) ys\n"
msgstr ""
"revOnto {n = S len} xs (x :: ys) =\n"
"  rewrite sym (plusSuccRightSucc m len) in revOnto (x :: xs) ys\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:1043
#, no-wrap
msgid ""
"I know from my own experience that this can be highly confusing\n"
"at first. If you use Idris as a general purpose programming language\n"
"and not as a proof assistant, you probably will not have to use\n"
"rewrite rules too often. Still, it is important to know that they\n"
"exist, as they allow us to teach complex equivalences to Idris.\n"
msgstr "我从我自己的经验中知道，起初这可能会让人非常困惑。如果您将 Idris 用作通用编程语言而不是证明助手，您可能不必经常使用重写规则。尽管如此，重要的是要知道它们的存在，因为它们允许我们向 Idris 教授复杂的等价性。\n"

#. type: Title ###
#: ../src/Tutorial/Eq.md:1044
#, no-wrap
msgid "A Note on Erasure"
msgstr "关于擦除的说明"

#. type: Plain text
#: ../src/Tutorial/Eq.md:1055
#, no-wrap
msgid ""
"Single value data types like `Unit`, `Equal`, or `SameSchema` have\n"
"not runtime relevance, as values of these types are always identical.\n"
"We can therefore always use them as erased function arguments while\n"
"still being able to pattern match on these values.\n"
"For instance, when you look at the type of `replace`, you will see\n"
"that the equality proof is an erased argument.\n"
"This allows us to run arbitrarily complex computations to produce\n"
"such values without fear of these computations slowing down\n"
"the compiled Idris program.\n"
msgstr "`Unit`、`Equal` 或 `SameSchema` 等单值数据类型没有运行时相关性，因为这些类型的值始终相同。因此，我们始终可以将它们用作已擦除的函数参数，同时仍然能够对这些值进行模式匹配。例如，当您查看 `replace` 的类型时，您会看到等式证明是一个已删除的参数。这允许我们运行任意复杂的计算来生成这样的值，而不必担心这些计算会减慢编译的 Idris 程序。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:1059
#, no-wrap
msgid "Implement `plusSuccRightSucc` yourself.\n"
msgstr "自己实现 `plusSuccRightSucc`。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:1061
#, no-wrap
msgid "Proof that `minus n n` equals zero for all natural numbers `n`.\n"
msgstr "证明 `minus n n` 对于所有自然数 `n` 等于 0。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:1063
#, no-wrap
msgid "Proof that `minus n 0` equals n for all natural numbers `n`\n"
msgstr "证明 `minus n 0` 等于 n 对于所有自然数 `n`\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:1066
#, no-wrap
msgid ""
"Proof that `n * 1 = n` and `1 * n = n`\n"
"for all natural numbers `n`.\n"
msgstr "证明对于所有自然数 `n`，都有 `n * 1 = n` 和 `1 * n = n` 。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:1069
#, no-wrap
msgid ""
"Proof that addition of natural numbers is\n"
"commutative.\n"
msgstr "证明自然数的加法是可交换的。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:1071
#, no-wrap
msgid "Implement a tail-recursive version of `map` for vectors.\n"
msgstr "为向量实现 `map` 的尾递归版本。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Eq.md:1073
#, no-wrap
msgid "Proof the following proposition:\n"
msgstr "证明以下命题：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1074
#, no-wrap
msgid ""
"   mapAppend :  (f : a -> b)\n"
"             -> (xs : List a)\n"
"             -> (ys : List a)\n"
"             -> map f (xs ++ ys) = map f xs ++ map f ys\n"
msgstr ""
"   mapAppend :  (f : a -> b)\n"
"             -> (xs : List a)\n"
"             -> (ys : List a)\n"
"             -> map f (xs ++ ys) = map f xs ++ map f ys\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Eq.md:1084
#, no-wrap
msgid ""
"Use the proof from exercise 7 to implement again a function\n"
"for  zipping two `Table`s, this time using a rewrite rule\n"
"plus `Data.HList.(++)` instead of custom function `appRows`.\n"
msgstr ""
"使用练习 7 中的证明再次实现压缩两个 `Table` 的函数，这次使用重写规则加上 "
"`Data.HList.(++)` 而不是自定义函数 `appRows`。\n"

#. type: Plain text
#: ../src/Tutorial/Eq.md:1096
#, no-wrap
msgid ""
"The concept of *types as propositions, values as proofs* is\n"
"a very powerful tool for writing provably correct programs. We\n"
"will therefore spend some more time defining data types\n"
"for describing contracts between values, and values of these\n"
"types as proofs that the contracts hold. This will allow\n"
"us to describe necessary pre- and postconditions for our functions,\n"
"thus reducing the need to return a `Maybe` or other failure type,\n"
"because due to the restricted input, our functions can no longer\n"
"fail.\n"
msgstr "*类型作为命题，值作为证明* 的概念是编写可证明正确的程序的非常强大的工具。因此，我们将花更多时间定义数据类型来描述值之间的协议，并将这些类型的值作为合约持有的证据。这将允许我们为我们的函数描述必要的前置条件和后置条件，从而减少返回 `Maybe` 或其他故障类型的需要，因为由于输入受限，我们的函数不能再失败。\n"

#. type: Title #
#: ../src/Tutorial/Folds.md:1
#, no-wrap
msgid "Recursion and Folds"
msgstr "递归和折叠"

#. type: Plain text
#: ../src/Tutorial/Folds.md:12
#, no-wrap
msgid ""
"In this chapter, we are going to have a closer look at the\n"
"computations we typically perform with *container types*:\n"
"Parameterized data types like `List`, `Maybe`, or\n"
"`Identity`, holding zero or more values of the parameter's\n"
"type. Many of these functions are recursive in nature,\n"
"so we start with a discourse about recursion in general,\n"
"and tail recursion as an important optimization technique\n"
"in particular. Most recursive functions in this part\n"
"will describe pure iterations over lists.\n"
msgstr "在本章中，我们将仔细研究我们通常使用 *容器类型* 执行的计算：参数化数据类型，如 `List`、`Maybe` 或 `Identity`，保存参数类型的零个或多个值。其中许多函数本质上是递归的，因此我们首先讨论一般的递归，特别是尾递归作为一种重要的优化技术。这部分中的大多数递归函数将描述列表上的纯迭代。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:17
#, no-wrap
msgid ""
"It is recursive functions, for which totality is hard\n"
"to determine, so we will next have a quick look at the\n"
"totality checker and learn, when it will refuse to\n"
"accept a function as being total and what to do about this.\n"
msgstr "它是递归函数，其完全性很难确定，因此我们接下来将快速查看完全性检查器并了解它何时会拒绝接受一个函数作为全函数以及如何处理。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:22
#, no-wrap
msgid ""
"Finally, we will start looking for common patterns in\n"
"the recursive functions from the first part and will\n"
"eventually introduce a new interface for consuming\n"
"container types: Interface `Foldable`.\n"
msgstr "最后，我们将从第一部分开始寻找递归函数中的常见模式，并最终引入一个用于消费容器类型的新接口：接口 `Foldable`。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:23
#, no-wrap
msgid ""
"module Tutorial.Folds\n"
"\n"
"import Data.List1\n"
"import Data.Maybe\n"
"import Data.Vect\n"
"import Debug.Trace\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Folds\n"
"\n"
"import Data.List1\n"
"import Data.Maybe\n"
"import Data.Vect\n"
"import Debug.Trace\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Folds.md:34
#, no-wrap
msgid "Recursion"
msgstr "递归"

#. type: Plain text
#: ../src/Tutorial/Folds.md:38
#, no-wrap
msgid ""
"In this section, we are going to have a closer look at\n"
"recursion in general and at tail recursion in particular.\n"
msgstr "在本节中，我们将仔细研究一般的递归，特别是尾递归。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:47
#, no-wrap
msgid ""
"Recursive functions are functions, which call themselves\n"
"to repeat a task or calculation until a certain aborting\n"
"condition (called the *base case*) holds.\n"
"Please note, that it is recursive functions, which\n"
"make it hard to verify totality: Non-recursive functions,\n"
"which are *covering* (they cover all possible cases in their\n"
"pattern matches) are automatically total if they only invoke\n"
"other total functions.\n"
msgstr "递归函数是函数，它们调用自己来重复任务或计算，直到某个中止条件（称为 *基本情况*）成立。请注意，它是递归函数，因此很难验证完全性：非递归函数，即 *全覆盖*（它们涵盖了模式匹配中的所有可能情况）如果它们只调用其他函数，它们就会自动为完全的。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:50
#, no-wrap
msgid ""
"Here is an example of a recursive function: It generates\n"
"a list of the given length filling it with identical values:\n"
msgstr "这是一个递归函数的例子：它生成一个给定长度的列表，用相同的值填充它：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:51
#, no-wrap
msgid ""
"replicateList : Nat -> a -> List a\n"
"replicateList 0     _ = []\n"
"replicateList (S k) x = x :: replicateList k x\n"
msgstr ""
"replicateList : Nat -> a -> List a\n"
"replicateList 0     _ = []\n"
"replicateList (S k) x = x :: replicateList k x\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:63
#, no-wrap
msgid ""
"As you can see (this module has the `%default total` pragma at the top),\n"
"this function is provably total. Idris verifies, that the `Nat` argument\n"
"gets *strictly smaller* in each recursive call, and that therefore, the\n"
"function *must* eventually come to an end. Of course, we can do the\n"
"same thing for `Vect`, where we can even show that the length of the\n"
"resulting vector matches the given natural number:\n"
msgstr "正如你所看到的（这个模块在顶部有 `%default total` pragma），这个函数可以证明是完全的。 Idris 验证 `Nat` 参数在每次递归调用中 *严格缩小*，因此，函数 *肯定会* 最终结束。当然，我们可以对 `Vect` 做同样的事情，我们甚至可以证明结果向量的长度与给定的自然数匹配：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:64
#, no-wrap
msgid ""
"replicateVect : (n : Nat) -> a -> Vect n a\n"
"replicateVect 0     _ = []\n"
"replicateVect (S k) x = x :: replicateVect k x\n"
msgstr ""
"replicateVect : (n : Nat) -> a -> Vect n a\n"
"replicateVect 0     _ = []\n"
"replicateVect (S k) x = x :: replicateVect k x\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:73
#, no-wrap
msgid ""
"While we often use recursion to *create* values of data types like\n"
"`List` or `Vect`, we also use recursion, when we *consume* such values.\n"
"For instance, here is a function for calculating the length of a list:\n"
msgstr "虽然我们经常使用递归来 *创建* 数据类型的值，例如 `List` 或 `Vect`，当我们 *使用* 此类值时，我们也会使用递归，例如，这是一个计算列表长度的函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:74
#, no-wrap
msgid ""
"len : List a -> Nat\n"
"len []        = 0\n"
"len (_ :: xs) = 1 + len xs\n"
msgstr ""
"len : List a -> Nat\n"
"len []        = 0\n"
"len (_ :: xs) = 1 + len xs\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:82
#, no-wrap
msgid ""
"Again, Idris can verify that `len` is total, as the list we pass in\n"
"the recursive case is strictly smaller than the original list argument.\n"
msgstr "同样，Idris 可以验证 `len` 是完全的，因为我们在递归情况下传递的列表严格小于原始列表参数。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:88
#, no-wrap
msgid ""
"But when is a recursive function non-total? Here is an example: The\n"
"following function creates a sequence of values until the given\n"
"generation function (`gen`) returns a `Nothing`. Note, how we use\n"
"a *state* value (of generic type `s`) and use `gen` to calculate\n"
"a value together with the next state:\n"
msgstr "但是什么时候递归函数是非全部的？这是一个示例：以下函数创建一系列值，直到给定的生成函数 (`gen`) 返回 `Nothing`。请注意，我们如何使用 *状态* 值（通用类型 `s`）并使用 `gen` 来计算一个值以及下一个状态：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:89
#, no-wrap
msgid ""
"covering\n"
"unfold : (gen : s -> Maybe (s,a)) -> s -> List a\n"
"unfold gen vs = case gen vs of\n"
"  Just (vs',va) => va :: unfold gen vs'\n"
"  Nothing       => []\n"
msgstr ""
"covering\n"
"unfold : (gen : s -> Maybe (s,a)) -> s -> List a\n"
"unfold gen vs = case gen vs of\n"
"  Just (vs',va) => va :: unfold gen vs'\n"
"  Nothing       => []\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:103
#, no-wrap
msgid ""
"With `unfold`, Idris can't verify that any of its arguments is\n"
"converging towards the base case. It therefore rightfully\n"
"refuses to accept that `unfold` is total. And indeed, the following\n"
"function produces an infinite list (so please, don't try to inspect\n"
"this at the REPL, as doing so will consume all your computer's\n"
"memory):\n"
msgstr "使用 `unfold`，Idris 无法验证其任何论点是否收敛于基本情况。因此，它理所当然地拒绝接受 `unfold` 是完全的。事实上，下面的函数会生成一个无限列表（所以请不要尝试在 REPL 中检查它，因为这样做会消耗您计算机的所有内存）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:104
#, no-wrap
msgid ""
"fiboHelper : (Nat,Nat) -> ((Nat,Nat),Nat)\n"
"fiboHelper (f0,f1) = ((f1, f0 + f1), f0)\n"
"\n"
"covering\n"
"fibonacci : List Nat\n"
"fibonacci = unfold (Just . fiboHelper) (1,1)\n"
msgstr ""
"fiboHelper : (Nat,Nat) -> ((Nat,Nat),Nat)\n"
"fiboHelper (f0,f1) = ((f1, f0 + f1), f0)\n"
"\n"
"covering\n"
"fibonacci : List Nat\n"
"fibonacci = unfold (Just . fiboHelper) (1,1)\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:117
#, no-wrap
msgid ""
"In order to safely create a (finite) sequence of Fibonacci numbers,\n"
"we need to make sure the function generating the sequence will\n"
"stop after a finite number of steps, for instance by limiting\n"
"the length of the list:\n"
msgstr "为了安全地创建一个（有限）斐波那契数列，我们需要确保生成该序列的函数将在有限步数后停止，例如通过限制列表的长度：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:118
#, no-wrap
msgid ""
"unfoldTot : Nat -> (gen : s -> Maybe (s,a)) -> s -> List a\n"
"unfoldTot 0     _   _  = []\n"
"unfoldTot (S k) gen vs = case gen vs of\n"
"  Just (vs',va) => va :: unfoldTot k gen vs'\n"
"  Nothing       => []\n"
"\n"
"fibonacciN : Nat -> List Nat\n"
"fibonacciN n = unfoldTot n (Just . fiboHelper) (1,1)\n"
msgstr ""
"unfoldTot : Nat -> (gen : s -> Maybe (s,a)) -> s -> List a\n"
"unfoldTot 0     _   _  = []\n"
"unfoldTot (S k) gen vs = case gen vs of\n"
"  Just (vs',va) => va :: unfoldTot k gen vs'\n"
"  Nothing       => []\n"
"\n"
"fibonacciN : Nat -> List Nat\n"
"fibonacciN n = unfoldTot n (Just . fiboHelper) (1,1)\n"

#. type: Title ###
#: ../src/Tutorial/Folds.md:129
#, no-wrap
msgid "The Call Stack"
msgstr "调用栈"

#. type: Plain text
#: ../src/Tutorial/Folds.md:133
#, no-wrap
msgid ""
"In order to demonstrate what tail recursion is about, we require\n"
"the following `main` function:\n"
msgstr "为了演示尾递归是什么，我们需要以下 `main` 函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:134
#, no-wrap
msgid ""
"main : IO ()\n"
"main = printLn . len $ replicateList 10000 10\n"
msgstr ""
"main : IO ()\n"
"main = printLn . len $ replicateList 10000 10\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:144
#, no-wrap
msgid ""
"If you have [Node.js](https://nodejs.org/en/) installed on your system,\n"
"you might try the following experiment. Compile and run this\n"
"module using the *Node.js* backend of Idris instead of the default\n"
"*Chez Scheme* backend and run the resulting JavaScript source file\n"
"with the Node.js binary:\n"
msgstr "如果您的系统上安装了 [Node.js](https://nodejs.org/en/)，您可以尝试以下实验。使用 Idris 的 *Node.js* 后端而不是默认的 *Chez Scheme* 后端编译并运行此模块，并使用 Node.js 二进制文件运行生成的 JavaScript 源文件：\n"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Folds.md:145
#, no-wrap
msgid ""
"idris2 --cg node -o test.js --find-ipkg -src/Tutorial/Folds.md\n"
"node build/exec/test.js\n"
msgstr ""
"idris2 --cg node -o test.js --find-ipkg -src/Tutorial/Folds.md\n"
"node build/exec/test.js\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:154
#, no-wrap
msgid ""
"Node.js will fail with the following error message and a lengthy\n"
"stack trace: `RangeError: Maximum call stack size exceeded`.\n"
"What's going on here? How can it be that `main` fails with an\n"
"exception although it is provably total?\n"
msgstr "Node.js 将失败并显示以下错误消息和冗长的堆栈跟踪：`RangeError: Maximum call stack size exceeded`。这里发生了什么？ `main` 怎么会失败并出现异常，尽管它可以证明是完全的？\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:169
#, no-wrap
msgid ""
"First, remember that a function\n"
"being total means that it will eventually produce a value\n"
"of the given type in a finite amount of time, *given\n"
"enough resources like computer memory*. Here, `main` hasn't\n"
"been given enough resources as Node.js has a very small size\n"
"limit on its call stack. The *call stack* can be thought\n"
"of as a stack data structure (first in, last out), where\n"
"nested function calls are put. In case of recursive functions,\n"
"the stack size increases by one with every recursive function\n"
"call. In case of our `main` function, we create and consume\n"
"a list of length 10'000, so the call stack will hold\n"
"at least 10'000 function calls before they are being invoked\n"
"and the stack's size is reduced again. This exceeds Node.js's\n"
"stack size limit by far, hence the overflow error.\n"
msgstr "首先，记住一个函数是完全的意味着它最终会在有限的时间内产生一个给定类型的值，*给定足够的资源，比如计算机内存*。在这里，`main` 没有获得足够的资源，因为 Node.js 在其调用堆栈上的大小限制非常小。 *调用堆栈* 可以被认为是一个堆栈数据结构（先进后出），其中放置了嵌套的函数调用。在递归函数的情况下，堆栈大小随着每个递归函数调用而增加一。对于我们的 `main` 函数，我们创建并使用长度为 10'000 的列表，因此调用堆栈将在调用之前至少保存 10'000 个函数调用，并且堆栈的大小再次减小.这远远超出了 Node.js 的堆栈大小限制，因此出现了溢出错误。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:180
#, no-wrap
msgid ""
"Now, before we look at a solution how to circumvent this issue,\n"
"please note that this is a very serious and limiting source of\n"
"bugs when using the JavaScript backends of Idris. In Idris, having no\n"
"access to control structures like `for` or `while` loops, we *always*\n"
"have to resort to recursion in order to describe iterative\n"
"computations. Luckily (or should I say \"unfortunately\", since otherwise\n"
"this issue would already have been addressed with all seriousness),\n"
"the Scheme backends don't have this issue, as their stack size\n"
"limit is much larger and they perform all kinds of optimizations\n"
"internally to prevent the call stack from overflowing.\n"
msgstr "现在，在我们研究如何规避此问题的解决方案之前，请注意，在使用 Idris 的 JavaScript 后端时，这是一个非常严重且限制性的错误来源。在 Idris 中，由于无法访问 `for` 或 `while` 循环等控制结构，我们 *总是* 必须求助于递归来描述迭代计算。幸运的是（或者我应该说“不幸”，否则这个问题已经得到了严肃的解决），Scheme 后端没有这个问题，因为它们的堆栈大小限制要大得多，并且它们在内部执行各种优化以防止调用堆栈溢出。\n"

#. type: Title ###
#: ../src/Tutorial/Folds.md:181
#, no-wrap
msgid "Tail Recursion"
msgstr "尾递归"

#. type: Plain text
#: ../src/Tutorial/Folds.md:187
#, no-wrap
msgid ""
"A recursive function is said to be *tail recursive*, if\n"
"all recursive calls occur at *tail position*: The last\n"
"function call in a (sub)expression. For instance, the following\n"
"version of `len` is tail recursive:\n"
msgstr "如果所有递归调用都发生在 *尾部位置* 处，则称递归函数为 *尾递归*：（子）表达式中的最后一个函数调用。例如，以下版本的 `len` 是尾递归的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:188
#, no-wrap
msgid ""
"lenOnto : Nat -> List a -> Nat\n"
"lenOnto k []        = k\n"
"lenOnto k (_ :: xs) = lenOnto (k + 1) xs\n"
msgstr ""
"lenOnto : Nat -> List a -> Nat\n"
"lenOnto k []        = k\n"
"lenOnto k (_ :: xs) = lenOnto (k + 1) xs\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:197
#, no-wrap
msgid ""
"Compare this to `len` as defined above: There, the last\n"
"function call is an invocation of operator `(+)`, and\n"
"the recursive call happens in one of its arguments:\n"
msgstr "将此与上面定义的 `len` 进行比较：最后一个函数调用是对运算符 `(+)` 的调用，递归调用发生在它的一个参数中：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:198
#, no-wrap
msgid "len (_ :: xs) = 1 + len xs\n"
msgstr "len (_ :: xs) = 1 + len xs\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:204
#, no-wrap
msgid ""
"We can use `lenOnto` as a utility to implement a tail recursive\n"
"version of `len` without the additional `Nat` argument:\n"
msgstr "我们可以使用 `lenOnto` 作为实用程序来实现 `len` 的尾递归版本，而无需额外的 `Nat` 参数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:205
#, no-wrap
msgid ""
"lenTR : List a -> Nat\n"
"lenTR = lenOnto 0\n"
msgstr ""
"lenTR : List a -> Nat\n"
"lenTR = lenOnto 0\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:215
#, no-wrap
msgid ""
"This is a common pattern when writing tail recursive functions:\n"
"We typically add an additional function argument for accumulating\n"
"intermediary results, which is then passed on explicitly at each\n"
"recursive call. For instance, here is a tail recursive version\n"
"of `replicateList`:\n"
msgstr "这是编写尾递归函数时的常见模式：我们通常添加一个额外的函数参数来累积中间结果，然后在每次递归调用时显式传递。例如，这里是 `replicateList` 的尾递归版本：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:216
#, no-wrap
msgid ""
"replicateListTR : Nat -> a -> List a\n"
"replicateListTR n v = go Nil n\n"
"  where go : List a -> Nat -> List a\n"
"        go xs 0     = xs\n"
"        go xs (S k) = go (v :: xs) k\n"
msgstr ""
"replicateListTR : Nat -> a -> List a\n"
"replicateListTR n v = go Nil n\n"
"  where go : List a -> Nat -> List a\n"
"        go xs 0     = xs\n"
"        go xs (S k) = go (v :: xs) k\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:229
#, no-wrap
msgid ""
"The big advantage of tail recursive functions is, that they\n"
"can be easily converted to efficient, imperative loops by the Idris\n"
"compiler, and are thus *stack safe*: Recursive function calls\n"
"are *not* added to the call stack, thus avoiding the dreaded\n"
"stack overflow errors.\n"
msgstr "尾递归函数的一大优点是，它们可以通过 Idris 编译器轻松转换为高效的命令式循环，因此是 *堆栈安全* 的：递归函数调用 *不会* 添加到调用堆栈，从而避免了可怕的堆栈溢出错误。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:230
#, no-wrap
msgid ""
"main1 : IO ()\n"
"main1 = printLn . lenTR $ replicateListTR 10000 10\n"
msgstr ""
"main1 : IO ()\n"
"main1 = printLn . lenTR $ replicateListTR 10000 10\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:240
#, no-wrap
msgid ""
"We can again run `main1` using the *Node.js* backend. This time,\n"
"we use slightly different syntax to execute a function other than\n"
"`main` (Remember: The dollar prefix is only there to distinghish\n"
"a terminal command from its output. It is not part of the\n"
"command you enter in a terminal sesssion.):\n"
msgstr "我们可以使用 *Node.js* 后端再次运行 `main1`。这一次，我们使用稍有不同的语法来执行除 `main` 以外的函数（请记住：美元前缀仅用于将终端命令与其输出区分开来。它不是您在终端会话输入的命令的一部分。）：\n"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Folds.md:241
#, no-wrap
msgid ""
"$ idris2 --cg node --exec main1 --find-ipkg src/Tutorial/Folds.md\n"
"10000\n"
msgstr ""
"$ idris2 --cg node --exec main1 --find-ipkg src/Tutorial/Folds.md\n"
"10000\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:248
#, no-wrap
msgid ""
"As you can see, this time the computation finished without\n"
"overflowing the call stack.\n"
msgstr "如您所见，这次计算完成并没有溢出调用堆栈。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:253
#, no-wrap
msgid ""
"Tail recursive functions are allowed to consist of\n"
"(possibly nested) pattern matches, with recursive\n"
"calls at tail position in several of the branches.\n"
"Here is an example:\n"
msgstr "尾递归函数允许由（可能是嵌套的）模式匹配组成，在几个分支的尾位置进行递归调用。这是一个例子：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:254
#, no-wrap
msgid ""
"countTR : (a -> Bool) -> List a -> Nat\n"
"countTR p = go 0\n"
"  where go : Nat -> List a -> Nat\n"
"        go k []        = k\n"
"        go k (x :: xs) = case p x of\n"
"          True  => go (S k) xs\n"
"          False => go k xs\n"
msgstr ""
"countTR : (a -> Bool) -> List a -> Nat\n"
"countTR p = go 0\n"
"  where go : Nat -> List a -> Nat\n"
"        go k []        = k\n"
"        go k (x :: xs) = case p x of\n"
"          True  => go (S k) xs\n"
"          False => go k xs\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:266
#, no-wrap
msgid ""
"Note, how each invocation of `go` is in tail position in\n"
"its branch of the case expression.\n"
msgstr "请注意，`go` 的每次调用如何在其 case 表达式的分支中处于尾部位置。\n"

#. type: Title ###
#: ../src/Tutorial/Folds.md:267
#, no-wrap
msgid "Mutual Recursion"
msgstr "相互递归"

#. type: Plain text
#: ../src/Tutorial/Folds.md:281
#, no-wrap
msgid ""
"It is sometimes convenient to implement several related\n"
"functions, which call each other recursively. In Idris,\n"
"unlike in many other programming languages,\n"
"a function must be declared in a source file\n"
"*before* it can be called by other functions, as in general\n"
"a function's implementation must\n"
"be available during type checking (because Idris has\n"
"dependent types). There are two ways around this, which\n"
"actually result in the same internal representation in the\n"
"compiler. Our first option is to write down the functions' declarations\n"
"first with the implementations following after. Here's a\n"
"silly example:\n"
msgstr "有时可以方便地实现几个相关的函数，它们以递归方式相互调用。在 Idris 中，与许多其他编程语言不同，函数必须在源文件中声明 *之后* 才能被其他函数调用，因为通常函数的实现必须在类型检查期间可用（因为 Idris 有依赖类型）。有两种方法可以解决这个问题，它们实际上会在编译器中产生相同的内部表示。我们的第一个选择是先写下函数的声明，然后是实现。这是一个愚蠢的例子：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:282
#, no-wrap
msgid ""
"even : Nat -> Bool\n"
"\n"
"odd : Nat -> Bool\n"
"\n"
"even 0     = True\n"
"even (S k) = odd k\n"
"\n"
"odd 0     = False\n"
"odd (S k) = even k\n"
msgstr ""
"even : Nat -> Bool\n"
"\n"
"odd : Nat -> Bool\n"
"\n"
"even 0     = True\n"
"even (S k) = odd k\n"
"\n"
"odd 0     = False\n"
"odd (S k) = even k\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:297
#, no-wrap
msgid ""
"As you can see, function `even` is allowed to call function `odd` in\n"
"its implementation, since `odd` has already been declared (but not yet\n"
"implemented).\n"
msgstr "如您所见，函数 `even` 被允许在其实现中调用函数 `odd`，因为 `odd` 已经被声明（但尚未实现）。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:302
#, no-wrap
msgid ""
"If you're like me and want to keep declarations and implementations\n"
"next to each other, you can introduce a `mutual` block, which has\n"
"the same effect. Like with other code blocks, functions in a `mutual`\n"
"block must all be indented by the same amount of whitespace:\n"
msgstr "如果你和我一样，想保持声明和实现彼此相邻，你可以引入一个 `mutual` 块，它具有相同的效果。与其他代码块一样，`mutual` 块中的函数必须全部缩进相同数量的空格：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:303
#, no-wrap
msgid ""
"mutual\n"
"  even' : Nat -> Bool\n"
"  even' 0     = True\n"
"  even' (S k) = odd' k\n"
"\n"
"  odd' : Nat -> Bool\n"
"  odd' 0     = False\n"
"  odd' (S k) = even' k\n"
msgstr ""
"mutual\n"
"  even' : Nat -> Bool\n"
"  even' 0     = True\n"
"  even' (S k) = odd' k\n"
"\n"
"  odd' : Nat -> Bool\n"
"  odd' 0     = False\n"
"  odd' (S k) = even' k\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:319
#, no-wrap
msgid ""
"Just like with single recursive functions, mutually recursive\n"
"functions can be optimized to imperative loops if all\n"
"recursive calls occur at tail position. This is the case\n"
"with functions `even` and `odd`, as can again be\n"
"verified at the *Node.js* backend:\n"
msgstr "就像单个递归函数一样，如果所有递归调用都发生在尾部位置，则可以将相互递归函数优化为命令式循环。函数 `even` 和 `odd` 就是这种情况，可以在 *Node.js* 后端再次验证：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:320
#, no-wrap
msgid ""
"main2 : IO ()\n"
"main2 =  printLn (even 100000)\n"
"      >> printLn (odd 100000)\n"
msgstr ""
"main2 : IO ()\n"
"main2 =  printLn (even 100000)\n"
"      >> printLn (odd 100000)\n"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Folds.md:326
#, no-wrap
msgid ""
"$ idris2 --cg node --exec main2 --find-ipkg src/Tutorial/Folds.md\n"
"True\n"
"False\n"
msgstr ""
"$ idris2 --cg node --exec main2 --find-ipkg src/Tutorial/Folds.md\n"
"True\n"
"False\n"

#. type: Title ###
#: ../src/Tutorial/Folds.md:332
#, no-wrap
msgid "Final Remarks"
msgstr "最后的言论"

#. type: Plain text
#: ../src/Tutorial/Folds.md:336
#, no-wrap
msgid ""
"In this section, we learned about several important aspects\n"
"of recursion and totality checking, which are summarized here:\n"
msgstr "在本节中，我们了解了递归和完全性检查的几个重要方面，总结如下：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:339
#, no-wrap
msgid ""
"In pure functional programming, recursion is the\n"
"way to implement iterative procedures.\n"
msgstr "在纯函数式编程中，递归是实现迭代过程的方式。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:343
#, no-wrap
msgid ""
"Recursive functions pass the totality checker, if it can\n"
"verify that one of the arguments is getting strictly smaller\n"
"in every recursive function call.\n"
msgstr "递归函数通过完全性检查器的条件为，如果它可以验证每个递归函数调用中的参数之一"
"严格收敛。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:346
#, no-wrap
msgid ""
"Arbitrary recursion can lead to stack overflow exceptions on\n"
"backends with small stack size limits.\n"
msgstr "任意递归可能会导致堆栈大小限制较小的后端出现堆栈溢出异常。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:350
#, no-wrap
msgid ""
"The JavaScript backends of Idris perform mutual tail call\n"
"optimization: Tail recursive functions are converted to\n"
"stack safe, imperative loops.\n"
msgstr "Idris 的 JavaScript "
"后端执行相互尾调用优化：尾递归函数被转换为堆栈安全的命令式循环。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:354
#, no-wrap
msgid ""
"Note, that not all Idris backends you will come across in the wild\n"
"will perform tail call optimization. Please check the corresponding\n"
"documentation.\n"
msgstr "请注意，并非您在野外遇到的所有 Idris 后端都会执行尾调用优化。请检查相应的文档。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:372
#, no-wrap
msgid ""
"Note also, that most recursive functions in the core libraries (*prelude*\n"
"and *base*) do not yet make use of tail recursion. There is an\n"
"important reason for this: In many cases, non-tail recursive\n"
"functions are easier to use in compile-time proofs, as they\n"
"unify more naturally than their tail recursive counterparts.\n"
"Compile-time proofs are an important aspect of programming\n"
"in Idris (as we will see in later chapters), so there is a\n"
"compromise to be made between what performs well at runtime\n"
"and what works well at compile time. Eventually, the way\n"
"to go might be to provide two implementations for most\n"
"recursive functions with a *transform rule* telling the\n"
"compiler to use the optimized version at runtime whenever\n"
"programmers use the non-optimized version in their code.\n"
"Such transform rules have - for instance - already been\n"
"written for functions `pack` and `unpack` (which use\n"
"`fastPack` and `fastUnpack` at runtime; see the corresponding\n"
"rules in [the following source file](https://github.com/idris-lang/Idris2/blob/main/libs/prelude/Prelude/Types.idr)).\n"
msgstr "还要注意，核心库中的大多数递归函数（*prelude* 和 *base*）还没有使用尾递归。这有一个重要原因：在许多情况下，非尾递归函数更容易在编译时证明中使用，因为它们比尾递归对应物更自然地统一。编译时证明是 Idris 编程的一个重要方面（我们将在后面的章节中看到），因此在运行时表现良好和编译时表现良好之间需要做出折衷。最终，要走的路可能是为大多数递归函数提供两种实现，使用 *转换规则* 告诉编译器在运行时使用优化版本，只要程序员在其代码中使用非优化版本。例如，已经为函数 `pack` 和 `unpack` 编写了这样的转换规则（它们在运行时使用 `fastPack` 和 `fastUnpack`；参见[以下源文件](https://github.com/idris-lang/Idris2/blob/main/libs/prelude/Prelude/Types.idr)中的相应规则。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:379
#, no-wrap
msgid ""
"In these exercises you are going to implement several\n"
"recursive functions. Make sure to use tail recursion\n"
"whenever possible and quickly verify the correct\n"
"behavior of all functions at the REPL.\n"
msgstr "在这些练习中，您将实现几个递归函数。确保尽可能使用尾递归，并快速验证 REPL 中所有函数的正确行为。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Folds.md:383
#, no-wrap
msgid ""
"Implement functions `anyList` and `allList`, which return\n"
"`True` if any element (or all elements in case of `allList`) in\n"
"a list fulfills the given predicate:\n"
msgstr "实现函数 `anyList` 和 `allList`，如果列表中的任何元素（或 `allList` "
"的所有元素）满足给定谓词：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:384
#, no-wrap
msgid ""
"   anyList : (a -> Bool) -> List a -> Bool\n"
"\n"
"   allList : (a -> Bool) -> List a -> Bool\n"
msgstr ""
"   anyList : (a -> Bool) -> List a -> Bool\n"
"\n"
"   allList : (a -> Bool) -> List a -> Bool\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:392
#, no-wrap
msgid ""
"Implement function `findList`, which returns the first value\n"
"(if any) fulfilling the given predicate:\n"
msgstr "实现函数 `findList`，它返回满足给定谓词的第一个值（如果有）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:393
#, no-wrap
msgid "   findList : (a -> Bool) -> List a -> Maybe a\n"
msgstr "   findList : (a -> Bool) -> List a -> Maybe a\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:399
#, no-wrap
msgid ""
"Implement function `collectList`, which returns the first value\n"
"(if any), for which the given function returns a `Just`:\n"
msgstr "实现函数 `collectList`，它返回第一个值（如果有），给定函数为此返回一个 "
"`Just`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:400
#, no-wrap
msgid "   collectList : (a -> Maybe b) -> List a -> Maybe b\n"
msgstr "   collectList : (a -> Maybe b) -> List a -> Maybe b\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:405
#, no-wrap
msgid "   Implement `lookupList` in terms of `collectList`:\n"
msgstr "   根据 `collectList` 实现 `lookupList`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:406
#, no-wrap
msgid "   lookupList : Eq a => a -> List (a,b) -> Maybe b\n"
msgstr "   lookupList : Eq a => a -> List (a,b) -> Maybe b\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:423
#, no-wrap
msgid ""
"For functions like `map` or `filter`, which must\n"
"loop over a list without affecting the order of elements,\n"
"it is harder to write a tail recursive implementation.\n"
"The safest way to do so is by using a `SnocList` (a\n"
"*reverse* kind of list that's built from head to tail\n"
"instead of from tail to head) to accumulate intermediate\n"
"results. Its two constructors\n"
"are `Lin` and `(:<)` (called the *snoc* operator).\n"
"Module `Data.SnocList` exports two tail recursive operators\n"
"called *fish* and *chips* (`(<><)` and `(<>>)`) for going\n"
"from `SnocList` to `List` and vice versa. Have a look\n"
"at the types of all new data constructors and operators\n"
"before continuing with the exercise.\n"
msgstr ""
"对于像 `map` 或 `filter` 这样的函数，它们必须在不影响元素顺序的情况下循环遍历"
"列表，因此很难编写尾递归实现。最安全的方法是使用 `SnocList`（一种*反转*类别的"
"列表，从头到尾而不是从尾到头构建）来累积中间结果。它的两个构造函数是 `Lin` "
"和 `(:<)` （称为 *snoc* 运算符）。模块 `Data.SnocList` 导出两个尾递归运算符，"
"称为 *鱼* 和 *船* (`(<><)` 和 `(<>>)`) 用于从 `SnocList` 到 `List` "
"，反之亦然。在继续练习之前，请查看所有新数据构造函数和运算符的类型。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:428
#, no-wrap
msgid ""
"   Implement a tail recursive version of `map` for `List`\n"
"   by using a `SnocList` to reassemble the mapped list. Use then\n"
"   the *chips* operator with a `Nil` argument to\n"
"   in the end convert the `SnocList` back to a `List`.\n"
msgstr ""
"   为 `List` 实现 `map` 的尾递归版本\n"
"   通过使用 `SnocList` 重新组装映射列表。然后使用\n"
"   带有 `Nil` 参数的 *chips* 运算符\n"
"   最后将 `SnocList` 转换回 `List`。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:429
#, no-wrap
msgid "   mapTR : (a -> b) -> List a -> List b\n"
msgstr "   mapTR : (a -> b) -> List a -> List b\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:437
#, no-wrap
msgid ""
"Implement a tail recursive version of `filter`, which\n"
"only keeps those values in a list, which fulfill the\n"
"given predicate. Use the same technique as described in\n"
"exercise 4.\n"
msgstr "实现 `filter` 的尾递归版本，它只将那些值保存在列表中，满足给定的谓词。"
"使用练习 4 中描述的相同技术。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:438
#, no-wrap
msgid "   filterTR : (a -> Bool) -> List a -> List a\n"
msgstr "   filterTR : (a -> Bool) -> List a -> List a\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Folds.md:445
#, no-wrap
msgid ""
"Implement a tail recursive version of `mapMaybe`, which\n"
"only keeps those values in a list, for which the given\n"
"function argument returns a `Just`:\n"
msgstr "实现 `mapMaybe` 的尾递归版本，它只将这些值保存在列表中，给定函数参数返回 "
"`Just`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:446
#, no-wrap
msgid "   mapMaybeTR : (a -> Maybe b) -> List a -> List b\n"
msgstr "   mapMaybeTR : (a -> Maybe b) -> List a -> List b\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:451
#, no-wrap
msgid "   Implement `catMaybesTR` in terms of `mapMaybeTR`:\n"
msgstr "   根据 `mapMaybeTR` 实现 `catMaybesTR`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:452
#, no-wrap
msgid "   catMaybesTR : List (Maybe a) -> List a\n"
msgstr "   catMaybesTR : List (Maybe a) -> List a\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Folds.md:457
#, no-wrap
msgid "Implement a tail recursive version of list concatenation:\n"
msgstr "实现列表连接的尾递归版本：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:458
#, no-wrap
msgid "   concatTR : List a -> List a -> List a\n"
msgstr "   concatTR : List a -> List a -> List a\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Folds.md:464
#, no-wrap
msgid ""
"Implement tail recursive versions of *bind* and `join`\n"
"for `List`:\n"
msgstr "为 `List` 实现 *绑定* 和 `join` 的尾递归版本：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:465
#, no-wrap
msgid ""
"   bindTR : List a -> (a -> List b) -> List b\n"
"\n"
"   joinTR : List (List a) -> List a\n"
msgstr ""
"   bindTR : List a -> (a -> List b) -> List b\n"
"\n"
"   joinTR : List (List a) -> List a\n"

#. type: Title ##
#: ../src/Tutorial/Folds.md:471
#, no-wrap
msgid "A few Notes on Totality Checking"
msgstr "关于完全性检查的一些注意事项"

#. type: Plain text
#: ../src/Tutorial/Folds.md:482
#, no-wrap
msgid ""
"The totality checker in Idris verifies, that at least one\n"
"(possibly erased!) argument in a recursive call converges towards\n"
"a base case. For instance, with natural numbers, if the base case\n"
"is zero (corresponding to data constructor `Z`), and we continue\n"
"with `k` after pattern matching on `S k`, Idris can derive from\n"
"`Nat`'s constructors, that `k` is strictly smaller than `S k`\n"
"and therefore the recursive call must converge towards a base case.\n"
"Exactly the same reasoning is used when pattern matching on a list\n"
"and continuing only with its tail in the recursive call.\n"
msgstr "Idris 中的完全性检查器验证递归调用中的至少一个（可能已删除！）参数收敛于基本情况。例如，对于自然数，如果基本情况为零（对应于数据构造函数 `Z`），我们在 `S k` 上进行模式匹配后继续 `k` , Idris 可以从 `Nat` 的构造函数派生，即 `k` 严格小于 `S k`，因此递归调用必须收敛于基本情况。当对列表进行模式匹配并仅在递归调用中继续其尾部时，使用完全相同的推理。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:487
#, no-wrap
msgid ""
"While this works in many cases, it doesn't always go as expected.\n"
"Below, I'll show you a couple of examples where totality checking\n"
"fails, although *we* know, that the functions in question are definitely\n"
"total.\n"
msgstr "虽然这在许多情况下都有效，但并不总是按预期进行。下面，我将向您展示几个完全性检查失败的示例，尽管 *我们* 知道，所讨论的函数肯定是完全的。\n"

#. type: Title ###
#: ../src/Tutorial/Folds.md:488
#, no-wrap
msgid "Case 1: Recursion over a Primitive"
msgstr "案例 1：在原语上递归"

#. type: Plain text
#: ../src/Tutorial/Folds.md:494
#, no-wrap
msgid ""
"Idris doesn't know anything about the internal structure of\n"
"primitive data types. So the following function, although\n"
"being obviously total, will not be accepted by the totality\n"
"checker:\n"
msgstr "Idris 对原语数据类型的内部结构一无所知。因此，以下函数虽然显然是完全的，但不会被完全性检查器接受：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:495
#, no-wrap
msgid ""
"covering\n"
"replicatePrim : Bits32 -> a -> List a\n"
"replicatePrim 0 v = []\n"
"replicatePrim x v = v :: replicatePrim (x - 1) v\n"
msgstr ""
"covering\n"
"replicatePrim : Bits32 -> a -> List a\n"
"replicatePrim 0 v = []\n"
"replicatePrim x v = v :: replicatePrim (x - 1) v\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:514
#, no-wrap
msgid ""
"Unlike with natural numbers (`Nat`), which are defined as an inductive\n"
"data type and are only converted to integer primitives during compilation,\n"
"Idris can't tell that `x - 1` is strictly smaller than `x`, and so it\n"
"fails to verify that this must converge towards the base case.\n"
"(The reason is, that `x - 1` is implemented in terms of primitive\n"
"function `prim__sub_Bits32`, which is built into the compiler and\n"
"must be implemented by each backend individually. The totality\n"
"checker knows about data types, constructors, and functions\n"
"defined in Idris, but not about (primitive) functions and foreign functions\n"
"implemented at the backends. While it is theoretically possible to\n"
"also define and use laws for primitive and foreign functions, this hasn't yet\n"
"been done for most of them.)\n"
msgstr "与自然数 (`Nat`) 不同，自然数被定义为归纳数据类型并且仅在编译期间转换为整数原语，Idris 无法判断 `x - 1` 严格小于比 `x`，因此它无法验证这必须收敛到基本情况。 （原因是 `x - 1` 是根据原始函数 `prim__sub_Bits32` 实现的，它内置在编译器中，必须由每个后端单独实现。完全性检查器知道Idris 中定义的数据类型、构造函数和函数，但与后端实现的（原语）函数和外部函数无关。虽然理论上也可以为原语函数和外部函数定义和使用定律，但这还没有完成对于他们中的大多数情况。）\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:520
#, no-wrap
msgid ""
"Since non-totality is highly contagious (all functions invoking a\n"
"partial function are themselves considered to be partial by the\n"
"totality checker), there is utility function `assert_smaller`, which\n"
"we can use to convince the totality checker and still annotate our\n"
"functions with the `total` keyword:\n"
msgstr "由于非完全性具有高度传染性（所有调用偏函数的函数本身都被完全性检查器认为是不完全的），所以有实用函数 `assert_smaller`，我们可以使用它来说服完全性检查器并我们仍然使用 `total` 关键字注释函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:521
#, no-wrap
msgid ""
"replicatePrim' : Bits32 -> a -> List a\n"
"replicatePrim' 0 v = []\n"
"replicatePrim' x v = v :: replicatePrim' (assert_smaller x $ x - 1) v\n"
msgstr ""
"replicatePrim' : Bits32 -> a -> List a\n"
"replicatePrim' 0 v = []\n"
"replicatePrim' x v = v :: replicatePrim' (assert_smaller x $ x - 1) v\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:532
#, no-wrap
msgid ""
"Please note, though, that whenever you use `assert_smaller` to\n"
"silence the totality checker, the burden of proving totality rests\n"
"on your shoulders. Failing to do so can lead to arbitrary and\n"
"unpredictable program behavior (which is the default with most\n"
"other programming languages).\n"
msgstr "但是请注意，每当您使用 `assert_smaller` 来使完全性检查器静音时，证明完全性的重任就落在了您的肩上。不这样做可能会导致任意和不可预测的程序行为（这是大多数其他编程语言的默认设置）。\n"

#. type: Title ####
#: ../src/Tutorial/Folds.md:533
#, no-wrap
msgid "Ex Falso Quodlibet"
msgstr "Ex Falso Quodlibet"

#. type: Plain text
#: ../src/Tutorial/Folds.md:543
#, no-wrap
msgid ""
"Below - as a demonstration - is a simple proof of `Void`.\n"
"`Void` is an *uninhabited type*: a type with no values.\n"
"*Proofing `Void`* means, that we implement a function accepted\n"
"by the totality checker, which returns a value of type `Void`,\n"
"although this is supposed to be impossible as there is no\n"
"such value. Doing so allows us to completely\n"
"disable the type system together with all the guarantees it provides.\n"
"Here's the code and its dire consequences:\n"
msgstr "下面 - 作为演示 - 是 `Void` 的简单证明。 `Void`是*无人居住的类型*：没有值的类型。 *证明 `Void`* 意味着，我们实现了一个被完全性检查器接受的函数，它返回一个类型为 `Void` 的值，尽管这应该是不可能的，因为没有这样的值.这样做可以让我们完全禁用类型系统以及它提供的所有保证。这是代码及其可怕的后果：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:544
#, no-wrap
msgid ""
"-- In order to proof `Void`, we just loop forever, using\n"
"-- `assert_smaller` to silence the totality checker.\n"
"proofOfVoid : Bits8 -> Void\n"
"proofOfVoid n = proofOfVoid (assert_smaller n n)\n"
"\n"
"-- From a value of type `Void`, anything follows!\n"
"-- This function is safe and total, as there is no\n"
"-- value of type `Void`!\n"
"exFalsoQuodlibet : Void -> a\n"
"exFalsoQuodlibet _ impossible\n"
"\n"
"-- By passing our proof of void to `exFalsoQuodlibet`\n"
"-- (exported by the *Prelude* by the name of `void`), we\n"
"-- can coerce any value to a value of any other type.\n"
"-- This renders type checking completely useless, as\n"
"-- we can freely convert between values of different\n"
"-- types.\n"
"coerce : a -> b\n"
"coerce _ = exFalsoQuodlibet (proofOfVoid 0)\n"
"\n"
"-- Finally, we invoke `putStrLn` with a number instead\n"
"-- of a string. `coerce` allows us to do just that.\n"
"pain : IO ()\n"
"pain = putStrLn $ coerce 0\n"
msgstr ""
"-- 为了证明 `Void`，我们只是永远循环，使用\n"
"-- `assert_smaller` 使完全性检查器静音。\n"
"proofOfVoid : Bits8 -> Void\n"
"proofOfVoid n = proofOfVoid (assert_smaller n n)\n"
"\n"
"-- 从 `Void` 类型的值开始，任何东西都会出现！\n"
"-- 这个函数是安全和完全的，因为没有\n"
"-- `Void` 类型的值！\n"
"exFalsoQuodlibet : Void -> a\n"
"exFalsoQuodlibet _ impossible\n"
"\n"
"-- 通过将我们的无效证明传递给 `exFalsoQuodlibet`\n"
"--（由*Prelude*以`void`的名义导出），我们\n"
"-- 可以将任何值强制转换为任何其他类型的值。\n"
"-- 这使得类型检查完全没用，因为\n"
"-- 我们可以在不同的值之间自由转换\n"
"-- 类型。\n"
"coerce : a -> b\n"
"coerce _ = exFalsoQuodlibet (proofOfVoid 0)\n"
"\n"
"-- 最后，我们用一个数字调用 `putStrLn`\n"
"-- 而不是一个字符串。 `coerce` 允许我们这样做。\n"
"pain : IO ()\n"
"pain = putStrLn $ coerce 0\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:576
#, no-wrap
msgid ""
"Please take a moment to marvel at provably total function `coerce`:\n"
"It claims to convert *any* value to a value of *any* other type.\n"
"And it is completely safe, as it only uses total functions in its\n"
"implementation. The problem is - of course - that `proofOfVoid` should\n"
"never ever have been a total function.\n"
msgstr "请花点时间惊叹于可证明的全函数 `coerce`：它声称将 *any* 值转换为 *any* 其他类型的值。而且它是完全安全的，因为它在实现中只使用了全函数。问题是 - 当然 - `proofOfVoid` 永远不应该是一个完全的函数。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:581
#, no-wrap
msgid ""
"In `pain` we use `coerce` to conjure a string from an integer.\n"
"In the end, we get what we deserve: The program crashes with an error.\n"
"While things could have been much worse, it can still be quite\n"
"time consuming and annoying to localize the source of such an error.\n"
msgstr "在 `pain` 中，我们使用 `coerce` 从整数变出一个字符串。最后，我们得到了我们应得的：程序因错误而崩溃。尽管情况可能会更糟，但定位此类错误的来源仍然非常耗时且令人讨厌。\n"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Folds.md:582
#, no-wrap
msgid ""
"$ idris2 --cg node --exec pain --find-ipkg src/Tutorial/Folds.md\n"
"ERROR: No clauses\n"
msgstr ""
"$ idris2 --cg node --exec pain --find-ipkg src/Tutorial/Folds.md\n"
"ERROR: No clauses\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:590
#, no-wrap
msgid ""
"So, with a single thoughtless placement of `assert_smaller` we wrought\n"
"havoc within our pure and total codebase sacrificing totality and\n"
"type safety in one fell swoop. Therefore: Use at your own risk!\n"
msgstr "因此，通过 `assert_smaller` 的一次轻率放置，我们在我们的纯代码库中造成了严重破坏，一举牺牲了完全性和类型安全性。因此：使用风险自负！\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:594
#, no-wrap
msgid ""
"Note: I do not expect you to understand all the dark magic at\n"
"work in the code above. I'll explain the details in due time\n"
"in another chapter.\n"
msgstr "注意：我不希望你理解上面代码中所有的黑魔法。我将在适当的时候在另一章中解释细节。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:602
#, no-wrap
msgid ""
"Second note: *Ex falso quodlibet*, also called\n"
"[the principle of explosion](https://en.wikipedia.org/wiki/Principle_of_explosion)\n"
"is a law in classical logic: From a contradiction, any statement can be proven.\n"
"In our case, the contradiction was our proof of `Void`: The claim that we wrote\n"
"a total function producing such a value, although `Void` is an uninhabited type.\n"
"You can verify this by inspecting `Void` at the REPL with `:doc Void`: It\n"
"has no data constructors.\n"
msgstr "第二注：*Ex falso quodlibet*，也称为[爆炸原理](https://en.wikipedia.org/wiki/Principle_of_explosion) 是经典逻辑中的一条定律：从矛盾中，任何陈述都可以被证明。在我们的例子中，矛盾在于我们对 `Void` 的证明：声称我们编写了一个产生这样一个值的全函数，尽管 `Void` 是一种无人居住的类型。您可以通过在 REPL 中使用 `:doc Void` 检查 `Void` 来验证这一点：它没有数据构造函数。\n"

#. type: Title ###
#: ../src/Tutorial/Folds.md:603
#, no-wrap
msgid "Case 2: Recursion via Function Calls"
msgstr "案例 2：通过函数调用进行递归"

#. type: Plain text
#: ../src/Tutorial/Folds.md:608
#, no-wrap
msgid ""
"Below is an implementation of a [*rose tree*](https://en.wikipedia.org/wiki/Rose_tree).\n"
"Rose trees can represent search paths in computer algorithms,\n"
"for instance in graph theory.\n"
msgstr "下面是 [*玫瑰树*](https://en.wikipedia.org/wiki/Rose_tree) 的实现。玫瑰树可以表示计算机算法中的搜索路径，例如在图论中。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:609
#, no-wrap
msgid ""
"record Tree a where\n"
"  constructor Node\n"
"  value  : a\n"
"  forest : List (Tree a)\n"
"\n"
"Forest : Type -> Type\n"
"Forest = List . Tree\n"
msgstr ""
"record Tree a where\n"
"  constructor Node\n"
"  value  : a\n"
"  forest : List (Tree a)\n"
"\n"
"Forest : Type -> Type\n"
"Forest = List . Tree\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:620
#, no-wrap
msgid "We could try and compute the size of such a tree as follows:\n"
msgstr "我们可以尝试计算这样一棵树的大小，如下所示：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:621
#, no-wrap
msgid ""
"covering\n"
"size : Tree a -> Nat\n"
"size (Node _ forest) = S . sum $ map size forest\n"
msgstr ""
"covering\n"
"size : Tree a -> Nat\n"
"size (Node _ forest) = S . sum $ map size forest\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:632
#, no-wrap
msgid ""
"In the code above, the recursive call happens within `map`. *We* know that\n"
"we are using only subtrees in the recursive calls (since we know how `map`\n"
"is implemented for `List`), but Idris can't know this (teaching a totality\n"
"checker how to figure this out on its own seems to be an open research\n"
"question). So it will refuse to accept the function as being total.\n"
msgstr "在上面的代码中，递归调用发生在 `map` 中。 *我们* 知道我们在递归调用中只使用子树（因为我们知道 `map` 是如何为 `List` 实现的），但 Idris 不知道这一点（教一个完全性检查器如何自己解决这个问题似乎是一个开放的研究问题）。所以它会拒绝接受这个函数是完全的。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:637
#, no-wrap
msgid ""
"There are two ways to handle the case above. If we don't mind writing\n"
"a bit of otherwise unneeded boilerplate code, we can use explicit recursion.\n"
"In fact, since we often also work with search *forests*, this is\n"
"the preferable way here.\n"
msgstr "有两种方法可以处理上述情况。如果我们不介意编写一些其他不需要的样板代码，我们可以使用显式递归。事实上，由于我们也经常使用搜索 *森林*，因此这是这里的首选方式。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:638
#, no-wrap
msgid ""
"mutual\n"
"  treeSize : Tree a -> Nat\n"
"  treeSize (Node _ forest) = S $ forestSize forest\n"
"\n"
"  forestSize : Forest a -> Nat\n"
"  forestSize []        = 0\n"
"  forestSize (x :: xs) = treeSize x + forestSize xs\n"
msgstr ""
"mutual\n"
"  treeSize : Tree a -> Nat\n"
"  treeSize (Node _ forest) = S $ forestSize forest\n"
"\n"
"  forestSize : Forest a -> Nat\n"
"  forestSize []        = 0\n"
"  forestSize (x :: xs) = treeSize x + forestSize xs\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:652
#, no-wrap
msgid ""
"In the case above, Idris can verify that we don't blow up our trees behind\n"
"its back as we are explicit about what happens in each recursive step.\n"
"This is the safe, preferable way of going about this, especially if you are\n"
"new to the language and totality checking in general.\n"
msgstr "在上面的例子中，Idris 可以验证我们不会在它背后炸毁我们的树，因为我们清楚地知道每个递归步骤中发生的事情。这是解决此问题的安全、可取的方法，特别是如果您不熟悉语言和完全性检查。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:655
#, no-wrap
msgid ""
"However, sometimes the solution presented above is just too cumbersome to\n"
"write. For instance, here is an implementation of `Show` for rose trees:\n"
msgstr "但是，有时上面提出的解决方案写起来太麻烦了。例如，这里是玫瑰树的 `Show` 的实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:656
#, no-wrap
msgid ""
"Show a => Show (Tree a) where\n"
"  showPrec p (Node v ts) =\n"
"    assert_total $ showCon p \"Node\" (showArg v ++ showArg ts)\n"
msgstr ""
"Show a => Show (Tree a) where\n"
"  showPrec p (Node v ts) =\n"
"    assert_total $ showCon p \"Node\" (showArg v ++ showArg ts)\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:667
#, no-wrap
msgid ""
"In this case, we'd have to manually reimplement `Show` for lists of trees:\n"
"A tedious task - and error-prone on its own. Instead, we resort to using the\n"
"mighty sledgehammer of totality checking: `assert_total`. Needless to say\n"
"that this comes with the same risks as `assert_smaller`, so be very\n"
"careful.\n"
msgstr "在这种情况下，我们必须为树列表手动重新实现 `Show`：这是一项乏味的任务——而且它本身很容易出错。相反，我们求助于使用强大的完全性检查大锤：`assert_total`。不用说，这会带来与 `assert_smaller` 相同的风险，所以要非常小心。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:673
#, no-wrap
msgid ""
"Implement the following functions in a provably total\n"
"way without \"cheating\". Note: It is not necessary to\n"
"implement these in a tail recursive way.\n"
msgstr "以可证明的完整方式实现以下功能，而不会“作弊”。注意：没有必要以尾递归的方式实现这些。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:682
#, no-wrap
msgid ""
"<!-- textlint-disable terminology -->\n"
"1. Implement function `depth` for rose trees. This\n"
"   should return the maximal number of `Node` constructors\n"
"   from the current node to the farthest child node.\n"
"   For instance, the current node should be at depth one,\n"
"   all its direct child nodes are at depth two, their\n"
"   immediate child nodes at depth three and so on.\n"
"<!-- textlint-enable -->\n"
msgstr ""
"<!-- textlint-disable terminology -->\n"
"1. 实现玫瑰树上的函数 `depth`。这个\n"
"   应该从当前节点到最远的子节点返回最大数量的 `Node` 构造函数。\n"
"   例如，当前节点在深度一，\n"
"   它的所有深度为二直接子节点，它们的\n"
"   深度三的直接子节点，依此类推。\n"
"<!-- textlint-enable -->\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:684
#, no-wrap
msgid "Implement interface `Eq` for rose trees.\n"
msgstr "为玫瑰树实现接口 `Eq`。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:686
#, no-wrap
msgid "Implement interface `Functor` for rose trees.\n"
msgstr "为玫瑰树实现接口 `Functor`。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:688
#, no-wrap
msgid "For the fun of it: Implement interface `Show` for rose trees.\n"
msgstr "为了乐趣：为玫瑰树实现接口`Show`。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:692
#, no-wrap
msgid ""
"In order not to forget how to program with dependent types,\n"
"implement function `treeToVect` for converting a rose\n"
"tree to a vector of the correct size.\n"
msgstr "为了不忘记如何使用依赖类型进行编程，请实现函数 `treeToVect` "
"以将玫瑰树转换为正确大小的向量。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:696
#, no-wrap
msgid ""
"   Hint: Make sure to follow the same recursion scheme as in\n"
"   the implementation of `treeSize`. Otherwise, this might be\n"
"   very hard to get to work.\n"
msgstr "   提示：确保遵循与`treeSize` 的实现中相同的递归方案。否则，这可能是很难工作。\n"

#. type: Title ##
#: ../src/Tutorial/Folds.md:697
#, no-wrap
msgid "Interface Foldable"
msgstr "Foldable 接口"

#. type: Plain text
#: ../src/Tutorial/Folds.md:707
#, no-wrap
msgid ""
"When looking back at all the exercises we solved\n"
"in the section about recursion, most tail recursive functions\n"
"on lists were of the following pattern: Iterate\n"
"over all list elements from head to tail while\n"
"passing along some state for accumulating intermediate\n"
"results. At the end of the list,\n"
"return the final state or convert it with an\n"
"additional function call.\n"
msgstr "当回顾我们在递归部分解决的所有练习时，列表中的大多数尾递归函数都遵循以下模式：从头到尾迭代所有列表元素，同时传递一些状态以累积中间结果。在列表的末尾，返回最终状态或使用附加函数调用对其进行转换。\n"

#. type: Title ###
#: ../src/Tutorial/Folds.md:708
#, no-wrap
msgid "Left Folds"
msgstr "左折叠"

#. type: Plain text
#: ../src/Tutorial/Folds.md:719
#, no-wrap
msgid ""
"This is functional programming, and we'd like to abstract\n"
"over such reoccurring patterns. In order to tail recursively\n"
"iterate over a list, all we need is an accumulator function\n"
"and some initial state. But what should be the type of\n"
"the accumulator? Well, it combines the current state\n"
"with the list's next element and returns an updated\n"
"state: `state -> elem -> state`. Surely, we can come\n"
"up with a higher-order function to encapsulate this\n"
"behavior:\n"
msgstr "这是函数式编程，我们想抽象出这种重复出现的模式。为了对列表进行递归迭代，我们只需要一个累加器函数和一些初始状态。但是累加器的类型应该是什么？好吧，它将当前状态与列表的下一个元素组合并返回更新状态：`state -> elem -> state`。当然，我们可以提出一个高阶函数来封装这种行为：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:720
#, no-wrap
msgid ""
"leftFold : (acc : state -> el -> state) -> (st : state) -> List el -> state\n"
"leftFold _   st []        = st\n"
"leftFold acc st (x :: xs) = leftFold acc (acc st x) xs\n"
msgstr ""
"leftFold : (acc : state -> el -> state) -> (st : state) -> List el -> state\n"
"leftFold _   st []        = st\n"
"leftFold acc st (x :: xs) = leftFold acc (acc st x) xs\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:734
#, no-wrap
msgid ""
"We call this function a *left fold*, as it iterates over\n"
"the list from left to right (head to tail), collapsing (or\n"
"*folding*) the list until just a single value remains.\n"
"This new value might still be a list or other container type,\n"
"but the original list has been consumed from head to tail.\n"
"Note how `leftFold` is tail recursive, and therefore all\n"
"functions implemented in terms of `leftFold` are\n"
"tail recursive (and thus, stack safe!) as well.\n"
msgstr "我们将此函数称为 *左折叠*，因为它从左到右（从头到尾）迭代列表，折叠（或 *folding*）列表直到只剩下一个值。这个新值可能仍然是一个列表或其他容器类型，但原来的列表已经从头到尾被消耗掉了。请注意 `leftFold` 是如何尾递归的，因此根据 `leftFold` 实现的所有函数也是尾递归的（因此，堆栈安全！）。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:736
#, no-wrap
msgid "Here are a few examples:\n"
msgstr "这里有一些例子：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:737
#, no-wrap
msgid ""
"sumLF : Num a => List a -> a\n"
"sumLF = leftFold (+) 0\n"
"\n"
"reverseLF : List a -> List a\n"
"reverseLF = leftFold (flip (::)) Nil\n"
"\n"
"-- this is more natural than `reverseLF`!\n"
"toSnocListLF : List a -> SnocList a\n"
"toSnocListLF = leftFold (:<) Lin\n"
msgstr ""
"sumLF : Num a => List a -> a\n"
"sumLF = leftFold (+) 0\n"
"\n"
"reverseLF : List a -> List a\n"
"reverseLF = leftFold (flip (::)) Nil\n"
"\n"
"-- this is more natural than `reverseLF`!\n"
"toSnocListLF : List a -> SnocList a\n"
"toSnocListLF = leftFold (:<) Lin\n"

#. type: Title ###
#: ../src/Tutorial/Folds.md:749
#, no-wrap
msgid "Right Folds"
msgstr "右折叠"

#. type: Plain text
#: ../src/Tutorial/Folds.md:760
#, no-wrap
msgid ""
"The example functions we implemented in terms of `leftFold` had\n"
"to always completely traverse the whole list, as every single\n"
"element was required to compute the result. This is not always\n"
"necessary, however. For instance, if you look at `findList` from\n"
"the exercises, we could abort iterating over the list as soon\n"
"as our search was successful. It is *not* possible to implement\n"
"this more efficient behavior in terms of `leftFold`: There,\n"
"the result will only be returned when our pattern match reaches\n"
"the `Nil` case.\n"
msgstr "我们根据 `leftFold` 实现的示例函数必须始终完全遍历整个列表，因为需要每个元素来计算结果。然而，这并不总是必要的。例如，如果您查看练习中的 `findList`，我们可以在搜索成功后立即中止迭代列表。在 `leftFold` 方面，*不* 可能实现这种更有效的行为：在那里，只有当我们的模式匹配达到 `Nil` 情况时才会返回结果。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:765
#, no-wrap
msgid ""
"Interestingly, there is another, non-tail recursive fold, which\n"
"reflects the list structure more naturally, we can use for\n"
"breaking out early from an iteration. We call this a\n"
"*right fold*. Here is its implementation:\n"
msgstr "有趣的是，还有另一种非尾递归折叠，它更自然地反映了列表结构，我们可以用于从迭代的早期突破。我们称之为 *右折叠*。这是它的实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:766
#, no-wrap
msgid ""
"rightFold : (acc : el -> state -> state) -> state -> List el -> state\n"
"rightFold acc st []        = st\n"
"rightFold acc st (x :: xs) = acc x (rightFold acc st xs)\n"
msgstr ""
"rightFold : (acc : el -> state -> state) -> state -> List el -> state\n"
"rightFold acc st []        = st\n"
"rightFold acc st (x :: xs) = acc x (rightFold acc st xs)\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:775
#, no-wrap
msgid ""
"Now, it might not immediately be obvious how this differs from `leftFold`.\n"
"In order to see this, we will have to talk about lazy evaluation\n"
"first.\n"
msgstr "现在，它与 `leftFold` 的区别可能不是很明显。为了看到这一点，我们必须先谈谈惰性求值。\n"

#. type: Title ####
#: ../src/Tutorial/Folds.md:776
#, no-wrap
msgid "Lazy Evaluation in Idris"
msgstr "Idris 中的惰性求值"

#. type: Plain text
#: ../src/Tutorial/Folds.md:784
#, no-wrap
msgid ""
"For some computations, it is not necessary to evaluate all function\n"
"arguments in order to return a result. For instance, consider\n"
"boolean operator `(&&)`: If the first argument evaluates to `False`,\n"
"we already know that the result is `False` without even looking at\n"
"the second argument. In such a case, we don't want to unnecessarily evaluate\n"
"the second argument, as this might include a lengthy computation.\n"
msgstr "对于某些计算，无需求值所有函数参数即可返回结果。例如，考虑布尔运算符 `(&&)`：如果第一个参数的计算结果为 `False`，我们甚至无需查看第二个参数就已经知道争论结果是 `False`。在这种情况下，我们不想也不需要地求值第二个参数，因为这可能包括冗长的计算。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:786
#, no-wrap
msgid "Consider the following REPL session:\n"
msgstr "考虑以下 REPL 会话：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:787
#, no-wrap
msgid ""
"Tutorial.Folds> False && (length [1..10000000000] > 100)\n"
"False\n"
msgstr ""
"Tutorial.Folds> False && (length [1..10000000000] > 100)\n"
"False\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:797
#, no-wrap
msgid ""
"If the second argument were evaluated, this computation would most\n"
"certainly blow up your computer's memory, or at least take a very long\n"
"time to run to completion. However, in this case, the result `False` is\n"
"printed immediately. If you look at the type of `(&&)`, you'll see\n"
"the following:\n"
msgstr "如果计算第二个参数，这个计算肯定会炸毁你的计算机内存，或者至少需要很长时间才能完成。但是，在这种情况下，会立即打印结果 `False`。如果查看 `(&&)` 的类型，您将看到以下内容：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:798
#, no-wrap
msgid ""
"Tutorial.Folds> :t (&&)\n"
"Prelude.&& : Bool -> Lazy Bool -> Bool\n"
msgstr ""
"Tutorial.Folds> :t (&&)\n"
"Prelude.&& : Bool -> Lazy Bool -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:816
#, no-wrap
msgid ""
"As you can see, the second argument is wrapped in a `Lazy` type\n"
"constructor. This is a built-in type, and the details are handled\n"
"by Idris automatically most of the time. For instance, when passing\n"
"arguments to `(&&)`, we don't have to manually wrap the values in\n"
"some data constructor.\n"
"A lazy function argument will only be evaluated at the moment it\n"
"is *required* in the function's implementation, for instance,\n"
"because it is being pattern matched on, or it is being passed\n"
"as a strict argument to another function. In the implementation\n"
"of `(&&)`, the pattern match happens\n"
"on the first argument, so the second will only be evaluated if\n"
"the first argument is `True` and the second is returned as the function's\n"
"(strict) result.\n"
msgstr "如您所见，第二个参数包装在 `Lazy` 类型构造函数中。这是一个内置类型，大部分时间细节由 Idris 自动处理。例如，当将参数传递给 `(&&)` 时，我们不必手动将值包装在某些数据构造函数中。惰性函数参数仅在函数实现中为 *required* 时才被评估，例如，因为它正在被模式匹配，或者它作为严格参数传递给另一个函数。在 `(&&)` 的实现中，模式匹配发生在第一个参数上，因此只有当第一个参数是 `True` 并且第二个参数作为函数返回时才会计算第二个参数（严格）结果。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:821
#, no-wrap
msgid ""
"There are two utility functions for working with lazy evaluation:\n"
"Function `delay` wraps a value in the `Lazy` data type. Note, that\n"
"the argument of `delay` is strict, so the following might take\n"
"several seconds to print its result:\n"
msgstr "有两个实用函数用于处理惰性求值： 函数 `delay` 将值包装在 `Lazy` 数据类型中。请注意，`delay` 的参数是严格的，因此以下可能需要几秒钟才能打印其结果：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:822
#, no-wrap
msgid ""
"Tutorial.Folds> False && (delay $ length [1..10000] > 100)\n"
"False\n"
msgstr ""
"Tutorial.Folds> False && (delay $ length [1..10000] > 100)\n"
"False\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:829
#, no-wrap
msgid ""
"In addition, there is function `force`, which forces evaluation\n"
"of a `Lazy` value.\n"
msgstr "此外，还有一个函数 `force`，它强制对 `Lazy` 值进行求值。\n"

#. type: Title ####
#: ../src/Tutorial/Folds.md:830
#, no-wrap
msgid "Lazy Evaluation and Right Folds"
msgstr "惰性求值和右折叠"

#. type: Plain text
#: ../src/Tutorial/Folds.md:838
#, no-wrap
msgid ""
"We will now learn how to make use of `rightFold` and lazy evaluation\n"
"to implement folds, which can break out from iteration early.\n"
"Note, that in the implementation of `rightFold` the result of\n"
"folding over the remainder of the list is passed as an argument\n"
"to the accumulator (instead of the result of invoking the accumulator\n"
"being used in the recursive call):\n"
msgstr "我们现在将学习如何利用 `rightFold` 和惰性求值来实现折叠，它可以在迭代早期中断迭代。请注意，在 `rightFold` 的实现中，折叠列表剩余部分的结果作为参数传递给累加器（而不是在递归调用中调用累加器的结果）：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:839
#, no-wrap
msgid "rightFold acc st (x :: xs) = acc x (rightFold acc st xs)\n"
msgstr "rightFold acc st (x :: xs) = acc x (rightFold acc st xs)\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:846
#, no-wrap
msgid ""
"If the second argument of `acc` were lazily evaluated, it would be possible\n"
"to abort the computation of `acc`'s result without having to iterate\n"
"till the end of the list:\n"
msgstr "如果 `acc` 的第二个参数被延迟求值，则可以中止 `acc` 的结果的计算，而不必迭代到列表末尾：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:847
#, no-wrap
msgid ""
"foldHead : List a -> Maybe a\n"
"foldHead = force . rightFold first Nothing\n"
"  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)\n"
"        first v _ = Just v\n"
msgstr ""
"foldHead : List a -> Maybe a\n"
"foldHead = force . rightFold first Nothing\n"
"  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)\n"
"        first v _ = Just v\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:858
#, no-wrap
msgid ""
"Note, how Idris takes care of the bookkeeping of laziness most of the time. (It\n"
"doesn't handle the curried invocation of `rightFold` correctly, though, so we\n"
"either must pass on the list argument of `foldHead` explicitly, or compose\n"
"the curried function with `force` to get the types right.)\n"
msgstr "请注意，Idris 在大多数情况下是如何处理懒惰的。 （但是，它不能正确处理 `rightFold` 的柯里化调用，因此我们要么必须显式传递 `foldHead` 的列表参数，要么使用 `force` 组合柯里化函数获得正确的类型。）\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:865
#, no-wrap
msgid ""
"In order to verify that this works correctly, we need a debugging utility\n"
"called `trace` from module `Debug.Trace`. This \"function\" allows us to\n"
"print debugging messages to the console at certain points in our pure\n"
"code. Please note, that this is for debugging purposes only and should\n"
"never be left lying around in production code, as, strictly speaking,\n"
"printing stuff to the console breaks referential transparency.\n"
msgstr "为了验证它是否正常工作，我们需要一个来自模块 `Debug.Trace` 的名为 `trace` 的调试实用程序。这个“函数”允许我们在纯代码中的某些点将调试消息打印到控制台。请注意，这仅用于调试目的，绝不应留在生产代码中，因为严格来说，将内容打印到控制台会破坏引用透明度。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:868
#, no-wrap
msgid ""
"Here is an adjusted version of `foldHead`, which prints \"folded\" to\n"
"standard output every time utility function `first` is being invoked:\n"
msgstr "这是 `foldHead` 的调整版本，每次调用实用函数 `first` 时都会将“折叠”打印到标准输出：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:869
#, no-wrap
msgid ""
"foldHeadTraced : List a -> Maybe a\n"
"foldHeadTraced = force . rightFold first Nothing\n"
"  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)\n"
"        first v _ = trace \"folded\" (Just v)\n"
msgstr ""
"foldHeadTraced : List a -> Maybe a\n"
"foldHeadTraced = force . rightFold first Nothing\n"
"  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)\n"
"        first v _ = trace \"folded\" (Just v)\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:879
#, no-wrap
msgid ""
"In order to test this at the REPL, we need to know that `trace` uses `unsafePerformIO`\n"
"internally and therefore will not reduce during evaluation. We have to\n"
"resort to the `:exec` command to see this in action at the REPL:\n"
msgstr "为了在 REPL 上进行测试，我们需要知道 `trace` 在内部使用 `unsafePerformIO`，因此在求值期间不会缩减「译者注：不会执行副作用」。我们必须求助于 `:exec` 命令才能在 REPL 中看到这一点：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:880
#, no-wrap
msgid ""
"Tutorial.Folds> :exec printLn $ foldHeadTraced [1..10]\n"
"folded\n"
"Just 1\n"
msgstr ""
"Tutorial.Folds> :exec printLn $ foldHeadTraced [1..10]\n"
"folded\n"
"Just 1\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:888
#, no-wrap
msgid ""
"As you can see, although the list holds ten elements, `first` is only called\n"
"once resulting in a considerable increase of efficiency.\n"
msgstr "如您所见，虽然列表包含十个元素，但 `first` 仅被调用一次，从而大大提高了效率。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:891
#, no-wrap
msgid ""
"Let's see what happens, if we change the implementation of `first` to\n"
"use strict evaluation:\n"
msgstr "让我们看看会发生什么，如果我们将 `first` 的实现更改为使用严格求值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:892
#, no-wrap
msgid ""
"foldHeadTracedStrict : List a -> Maybe a\n"
"foldHeadTracedStrict = rightFold first Nothing\n"
"  where first : a -> Maybe a -> Maybe a\n"
"        first v _ = trace \"folded\" (Just v)\n"
msgstr ""
"foldHeadTracedStrict : List a -> Maybe a\n"
"foldHeadTracedStrict = rightFold first Nothing\n"
"  where first : a -> Maybe a -> Maybe a\n"
"        first v _ = trace \"folded\" (Just v)\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:903
#, no-wrap
msgid ""
"Although we don't use the second argument in the implementation of `first`,\n"
"it is still being evaluated before evaluating the body of `first`, because\n"
"Idris - unlike Haskell! - defaults to use strict semantics. Here's how this\n"
"behaves at the REPL:\n"
msgstr "虽然我们在 `first` 的实现中没有使用第二个参数，但它仍然在评估 `first` 的主体之前被评估，因为 Idris - 不像 Haskell！ - 默认使用严格的语义。以下是它在 REPL 中的行为方式：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:904
#, no-wrap
msgid ""
"Tutorial.Folds> :exec printLn $ foldHeadTracedStrict [1..10]\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"Just 1\n"
msgstr ""
"Tutorial.Folds> :exec printLn $ foldHeadTracedStrict [1..10]\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"Just 1\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:925
#, no-wrap
msgid ""
"While this technique can sometimes lead to very elegant code, always\n"
"remember that `rightFold` is not stack safe in the general case. So,\n"
"unless your accumulator is not guaranteed to return a result after\n"
"not too many iterations, consider implementing your function\n"
"tail recursively with an explicit pattern match. Your code will be\n"
"slightly more verbose, but with the guaranteed benefit of stack safety.\n"
msgstr "虽然这种技术有时会产生非常优雅的代码，但请始终记住 `rightFold` 在一般情况下不是堆栈安全的。因此，除非您的累加器不能保证在没有太多迭代后返回结果，否则请考虑使用显式模式匹配的尾递归地实现您的函数。您的代码会稍微冗长一些，但可以保证堆栈安全。\n"

#. type: Title ###
#: ../src/Tutorial/Folds.md:926
#, no-wrap
msgid "Folds and Monoids"
msgstr "折叠和幺半群"

#. type: Plain text
#: ../src/Tutorial/Folds.md:934
#, no-wrap
msgid ""
"Left and right folds share a common pattern: In both cases, we start\n"
"with an initial *state* value and use an accumulator function for\n"
"combining the current state with the current element. This principle\n"
"of *combining values* after starting from an *initial value* lies\n"
"at the heart of an interface we've already learned about: `Monoid`.\n"
"It therefore makes sense to fold a list over a monoid:\n"
msgstr "左右折叠有一个共同的模式：在这两种情况下，我们从初始*状态*值开始，并使用累加器函数将当前状态与当前元素相结合。从*初始值*开始后*组合值*的原理是我们已经了解的接口的核心：`Monoid`。因此，将列表折叠在一个幺半群上是有意义的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:935
#, no-wrap
msgid ""
"foldMapList : Monoid m => (a -> m) -> List a -> m\n"
"foldMapList f = leftFold (\\vm,va => vm <+> f va) neutral\n"
msgstr ""
"foldMapList : Monoid m => (a -> m) -> List a -> m\n"
"foldMapList f = leftFold (\\vm,va => vm <+> f va) neutral\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:946
#, no-wrap
msgid ""
"Note how, with `foldMapList`, we no longer need to pass an accumulator\n"
"function. All we need is a conversion from the element type to\n"
"a type with an implementation of `Monoid`. As we have already seen\n"
"in the chapter about [interfaces](Interfaces.md), there are *many*\n"
"monoids in functional programming, and therefore, `foldMapList` is\n"
"an incredibly useful function.\n"
msgstr "请注意，使用 `foldMapList`，我们不再需要传递累加器函数。我们所需要的只是将元素类型转换为具有 `Monoid` 实现的类型。正如我们在关于 [接口](Interfaces.md) 的章节中已经看到的，在函数式编程中有 *很多* 幺半群，因此，`foldMapList` 是一个非常有用的函数。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:950
#, no-wrap
msgid ""
"We could make this even shorter: If the elements in our list already\n"
"are of a type with a monoid implementation, we don't even need a\n"
"conversion function to collapse the list:\n"
msgstr "我们可以让这个更短：如果我们列表中的元素已经是具有 monoid 实现的类型，我们甚至不需要转换函数来折叠列表：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:951
#, no-wrap
msgid ""
"concatList : Monoid m => List m -> m\n"
"concatList = foldMapList id\n"
msgstr ""
"concatList : Monoid m => List m -> m\n"
"concatList = foldMapList id\n"

#. type: Title ###
#: ../src/Tutorial/Folds.md:956
#, no-wrap
msgid "Stop Using `List` for Everything"
msgstr "停止对所有内容使用 `List`"

#. type: Plain text
#: ../src/Tutorial/Folds.md:971
#, no-wrap
msgid ""
"And here we are, finally, looking at a large pile of utility functions\n"
"all dealing in some way with the concept of collapsing (or folding)\n"
"a list of values into a single result. But all of these folding functions\n"
"are just as useful when working with vectors, with non-empty lists, with\n"
"rose trees, even with single-value containers like `Maybe`, `Either e`,\n"
"or `Identity`. Heck, for the sake of completeness, they are even useful\n"
"when working with zero-value containers like `Control.Applicative.Const e`!\n"
"And since there are so many of these functions, we'd better look out for\n"
"an essential set of them in terms of which we can implement all\n"
"the others, and wrap up the whole bunch in an interface. This interface\n"
"is called `Foldable`, and is available from the `Prelude`. When you\n"
"look at its definition in the REPL (`:doc Foldable`), you'll see that\n"
"it consists of six essential functions:\n"
msgstr "最后，我们在这里查看一大堆实用函数，它们都以某种方式处理将值列表折叠（或折叠）为单个结果的概念。但是所有这些折叠函数在处理向量、非空列表、玫瑰树，甚至是单值容器（如 `Maybe`、`e` 或`Identity`。哎呀，为了完整起见，它们甚至在使用诸如 `Control.Applicative.Const e` 之类的零值容器时很有用！而且由于这些功能有很多，我们最好找出其中的一组基本功能，我们可以根据这些功能实现所有其他功能，并将所有功能封装在一个接口中。此接口称为 `Foldable`，可从 `Prelude` 获得。当你在 REPL (`:doc Foldable`) 中查看它的定义时，你会发现它包含六个基本函数：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
#, no-wrap
msgid "`foldr`, for folds from the right\n"
msgstr "`foldr`，用于从右侧折叠\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
#, no-wrap
msgid "`foldl`, for folds from the left\n"
msgstr "`foldl`，用于从左侧折叠\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
#, no-wrap
msgid "`null`, for testing if the container is empty or not\n"
msgstr "`null`，用于测试容器是否为空\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
#, no-wrap
msgid "`foldlM`, for effectful folds in a monad\n"
msgstr "`foldlM`，用于单子中的副作用折叠\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
#, no-wrap
msgid "`toList`, for converting the container to a list of values\n"
msgstr "`toList`，用于将容器转换为值列表\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
#, no-wrap
msgid "`foldMap`, for folding over a monoid\n"
msgstr "`foldMap`，用于折叠一个幺半群\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:987
#, no-wrap
msgid ""
"For a minimal implementation of `Foldable`, it is sufficient to only\n"
"implement `foldr`. However, consider implementing all six functions\n"
"manually, because folds over container types are often performance\n"
"critical operations, and each of them should be optimized accordingly.\n"
"For instance, implementing `toList` in terms of `foldr` for `List`\n"
"just makes no sense, as this is a non-tail recursive function\n"
"running in linear time complexity, while a hand-written implementation\n"
"can just return its argument without any modifications.\n"
msgstr "对于 `Foldable` 的最小实现，仅实现 `foldr` 就足够了。但是，请考虑手动实现所有六个函数，因为对容器类型的折叠通常是性能关键操作，并且应相应地优化它们中的每一个。例如，根据 `List` 的 `foldr` 来实现 `toList` 是没有意义的，因为这是一个以线性时间复杂度运行的非尾递归函数，而一个手写的实现可以只返回它的参数而不做任何修改。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:993
#, no-wrap
msgid ""
"In these exercises, you are going to implement `Foldable`\n"
"for different data types. Make sure to try and manually\n"
"implement all six functions of the interface.\n"
msgstr "在这些练习中，您将为不同的数据类型实现 `Foldable`。确保尝试手动实现接口中的所有六个函数。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Folds.md:995
#, no-wrap
msgid "Implement `Foldable` for `Crud i`:\n"
msgstr "为 `Crud i` 实现 `Foldable`：\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:1005
#, no-wrap
msgid "Implement `Foldable` for `Response e i`:\n"
msgstr "为 `Response e i` 实现 `Foldable`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1006 ../src/Tutorial/Functor.md:429
#: ../src/Tutorial/Traverse.md:295
#, no-wrap
msgid ""
"   data Response : (e, i, a : Type) -> Type where\n"
"     Created : (id : i) -> (value : a) -> Response e i a\n"
"     Updated : (id : i) -> (value : a) -> Response e i a\n"
"     Found   : (values : List a) -> Response e i a\n"
"     Deleted : (id : i) -> Response e i a\n"
"     Error   : (err : e) -> Response e i a\n"
msgstr ""
"   data Response : (e, i, a : Type) -> Type where\n"
"     Created : (id : i) -> (value : a) -> Response e i a\n"
"     Updated : (id : i) -> (value : a) -> Response e i a\n"
"     Found   : (values : List a) -> Response e i a\n"
"     Deleted : (id : i) -> Response e i a\n"
"     Error   : (err : e) -> Response e i a\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:1018
#, no-wrap
msgid ""
"Implement `Foldable` for `List01`. Use tail recursion\n"
"in the implementations of `toList`, `foldMap`, and\n"
"`foldl`.\n"
msgstr "为 `List01` 实现 `Foldable`。在 `toList`、`foldMap` 和 `foldl` "
"的实现中使用尾递归。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/Traverse.md:267
#, no-wrap
msgid ""
"   data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"     Nil  : List01 False a\n"
"     (::) : a -> List01 False a -> List01 ne a\n"
msgstr ""
"   data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"     Nil  : List01 False a\n"
"     (::) : a -> List01 False a -> List01 ne a\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:1030
#, no-wrap
msgid ""
"Implement `Foldable` for `Tree`. There is no need\n"
"to use tail recursion in your implementations, but\n"
"your functions must be accepted by the totality\n"
"checker, and you are not allowed to cheat by using\n"
"`assert_smaller` or `assert_total`.\n"
msgstr ""
"为 `Tree` 实现 "
"`Foldable`。在你的实现中不需要使用尾递归，但你的函数必须被完全性检查器接受，"
"并且你不能使用 `assert_smaller` 或 `assert_total` 作弊。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:1034
#, no-wrap
msgid ""
"   Hint: You can test the correct behavior of your implementations\n"
"   by running the same folds on the result of `treeToVect` and\n"
"   verify that the outcome is the same.\n"
msgstr ""
"   提示：您可以测试实现的正确行为\n"
"   通过对 `treeToVect` 的结果运行相同的折叠并且验证结果是否相同。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:1039
#, no-wrap
msgid ""
"Like `Functor` and `Applicative`, `Foldable` composes:\n"
"The product and composition of two foldable container\n"
"types are again foldable container types. Proof\n"
"this by implementing `Foldable` for `Comp` and `Product`:\n"
msgstr ""
"与 `Functor` 和 `Applicative` 一样，`Foldable` 组合： "
"两种可折叠容器类型的乘积和组合又是可折叠容器类型。通过为 `Comp` 和 `Product` "
"实现 `Foldable` 来证明这一点：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1040 ../src/Tutorial/Traverse.md:308
#, no-wrap
msgid ""
"   record Comp (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkComp\n"
"     unComp  : f (g a)\n"
"\n"
"   record Product (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkProduct\n"
"     fst : f a\n"
"     snd : g a\n"
msgstr ""
"   record Comp (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkComp\n"
"     unComp  : f (g a)\n"
"\n"
"   record Product (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkProduct\n"
"     fst : f a\n"
"     snd : g a\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:1058
#, no-wrap
msgid ""
"We learned a lot about recursion, totality checking, and folds\n"
"in this chapter, all of which are important concepts in pure\n"
"functional programming in general. Wrapping one's head\n"
"around recursion takes time and experience. Therefore - as\n"
"usual - try to solve as many exercises as you can.\n"
msgstr "我们在本章中学到了很多关于递归、完全性检查和折叠的知识，所有这些都是纯函数式编程中的重要概念。围绕递归进行思考需要时间和经验。因此 - 像往常一样 - 尝试尽可能多地解决练习。\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:1062
#, no-wrap
msgid ""
"In the next chapter, we are taking the concept of iterating\n"
"over container types one step further and look at\n"
"effectful data traversals.\n"
msgstr "在下一章中，我们将迭代容器类型的概念更进一步，并研究有效的数据遍历。\n"

#. type: Title #
#: ../src/Tutorial/Functions1.md:1
#, no-wrap
msgid "Functions Part 1"
msgstr "函数第 1 部分"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:12
#, no-wrap
msgid ""
"Idris is a *functional* programming language. This means,\n"
"that functions are its main form of abstraction (unlike for\n"
"instance in an object oriented language like Java, where\n"
"*objects* and *classes* are the main form of abstraction). It also\n"
"means that we expect Idris to make it very easy for\n"
"us to compose and combine functions to create new\n"
"functions. In fact, in Idris functions are *first class*:\n"
"Functions can take other functions as arguments and\n"
"can return functions as their results.\n"
msgstr "Idris 是一种*函数式*编程语言。这意味着，函数是它的主要抽象形式（与 Java 等面向对象的语言不同，其中 *objects* 和 *classes* 是抽象的主要形式）。这也意味着我们希望 Idris 能够让我们非常轻松地组合函数以创建新函数。实际上，在 Idris 中，函数是*一等*的：函数可以将其他函数作为参数，并且可以将函数作为结果返回。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:16
#, no-wrap
msgid ""
"We already learned about the basic shape of top level\n"
"function declarations in Idris in the [introduction](Intro.md),\n"
"so we will continue from what we learned there.\n"
msgstr "我们已经在 [介绍](Intro.md) 中了解了 Idris 中顶级函数声明的基本形式，因此我们将从那里学到的内容继续。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:17
#, no-wrap
msgid "module Tutorial.Functions1\n"
msgstr "module Tutorial.Functions1\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:21
#, no-wrap
msgid "Functions with more than one Argument"
msgstr "具有多个参数的函数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:28
#, no-wrap
msgid ""
"Let's implement a function, which checks if its three\n"
"`Integer` arguments form a\n"
"[Pythagorean triple](https://en.wikipedia.org/wiki/Pythagorean_triple).\n"
"We get to use a new operator for this: `==`, the equality\n"
"operator.\n"
msgstr "让我们实现一个函数，它检查它的三个 `Integer` 参数是否形成一个 [勾股三元组](https://en.wikipedia.org/wiki/Pythagorean_triple)。我们为此使用一个新的运算符：`==`，相等运算符。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:29
#, no-wrap
msgid ""
"isTriple : Integer -> Integer -> Integer -> Bool\n"
"isTriple x y z = x * x + y * y == z * z\n"
msgstr ""
"isTriple : Integer -> Integer -> Integer -> Bool\n"
"isTriple x y z = x * x + y * y == z * z\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:36
#, no-wrap
msgid ""
"Let's give this a spin at the REPL before we talk a bit\n"
"about the types:\n"
msgstr "在讨论类型之前，让我们先在 REPL 上试一下：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:37
#, no-wrap
msgid ""
"Tutorial.Functions1> isTriple 1 2 3\n"
"False\n"
"Tutorial.Functions1> isTriple 3 4 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> isTriple 1 2 3\n"
"False\n"
"Tutorial.Functions1> isTriple 3 4 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:49
#, no-wrap
msgid ""
"As can be seen from this example, the type of a function\n"
"of several arguments consists just of a sequence\n"
"of argument types (also called *input types*)\n"
"chained by function arrows (`->`), which\n"
"is terminated by an output type (`Bool` in this case).\n"
msgstr "从这个例子可以看出，多参函数的类型包含一个参数类型的序列（也称为 *输入类型*），由函数箭头（`->`）链接起来，其中由输出类型终止（在本例中为 `Bool`）。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:61
#, no-wrap
msgid ""
"The implementation looks a bit like a mathematical equation:\n"
"We list the arguments on the left hand side of `=` and describe the\n"
"computation(s) to perform with them on the right hand\n"
"side. Function implementations in functional programming\n"
"languages often have this more mathematical look compared\n"
"to implementations in imperative  languages, which often\n"
"describe not *what* to compute, but *how* to\n"
"compute it by describing an algorithm as a sequence of\n"
"imperative statements. We will later see that this\n"
"imperative style is also available in Idris, but whenever\n"
"possible we prefer the declarative style.\n"
msgstr "该实现看起来有点像一个数学方程：我们在 `=` 的左侧列出参数，并在右侧描述要使用它们执行的计算。与命令式语言中的实现相比，函数式编程语言中的函数实现通常具有更多的数学外观，命令式语言通常不是描述*要计算什么*，而是通过将算法描述为*如何*来计算它命令式语句的序列。我们稍后会看到这种命令式风格在 Idris 中也可用，但只要有可能，我们更喜欢声明式风格。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:68
#, no-wrap
msgid ""
"As can be seen in the REPL example, functions can be invoked\n"
"by passing the arguments separated by whitespace. No parentheses\n"
"are necessary unless one of the expressions we pass as the\n"
"function's arguments contains itself additional whitespace.\n"
"This comes in very handy when we apply functions\n"
"only partially (see later in this chapter).\n"
msgstr "从 REPL 示例中可以看出，可以通过传递由空格分隔的参数来调用函数。除非我们作为将包含额外的空格的表达式作为函数参数进行传递，否则不需要括号。当我们仅部分应用函数时，这非常方便（见本章后面）。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:74
#, no-wrap
msgid ""
"Note that, unlike `Integer` or `Bits8`, `Bool` is not a primitive\n"
"data type built into the Idris language but just a custom\n"
"data type that you could have written yourself. We will\n"
"learn more about declaring new data types in the\n"
"next chapter.\n"
msgstr "请注意，与 `Integer` 或 `Bits8` 不同，`Bool` 不是 Idris 语言中内置的原语数据类型，而只是您可以自己编写的自定义数据类型.我们将在下一章了解更多关于声明新数据类型的内容。\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:75
#, no-wrap
msgid "Function Composition"
msgstr "函数组合"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:79
#, no-wrap
msgid ""
"Functions can be combined in several ways, the most direct\n"
"probably being the dot operator:\n"
msgstr "函数可以通过多种方式组合，最直接的可能是点运算符：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:80
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
"\n"
"times2 : Integer -> Integer\n"
"times2 n = 2 * n\n"
"\n"
"squareTimes2 : Integer -> Integer\n"
"squareTimes2 = times2 . square\n"
msgstr ""
"square : Integer -> Integer\n"
"square n = n * n\n"
"\n"
"times2 : Integer -> Integer\n"
"times2 n = 2 * n\n"
"\n"
"squareTimes2 : Integer -> Integer\n"
"squareTimes2 = times2 . square\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:92
#, no-wrap
msgid "Give this a try at the REPL! Does it do what you'd expect?\n"
msgstr "在 REPL 试试这个！它是否符合您的预期？\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:95
#, no-wrap
msgid ""
"We could have implemented `squareTimes2` without using\n"
"the dot operator as follows:\n"
msgstr "我们可以在不使用点运算符的情况下实现 `squareTimes2`，如下所示：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:96
#, no-wrap
msgid ""
"squareTimes2' : Integer -> Integer\n"
"squareTimes2' n = times2 (square n)\n"
msgstr ""
"squareTimes2' : Integer -> Integer\n"
"squareTimes2' n = times2 (square n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:105
#, no-wrap
msgid ""
"It is important to note, that functions chained by the dot\n"
"operator are invoked from right to left: `times2 . square`\n"
"is the same as `\\n => times2 (square n)` and not\n"
"`\\n => square (times2 n)`.\n"
msgstr "需要注意的是，由点链接的函数，运算符会从右到左调用： `times2 . square`，等同于 `\\n => times2 (square n)` ，而不是 `\\n => square (times2 n)`。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:108
#, no-wrap
msgid ""
"We can conveniently chain several functions using the\n"
"dot operator to write more complex functions:\n"
msgstr "我们可以方便地使用点运算符链接多个函数来编写更复杂的函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:109
#, no-wrap
msgid ""
"dotChain : Integer -> String\n"
"dotChain = reverse . show . square . square . times2 . times2\n"
msgstr ""
"dotChain : Integer -> String\n"
"dotChain = reverse . show . square . square . times2 . times2\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:119
#, no-wrap
msgid ""
"This will first multiply the argument by four, then square\n"
"it twice before converting it to a string (`show`) and\n"
"reversing the resulting `String` (functions `show` and\n"
"`reverse` are part of the Idris *Prelude* and as such are\n"
"available in every Idris program).\n"
msgstr "这将首先将参数乘以四，然后将其平方两次，然后将其转换为字符串 (`show`) 并反转结果 `String`（函数 `show` 和 `reverse` 是 Idris *Prelude* 的一部分，因此在每个 Idris 程序中都可用）。\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:120
#, no-wrap
msgid "Higher-order Functions"
msgstr "高阶函数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:126
#, no-wrap
msgid ""
"Functions can take other functions as arguments. This is\n"
"an incredibly powerful concept and we can go crazy with\n"
"this very easily. But for sanity's sake, we'll start\n"
"slowly:\n"
msgstr "函数可以将其他函数作为参数。这是一个非常强大的概念，我们可以很容易地为此发疯。但为了理智起见，我们将慢慢开始：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:127
#, no-wrap
msgid ""
"isEven : Integer -> Bool\n"
"isEven n = mod n 2 == 0\n"
"\n"
"testSquare : (Integer -> Bool) -> Integer -> Bool\n"
"testSquare fun n = fun (square n)\n"
msgstr ""
"isEven : Integer -> Bool\n"
"isEven n = mod n 2 == 0\n"
"\n"
"testSquare : (Integer -> Bool) -> Integer -> Bool\n"
"testSquare fun n = fun (square n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:142
#, no-wrap
msgid ""
"First `isEven` uses the `mod` function to check, whether\n"
"an integer is divisible by two. But the interesting function\n"
"is `testSquare`. It takes two arguments: The first argument\n"
"is of type *function from `Integer` to `Bool`*, and the second\n"
"of type `Integer`. This second argument is squared before\n"
"being passed to the first argument. Again, give this a go\n"
"at the REPL:\n"
msgstr "首先 `isEven` 使用 `mod` 函数来检查一个整数是否可以被 2 整除。但有趣的函数是 `testSquare`。它有两个参数：第一个参数的类型是 *从 `Integer` 到 `Bool` 的函数*，第二个参数是 `Integer` 类型。在传递给应用第一个参数之前，先把第二个参数进行平方计算。继续在 REPL 上试一试：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:143
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare isEven 12\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare isEven 12\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:154
#, no-wrap
msgid ""
"Take your time to understand what's going on here. We pass\n"
"function `isEven` as an argument to `testSquare`. The\n"
"second argument is an integer, which will first be squared\n"
"and then passed to `isEven`. While this is not very interesting,\n"
"we will see lots of use cases for passing functions as\n"
"arguments to other functions.\n"
msgstr "花点时间了解这里发生了什么。我们将函数 `isEven` 作为参数传递给 `testSquare`。第二个参数是一个整数，它首先会被平方，然后传递给 `isEven`。虽然这不是很有趣，但我们会看到很多将函数作为参数传递给其他函数的用例。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:157
#, no-wrap
msgid ""
"I said above, we could go crazy pretty easily.\n"
"Consider for instance the following example:\n"
msgstr "我在上面说过，我们很容易发疯。例如，考虑以下示例：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:158
#, no-wrap
msgid ""
"twice : (Integer -> Integer) -> Integer -> Integer\n"
"twice f n = f (f n)\n"
msgstr ""
"twice : (Integer -> Integer) -> Integer -> Integer\n"
"twice f n = f (f n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:164 ../src/Tutorial/Functions1.md:227
#: ../src/Tutorial/Interfaces.md:504 ../src/Tutorial/Predicates.md:461
#: ../src/Tutorial/Prim.md:646
#, no-wrap
msgid "And at the REPL:\n"
msgstr "在 REPL 试一下：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:165
#, no-wrap
msgid ""
"Tutorial.Functions1> twice square 2\n"
"16\n"
"Tutorial.Functions1> (twice . twice) square 2\n"
"65536\n"
"Tutorial.Functions1> (twice . twice . twice . twice) square 2\n"
"*** huge number ***\n"
msgstr ""
"Tutorial.Functions1> twice square 2\n"
"16\n"
"Tutorial.Functions1> (twice . twice) square 2\n"
"65536\n"
"Tutorial.Functions1> (twice . twice . twice . twice) square 2\n"
"*** huge number ***\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:177
#, no-wrap
msgid ""
"You might be surprised about this behavior, so we'll try\n"
"and break it down. The following two expressions are identical\n"
"in their behavior:\n"
msgstr "您可能会对这种行为感到惊讶，因此我们将尝试对其进行分解。以下两个表达式的行为相同：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:178
#, no-wrap
msgid ""
"expr1 : Integer -> Integer\n"
"expr1 = (twice . twice . twice . twice) square\n"
"\n"
"expr2 : Integer -> Integer\n"
"expr2 = twice (twice (twice (twice square)))\n"
msgstr ""
"expr1 : Integer -> Integer\n"
"expr1 = (twice . twice . twice . twice) square\n"
"\n"
"expr2 : Integer -> Integer\n"
"expr2 = twice (twice (twice (twice square)))\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:194
#, no-wrap
msgid ""
"So, `square` raises its argument to the 2nd power,\n"
"`twice square` raises it to its 4th power (by invoking\n"
"`square` twice in succession),\n"
"`twice (twice square)` raises it to its 16th power\n"
"(by invoking `twice square` twice in succession),\n"
"and so on, until `twice (twice (twice (twice square)))`\n"
"raises it to its 65536th power resulting in an impressively\n"
"huge result.\n"
msgstr "因此，`square` 将其参数提升到 2 次方，`twice square` 将其提升到 4 次方（通过连续调用 `square` 两次），`twice (twice square)` 将其提升到其 16 次方（通过连续调用 `twice square` 两次），依此类推，直到 `twice (twice (twice (twice square))))` 将其提高到 65536 次方，从而产生了令人印象深刻的巨大结果。\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:195
#, no-wrap
msgid "Currying"
msgstr "柯里化"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:201
#, no-wrap
msgid ""
"Once we start using higher-order functions, the concept\n"
"of partial function application (also called *currying*\n"
"after mathematician and logician Haskell Curry) becomes\n"
"very important.\n"
msgstr "一旦我们开始使用高阶函数，偏应用函数的概念（在数学家和逻辑学家 Haskell Curry 之后也称为 *柯里化*）变得非常重要。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:203
#, no-wrap
msgid "Load this file in a REPL session and try the following:\n"
msgstr "在 REPL 会话中加载此文件并尝试以下操作：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:204
#, no-wrap
msgid ""
"Tutorial.Functions1> :t testSquare isEven\n"
"testSquare isEven : Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1\n"
"isTriple 1 : Integer -> Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1 2\n"
"isTriple 1 2 : Integer -> Bool\n"
msgstr ""
"Tutorial.Functions1> :t testSquare isEven\n"
"testSquare isEven : Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1\n"
"isTriple 1 : Integer -> Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1 2\n"
"isTriple 1 2 : Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:220
#, no-wrap
msgid ""
"Note, how in Idris we can partially apply a function\n"
"with more than one argument and as a result get a new function\n"
"back. For instance, `isTriple 1` applies argument `1` to function\n"
"`isTriple` and as a result returns a new function of\n"
"type `Integer -> Integer -> Bool`. We can even\n"
"use the result of such a partially applied function in\n"
"a new top level definition:\n"
msgstr "注意，我们如何在 Idris 中部分应用多参函数，并且返回一个新函数。例如， `isTriple 1` 会将参数 `1` 应用于函数 `isTriple` 并因此返回一个新函数，类型为为 `Integer -> Integer -> Bool`。我们甚至可以使用这种部分应用函数的结果作为一个新的顶级定义：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:221
#, no-wrap
msgid ""
"partialExample : Integer -> Bool\n"
"partialExample = isTriple 3 4\n"
msgstr ""
"partialExample : Integer -> Bool\n"
"partialExample = isTriple 3 4\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:228
#, no-wrap
msgid ""
"Tutorial.Functions1> partialExample 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> partialExample 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:236
#, no-wrap
msgid ""
"We already used partial function application in our `twice`\n"
"examples above to get some impressive results with very\n"
"little code.\n"
msgstr "我们已经在上面的 `twice` 示例中使用了偏应用函数的应用程序，只需很少的代码即可获得一些令人印象深刻的结果。\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:237
#, no-wrap
msgid "Anonymous Functions"
msgstr "匿名函数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:245
#, no-wrap
msgid ""
"Sometimes we'd like to pass a small custom function to\n"
"a higher-order function without bothering to write a\n"
"top level definition. For instance, in the following example,\n"
"function `someTest` is very specific and probably not\n"
"very useful in general, but we'd still like to pass it\n"
"to higher-order function `testSquare`:\n"
msgstr "有时我们想将一个小的自定义函数传递给一个高阶函数，而无需编写顶层定义。例如，在下面的示例中，函数 `someTest` 非常具体，一般来说可能不是很有用，但我们仍然希望将它传递给高阶函数 `testSquare`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:246
#, no-wrap
msgid ""
"someTest : Integer -> Bool\n"
"someTest n = n >= 3 || n <= 10\n"
msgstr ""
"someTest : Integer -> Bool\n"
"someTest n = n >= 3 || n <= 10\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:252
#, no-wrap
msgid "Here's, how to pass it to `testSquare`:\n"
msgstr "下面将展示如何将其传递给 `testSquare`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:253
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare someTest 100\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare someTest 100\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:260
#, no-wrap
msgid ""
"Instead of defining and using `someTest`, we can use an\n"
"anonymous function:\n"
msgstr "我们也可以使用匿名函数，而不用定义和使用 `someTest`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:261
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (\\n => n >= 3 || n <= 10) 100\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare (\\n => n >= 3 || n <= 10) 100\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:277
#, no-wrap
msgid ""
"Anonymous functions are sometimes also called *lambdas* (from\n"
"[lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus)),\n"
"and the backslash is chosen since it resembles the Greek\n"
"letter *lambda*. The `\\n =>` syntax introduces a new anonymous\n"
"function of one argument called `n`, the implementation of\n"
"which is on the right hand side of the function arrow.\n"
"Like other top level functions, lambdas can have more\n"
"than one arguments, separated by commas: `\\x,y => x * x + y`.\n"
"When we pass lambdas as arguments to higher-order functions,\n"
"they typically need to be wrapped in parentheses or separated\n"
"by the dollar operator `($)` (see the next section about this).\n"
msgstr ""
"匿名函数有时也称为 *lambdas*（来自[λ演算](https://en.wikipedia.org/wiki/Lambda_calculus)),并且选择了反斜杠，因为它类似于希腊语"
"字母 *λ*。 `\\n =>` 语法引入了一个新的参数为 `n` 的匿名函数，实现位于函数箭头的右侧。像其他顶级函数一样，lambda 可以有多个参数，并以逗号分隔：`\\x,y => x * x + y`。当我们将 lambdas 作为参数传递给高阶函数时，它们通常需要用括号括起来或由美元运算符 `($)` 分开（请参阅下一节）。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:280
#, no-wrap
msgid ""
"Note that, in a lambda, arguments are not annotated with types,\n"
"so Idris has to be able to infer them from the current context.\n"
msgstr "请注意，在 lambda 中，参数不使用类型进行注释，因此 Idris 必须能够从当前上下文中推断出它们。\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:281
#, no-wrap
msgid "Operators"
msgstr "运算符"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:288
#, no-wrap
msgid ""
"In Idris, infix operators like `.`, `*` or `+` are not built into\n"
"the language, but are just regular Idris function with\n"
"some special support for using them in infix notation.\n"
"When we don't use operators in infix notation, we have\n"
"to wrap them in parentheses.\n"
msgstr "在 Idris 中，`.`、`*` 或 `+` 等中缀运算符并未内置于语言中，而只是常规的 Idris 函数对应的中缀符号。当我们使用非中缀表示法的运算符时，我们必须将它们包裹在括号中。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:291
#, no-wrap
msgid ""
"As an example, let us define a custom operator for sequencing\n"
"functions of type `Bits8 -> Bits8`:\n"
msgstr "举个例子，让我们为类型为 `Bits8 -> Bits8` 的函数自定义运算符：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:292
#, no-wrap
msgid ""
"infixr 4 >>>\n"
"\n"
"(>>>) : (Bits8 -> Bits8) -> (Bits8 -> Bits8) -> Bits8 -> Bits8\n"
"f1 >>> f2 = f2 . f1\n"
"\n"
"foo : Bits8 -> Bits8\n"
"foo n = 2 * n + 3\n"
"\n"
"test : Bits8 -> Bits8\n"
"test = foo >>> foo >>> foo >>> foo\n"
msgstr ""
"infixr 4 >>>\n"
"\n"
"(>>>) : (Bits8 -> Bits8) -> (Bits8 -> Bits8) -> Bits8 -> Bits8\n"
"f1 >>> f2 = f2 . f1\n"
"\n"
"foo : Bits8 -> Bits8\n"
"foo n = 2 * n + 3\n"
"\n"
"test : Bits8 -> Bits8\n"
"test = foo >>> foo >>> foo >>> foo\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:311
#, no-wrap
msgid ""
"In addition to declaring and defining the operator\n"
"itself, we also have to specify its fixity: `infixr 4 >>>` means,\n"
"that `(>>>)` associates to the right (meaning, that\n"
"`f >>> g >>> h` is to be interpreted as `f >>> (g >>> h)`)\n"
"with a priority of `4`. You can also have a look at the fixity\n"
"of operators exported by the *Prelude* in the REPL:\n"
msgstr ""
"除了声明和定义运算符本身，我们还必须指定它的结合性：`infixr 4 >>>` 表示，`(>>>)` 关联到右边（意味着 "
"`f >>> g >>> h` 将被解释为 `f >>> (g >>> h)`)优先级为 `4`。你也可以在 REPL 中 看看 *Prelude* 导出的运算符的结合性：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:312
#, no-wrap
msgid ""
"Tutorial.Functions1> :doc (.)\n"
"Prelude.. : (b -> c) -> (a -> b) -> a -> c\n"
"  Function composition.\n"
"  Totality: total\n"
"  Fixity Declaration: infixr operator, level 9\n"
msgstr ""
"Tutorial.Functions1> :doc (.)\n"
"Prelude.. : (b -> c) -> (a -> b) -> a -> c\n"
"  Function composition.\n"
"  Totality: total\n"
"  Fixity Declaration: infixr operator, level 9\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:325
#, no-wrap
msgid ""
"When you mix infix operators in an expression, those with\n"
"a higher priority bind more tightly. For instance, `(+)`\n"
"is left associated with a priority of 8, while `(*)`\n"
"is left associated with a priority of 9. Hence,\n"
"`a * b + c` is the same as `(a * b) + c` instead of `a * (b + c)`.\n"
msgstr "当您在表达式中混合使用中缀运算符时，具有较高优先级的运算符绑定得更紧密。例如，`(+)` 的优先级为 8，而 `(*)` 的优先级为 9。因此，`a * b + c ` 与 `(a * b) + c` 相同，而不是 `a * (b + c)`。\n"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:326
#, no-wrap
msgid "Operator Sections"
msgstr "运算符块"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:332
#, no-wrap
msgid ""
"Operators can be partially applied just like regular\n"
"functions. In this case, the whole expression has to\n"
"be wrapped in parentheses and is called an *operator\n"
"section*. Here are two examples:\n"
msgstr "运算符可以像常规函数一样被部分应用。在这种情况下，整个表达式必须用括号括起来，称为 *运算符块*。这里有两个例子：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:333
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (< 10) 5\n"
"False\n"
"Tutorial.Functions1> testSquare (10 <) 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare (< 10) 5\n"
"False\n"
"Tutorial.Functions1> testSquare (10 <) 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:344
#, no-wrap
msgid ""
"As you can see, there is a difference between `(< 10)`\n"
"and `(10 <)`. The first tests, whether its argument is\n"
"less than 10, the second, whether 10 is less than its\n"
"argument.\n"
msgstr "如您所见，`(< 10)`和 `(10 <)`。第一个测试，它的参数为是否小于10，第二，参数是否大于10。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:348
#, no-wrap
msgid ""
"One exception where operator sections will not work is\n"
"with the *minus* operator `(-)`. Here is an example to\n"
"demonstrate this:\n"
msgstr "运算符部分不起作用的一个例外是使用 *减法* 运算符 `(-)`。下面是一个例子来证明这一点：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:349
#, no-wrap
msgid ""
"applyToTen : (Integer -> Integer) -> Integer\n"
"applyToTen f = f 10\n"
msgstr ""
"applyToTen : (Integer -> Integer) -> Integer\n"
"applyToTen f = f 10\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:357
#, no-wrap
msgid ""
"This is just a higher-order function applying the number ten\n"
"to its function argument. This works very well in the following\n"
"example:\n"
msgstr "这只是一个将数字 10 应用于其函数参数的高阶函数。这在以下示例中非常有效：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:358
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (* 2)\n"
"20\n"
msgstr ""
"Tutorial.Functions1> applyToTen (* 2)\n"
"20\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:365
#, no-wrap
msgid ""
"However, if we want to subtract five from ten, the following\n"
"will fail:\n"
msgstr "但是，如果我们想从 10 中减去 5，以下将失败：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:366
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (- 5)\n"
"Error: Can't find an implementation for Num (Integer -> Integer).\n"
"\n"
"(Interactive):1:12--1:17\n"
" 1 | applyToTen (- 5)\n"
msgstr ""
"Tutorial.Functions1> applyToTen (- 5)\n"
"Error: Can't find an implementation for Num (Integer -> Integer).\n"
"\n"
"(Interactive):1:12--1:17\n"
" 1 | applyToTen (- 5)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:377
#, no-wrap
msgid ""
"The problem here is, that Idris treats `- 5` as an integer literal\n"
"instead of an operator section. In this special case, we therefore\n"
"have to use an anonymous function instead:\n"
msgstr "这里的问题是，Idris 将 `- 5` 视为整数字面量而不是运算符块。在这种特殊情况下，我们因此必须使用匿名函数：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:378
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (\\x => x - 5)\n"
"5\n"
msgstr ""
"Tutorial.Functions1> applyToTen (\\x => x - 5)\n"
"5\n"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:383
#, no-wrap
msgid "Infix Notation for Non-Operators"
msgstr "非运算符的中缀表示法"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:390
#, no-wrap
msgid ""
"In Idris, it is possible to use infix notation for\n"
"regular binary functions, by wrapping them in backticks.\n"
"It is even possible to define a precedence (fixity) for\n"
"these and use them in operator sections, just like regular\n"
"operators:\n"
msgstr "在 Idris 中，可以对常规双参函数使用中缀表示法，方法是将它们包装在反引号中。甚至可以为这些定义优先级（结合性）并在运算符块中使用它们，就像常规运算符一样：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:391
#, no-wrap
msgid ""
"infixl 8 `plus`\n"
"\n"
"infixl 9 `mult`\n"
"\n"
"plus : Integer -> Integer -> Integer\n"
"plus = (+)\n"
"\n"
"mult : Integer -> Integer -> Integer\n"
"mult = (*)\n"
"\n"
"arithTest : Integer\n"
"arithTest = 5 `plus` 10 `mult` 12\n"
"\n"
"arithTest' : Integer\n"
"arithTest' = 5 + 10 * 12\n"
msgstr ""
"infixl 8 `plus`\n"
"\n"
"infixl 9 `mult`\n"
"\n"
"plus : Integer -> Integer -> Integer\n"
"plus = (+)\n"
"\n"
"mult : Integer -> Integer -> Integer\n"
"mult = (*)\n"
"\n"
"arithTest : Integer\n"
"arithTest = 5 `plus` 10 `mult` 12\n"
"\n"
"arithTest' : Integer\n"
"arithTest' = 5 + 10 * 12\n"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:409
#, no-wrap
msgid "Operators exported by the *Prelude*"
msgstr "*Prelude* 导出的运算符"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:419
#, no-wrap
msgid ""
"Here is a list of important operators exported by the *Prelude*.\n"
"Most of these are *constrained*, that is they work only\n"
"for types implementing a certain *interface*. Don't worry\n"
"about this right now. We will learn about interfaces in due\n"
"time, and the operators behave as they intuitively should.\n"
"For instance, addition and multiplication work for all\n"
"numeric types, comparison operators work for almost all\n"
"types in the *Prelude* with the exception of functions.\n"
msgstr "以下是 *Prelude* 导出的重要运算符列表。其中大多数具有 *约束 *，也就是说它们仅适用于实现了某个 *接口* 的类型。现在不要担心这个。我们将在适当的时候了解接口，运算符会按照直觉行事。例如，加法和乘法适用于所有数字类型，比较运算符适用于 *Prelude* 中的几乎所有类型，但函数除外。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(.)`: Function composition\n"
msgstr "`(.)`：函数组合\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(+)`: Addition\n"
msgstr "`(+)`：加法\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(*)`: Multiplication\n"
msgstr "`(*)`：乘法\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(-)`: Subtraction\n"
msgstr "`(-)`：减法\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(/)`: Division\n"
msgstr "`(/)`：除法\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(==)` : True, if two values are equal\n"
msgstr "`(==)` ：判断两个值是否相等\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(/=)` : True, if two values are not equal\n"
msgstr "`(/=)` ：判断两个值是否不相等\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`(<=)`, `(>=)`, `(<)`, and `(>)` : Comparison operators\n"
msgstr "`(<=)`、`(>=)`、`(<)` 和 `(>)` ：比较运算符\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, no-wrap
msgid "`($)`: Function application\n"
msgstr "`($)`：函数应用\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:440
#, no-wrap
msgid ""
"The most special of the above is the last one. It has a\n"
"priority of 0, so all other operators bind more tightly.\n"
"In addition, function application binds more tightly, so\n"
"this can be used to reduce the number of parentheses\n"
"required. For instance, instead of writing\n"
"`isTriple 3 4 (2 + 3 * 1)` we can write\n"
"`isTriple 3 4 $ 2 + 3 * 1`,\n"
"which is exactly the same. Sometimes, this helps readability,\n"
"sometimes, it doesn't. The important thing to remember is\n"
"that `fun $ x y` is just the same as `fun (x y)`.\n"
msgstr "上面最特别的是最后一个。它的优先级为 0，所有其他运算符都比他绑定得更紧密。因此可以使用它来减少所需的括号数量。例如，不写 `isTriple 3 4 (2 + 3 * 1)` 我们可以写成 `isTriple 3 4 $ 2 + 3 * 1`，这完全一样。有时，这有助于提高可读性，虽然有时并不会。要记住的重要一点是 `fun $ x y` 与 `fun (x y)` 相同。\n"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:441 ../src/Tutorial/Functions2.md:339
#, no-wrap
msgid "Exercises"
msgstr "练习"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions1.md:450
#, no-wrap
msgid ""
"Reimplement functions `testSquare` and `twice` by using the dot\n"
"operator and dropping the second arguments (have a look at the\n"
"implementation of `squareTimes2` to get an idea where this should\n"
"lead you). This highly concise\n"
"way of writing function implementations is sometimes called\n"
"*point-free style* and is often the preferred way of writing\n"
"small utility functions.\n"
msgstr ""
"通过使用点运算符并删除第二个参数重新实现函数 `testSquare` 和 `twice`（查看 "
"`squareTimes2` 的实现应该可以让你更加了解）。这种编写函数实现的高度简洁的方式"
"有时被称为 *无值风格*，并且通常是编写小型实用函数的首选方式。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions1.md:453
#, no-wrap
msgid ""
"Declare and implement function `isOdd` by combining functions `isEven`\n"
"from above and `not` (from the Idris *Prelude*). Use point-free style.\n"
msgstr ""
"通过组合上面的函数 `isEven` 和 `not`（来自 Idris *Prelude*）来声明和实现函数 "
"`isOdd`。使用无值风格。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions1.md:456
#, no-wrap
msgid ""
"Declare and implement function `isSquareOf`, which checks whether\n"
"its first `Integer` argument is the square of the second argument.\n"
msgstr "声明并实现函数 `isSquareOf`，检查它的第一个 `Integer` "
"参数是否是第二个参数的平方。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions1.md:460
#, no-wrap
msgid ""
"Declare and implement function `isSmall`, which checks whether\n"
"its `Integer` argument is less than or equal to 100. Use one of the\n"
"comparison operators `<=` or `>=` in your implementation.\n"
msgstr ""
"声明并实现函数 `isSmall`，检查其 `Integer` 参数是否小于或等于 100。"
"在你的实现中使用比较运算符 `<=` 或 `>=` 之一。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions1.md:465
#, no-wrap
msgid ""
"Declare and implement function `absIsSmall`, which checks whether\n"
"the absolute value of its `Integer` argument is less than or equal to 100.\n"
"Use functions `isSmall` and `abs` (from the Idris *Prelude*) in your implementation,\n"
"which should be in point-free style.\n"
msgstr ""
"声明并实现函数 `absIsSmall`，检查其 `Integer` 参数的绝对值是否小于等于100。"
"在你的实现中使用函数 `isSmall` 和 `abs `（来自 Idris "
"*Prelude*），最好是无值风格的。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functions1.md:471
#, no-wrap
msgid ""
"In this slightly extended exercise we are going to implement\n"
"some utilities for working with `Integer` predicates (functions\n"
"from `Integer` to `Bool`). Implement the following higher-order\n"
"functions (use boolean operators `&&`, `||`, and function `not` in\n"
"your implementations):\n"
msgstr ""
"在这个稍微扩展的练习中，我们将实现一些实用程序来处理 `Integer` 谓词（从 "
"`Integer` 到 `Bool` 的函数）。实现以下高阶函数（在您的实现中使用布尔运算符 "
"`&&`、`||` 和函数 `not`）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:472
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   and : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   or : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   negate : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"   -- return true, if and only if both predicates hold\n"
"   and : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   or : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   negate : (Integer -> Bool) -> Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:487
#, no-wrap
msgid ""
"   After solving this exercise, give it a go in the REPL. In the\n"
"   example below, we use binary function `and` in infix notation\n"
"   by wrapping it in backticks. This is just a syntactic convenience\n"
"   to make certain function applications more readable:\n"
msgstr ""
"   完成这个练习后，在 REPL 中试一试。在下面的例子中，我们通过用反引号包裹来使用双参函数 `and` 的中缀表示法的"
"。这只是一种语法糖，使某些功能应用程序更具可读性：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:488
#, no-wrap
msgid ""
"   Tutorial.Functions1> negate (isSmall `and` isOdd) 73\n"
"   False\n"
msgstr ""
"   Tutorial.Functions1> negate (isSmall `and` isOdd) 73\n"
"   False\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Functions1.md:500
#, no-wrap
msgid ""
"As explained above, Idris allows us to define our own infix operators.\n"
"Even better, Idris supports *overloading* of function names,\n"
"that is, two functions or operators can have the same\n"
"name, but different types and implementations.\n"
"Idris will make use of the\n"
"types to distinguish between equally named operators and\n"
"functions.\n"
msgstr ""
"如上所述，Idris 允许我们定义自己的中缀运算符。更好的是，Idris "
"支持函数名的 *重载*，即两个函数或运算符可以有相同的名称，但类型和实现不同。 "
"Idris 将使用类型来区分同名的运算符和函数。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:504
#, no-wrap
msgid ""
"   This allows us, to reimplement functions `and`, `or`, and `negate`\n"
"   from Exercise 6 by using the existing operator and function\n"
"   names from boolean algebra:\n"
msgstr "   这允许我们重新实现函数 `and`、`or` 和 `negate`，在练习 6 中，使用布尔代数中现有的运算符和函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:505
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   (&&) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"   x && y = and x y\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   (||) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   not : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"   -- return true, if and only if both predicates hold\n"
"   (&&) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"   x && y = and x y\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   (||) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   not : (Integer -> Bool) -> Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:518
#, no-wrap
msgid "   Implement the other two functions and test them at the REPL:\n"
msgstr "   实现另外两个函数并在 REPL 上测试它们：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:519
#, no-wrap
msgid ""
"   Tutorial.Functions1> not (isSmall && isOdd) 73\n"
"   False\n"
msgstr ""
"   Tutorial.Functions1> not (isSmall && isOdd) 73\n"
"   False\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:527
#, no-wrap
msgid "What we learned in this chapter:\n"
msgstr "我们在本章中学到了什么：\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:530
#, no-wrap
msgid ""
"* A function in Idris can take an arbitrary number of arguments,\n"
"separated by `->` in the function's type.\n"
msgstr "* Idris 中的函数可以接受任意数量的参数，由函数类型中的 `->` 分隔。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:534
#, no-wrap
msgid ""
"* Functions can be combined\n"
"sequentially using the dot operator, which leads to highly\n"
"concise code.\n"
msgstr "* 函数可以依次使用点运算符进行组合，这会产生高度简洁的代码。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:539
#, no-wrap
msgid ""
"* Functions can be partially applied by passing them fewer\n"
"arguments than they expect. The result is a new function\n"
"expecting the remaining arguments. This technique is called\n"
"*currying*.\n"
msgstr "* 可以通过传递更少的函数来偏应用函数，参数少于函数的预期。结果是一个新的函数，预期传入剩下的参数。这种技术被称为 *柯里化*。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:543
#, no-wrap
msgid ""
"* Functions can be passed as arguments to other functions, which\n"
"allows us to easily combine small coding units to create\n"
"more complex behavior.\n"
msgstr "* 函数可以作为参数传递给其他函数，允许我们轻松组合小型程序单元来创建更复杂的"
"行为。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:547
#, no-wrap
msgid ""
"* We can pass anonymous functions (*lambdas*) to higher-order\n"
"functions, if writing a corresponding top level\n"
"function would be too cumbersome.\n"
msgstr "* 如果编写相应的顶层函数太繁琐，我们可以将匿名函数 (*lambdas*) 传递给高阶函数。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:551
#, no-wrap
msgid ""
"* Idris allows us to define our own infix operators. These\n"
"have to be written in parentheses unless they are being used\n"
"in infix notation.\n"
msgstr ""
"* Idris 允许我们定义自己的中缀运算符。这些必须写在括号中，除非它们被声明为"
"中缀表示法。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:556
#, no-wrap
msgid ""
"* Infix operators can also be partially applied. These *operator sections*\n"
"have to be wrapped in parentheses, and the position of the\n"
"argument determines, whether it is used as the operator's first\n"
"or second argument.\n"
msgstr "* 也可以部分应用中缀运算符。这些 *运算符块* 必须用括号括起来，并且用作运算符的第一个或第二个参数被确定。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:560
#, no-wrap
msgid ""
"* Idris supports name overloading: Functions can have the same\n"
"names but different implementations. Idris will decide, which function\n"
"to used based to the types involved.\n"
msgstr "* Idris 支持名称重载：函数可以具有相同的名称，但拥有不同的实现。Idris 将根据所涉及的类型决定使用哪个函数。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:567
#, no-wrap
msgid ""
"Please note, that function and operator names in a module\n"
"must be unique. In order to define two functions with the same\n"
"name, they have to be declared in distinct modules. If Idris\n"
"is not able to decide, which of the two functions to use, we\n"
"can help name resolution by prefixing a function with\n"
"(a part of) its *namespace*:\n"
msgstr "请注意，模块中的函数和运算符名称必须是唯一的。为了定义两个具有相同名称的函数，它们必须在不同的模块中声明。如果 Idris 无法决定使用这两个函数中的哪一个，我们可以通过在函数前面加上其 *命名空间* 的（部分）前缀来帮助名称解析：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:568
#, no-wrap
msgid ""
"Tutorial.Functions1> :t Prelude.not\n"
"Prelude.not : Bool -> Bool\n"
"Tutorial.Functions1> :t Functions1.not\n"
"Tutorial.Functions1.not : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"Tutorial.Functions1> :t Prelude.not\n"
"Prelude.not : Bool -> Bool\n"
"Tutorial.Functions1> :t Functions1.not\n"
"Tutorial.Functions1.not : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:581
#, no-wrap
msgid ""
"In the [next section](DataTypes.md), we will learn how to define\n"
"our own data types and how to construct and deconstruct\n"
"values of these new types. We will also learn about\n"
"generic types and functions.\n"
msgstr "在 [下一节](DataTypes.md) 中，我们将学习如何定义我们自己的数据类型以及如何构造和解构这些新类型的值。我们还将学习泛型类型和函数。\n"

#. type: Title #
#: ../src/Tutorial/Functions2.md:1
#, no-wrap
msgid "Functions Part 2"
msgstr "函数第 2 部分"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:9
#, no-wrap
msgid ""
"So far, we learned about the core features of the Idris\n"
"language, which it has in common with several other\n"
"pure, strongly typed programming languages like Haskell:\n"
"(Higher order) Functions, algebraic data types, pattern matching,\n"
"parametric polymorphism (generic types and functions), and\n"
"ad hoc polymorphism (interfaces and constrained functions).\n"
msgstr "到目前为止，我们了解了 Idris 语言的核心特性，它与其他几种纯的强类型编程语言（如 Haskell）有共同之处：（高阶）函数、代数数据类型、模式匹配、参数多态性（泛型类型和函数）和临时多态性（接口和约束函数）。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:15
#, no-wrap
msgid ""
"In this chapter, we start to dissect Idris functions and their types\n"
"for real. We learn about implicit arguments, named arguments, as well\n"
"as erasure and quantities. But first, we'll look at `let` bindings\n"
"and `where` blocks, which help us implement functions too complex\n"
"to fit on a single line of code. Let's get started!\n"
msgstr "在本章中，我们开始真正剖析 Idris 函数及其类型。我们了解隐式参数、命名参数以及擦除和定量。但首先，我们将看看 `let` 绑定和 `where` 块，它们可以帮助我们实现过于复杂而无法在一行代码中放置的函数。让我们开始吧！\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:16
#, no-wrap
msgid ""
"module Tutorial.Functions2\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Functions2\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Functions2.md:22
#, no-wrap
msgid "Let Bindings and Local Definitions"
msgstr "Let 绑定和局部定义"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:31
#, no-wrap
msgid ""
"The functions we looked at so far were simple enough\n"
"to be implemented directly via pattern matching\n"
"without the need of additional auxiliary functions or\n"
"variables. This is not always the case, and there are two\n"
"important language constructs for introducing and reusing\n"
"new local variables and functions. We'll look at these\n"
"in two case studies.\n"
msgstr "到目前为止，我们看到的函数非常简单，可以通过模式匹配直接实现，而不需要额外的辅助函数或变量。情况并非总是如此，并且有两个重要的语言结构用于引入和重用新的局部变量和函数。我们将在两个案例研究中研究这些。\n"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:32
#, no-wrap
msgid "Use Case 1: Arithmetic Mean and Standard Deviation"
msgstr "用例 1：算术平均值和标准差"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:37
#, no-wrap
msgid ""
"In this example, we'd like to calculate the arithmetic\n"
"mean and the standard deviation of a list of floating point values.\n"
"There are several things we need to consider.\n"
msgstr "在此示例中，我们要计算浮点值列表的算术平均值和标准差。我们需要考虑几件事。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:41
#, no-wrap
msgid ""
"First, we need a function for calculating the sum of\n"
"a list of numeric values. The *Prelude* exports function\n"
"`sum` for this:\n"
msgstr "首先，我们需要一个函数来计算数值列表的总和。 *Prelude* 为此导出函数 `sum`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:42
#, no-wrap
msgid ""
"Main> :t sum\n"
"Prelude.sum : Num a => Foldable t => t a -> a\n"
msgstr ""
"Main> :t sum\n"
"Prelude.sum : Num a => Foldable t => t a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:51
#, no-wrap
msgid ""
"This is - of course - similar to `sumList` from Exercise 10\n"
"of the [last section](Interfaces.md), but generalized to all\n"
"container types with a `Foldable` implementation. We will\n"
"learn about interface `Foldable` in a later section.\n"
msgstr "这 - 当然 - 类似于 [上一节](Interfaces.md) 的练习 10 中的 `sumList`，但推广到具有 `Foldable` 实现的所有容器类型。我们将在后面的部分了解接口 `Foldable`。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:62
#, no-wrap
msgid ""
"In order to also calculate the variance,\n"
"we need to convert every value in the list to\n"
"a new value, as we have to subtract the mean\n"
"from every value in the list and square the\n"
"result. In the previous section's exercises, we\n"
"defined function `mapList` for this. The *Prelude* - of course -\n"
"already exports a similar function called `map`,\n"
"which is again more general\n"
"and works also like our `mapMaybe` for `Maybe`\n"
"and `mapEither` for `Either e`. Here's its type:\n"
msgstr "为了也可以计算方差，我们需要将列表中的每个值转换为一个新值，因为我们必须从列表中的每个值中减去平均值并将结果平方。在上一节的练习中，我们为此定义了函数 `mapList`。 *Prelude* - 当然 - 已经导出了一个名为 `map` 的类似函数，它同样更通用并且也像我们的 `mapMaybe` 用于 `Maybe]` 和 `mapEither` 用于 `Either e`。这是它的类型：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:63
#, no-wrap
msgid ""
"Main> :t map\n"
"Prelude.map : Functor f => (a -> b) -> f a -> f b\n"
msgstr ""
"Main> :t map\n"
"Prelude.map : Functor f => (a -> b) -> f a -> f b\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:70
#, no-wrap
msgid ""
"Interface `Functor` is another one we'll talk about\n"
"in a later section.\n"
msgstr "接口 `Functor` 是另一个我们将在后面讨论的接口。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:73
#, no-wrap
msgid ""
"Finally, we need a way to calculate the length of\n"
"a list of values. We use function `length` for this:\n"
msgstr "最后，我们需要一种计算值列表长度的方法。我们为此使用函数 `length`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:74
#, no-wrap
msgid ""
"Main> :t List.length\n"
"Prelude.List.length : List a -> Nat\n"
msgstr ""
"Main> :t List.length\n"
"Prelude.List.length : List a -> Nat\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:87
#, no-wrap
msgid ""
"Here, `Nat` is the type of natural numbers\n"
"(unbounded, unsigned integers). `Nat` is actually not a primitive data\n"
"type but a sum type defined in the *Prelude* with\n"
"data constructors `Z : Nat` (for zero)\n"
"and `S : Nat -> Nat` (for successor). It might seem highly inefficient\n"
"to define natural numbers this way, but the Idris compiler\n"
"treats these and several other *number-like* types specially, and\n"
"replaces them with primitive integers during code generation.\n"
msgstr "这里，`Nat` 是自然数的类型（无界、无符号整数）。 `Nat` 实际上不是原语数据类型，而是在 *Prelude* 中使用数据构造函数 `Z: Nat` （为零）和 `S ： Nat -> Nat`（后继）定义的和类型 。以这种方式定义自然数似乎效率极低，但 Idris 编译器会特别处理这些类型和其他几个 *类数字* 类型，并在代码生成期间将它们替换为原语整数。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:93
#, no-wrap
msgid ""
"We are now ready to give the implementation of `mean` a go.\n"
"Since this is Idris, and we care about clear semantics, we will\n"
"quickly define a custom record type instead of just returning\n"
"a tuple of `Double`s. This makes it clearer, which floating\n"
"point number corresponds to which statistic entity:\n"
msgstr "我们现在已经准备好执行 `mean` 了。由于这是 Idris，并且我们关心清晰的语义，我们将快速定义自定义记录类型，而不是仅仅返回 `Double` 的元组。这样就更清楚了，哪个浮点数对应哪个统计实体：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:94
#, no-wrap
msgid ""
"square : Double -> Double\n"
"square n = n * n\n"
"\n"
"record Stats where\n"
"  constructor MkStats\n"
"  mean      : Double\n"
"  variance  : Double\n"
"  deviation : Double\n"
"\n"
"stats : List Double -> Stats\n"
"stats xs =\n"
"  let len      := cast (length xs)\n"
"      mean     := sum xs / len\n"
"      variance := sum (map (\\x => square (x - mean)) xs) / len\n"
"   in MkStats mean variance (sqrt variance)\n"
msgstr ""
"square : Double -> Double\n"
"square n = n * n\n"
"\n"
"record Stats where\n"
"  constructor MkStats\n"
"  mean      : Double\n"
"  variance  : Double\n"
"  deviation : Double\n"
"\n"
"stats : List Double -> Stats\n"
"stats xs =\n"
"  let len      := cast (length xs)\n"
"      mean     := sum xs / len\n"
"      variance := sum (map (\\x => square (x - mean)) xs) / len\n"
"   in MkStats mean variance (sqrt variance)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:113
#, no-wrap
msgid "As usual, we first try this at the REPL:\n"
msgstr "像往常一样，我们首先在 REPL 上尝试一下：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:114
#, no-wrap
msgid ""
"Tutorial.Functions2> stats [2,4,4,4,5,5,7,9]\n"
"MkStats 5.0 4.0 2.0\n"
msgstr ""
"Tutorial.Functions2> stats [2,4,4,4,5,5,7,9]\n"
"MkStats 5.0 4.0 2.0\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:133
#, no-wrap
msgid ""
"Seems to work, so let's digest this step by step.\n"
"We introduce several new local variables\n"
"(`len`, `mean`, and `variance`),\n"
"which all will be used more than once in the remainder\n"
"of the implementation. To do so, we use a `let` binding. This\n"
"consists of the `let` keyword, followed by one or more\n"
"variable assignments, followed by the final expression,\n"
"which has to be prefixed by `in`. Note, that whitespace\n"
"is significant again: We need to properly align the three\n"
"variable names. Go ahead, and try out what happens if\n"
"you remove a space in front of `mean` or `variance`.\n"
"Note also, that the alignment of assignment operators\n"
"`:=` is optional. I do this, since I thinks it helps\n"
"readability.\n"
msgstr "似乎有效，所以让我们一步一步消化这个。我们引入了几个新的局部变量（`len`、`mean` 和 `variance`），它们都将在余下的实现中多次使用。为此，我们使用 `let` 绑定。这包括 `let` 关键字，后跟一个或多个变量赋值，然后是最终表达式，它必须以 `in` 为前缀。请注意，空格同样很重要：我们需要正确对齐三个变量名。继续，试试如果删除 `mean` 或 `variance` 前面的空格会发生什么。另请注意，赋值运算符 `:=` 的对齐方式是可选的。我这样做是因为我认为它有助于提高可读性。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:149
#, no-wrap
msgid ""
"Let's also quickly look at the different variables\n"
"and their types. `len` is the length of the list\n"
"cast to a `Double`, since this is what's needed\n"
"later on, where we divide other values of type `Double`\n"
"by the length. Idris is very strict about this: We are\n"
"not allowed to mix up numeric types without explicit\n"
"casts. Please note, that in this case Idris is able\n"
"to *infer* the type of `len` from the surrounding\n"
"context. `mean` is straight forward: We `sum` up the\n"
"values stored in the list and divide by the list's\n"
"length. `variance` is the most involved of the\n"
"three: We map each item in the list to a new value\n"
"using an anonymous function to subtract the mean\n"
"and square the result. We then sum up the new terms\n"
"and divide again by the number of values.\n"
msgstr "让我们快速看看不同的变量及其类型。 `len` 是转换为 `Double` 的列表的长度，因为这是稍后需要的，我们将 `Double` 类型的其他值除以长度。 Idris 对此非常严格：我们不允许在没有显式转换的情况下混合数字类型。请注意，在这种情况下，Idris 能够从周围的上下文 *推断* `len` 的类型。 `mean` 很简单：我们 `sum` 将存储在列表中的值相加并除以列表的长度。 `variance` 是三个中涉及最多的一个：我们使用匿名函数将列表中的每个项目映射到一个新值，以减去均值并平方结果。然后我们将新项相加并再次除以值的数量。\n"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:150
#, no-wrap
msgid "Use Case 2: Simulating a Simple Web Server"
msgstr "用例 2：模拟一个简单的 Web 服务器"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:156
#, no-wrap
msgid ""
"In the second use case, we are going to write a slightly\n"
"larger application. This should give you an idea about how to\n"
"design data types and functions around some business\n"
"logic you'd like to implement.\n"
msgstr "在第二个用例中，我们将编写一个稍大的应用程序。这应该让您了解如何围绕您想要实现的某些业务逻辑设计数据类型和功能。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:161
#, no-wrap
msgid ""
"Assume we run a music streaming web server, where users\n"
"can buy whole albums and listen to them online. We'd\n"
"like to simulate a user connecting to the server and\n"
"getting access to one of the albums they bought.\n"
msgstr "假设我们运行一个音乐流网络服务器，用户可以在其中购买整张专辑并在线收听。我们想模拟一个用户连接到服务器并访问他们购买的一张专辑。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:163
#, no-wrap
msgid "We first define a bunch of record types:\n"
msgstr "我们首先定义了一堆记录类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:164
#, no-wrap
msgid ""
"record Artist where\n"
"  constructor MkArtist\n"
"  name : String\n"
"\n"
"record Album where\n"
"  constructor MkAlbum\n"
"  name   : String\n"
"  artist : Artist\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : String\n"
"  email    : Email\n"
"  password : Password\n"
"  albums   : List Album\n"
msgstr ""
"record Artist where\n"
"  constructor MkArtist\n"
"  name : String\n"
"\n"
"record Album where\n"
"  constructor MkAlbum\n"
"  name   : String\n"
"  artist : Artist\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : String\n"
"  email    : Email\n"
"  password : Password\n"
"  albums   : List Album\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:202
#, no-wrap
msgid ""
"Most of these should be self-explanatory. Note, however, that\n"
"in several cases (`Email`, `Artist`, `Password`) we wrap a\n"
"single value in a new record type. Of course, we *could* have\n"
"used the unwrapped `String` type instead, but we'd have ended\n"
"up with many `String` fields, which can be hard to disambiguate.\n"
"In order not to confuse an email string with a password string,\n"
"it can therefore be helpful to wrap both of them in a new\n"
"record type to drastically increase type safety at the cost\n"
"of having to reimplement some interfaces.\n"
"Utility function `on` from the *Prelude* is very useful for this. Don't\n"
"forget to inspect its type at the REPL, and try to understand what's\n"
"going on here.\n"
msgstr "其中大部分应该是不言自明的。但是请注意，在某些情况下（`Email`、`Artist`、`Password`）我们将单个值包装在新的记录类型中。当然，我们 *可以* 使用未包装的 `String` 类型，但我们最终会得到许多 `String` 字段，这很难消除歧义。为了不将电子邮件字符串与密码字符串混淆，因此将它们都包装在新的记录类型中会有所帮助，以大大提高类型安全性，但代价是必须重新实现某些接口。 *Prelude* 中的实用函数 `on` 对此非常有用。不要忘记在 REPL 中检查它的类型，并尝试了解这里发生了什么。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:203
#, no-wrap
msgid ""
"Eq Artist where (==) = (==) `on` name\n"
"\n"
"Eq Email where (==) = (==) `on` value\n"
"\n"
"Eq Password where (==) = (==) `on` value\n"
"\n"
"Eq Album where (==) = (==) `on` \\a => (a.name, a.artist)\n"
msgstr ""
"Eq Artist where (==) = (==) `on` name\n"
"\n"
"Eq Email where (==) = (==) `on` value\n"
"\n"
"Eq Password where (==) = (==) `on` value\n"
"\n"
"Eq Album where (==) = (==) `on` \\a => (a.name, a.artist)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:216
#, no-wrap
msgid ""
"In case of `Album`, we wrap the two fields of the record in\n"
"a `Pair`, which already comes with an implementation of `Eq`.\n"
"This allows us to again use function `on`, which is very convenient.\n"
msgstr "在 `Album` 的情况下，我们将记录的两个字段包装在 `Pair` 中，它已经附带了 `Eq` 的实现。这让我们可以再次使用`on`函数，非常方便。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:219
#, no-wrap
msgid ""
"Next, we have to define the data types representing\n"
"server requests and responses:\n"
msgstr "接下来，我们必须定义代表服务器请求和响应的数据类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:220
#, no-wrap
msgid ""
"record Credentials where\n"
"  constructor MkCredentials\n"
"  email    : Email\n"
"  password : Password\n"
"\n"
"record Request where\n"
"  constructor MkRequest\n"
"  credentials : Credentials\n"
"  album       : Album\n"
"\n"
"data Response : Type where\n"
"  UnknownUser     : Email -> Response\n"
"  InvalidPassword : Response\n"
"  AccessDenied    : Email -> Album -> Response\n"
"  Success         : Album -> Response\n"
msgstr ""
"record Credentials where\n"
"  constructor MkCredentials\n"
"  email    : Email\n"
"  password : Password\n"
"\n"
"record Request where\n"
"  constructor MkRequest\n"
"  credentials : Credentials\n"
"  album       : Album\n"
"\n"
"data Response : Type where\n"
"  UnknownUser     : Email -> Response\n"
"  InvalidPassword : Response\n"
"  AccessDenied    : Email -> Album -> Response\n"
"  Success         : Album -> Response\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:243
#, no-wrap
msgid ""
"For server responses, we use a custom sum type encoding\n"
"the possible outcomes of a client request. In practice,\n"
"the `Success` case would return some kind of connection\n"
"to start the actual album stream, but we just\n"
"wrap up the album we found to simulate this behavior.\n"
msgstr "对于服务器响应，我们使用自定义 sum 类型来编码客户端请求的可能结果。在实践中，`Success` 案例会返回某种连接来启动实际的专辑流，但我们只是包装我们找到的专辑来模拟这种行为。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:248
#, no-wrap
msgid ""
"We can now go ahead and simulate the handling of\n"
"a request at the server. To emulate our user data base,\n"
"a simple list of users will do. Here's the type of the\n"
"function we'd like to implement:\n"
msgstr "我们现在可以继续模拟在服务器上对请求的处理。为了模拟我们的用户数据库，一个简单的用户列表就可以了。这是我们要实现的函数的类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:249
#, no-wrap
msgid ""
"DB : Type\n"
"DB = List User\n"
"\n"
"handleRequest : DB -> Request -> Response\n"
msgstr ""
"DB : Type\n"
"DB = List User\n"
"\n"
"handleRequest : DB -> Request -> Response\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:265
#, no-wrap
msgid ""
"Note, how we defined a short alias for `List User` called `DB`.\n"
"This is often useful to make lengthy type signatures more readable\n"
"and communicate the meaning of a type in the given context. However,\n"
"this will *not* introduce a new type, nor will it\n"
"increase type safety: `DB` is *identical* to `List User`, and as\n"
"such, a value of type `DB` can be used wherever a `List User` is\n"
"expected and vice versa. In more complex programs it is therefore\n"
"usually preferable to define new types by wrapping values in\n"
"single-field records.\n"
msgstr "请注意，我们如何为 `List User` 定义一个称为 `DB` 的短别名。这通常有助于使冗长的类型签名更具可读性并在给定的上下文中传达类型的含义。但是，这将 *不会* 引入新类型，也不会增加类型安全性：`DB` 只是 `List User` 的一个 *身份*，并且作为这样，类型为 `DB` 的值可以在需要 `List User` 的任何地方使用，反之亦然。因此，在更复杂的程序中，通常最好通过将值包装在单字段记录中来定义新类型。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:274
#, no-wrap
msgid ""
"The implementation will proceed as follows: It will first\n"
"try and lookup a `User` by is email address in the data\n"
"base. If this is successful, it will compare the provided password\n"
"with the user's actual password. If the two match, it will\n"
"lookup the requested album in the user's list of albums.\n"
"If all of these steps succeed, the result will be an `Album`\n"
"wrapped in a `Success`. If any of the steps fails, the\n"
"result will describe exactly what went wrong.\n"
msgstr "实现将按如下进行：它将首先尝试在数据库中通过电子邮件地址查找 `User`。如果成功，它会将提供的密码与用户的实际密码进行比较。如果两者匹配，它将在用户的专辑列表中查找请求的专辑。如果所有这些步骤都成功，结果将是 `Album` 包裹在 `Success` 中。如果任何步骤失败，结果将准确描述问题所在。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:276
#, no-wrap
msgid "Here's a possible implementation:\n"
msgstr "这是一个可能的实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:277
#, no-wrap
msgid ""
"handleRequest db (MkRequest (MkCredentials email pw) album) =\n"
"  case lookupUser db of\n"
"    Just (MkUser _ _ password albums)  =>\n"
"      if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"    Nothing => UnknownUser email\n"
"\n"
"  where lookupUser : List User -> Maybe User\n"
"        lookupUser []        = Nothing\n"
"        lookupUser (x :: xs) =\n"
"          if x.email == email then Just x else lookupUser xs\n"
"\n"
"        lookupAlbum : List Album -> Response\n"
"        lookupAlbum []        = AccessDenied email album\n"
"        lookupAlbum (x :: xs) =\n"
"          if x == album then Success album else lookupAlbum xs\n"
msgstr ""
"handleRequest db (MkRequest (MkCredentials email pw) album) =\n"
"  case lookupUser db of\n"
"    Just (MkUser _ _ password albums)  =>\n"
"      if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"    Nothing => UnknownUser email\n"
"\n"
"  where lookupUser : List User -> Maybe User\n"
"        lookupUser []        = Nothing\n"
"        lookupUser (x :: xs) =\n"
"          if x.email == email then Just x else lookupUser xs\n"
"\n"
"        lookupAlbum : List Album -> Response\n"
"        lookupAlbum []        = AccessDenied email album\n"
"        lookupAlbum (x :: xs) =\n"
"          if x == album then Success album else lookupAlbum xs\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:305
#, no-wrap
msgid ""
"I'd like to point out several things in this example. First,\n"
"note how we can extract values from nested records in a\n"
"single pattern match.\n"
"Second, we defined two *local* functions in a `where` block: `lookupUser`,\n"
"and `lookupAlbum`. Both of these have access to all variables\n"
"in the surrounding scope. For instance, `lookupUser` uses the\n"
"`album` variable from the pattern match in the implementation's\n"
"first line. Likewise, `lookupAlbum` makes use of the `album`\n"
"variable.\n"
msgstr "我想在这个例子中指出几件事。首先，请注意我们如何在单个模式匹配中从嵌套记录中提取值。其次，我们在 `where` 块中定义了两个 *局部* 函数：`lookupUser` 和 `lookupAlbum`。这两者都可以访问作用域内的所有变量。例如，`lookupUser` 在实现的第一行中使用来自模式匹配的 `album` 变量。同样，`lookupAlbum` 使用 `album` 变量。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:310
#, no-wrap
msgid ""
"A `where` block introduces new local definitions, accessible\n"
"only from the surrounding scope and from other functions\n"
"defined later in the same `where` block. These need to\n"
"be explicitly typed and indented by the same amount of whitespace.\n"
msgstr "`where` 块引入了新的局部定义，只能从作用域和稍后在同一 `where` 块中定义的其他函数访问。这些需要以相同数量的空格输入和缩进。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:318
#, no-wrap
msgid ""
"Local definitions can also be introduce *before* a function's\n"
"implementation by using the `let` keyword. This usage\n"
"of `let` is not to be confused with *let bindings* described\n"
"above, which are used to bind and reuse the results of intermediate\n"
"computations. Below is how we could have implemented `handleRequest` with\n"
"local definitions introduced by the `let` keyword. Again,\n"
"all definitions have to be properly typed and indented:\n"
msgstr "局部定义也可以通过使用 `let` 关键字在函数实现 *之前* 引入。 `let` 的这种用法不要与上面描述的 *let bindings* 混淆，后者用于绑定和重用中间计算的结果。下面是我们如何使用 `let` 关键字引入的本地定义来实现 `handleRequest`。同样，所有定义都必须正确输入和缩进：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:319
#, no-wrap
msgid ""
"handleRequest' : DB -> Request -> Response\n"
"handleRequest' db (MkRequest (MkCredentials email pw) album) =\n"
"  let lookupUser : List User -> Maybe User\n"
"      lookupUser []        = Nothing\n"
"      lookupUser (x :: xs) =\n"
"        if x.email == email then Just x else lookupUser xs\n"
"\n"
"      lookupAlbum : List Album -> Response\n"
"      lookupAlbum []        = AccessDenied email album\n"
"      lookupAlbum (x :: xs) =\n"
"        if x == album then Success album else lookupAlbum xs\n"
"\n"
"   in case lookupUser db of\n"
"        Just (MkUser _ _ password albums)  =>\n"
"          if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"        Nothing => UnknownUser email\n"
msgstr ""
"handleRequest' : DB -> Request -> Response\n"
"handleRequest' db (MkRequest (MkCredentials email pw) album) =\n"
"  let lookupUser : List User -> Maybe User\n"
"      lookupUser []        = Nothing\n"
"      lookupUser (x :: xs) =\n"
"        if x.email == email then Just x else lookupUser xs\n"
"\n"
"      lookupAlbum : List Album -> Response\n"
"      lookupAlbum []        = AccessDenied email album\n"
"      lookupAlbum (x :: xs) =\n"
"        if x == album then Success album else lookupAlbum xs\n"
"\n"
"   in case lookupUser db of\n"
"        Just (MkUser _ _ password albums)  =>\n"
"          if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"        Nothing => UnknownUser email\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:345
#, no-wrap
msgid ""
"The exercises in this section are supposed to increase\n"
"you experience in writing purely functional code. In some\n"
"cases it might be useful to use `let` expressions or\n"
"`where` blocks, but this will not always be required.\n"
msgstr "本节中的练习旨在增加您编写纯函数式代码的经验。在某些情况下，使用 `let` 表达式或 `where` 块可能很有用，但这并不总是必需的。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:350
#, no-wrap
msgid ""
"Exercise 3 is again of utmost importance. `traverseList`\n"
"is a specialized version of the more general `traverse`,\n"
"one of the most powerful and versatile functions\n"
"available in the *Prelude* (check out its type!).\n"
msgstr "练习 3 同样至关重要。 `traverseList` 是更通用的 `traverse` 的专用版本，是 *Prelude* 中最强大和最通用的功能之一（查看它的类型！）。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions2.md:355
#, no-wrap
msgid ""
"Module `Data.List` in *base* exports functions `find` and `elem`.\n"
"Inspect their types and use these in the implementation of\n"
"`handleRequest`. This should allow you to completely get rid\n"
"of the `where` block.\n"
msgstr ""
"*base* 中的 `Data.List` 模块导出函数 `find` 和 `elem`。检查它们的类型并在 "
"`handleRequest` 的实现中使用它们。这应该可以让您完全摆脱 `where` 块。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions2.md:365
#, no-wrap
msgid ""
"Define an enumeration type listing the four\n"
"[nucleobases](https://en.wikipedia.org/wiki/Nucleobase)\n"
"occurring in DNA strands. Define also a type alias\n"
"`DNA` for lists of nucleobases.\n"
"Declare and implement function `readBase`\n"
"for converting a single character (type `Char`) to a nucleobase.\n"
"You can use character literals in your implementation like so:\n"
"`'A'`, `'a'`. Note, that this function might fail, so adjust the\n"
"result type accordingly.\n"
msgstr ""
"定义枚举类型，列出 DNA 链中出现的四个 [核碱基](https://en.wikipedia.org/wiki/"
"Nucleobase)。还为核碱基列表定义类型别名 `DNA`。声明并实现函数 `readBase` "
"用于将单个字符（类型 `Char`）转换为核碱基。您可以在实现中使用字符文字，如下所"
"示：`'A'`、`'a'`。请注意，此函数可能会失败，因此请相应地调整结果类型。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions2.md:371
#, no-wrap
msgid ""
"Implement the following function, which tries to convert all\n"
"values in a list with a function, which might fail. The\n"
"result should be a `Just` holding the list of converted\n"
"values in unmodified order, if and\n"
"only if every single conversion was successful.\n"
msgstr ""
"实现以下函数，该函数尝试使用函数转换列表中的所有值，这可能会失败。结果应该是 "
"`Just` 以未修改的顺序保存转换值的列表，当且仅当每次转换都成功时。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:372
#, no-wrap
msgid "   traverseList : (a -> Maybe b) -> List a -> Maybe (List b)\n"
msgstr "   traverseList : (a -> Maybe b) -> List a -> Maybe (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:378
#, no-wrap
msgid ""
"   You can verify, that the function behaves correctly with\n"
"   the following test: `traverseList Just [1,2,3] = Just [1,2,3]`.\n"
msgstr "   您可以通过下面的测试验证该函数是否正确运行：`traverseList Just [1,2,3] = Just [1,2,3]`。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions2.md:382
#, no-wrap
msgid ""
"Implement function `readDNA : String -> Maybe DNA`\n"
"using the functions and types defined in exercises 2 and 3.\n"
"You will also need function `unpack` from the *Prelude*.\n"
msgstr ""
"使用练习 2 和 3 中定义的函数和类型实现函数 `readDNA : String -> Maybe DNA`。"
"您还需要 *Prelude* 中的函数 `unpack`。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions2.md:385
#, no-wrap
msgid ""
"Implement function `complement : DNA -> DNA` to\n"
"calculate the complement of a strand of DNA.\n"
msgstr "实现函数 `complement : DNA -> DNA` 来计算一条 DNA 链的补码。\n"

#. type: Title ##
#: ../src/Tutorial/Functions2.md:386
#, no-wrap
msgid "The Truth about Function Arguments"
msgstr "关于函数参数的真相"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:390
#, no-wrap
msgid ""
"So far, when we defined a top level function, it looked something\n"
"like the following:\n"
msgstr "到目前为止，当我们定义一个顶级函数时，它看起来像下面这样：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:391
#, no-wrap
msgid ""
"zipEitherWith : (a -> b -> c) -> Either e a -> Either e b -> Either e c\n"
"zipEitherWith f (Right va) (Right vb) = Right (f va vb)\n"
"zipEitherWith f (Left e)   _          = Left e\n"
"zipEitherWith f _          (Left e)   = Left e\n"
msgstr ""
"zipEitherWith : (a -> b -> c) -> Either e a -> Either e b -> Either e c\n"
"zipEitherWith f (Right va) (Right vb) = Right (f va vb)\n"
"zipEitherWith f (Left e)   _          = Left e\n"
"zipEitherWith f _          (Left e)   = Left e\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:401
#, no-wrap
msgid ""
"Function `zipEitherWith` is a generic higher-order function combining the\n"
"values stored in two `Either`s via a binary function. If either\n"
"of the `Either` arguments is a `Left`, the result is also a `Left`.\n"
msgstr "函数 `zipEitherWith` 是一个通用的高阶函数，通过二进制函数将两个 `Either` 中存储的值组合在一起。如果任一 `Either` 类型参数是 `Left`，则结果也是 `Left`。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:407
#, no-wrap
msgid ""
"This is a *generic function* with *type parameters* `a`, `b`, `c`, and `e`.\n"
"However, there is a more verbose type for `zipEitherWith`, which is\n"
"visible in the REPL when entering `:ti zipEitherWith` (the `i` here\n"
"tells Idris to include `implicit` arguments). You will get a type\n"
"similar to this:\n"
msgstr "这是一个 *泛型函数*，带有 *类型参数* `a`、`b`、`c` 和 `e`。但是，`zipEitherWith` 有一个更详细的类型，当在 REPL 中输入 `:ti zipEitherWith`（这里的 `i` 告诉 Idris 包含 `implicit` 参数）时。你会得到一个类似这样的类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:408
#, no-wrap
msgid ""
"zipEitherWith' :  {0 a : Type}\n"
"               -> {0 b : Type}\n"
"               -> {0 c : Type}\n"
"               -> {0 e : Type}\n"
"               -> (a -> b -> c)\n"
"               -> Either e a\n"
"               -> Either e b\n"
"               -> Either e c\n"
msgstr ""
"zipEitherWith' :  {0 a : Type}\n"
"               -> {0 b : Type}\n"
"               -> {0 c : Type}\n"
"               -> {0 e : Type}\n"
"               -> (a -> b -> c)\n"
"               -> Either e a\n"
"               -> Either e b\n"
"               -> Either e c\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:421
#, no-wrap
msgid ""
"In order to understand what's going on here, we will have to talk about\n"
"named arguments, implicit arguments, and quantities.\n"
msgstr "为了理解这里发生了什么，我们将不得不讨论命名参数、隐式参数和定量。\n"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:422
#, no-wrap
msgid "Named Arguments"
msgstr "命名参数"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:425
#, no-wrap
msgid "In a function type, we can give each argument a name. Like so:\n"
msgstr "在函数类型中，我们可以给每个参数一个名称。像这样：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:426
#, no-wrap
msgid ""
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"
msgstr ""
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:439
#, no-wrap
msgid ""
"Here, the first argument is given name `deflt`, the second `ma`. These\n"
"names can be reused in a function's implementation, as was done for `deflt`,\n"
"but this is not mandatory: We are free to use different names in the\n"
"implementation. There are several reasons, why we'd choose to name our\n"
"arguments: It can serve as documentation, but it also\n"
"allows us to pass the arguments to a function in arbitrary order\n"
"when using the following syntax:\n"
msgstr "这里，第一个参数的名称是 `deflt`，第二个参数是 `ma`。这些名称可以在函数的实现中重复使用，就像 `deflt` 所做的那样，但这不是强制性的：我们可以在实现中自由使用不同的名称。我们选择命名参数有几个原因：它可以用作文档，但它也允许我们在使用以下语法时以任意顺序将参数传递给函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:440
#, no-wrap
msgid ""
"extractBool : Maybe Bool -> Bool\n"
"extractBool v = fromMaybe { ma = v, deflt = False }\n"
msgstr ""
"extractBool : Maybe Bool -> Bool\n"
"extractBool v = fromMaybe { ma = v, deflt = False }\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:446
#, no-wrap
msgid "Or even :\n"
msgstr "甚至 ：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:447
#, no-wrap
msgid ""
"extractBool2 : Maybe Bool -> Bool\n"
"extractBool2 = fromMaybe { deflt = False }\n"
msgstr ""
"extractBool2 : Maybe Bool -> Bool\n"
"extractBool2 = fromMaybe { deflt = False }\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:454
#, no-wrap
msgid ""
"The arguments in a record's constructor are automatically named\n"
"in accordance with the field names:\n"
msgstr "记录构造函数中的参数根据字段名称自动命名：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:455
#, no-wrap
msgid ""
"record Dragon where\n"
"  constructor MkDragon\n"
"  name      : String\n"
"  strength  : Nat\n"
"  hitPoints : Int16\n"
"\n"
"gorgar : Dragon\n"
"gorgar = MkDragon { strength = 150, name = \"Gorgar\", hitPoints = 10000 }\n"
msgstr ""
"record Dragon where\n"
"  constructor MkDragon\n"
"  name      : String\n"
"  strength  : Nat\n"
"  hitPoints : Int16\n"
"\n"
"gorgar : Dragon\n"
"gorgar = MkDragon { strength = 150, name = \"Gorgar\", hitPoints = 10000 }\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:471
#, no-wrap
msgid ""
"For the use cases described above, named arguments are merely a\n"
"convenience and completely optional. However, Idris is a *dependently typed*\n"
"programming language: Types can be calculated from and depend on\n"
"values. For instance, the *result type* of a function can *depend* on\n"
"the *value* of one of its arguments. Here's a contrived example:\n"
msgstr "对于上述用例，命名参数只是一种方便且完全可选的。但是，Idris 是一种 *依赖类型* 编程语言：类型可以根据值计算并取决于值。例如，函数的 *结果类型* 可以 *取决于* 其参数之一的 *值*。这是一个人为的例子：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:472
#, no-wrap
msgid ""
"IntOrString : Bool -> Type\n"
"IntOrString True  = Integer\n"
"IntOrString False = String\n"
"\n"
"intOrString : (v : Bool) -> IntOrString v\n"
"intOrString False = \"I'm a String\"\n"
"intOrString True  = 1000\n"
msgstr ""
"IntOrString : Bool -> Type\n"
"IntOrString True  = Integer\n"
"IntOrString False = String\n"
"\n"
"intOrString : (v : Bool) -> IntOrString v\n"
"intOrString False = \"I'm a String\"\n"
"intOrString True  = 1000\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:489
#, no-wrap
msgid ""
"If you see such a thing for the first time, it can be hard to understand\n"
"what's going on here. First, function `IntOrString` computes a `Type`\n"
"from a `Bool` value: If the argument is `True`, it returns type `Integer`,\n"
"if the argument is `False` it returns `String`. We use this to\n"
"calculate the return type of function `intOrString` based on its\n"
"boolean argument `v`: If `v` is `True`, the return type is (in accordance\n"
"with `IntOrString True = Integer`) `Integer`, otherwise it is `String`.\n"
msgstr "如果您第一次看到这样的事情，可能很难理解这里发生了什么。首先，函数 `IntOrString` 从 `Bool` 值计算 `Type`：如果参数是 `True`，则返回类型 `Integer`，如果参数为 `False`，则返回 `String`。我们使用 `intOrString` 来根据其布尔参数 `v` 计算函数 的返回类型： 如果 `v` 为 `True`，则返回类型为（根据`IntOrString True = Integer`）`Integer`，否则为`String`。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:493
#, no-wrap
msgid ""
"Note, how in the type signature of `intOrString`, we *must* give the\n"
"argument of type `Bool` a name (`v`) in order to reference it in\n"
"the result type `IntOrString v`.\n"
msgstr "注意，在 `intOrString` 的类型签名中，我们 *必须* 给 `Bool` 类型的参数命名 (`v`) 以便在结果类型 `IntOrString v` 中引用它。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:500
#, no-wrap
msgid ""
"You might wonder at this moment, why this is useful and why we would\n"
"ever want to define a function with such a strange type. We will see\n"
"lots of very useful examples in due time! For now, suffice to say that\n"
"in order to express dependent function types, we need to name\n"
"at least some of the function's arguments and refer to them by name\n"
"in the types of other arguments.\n"
msgstr "此时您可能想知道，为什么这很有用，以及为什么我们要定义一个具有如此奇怪类型的函数。我们会在适当的时候看到很多非常有用的例子！现在，可以这么说，为了表达依赖函数类型，我们至少需要命名函数的一些参数，并在其他参数的类型中通过名称引用它们。\n"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:501
#, no-wrap
msgid "Implicit Arguments"
msgstr "隐式参数"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:509
#, no-wrap
msgid ""
"Implicit arguments are arguments, the values of which the compiler\n"
"should infer and fill in for us automatically. For instance, in\n"
"the following function signature, we expect the compiler to\n"
"infer the value of type parameter `a` automatically from the\n"
"types of the other arguments (ignore the 0 quantity for the moment;\n"
"I'll explain it in the next subsection):\n"
msgstr "隐式参数也是参数，编译器应该自动为我们推断和填充其值。例如，在下面的函数签名中，我们希望编译器从其他参数的类型中自动推断类型参数 `a` 的值（暂时忽略定量 0；我将在下一小节）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:510
#, no-wrap
msgid ""
"maybeToEither : {0 a : Type} -> Maybe a -> Either String a\n"
"maybeToEither Nothing  = Left \"Nope\"\n"
"maybeToEither (Just x) = Right x\n"
"\n"
"-- Please remember, that the above is\n"
"-- equivalent to the following:\n"
"maybeToEither' : Maybe a -> Either String a\n"
"maybeToEither' Nothing  = Left \"Nope\"\n"
"maybeToEither' (Just x) = Right x\n"
msgstr ""
"maybeToEither : {0 a : Type} -> Maybe a -> Either String a\n"
"maybeToEither Nothing  = Left \"Nope\"\n"
"maybeToEither (Just x) = Right x\n"
"\n"
"-- Please remember, that the above is\n"
"-- equivalent to the following:\n"
"maybeToEither' : Maybe a -> Either String a\n"
"maybeToEither' Nothing  = Left \"Nope\"\n"
"maybeToEither' (Just x) = Right x\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:527
#, no-wrap
msgid ""
"As you can see, implicit arguments are wrapped in curly braces,\n"
"unlike explicit named arguments, which are wrapped in parentheses.\n"
"Inferring the value of an implicit argument is not always possible.\n"
"For instance, if we enter the following\n"
"at the REPL, Idris will fail with an error:\n"
msgstr "如您所见，隐式参数包含在花括号中，与显式命名参数不同，后者包含在括号中。推断隐含参数的值并不总是可能的。例如，如果我们在 REPL 中输入以下内容，Idris 将失败并出现错误：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:528
#, no-wrap
msgid ""
"Tutorial.Functions2> show (maybeToEither Nothing)\n"
"Error: Can't find an implementation for Show (Either String ?a).\n"
msgstr ""
"Tutorial.Functions2> show (maybeToEither Nothing)\n"
"Error: Can't find an implementation for Show (Either String ?a).\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:540
#, no-wrap
msgid ""
"Idris is unable to find an implementation of `Show (Either String a)`\n"
"without knowing what `a` actually is.\n"
"Note the question mark in front of the\n"
"type parameter: `?a`.\n"
"If this happens, there are several ways to help the type checker.\n"
"We could, for instance, pass a value for the implicit argument\n"
"explicitly. Here's the syntax to do this:\n"
msgstr "Idris 在不知道 `a` 实际上是什么的情况下无法找到 `Show (Either String a)` 的实现。注意类型参数前面的问号：`?a`。如果发生这种情况，有几种方法可以帮助类型检查器。例如，我们可以为隐式参数显式传递一个值。这是执行此操作的语法：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:541
#, no-wrap
msgid ""
"Tutorial.Functions2> show (maybeToEither {a = Int8} Nothing)\n"
"\"Left \"Nope\"\"\n"
msgstr ""
"Tutorial.Functions2> show (maybeToEither {a = Int8} Nothing)\n"
"\"Left \"Nope\"\"\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:549
#, no-wrap
msgid ""
"As you can see, we use the same syntax\n"
"as shown above for explicit named arguments and the\n"
"two forms of argument passing can be mixed.\n"
msgstr "如您所见，我们对显式命名参数使用与上面所示相同的语法，并且可以混合使用两种形式的参数传递。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:552
#, no-wrap
msgid ""
"We could also specify the type of the whole expression using\n"
"utility function `the` from the *Prelude*:\n"
msgstr "我们还可以使用 *Prelude* 中的实用函数 `the` 指定整个表达式的类型：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:553
#, no-wrap
msgid ""
"Tutorial.Functions2> show (the (Either String Int8) (maybeToEither Nothing))\n"
"\"Left \"Nope\"\"\n"
msgstr ""
"Tutorial.Functions2> show (the (Either String Int8) (maybeToEither Nothing))\n"
"\"Left \"Nope\"\"\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:559
#, no-wrap
msgid "It is instructive to have a look at the type of `the`:\n"
msgstr "查看 `the` 的类型很有启发性：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:560
#, no-wrap
msgid ""
"Tutorial.Functions2> :ti the\n"
"Prelude.the : (0 a : Type) -> a -> a\n"
msgstr ""
"Tutorial.Functions2> :ti the\n"
"Prelude.the : (0 a : Type) -> a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:566
#, no-wrap
msgid "Compare this with the identity function `id`:\n"
msgstr "将此与恒等函数 `id` 进行比较：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:567
#, no-wrap
msgid ""
"Tutorial.Functions2> :ti id\n"
"Prelude.id : {0 a : Type} -> a -> a\n"
msgstr ""
"Tutorial.Functions2> :ti id\n"
"Prelude.id : {0 a : Type} -> a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:581
#, no-wrap
msgid ""
"The only difference between the two: In case of `the`,\n"
"the type parameter `a` is an *explicit* argument, while\n"
"in case of `id`, it is an *implicit* argument. Although\n"
"the two functions have almost identical types (and implementations!),\n"
"they serve quite different purposes: `the` is used to help\n"
"type inference, while `id` is used whenever we'd like\n"
"to return an argument without modifying it at all (which,\n"
"in the presence of higher-order functions,\n"
"happens surprisingly often).\n"
msgstr "两者之间的唯一区别：在 `the` 的情况下，类型参数 `a` 是 *显式* 参数，而在 `id` 的情况下，它是一个 *隐式* 参数。尽管这两个函数具有几乎相同的类型（和实现！），但它们的用途却截然不同：`the` 用于帮助类型推断，而 `id` 用于我们想要的任何时候返回一个参数而不修改它（在高阶函数存在的情况下，这种情况经常发生）。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:585
#, no-wrap
msgid ""
"Both ways to improve type inference shown above\n"
"are used quite often, and must be understood by Idris\n"
"programmers.\n"
msgstr "上面显示的两种改进类型推断的方法都经常使用，并且 Idris 程序员必须理解。\n"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:586
#, no-wrap
msgid "Multiplicities"
msgstr "多重性"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:593
#, no-wrap
msgid ""
"Finally, we need to talk about the zero multiplicity, which appeared\n"
"in several of the type signatures in this section. Idris 2, unlike\n"
"its predecessor Idris 1, is based on a core language called\n"
"*quantitative type theory* (QTT): Every variable in Idris 2 is\n"
"associated with one of three possible multiplicities:\n"
msgstr "最后，我们需要谈谈在本节的几个类型签名中出现的零多重性。 Idris 2 与其前身 Idris 1 不同，它基于称为 *定量类型理论* (QTT) 的核心语言：Idris 2 中的每个变量都与三种可能的多重性之一相关联：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
#, no-wrap
msgid "`0`, meaning that the variable is *erased* at runtime.\n"
msgstr "`0` ，表示变量在运行时被 *擦除*。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
#, no-wrap
msgid "`1`, meaning that the variable is used *exactly once* at runtime.\n"
msgstr "`1` ，表示变量在运行时 *正好使用一次* 。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:598
#, no-wrap
msgid ""
"* *Unrestricted* (the default), meaning that the variable is used\n"
"   an arbitrary number of times at runtime.\n"
msgstr "* *无限制*（默认），表示在运行时使用变量任意次数。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:604
#, no-wrap
msgid ""
"We will not talk about the most complex of the three, multiplicity `1`, here.\n"
"We are, however, often interested in multiplicity `0`: A variable with\n"
"multiplicity `0` is only relevant at *compile time*. It will not make\n"
"any appearance at runtime, and the computation of such a variable will\n"
"never affect a program's runtime performance.\n"
msgstr "我们不会在这里讨论三者中最复杂的，多重性 `1`。然而，我们经常对多重性 `0` 感兴趣：具有多重性 `0` 的变量仅在 *编译时* 相关。它不会在运行时出现，并且这样一个变量的计算永远不会影响程序的运行时性能。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:609
#, no-wrap
msgid ""
"In the type signature of `maybeToEither` we see that type\n"
"parameter `a` has multiplicity `0`, and will therefore be erased and\n"
"is only relevant at compile time, while the `Maybe a` argument\n"
"has *unrestricted* multiplicity.\n"
msgstr "在 `maybeToEither` 的类型签名中，我们看到类型参数 `a` 具有多重性 `0`，因此将被擦除并且仅在编译时相关，而 `Maybe a ` 参数具有 *无限制* 多重性。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:613
#, no-wrap
msgid ""
"It is also possible to annotate explicit arguments with multiplicities,\n"
"in which case the argument must again be put in parentheses. For an example,\n"
"look again at the type signature of `the`.\n"
msgstr "也可以用多重性注释显式参数，在这种情况下，同样参数必须放在括号中。例如，再次查看 `the` 的类型签名。\n"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:614
#, no-wrap
msgid "Underscores"
msgstr "下划线"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:623
#, no-wrap
msgid ""
"It is often desirable, to only write as little code as necessary\n"
"and let Idris figure out the rest.\n"
"We have already learned about one such occasion: Catch-all patterns.\n"
"If a variable in a pattern match is not used on the right hand side,\n"
"we can't just drop it, as this would make it impossible for\n"
"Idris, which of several arguments we were planning to drop,\n"
"but we can use an underscore as a placeholder instead:\n"
msgstr "通常希望只编写必要的代码，让 Idris 解决剩下的问题。我们已经了解了这样一种情况：全捕获模式。如果模式匹配中的变量未在右侧使用，我们不能直接删除它，因为这会使 Idris 无法使用，但我们可以使用下划线作为一个占位符，表明我们计划删除几个参数中的哪一个：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:624
#, no-wrap
msgid ""
"isRight : Either a b -> Bool\n"
"isRight (Right _) = True\n"
"isRight _         = False\n"
msgstr ""
"isRight : Either a b -> Bool\n"
"isRight (Right _) = True\n"
"isRight _         = False\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:633
#, no-wrap
msgid ""
"But when we look at the type signature of `isRight`, we will note\n"
"that type parameters `a` and `b` are also only used once, and\n"
"are therefore of no importance. Let's get rid of them:\n"
msgstr "但是当我们查看 `isRight` 的类型签名时，我们会注意到类型参数 `a` 和 `b` 也只使用一次，因此它们并不重要.让我们摆脱它们：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:634
#, no-wrap
msgid ""
"isRight' : Either _ _ -> Bool\n"
"isRight' (Right _) = True\n"
"isRight' _         = False\n"
msgstr ""
"isRight' : Either _ _ -> Bool\n"
"isRight' (Right _) = True\n"
"isRight' _         = False\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:645
#, no-wrap
msgid ""
"In the detailed type signature of `zipEitherWith`, it should\n"
"be obvious for Idris that the implicit arguments are of type `Type`.\n"
"After all, all of them are later on applied to the `Either` type\n"
"constructor, which is of type `Type -> Type -> Type`. Let's get rid\n"
"of them:\n"
msgstr "在 `zipEitherWith` 的详细类型签名中，对 Idris 来说，隐式参数的类型应该是 `Type`。毕竟，它们后来都应用于 `Either` 类型构造函数，它的类型为 `Type -> Type -> Type`。让我们摆脱它们：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:646
#, no-wrap
msgid ""
"zipEitherWith'' :  {0 a : _}\n"
"                -> {0 b : _}\n"
"                -> {0 c : _}\n"
"                -> {0 e : _}\n"
"                -> (a -> b -> c)\n"
"                -> Either e a\n"
"                -> Either e b\n"
"                -> Either e c\n"
msgstr ""
"zipEitherWith'' :  {0 a : _}\n"
"                -> {0 b : _}\n"
"                -> {0 c : _}\n"
"                -> {0 e : _}\n"
"                -> (a -> b -> c)\n"
"                -> Either e a\n"
"                -> Either e b\n"
"                -> Either e c\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:658
#, no-wrap
msgid "Consider the following contrived example:\n"
msgstr "考虑以下人为设计的示例：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:659
#, no-wrap
msgid ""
"foo : Integer -> String\n"
"foo n = show (the (Either String Integer) (Right n))\n"
msgstr ""
"foo : Integer -> String\n"
"foo n = show (the (Either String Integer) (Right n))\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:669
#, no-wrap
msgid ""
"Since we wrap an `Integer` in a `Right`, it is obvious\n"
"that the second argument in `Either String Integer` is\n"
"`Integer`. Only the `String` argument can't be inferred\n"
"by Idris. Even better, the `Either` itself is obvious!\n"
"Let's get rid of the unnecessary noise:\n"
msgstr "由于我们将 `Integer` 包装在 `Right` 中，很明显 `Either String Integer` 中的第二个参数是 `Integer`。 Idris 无法推断出的只有 `String` 参数。更妙的是，`Either` 本身就很明显了！让我们摆脱不必要的噪音：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:670
#, no-wrap
msgid ""
"foo' : Integer -> String\n"
"foo' n = show (the (_ String _) (Right n))\n"
msgstr ""
"foo' : Integer -> String\n"
"foo' n = show (the (_ String _) (Right n))\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:680
#, no-wrap
msgid ""
"Please note, that using underscores as in `foo'` is\n"
"not always desirable, as it can quite drastically\n"
"obfuscate the written code. Always use a syntactic\n"
"convenience to make code more readable, and not to\n"
"show people how clever you are.\n"
msgstr "请注意，在 `foo'` 中使用下划线并不总是可取的，因为它会极大地混淆编写的代码。始终使用方便的语法来使代码更具可读性，而不是向人们展示你有多聪明。\n"

#. type: Title ##
#: ../src/Tutorial/Functions2.md:681
#, no-wrap
msgid "Programming with Holes"
msgstr "孔编程"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:696
#, no-wrap
msgid ""
"Solved all the exercises so far? Got angry at the type checker\n"
"for always complaining and never being really helpful? It's time\n"
"to change that. Idris comes with several highly useful interactive\n"
"editing features. Sometimes, the compiler is able to implement\n"
"complete functions for us (if the types are specific enough). Even\n"
"if that's not possible, there's an incredibly useful and important\n"
"feature, which can help us when the types are getting too complicated: Holes.\n"
"Holes are variables, the names of which are prefixed with a question mark.\n"
"We can use them as placeholders whenever we plan to implement a piece\n"
"of functionality at a later time. In addition, their types and the types\n"
"and quantities of all other variables in scope can be inspected\n"
"at the REPL (or in your editor, if you setup the necessary plugin).\n"
"Let's see them holes in action.\n"
msgstr "解决了到目前为止的所有练习？对类型检查器总是抱怨并且从来没有真正提供帮助而生气？是时候改变这一点了。 Idris 带有几个非常有用的交互式编辑功能。有时，编译器能够为我们实现完整的功能（如果类型足够具体）。即使这不可能，也有一个非常有用且重要的功能，当类型变得过于复杂时，它可以帮助我们：孔。孔是变量，其名称以问号为前缀。每当我们计划在以后实现某个功能时，我们都可以将它们用作占位符。此外，它们的类型以及范围内所有其他变量的类型和数量可以在 REPL（或在您的编辑器中，如果您设置了必要的插件）进行检查。让我们在实践中看看孔是什么样子。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:704
#, no-wrap
msgid ""
"Remember the `traverseList` example from an Exercise earlier in\n"
"this section? If this was your first encounter with applicative list\n"
"traversals, this might have been a nasty bit of work. Well, let's just\n"
"make it a wee bit harder still. We'd like to implement the same\n"
"piece of functionality for functions returning `Either e`, where\n"
"`e` is a type with a `Semigroup` implementation, and we'd like\n"
"to accumulate the values in all `Left`s we meet along the way.\n"
msgstr "还记得本节前面练习中的 `traverseList` 示例吗？如果这是您第一次遇到应用程序列表遍历，那么这可能是一项令人讨厌的工作。好吧，让我们让它变得更难一点。我们希望为返回 `Either e` 的函数实现相同的功能，其中 `e` 是具有 `Semigroup` 实现的类型，我们希望累积我们沿途遇到的所有 `Left` 中的值。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:706
#, no-wrap
msgid "Here's the type of the function:\n"
msgstr "这是函数的类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:707
#, no-wrap
msgid ""
"traverseEither :  Semigroup e\n"
"               => (a -> Either e b)\n"
"               -> List a\n"
"               -> Either e (List b)\n"
msgstr ""
"traverseEither :  Semigroup e\n"
"               => (a -> Either e b)\n"
"               -> List a\n"
"               -> Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:718
#, no-wrap
msgid ""
"Now, in order to follow along, you might want to start your own\n"
"Idris source file, load it into a REPL session and adjust the\n"
"code as described here. The first thing we'll do, is write a\n"
"skeleton implementation with a hole on the right hand side:\n"
msgstr "现在，为了继续进行，您可能想要启动自己的 Idris 源文件，将其加载到 REPL 会话中并按照此处所述调整代码。我们要做的第一件事是编写一个在右侧有一个孔的骨架实现：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:719
#, no-wrap
msgid "traverseEither fun as = ?impl\n"
msgstr "traverseEither fun as = ?impl\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:725
#, no-wrap
msgid ""
"When you now go to the REPL and reload the file using command `:r`,\n"
"you can enter `:m` to list all the *metavariables*:\n"
msgstr "当您现在转到 REPL 并使用命令 `:r` 重新加载文件时，您可以输入 `:m` 以列出所有 *元变量*：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:726
#, no-wrap
msgid ""
"Tutorial.Functions2> :m\n"
"1 hole:\n"
"  Tutorial.Functions2.impl : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :m\n"
"1 hole:\n"
"  Tutorial.Functions2.impl : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:734
#, no-wrap
msgid ""
"Next, we'd like to display the hole's type (including all variables in the\n"
"surrounding context plus their types):\n"
msgstr "接下来，我们要显示孔的类型（包括周围上下文中的所有变量及其类型）：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:735
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   as : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   as : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:750
#, no-wrap
msgid ""
"So, we have some erased type parameters (`a`, `b`, and `e`), a value\n"
"of type `List a` called `as`, and a function from `a` to\n"
"`Either e b` called `fun`. Our goal is to come up with a value\n"
"of type `Either a (List b)`.\n"
msgstr "因此，我们有一些已擦除的类型参数（`a`、`b` 和 `e`），类型为 `List a` 的值称为 `as`，以及从 `a` 到 `Either a b` 的函数，称为 `fun`。我们的目标是提出一个类型为 `Either a (List b)` 的值。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:754
#, no-wrap
msgid ""
"We *could* just return a `Right []`, but that only make sense\n"
"if our input list is indeed the empty list. We therefore should\n"
"start with a pattern match on the list:\n"
msgstr "我们 *可以* 只返回一个 `Right []`，但这只有在我们的输入列表确实是空列表时才有意义。因此，我们应该从列表中的模式匹配开始：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:755
#, no-wrap
msgid ""
"traverseEither fun []        = ?impl_0\n"
"traverseEither fun (x :: xs) = ?impl_1\n"
msgstr ""
"traverseEither fun []        = ?impl_0\n"
"traverseEither fun (x :: xs) = ?impl_1\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:762
#, no-wrap
msgid ""
"The result is two holes, which must be given distinct names. When inspecting `impl_0`,\n"
"we get the following result:\n"
msgstr "结果是两个孔，它们必须被赋予不同的名称。在检查 `impl_0` 时，我们得到以下结果：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:763
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_0\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_0 : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl_0\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_0 : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:779
#, no-wrap
msgid ""
"Now, this is an interesting situation. We are supposed to come up with a value\n"
"of type `Either e (List b)` with nothing to work with. We know nothing\n"
"about `a`, so we can't provide an argument with which to invoke `fun`.\n"
"Likewise, we know nothing about `e` or `b` either, so we can't produce\n"
"any values of these either. The *only* option we have is to replace `impl_0`\n"
"with an empty list wrapped in a `Right`:\n"
msgstr "现在，这是一个有趣的情况。我们应该想出一个类型为 `Either e (List b)` 的值，而不使用任何东西。我们对 `a` 一无所知，因此我们无法提供调用 `fun` 的参数。同样，我们对 `e` 或 `b` 也一无所知，因此我们也无法生成这些值。我们拥有的 *唯一* 选项是将 `impl_0` 替换为包含在 `Right` 中的空列表：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:780
#, no-wrap
msgid "traverseEither fun []        = Right []\n"
msgstr "traverseEither fun []        = Right []\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:786
#, no-wrap
msgid ""
"The non-empty case is of course slightly more involved. Here's the context\n"
"of `?impl_1`:\n"
msgstr "非空的情况当然稍微多一些。这是 `?impl_1` 的上下文：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:787
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_1\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   x : a\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_1 : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl_1\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   x : a\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_1 : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:810
#, no-wrap
msgid ""
"Since `x` is of type `a`, we can either use it as an argument\n"
"to `fun` or drop and ignore it. `xs`, on the other hand, is\n"
"the remainder of the list of type `List a`. We could again\n"
"drop it or process it further by invoking `traverseEither`\n"
"recursively. Since the goal is to try and convert *all* values,\n"
"we should drop neither. Since in case of two `Left`s we\n"
"are supposed to accumulate the values, we eventually need to\n"
"run both computations anyway (invoking `fun`, and recursively\n"
"calling `traverseEither`). We therefore can do both at the\n"
"same time and analyze the results in a single pattern match\n"
"by wrapping both in a `Pair`:\n"
msgstr "由于 `x` 是 `a` 类型，我们可以将其用作 `fun` 的参数，也可以放弃并忽略它。另一方面，`xs` 是 `List a` 类型列表的其余部分。我们可以通过递归调用 `traverseEither` 再次删除它或进一步处理它。由于目标是尝试转换 *所有* 值，我们都不应该放弃。因为在两个 `Left` 的情况下，我们应该累积值，我们最终还是需要运行这两个计算（调用 `fun`，并递归调用 `traverseEither`） .因此，我们可以同时进行这两项操作，并通过将两者包装在 `Pair` 中来分析单个模式匹配中的结果：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:811
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"   p => ?impl_2\n"
msgstr ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"   p => ?impl_2\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:818
#, no-wrap
msgid "Once again, we inspect the context:\n"
msgstr "我们再次检查上下文：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:819
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_2\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   p : (Either e b, Either e (List b))\n"
"------------------------------\n"
"impl_2 : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl_2\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   p : (Either e b, Either e (List b))\n"
"------------------------------\n"
"impl_2 : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:834
#, no-wrap
msgid ""
"We'll definitely need to pattern match on pair `p` next\n"
"to figure out, which of the two computations succeeded:\n"
msgstr "我们肯定需要在对 `p` 进行模式匹配，以确定两个计算中的哪一个成功：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:835
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => ?impl_6\n"
"    (Left y, Right _)  => ?impl_7\n"
"    (Right _, Left z)  => ?impl_8\n"
"    (Right y, Right z) => ?impl_9\n"
msgstr ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => ?impl_6\n"
"    (Left y, Right _)  => ?impl_7\n"
"    (Right _, Left z)  => ?impl_8\n"
"    (Right y, Right z) => ?impl_9\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:847
#, no-wrap
msgid ""
"At this point we might have forgotten what we actually\n"
"wanted to do (at least to me, this happens annoyingly often),\n"
"so we'll just quickly check what our goal is:\n"
msgstr "在这一点上，我们可能已经忘记了我们真正想要做什么（至少对我来说，这种情况经常发生），所以我们将快速检查我们的目标是什么：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:848
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_6\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   y : e\n"
"   z : e\n"
"------------------------------\n"
"impl_6 : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl_6\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   y : e\n"
"   z : e\n"
"------------------------------\n"
"impl_6 : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:868
#, no-wrap
msgid ""
"So, we are still looking for a value of type `Either e (List b)`, and\n"
"we have two values of type `e` in scope. According to the spec we\n"
"want to accumulate these using `e`s `Semigroup` implementation.\n"
"We can proceed for the other cases in a similar manner, remembering\n"
"that we should return a `Right`, if and only if all conversions\n"
"where successful:\n"
msgstr "因此，我们仍在寻找类型为 `Either e (List b)` 的值，并且我们在范围内有两个类型为 `e` 的值。根据规范，我们希望使用 `e` 的 `Semigroup` 实现来累积这些。我们可以以类似的方式处理其他情况，记住我们应该返回 `Right`，当且仅当所有转换都成功：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:869
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => Left (y <+> z)\n"
"    (Left y, Right _)  => Left y\n"
"    (Right _, Left z)  => Left z\n"
"    (Right y, Right z) => Right (y :: z)\n"
msgstr ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => Left (y <+> z)\n"
"    (Left y, Right _)  => Left y\n"
"    (Right _, Left z)  => Left z\n"
"    (Right y, Right z) => Right (y :: z)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:879
#, no-wrap
msgid "To reap the fruits of our labour, let's show off with a small example:\n"
msgstr "为了收获我们的劳动成果，让我们用一个小例子来炫耀一下：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:880
#, no-wrap
msgid ""
"data Nucleobase = Adenine | Cytosine | Guanine | Thymine\n"
"\n"
"readNucleobase : Char -> Either (List String) Nucleobase\n"
"readNucleobase 'A' = Right Adenine\n"
"readNucleobase 'C' = Right Cytosine\n"
"readNucleobase 'G' = Right Guanine\n"
"readNucleobase 'T' = Right Thymine\n"
"readNucleobase c   = Left [\"Unknown nucleobase: \" ++ show c]\n"
"\n"
"DNA : Type\n"
"DNA = List Nucleobase\n"
"\n"
"readDNA : String -> Either (List String) DNA\n"
"readDNA = traverseEither readNucleobase . unpack\n"
msgstr ""
"data Nucleobase = Adenine | Cytosine | Guanine | Thymine\n"
"\n"
"readNucleobase : Char -> Either (List String) Nucleobase\n"
"readNucleobase 'A' = Right Adenine\n"
"readNucleobase 'C' = Right Cytosine\n"
"readNucleobase 'G' = Right Guanine\n"
"readNucleobase 'T' = Right Thymine\n"
"readNucleobase c   = Left [\"Unknown nucleobase: \" ++ show c]\n"
"\n"
"DNA : Type\n"
"DNA = List Nucleobase\n"
"\n"
"readDNA : String -> Either (List String) DNA\n"
"readDNA = traverseEither readNucleobase . unpack\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:898
#, no-wrap
msgid "Let's try this at the REPL:\n"
msgstr "让我们在 REPL 上试试这个：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:899
#, no-wrap
msgid ""
"Tutorial.Functions2> readDNA \"CGTTA\"\n"
"Right [Cytosine, Guanine, Thymine, Thymine, Adenine]\n"
"Tutorial.Functions2> readDNA \"CGFTAQ\"\n"
"Left [\"Unknown nucleobase: 'F'\", \"Unknown nucleobase: 'Q'\"]\n"
msgstr ""
"Tutorial.Functions2> readDNA \"CGTTA\"\n"
"Right [Cytosine, Guanine, Thymine, Thymine, Adenine]\n"
"Tutorial.Functions2> readDNA \"CGFTAQ\"\n"
"Left [\"Unknown nucleobase: 'F'\", \"Unknown nucleobase: 'Q'\"]\n"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:906
#, no-wrap
msgid "Interactive Editing"
msgstr "交互式编辑"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:916
#, no-wrap
msgid ""
"There are plugins available for several editors and\n"
"programming environments, which facilitate interacting\n"
"with the Idris compiler when implementing your functions.\n"
"One editor, which is well supported in the Idris\n"
"community, is Neovim. Since I am a Neovim user myself,\n"
"I added some examples of what's possible to the\n"
"[appendix](../Appendices/Neovim.md). Now would be a good\n"
"time to start using the utilities discussed there.\n"
msgstr "有一些可用于多个编辑器和编程环境的插件，它们有助于在实现您的功能时与 Idris 编译器进行交互。一位深受 Idris 社区支持的编辑器是 Neovim。由于我自己是 Neovim 用户，因此我在 [附录](../Appendices/Neovim.md) 中添加了一些可能的示例。现在是开始使用那里讨论的实用程序的好时机。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:923
#, no-wrap
msgid ""
"If you use a different editor, probably with less support\n"
"for the Idris programming language, you should at the very\n"
"least have a REPL session open all the time, where the\n"
"source file you are currently working on is loaded. This\n"
"allows you to introduce new metavariables and inspect their\n"
"types and context as you develop your code.\n"
msgstr "如果您使用不同的编辑器，可能对 Idris 编程语言的支持较少，您至少应该始终打开一个 REPL 会话，您当前正在处理的源文件被加载到该会话中。这允许您在开发代码时引入新的元变量并检查它们的类型和上下文。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:929
#, no-wrap
msgid ""
"We again covered a lot of ground in this section. I can't stress enough that you\n"
"should get yourselves accustomed to programming with holes and let the\n"
"type checker help you figure out what to do next.\n"
msgstr "在本节中，我们再次涵盖了很多内容。我怎么强调都不过分，你应该让自己习惯于使用孔进行编程，并让类型检查器帮助你弄清楚下一步该做什么。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:932
#, no-wrap
msgid ""
"* When in need of local utility functions, consider defining them\n"
"as local definitions in a *where block*.\n"
msgstr ""
"* 当需要局部使用函数时，考虑定义它们\n"
"作为 *where 块*中的局部定义。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:934
#, no-wrap
msgid "Use *let expressions* to define and reuse local variables.\n"
msgstr "使用 *let 表达式* 来定义和重用局部变量。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:938
#, no-wrap
msgid ""
"* Function arguments can be given a name, which can serve as documentation,\n"
"can be used to pass arguments in any order, and is used to refer to\n"
"them in dependent types.\n"
msgstr ""
"* 函数参数可以命名，可以作为文档，\n"
"可用于以任意顺序传递参数，并用于引用\n"
"它们在依赖类型中。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:942
#, no-wrap
msgid ""
"* Implicit arguments are wrapped in curly braces. The compiler is\n"
"supposed to infer them from the context. If that's not possible,\n"
"they can be passed explicitly as other named arguments.\n"
msgstr "* 隐式参数用大括号括起来。编译器应该从上下文中推断出它们。如果这不可能，它们可以作为其他命名参数显式传递。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:945
#, no-wrap
msgid ""
"* Whenever possible, Idris adds implicit erased arguments for all\n"
"type parameters automatically.\n"
msgstr "* 只要有可能，Idris 都会为所有参数自动添加隐式擦除参数。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:948
#, no-wrap
msgid ""
"* Quantities allow us to track how often a function argument is\n"
"used. Quantity 0 means, the argument is erased at runtime.\n"
msgstr "* 定量允许我们跟踪函数参数的使用频率。定量 0 表示，参数在运行时被擦除。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:953
#, no-wrap
msgid ""
"* Use *holes* as placeholders for pieces of code you plan to fill\n"
"in at a later time. Use the REPL (or your editor) to inspect\n"
"the types of holes together with the names, types, and quantities of all\n"
"variables in their context.\n"
msgstr "* 使用 *孔* 作为您计划在稍后的时间填充代码片段的占位符。使用 REPL（或您的编辑器）检查孔的类型以及所有孔的名称、类型和在他们的上下文中的变量的定量。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:962
#, no-wrap
msgid ""
"In the [next chapter](Dependent.md)\n"
"we'll start using dependent types to help us write provably correct code.\n"
"Having a good understanding of how to read\n"
"Idris' type signatures will be of paramount importance there. Whenever\n"
"you feel lost, add one or more holes and inspect their context to decide what to\n"
"do next.\n"
msgstr "在 [下一章](Dependent.md) 中，我们将开始使用依赖类型来帮助我们编写可证明正确的代码。很好地理解如何阅读 Idris 的类型签名将是至关重要的。每当您感到迷茫时，添加一个或多个孔并检查其上下文以决定下一步该做什么。\n"

#. type: Title #
#: ../src/Tutorial/Functor.md:1
#, no-wrap
msgid "Functor and Friends"
msgstr "函子和它的朋友们"

#. type: Plain text
#: ../src/Tutorial/Functor.md:6
#, no-wrap
msgid ""
"Programming, like mathematics, is about abstraction. We\n"
"try to model parts of the real world, reusing recurring\n"
"patterns by abstracting over them.\n"
msgstr "编程，就像数学一样，是关于抽象的。我们尝试对现实世界的某些部分进行建模，通过对它们进行抽象来重用重复出现的模式。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:17
#, no-wrap
msgid ""
"In this chapter, we will learn about several related interfaces,\n"
"which are all about abstraction and therefore can be hard to\n"
"understand at the beginning. Especially figuring out\n"
"*why* they are useful and *when* to use them will take\n"
"time and experience. This chapter therefore comes\n"
"with tons of exercises, most of which can be solved\n"
"with only a few short lines of code. Don't skip them.\n"
"Come back to them several times until these things start\n"
"feeling natural to you. You will then realize that their\n"
"initial complexity has vanished.\n"
msgstr "在本章中，我们将学习几个相关的接口，它们都是关于抽象的，因此一开始可能很难理解。尤其是弄清楚 *为什么* 有用以及 *何时* 使用它们需要时间和经验。因此，本章包含大量练习，其中大部分练习只需几行代码即可解决。不要跳过它们。回到他们身边几次，直到这些事情开始对你来说很自然。然后你会意识到它们最初的复杂性已经消失了。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:18
#, no-wrap
msgid ""
"module Tutorial.Functor\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Functor\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Functor.md:28
#, no-wrap
msgid "Functor"
msgstr "函子"

#. type: Plain text
#: ../src/Tutorial/Functor.md:42
#, no-wrap
msgid ""
"What do type constructors like `List`, `List1`, `Maybe`, or\n"
"`IO` have in common? First, all of them are of type\n"
"`Type -> Type`. Second, they all put values of a given type\n"
"in a certain *context*. With `List`,\n"
"the *context* is *non-determinism*: We know there to\n"
"be zero or more values, but we don't know the exact number\n"
"until we start taking the list apart by pattern matching\n"
"on it. Likewise for `List1`, though we know for sure that\n"
"there is at least one value. For `Maybe`, we are still not\n"
"sure about how many values there are, but the possibilities\n"
"are much smaller: Zero or one. With `IO`, the context is a different one:\n"
"Arbitrary side effects.\n"
msgstr "`List`、`List1`、`Maybe` 或 `IO` 等类型构造函数有什么共同点？首先，它们都是类型 `Type -> Type`。其次，它们都将给定类型的值放在某个 *上下文* 中。对于 `List`，*上下文* 是 *不确定性*：我们知道有零个或多个值，但在开始之前我们不知道确切的数字通过对其进行模式匹配将列表分开。对于 `List1` 也是如此，尽管我们确定至少有一个值。对于 `Maybe`，我们仍然不确定有多少个值，但可能性要小得多：零或一。使用 `IO`，上下文是不同的：任意副作用。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:49
#, no-wrap
msgid ""
"Although the type constructors discussed above are quite\n"
"different in how they behave and when they are useful,\n"
"there are certain operations that keep coming up\n"
"when working with them. The first such operation\n"
"is *mapping a pure function over the data type, without\n"
"affecting its underlying structure*.\n"
msgstr "尽管上面讨论的类型构造函数在它们的行为方式和何时有用方面有很大不同，但在使用它们时会不断出现某些操作。第一个这样的操作是 *在数据类型上映射一个纯函数，而不影响其底层结构*。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:53
#, no-wrap
msgid ""
"For instance, given a list of numbers, we'd like to multiply\n"
"each number by two, without changing their order or removing\n"
"any values:\n"
msgstr "例如，给定一个数字列表，我们希望将每个数字乘以 2，而不更改它们的顺序或删除任何值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:54
#, no-wrap
msgid ""
"multBy2List : Num a => List a -> List a\n"
"multBy2List []        = []\n"
"multBy2List (x :: xs) = 2 * x :: multBy2List xs\n"
msgstr ""
"multBy2List : Num a => List a -> List a\n"
"multBy2List []        = []\n"
"multBy2List (x :: xs) = 2 * x :: multBy2List xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:62
#, no-wrap
msgid ""
"But we might just as well convert every string in a\n"
"list of strings to upper case characters:\n"
msgstr "但是我们也可以将字符串列表中的每个字符串都转换为大写字符：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:63
#, no-wrap
msgid ""
"toUpperList : List String -> List String\n"
"toUpperList []        = []\n"
"toUpperList (x :: xs) = toUpper x :: toUpperList xs\n"
msgstr ""
"toUpperList : List String -> List String\n"
"toUpperList []        = []\n"
"toUpperList (x :: xs) = toUpper x :: toUpperList xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:72
#, no-wrap
msgid ""
"Sometimes, the type of the stored value changes. In the\n"
"next example, we calculate the lengths of the strings stored\n"
"in a list:\n"
msgstr "有时，存储值的类型会发生变化。在下一个示例中，我们计算存储在列表中的字符串的长度：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:73
#, no-wrap
msgid ""
"toLengthList : List String -> List Nat\n"
"toLengthList []        = []\n"
"toLengthList (x :: xs) = length x :: toLengthList xs\n"
msgstr ""
"toLengthList : List String -> List Nat\n"
"toLengthList []        = []\n"
"toLengthList (x :: xs) = length x :: toLengthList xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:83
#, no-wrap
msgid ""
"I'd like you to appreciate, just how boring these functions are. They\n"
"are almost identical, with the only interesting part being\n"
"the function we apply to each element. Surely, there must be a\n"
"pattern to abstract over:\n"
msgstr "我希望你能体会到，这些功能是多么无聊。它们几乎相同，唯一有趣的部分是我们应用于每个元素的函数。当然，必须有一个抽象的模式：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:84
#, no-wrap
msgid ""
"mapList : (a -> b) -> List a -> List b\n"
"mapList f []        = []\n"
"mapList f (x :: xs) = f x :: mapList f xs\n"
msgstr ""
"mapList : (a -> b) -> List a -> List b\n"
"mapList f []        = []\n"
"mapList f (x :: xs) = f x :: mapList f xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:94
#, no-wrap
msgid ""
"This is often the first step of abstraction in functional\n"
"programming: Write a (possibly generic) higher-order function.\n"
"We can now concisely implement all examples shown above in\n"
"terms of `mapList`:\n"
msgstr "这通常是函数式编程中抽象的第一步：编写一个（可能是通用的）高阶函数。我们现在可以根据 `mapList` 简洁地实现上面显示的所有示例：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:95
#, no-wrap
msgid ""
"multBy2List' : Num a => List a -> List a\n"
"multBy2List' = mapList (2 *)\n"
"\n"
"toUpperList' : List String -> List String\n"
"toUpperList' = mapList toUpper\n"
"\n"
"toLengthList' : List String -> List Nat\n"
"toLengthList' = mapList length\n"
msgstr ""
"multBy2List' : Num a => List a -> List a\n"
"multBy2List' = mapList (2 *)\n"
"\n"
"toUpperList' : List String -> List String\n"
"toUpperList' = mapList toUpper\n"
"\n"
"toLengthList' : List String -> List Nat\n"
"toLengthList' = mapList length\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:110
#, no-wrap
msgid ""
"But surely we'd like to do the same kind of thing with\n"
"`List1` and `Maybe`! After all, they are just container\n"
"types like `List`, the only difference being some detail\n"
"about the number of values they can or can't hold:\n"
msgstr "但我们肯定想对 `List1` 和 `Maybe` 做同样的事情！毕竟，它们只是像 `List` 这样的容器类型，唯一的区别是关于它们可以或不可以保存的值的数量的一些细节：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:111
#, no-wrap
msgid ""
"mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"mapMaybe f Nothing  = Nothing\n"
"mapMaybe f (Just v) = Just (f v)\n"
msgstr ""
"mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"mapMaybe f Nothing  = Nothing\n"
"mapMaybe f (Just v) = Just (f v)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:125
#, no-wrap
msgid ""
"Even with `IO`, we'd like to be able to map pure functions\n"
"over effectful computations. The implementation is\n"
"a bit more involved, due to the nested layers of\n"
"data constructors, but if in doubt, the types will surely\n"
"guide us. Note, however, that `IO` is not publicly exported,\n"
"so its data constructor is unavailable to us. We can use\n"
"functions `toPrim` and `fromPrim`, however, for converting\n"
"`IO` from and to `PrimIO`, which we can freely dissect:\n"
msgstr "即使使用 `IO`，我们也希望能够将纯函数映射到副作用的计算上。由于数据构造函数的嵌套层，实现有点复杂，但如果有疑问，类型肯定会指导我们。但是请注意，`IO` 不是公开导出的，因此我们无法使用它的数据构造函数。我们可以使用函数 `toPrim` 和 `fromPrim`，但是，将 `IO` 与 `PrimIO` 相互转换，我们可以自由剖析：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:126
#, no-wrap
msgid ""
"mapIO : (a -> b) -> IO a -> IO b\n"
"mapIO f io = fromPrim $ mapPrimIO (toPrim io)\n"
"  where mapPrimIO : PrimIO a -> PrimIO b\n"
"        mapPrimIO prim w =\n"
"          let MkIORes va w2 = prim w\n"
"           in MkIORes (f va) w2\n"
msgstr ""
"mapIO : (a -> b) -> IO a -> IO b\n"
"mapIO f io = fromPrim $ mapPrimIO (toPrim io)\n"
"  where mapPrimIO : PrimIO a -> PrimIO b\n"
"        mapPrimIO prim w =\n"
"          let MkIORes va w2 = prim w\n"
"           in MkIORes (f va) w2\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:138
#, no-wrap
msgid ""
"From the concept of *mapping a pure function over\n"
"values in a context* follow some derived functions, which are\n"
"often useful. Here are some of them for `IO`:\n"
msgstr "从 *将纯函数映射到上下文中的值的概念* 遵循一些派生函数，这些函数通常很有用。以下是 `IO` 中的一些：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:139
#, no-wrap
msgid ""
"mapConstIO : b -> IO a -> IO b\n"
"mapConstIO = mapIO . const\n"
"\n"
"forgetIO : IO a -> IO ()\n"
"forgetIO = mapConstIO ()\n"
msgstr ""
"mapConstIO : b -> IO a -> IO b\n"
"mapConstIO = mapIO . const\n"
"\n"
"forgetIO : IO a -> IO ()\n"
"forgetIO = mapConstIO ()\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:151
#, no-wrap
msgid ""
"Of course, we'd want to implement `mapConst` and `forget` as well\n"
"for `List`, `List1`, and `Maybe` (and dozens of other type\n"
"constructors with some kind of mapping function), and they'd\n"
"all look the same and be equally boring.\n"
msgstr "当然，我们也想为 `List`、`List1` 和 `Maybe` 实现 `mapConst` 和 `forget` ]（以及其他几十个具有某种映射函数的类型构造函数），它们看起来都一样并且同样无聊。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:161
#, no-wrap
msgid ""
"When we come upon a recurring class of functions with\n"
"several useful derived functions, we should consider defining\n"
"an interface. But how should we go about this here?\n"
"When you look at the types of `mapList`, `mapMaybe`, and `mapIO`,\n"
"you'll see that it's the `List`, `List1`, and `IO` types we\n"
"need to get rid of. These are not of type `Type` but of type\n"
"`Type -> Type`. Luckily, there is nothing preventing us\n"
"from parametrizing an interface over something else than\n"
"a `Type`.\n"
msgstr "当我们遇到具有几个有用的派生函数的重复函数类时，我们应该考虑定义一个接口。但是我们应该怎么做呢？当您查看 `mapList`、`mapMaybe` 和 `mapIO` 的类型时，您会发现它是 `List`、`我们需要去掉 List1` 和 `IO` 类型。这些不是 `Type` 类型，而是 `Type -> Type` 类型。幸运的是，除了 `Type` 之外，没有什么能阻止我们对接口进行参数化。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:166
#, no-wrap
msgid ""
"The interface we are looking for is called `Functor`.\n"
"Here is its definition and an example implementation (I appended\n"
"a tick at the end of the names for them not to overlap with\n"
"the interface and functions exported by the *Prelude*):\n"
msgstr "我们要找的接口叫做`Functor`。这是它的定义和一个示例实现（我在名称末尾附加了一个引号，以免它们与 *Prelude* 导出的接口和函数重叠）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:167
#, no-wrap
msgid ""
"interface Functor' (0 f : Type -> Type) where\n"
"  map' : (a -> b) -> f a -> f b\n"
"\n"
"implementation Functor' Maybe where\n"
"  map' _ Nothing  = Nothing\n"
"  map' f (Just v) = Just $ f v\n"
msgstr ""
"interface Functor' (0 f : Type -> Type) where\n"
"  map' : (a -> b) -> f a -> f b\n"
"\n"
"implementation Functor' Maybe where\n"
"  map' _ Nothing  = Nothing\n"
"  map' f (Just v) = Just $ f v\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:179
#, no-wrap
msgid ""
"Note, that we had to give the type of parameter `f` explicitly,\n"
"and in that case it needs to be annotated with quantity zero if\n"
"you want it to be erased at runtime (which you almost always want).\n"
msgstr "请注意，我们必须明确给出参数 `f` 的类型，在这种情况下，如果您希望它在运行时被擦除（您几乎总是想要），则需要用定量零进行注释。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:186
#, no-wrap
msgid ""
"Now, reading type signatures consisting only of type parameters\n"
"like the one of `map'` can take some time to get used to, especially\n"
"when some type parameters are applied to other parameters as in\n"
"`f a`. It can be very helpful to inspect these signatures together\n"
"with all implicit arguments at the REPL (I formatted the output to\n"
"make it more readable):\n"
msgstr "现在，读取仅包含类型参数（如 `map'` 中的某个）的类型签名可能需要一些时间来适应，尤其是当某些类型参数应用于其他参数时，例如 `f a` .检查这些签名以及 REPL 中的所有隐式参数会非常有帮助（我对输出进行了格式化以使其更具可读性）：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:187
#, no-wrap
msgid ""
"Tutorial.Functor> :ti map'\n"
"Tutorial.Functor.map' :  {0 b : Type}\n"
"                      -> {0 a : Type}\n"
"                      -> {0 f : Type -> Type}\n"
"                      -> Functor' f\n"
"                      => (a -> b)\n"
"                      -> f a\n"
"                      -> f b\n"
msgstr ""
"Tutorial.Functor> :ti map'\n"
"Tutorial.Functor.map' :  {0 b : Type}\n"
"                      -> {0 a : Type}\n"
"                      -> {0 f : Type -> Type}\n"
"                      -> Functor' f\n"
"                      => (a -> b)\n"
"                      -> f a\n"
"                      -> f b\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:200
#, no-wrap
msgid ""
"It can also be helpful to replace type parameter `f` with a concrete\n"
"value of the same type:\n"
msgstr "将类型参数 `f` 替换为相同类型的具体值也很有帮助：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:201
#, no-wrap
msgid ""
"Tutorial.Functor> :t map' {f = Maybe}\n"
"map' : (?a -> ?b) -> Maybe ?a -> Maybe ?b\n"
msgstr ""
"Tutorial.Functor> :t map' {f = Maybe}\n"
"map' : (?a -> ?b) -> Maybe ?a -> Maybe ?b\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:209
#, no-wrap
msgid ""
"Remember, being able to interpret type signatures is paramount to\n"
"understanding what's going on in an Idris declaration. You *must*\n"
"practice this and make use of the tools and utilities given to you.\n"
msgstr "请记住，能够解释类型签名对于理解 Idris 声明中发生的事情至关重要。您 *必须* 练习这一点，并利用提供给您的工具和实用程序。\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:210
#, no-wrap
msgid "Derived Functions"
msgstr "派生函数"

#. type: Plain text
#: ../src/Tutorial/Functor.md:215
#, no-wrap
msgid ""
"There are several functions and operators directly derivable from interface\n"
"`Functor`. Eventually, you should know and remember all of them as\n"
"they are highly useful. Here they are together with their types:\n"
msgstr "有几个函数和运算符可以直接从接口 `Functor` 派生。最终，您应该知道并记住所有这些，因为它们非常有用。在这里，它们与它们的类型一起：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:216
#, no-wrap
msgid ""
"Tutorial.Functor> :t (<$>)\n"
"Prelude.<$> : Functor f => (a -> b) -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t (<&>)\n"
"Prelude.<&> : Functor f => f a -> (a -> b) -> f b\n"
"\n"
"Tutorial.Functor> :t ($>)\n"
"Prelude.$> : Functor f => f a -> b -> f b\n"
"\n"
"Tutorial.Functor> :t (<$)\n"
"Prelude.<$ : Functor f => b -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t ignore\n"
"Prelude.ignore : Functor f => f a -> f ()\n"
msgstr ""
"Tutorial.Functor> :t (<$>)\n"
"Prelude.<$> : Functor f => (a -> b) -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t (<&>)\n"
"Prelude.<&> : Functor f => f a -> (a -> b) -> f b\n"
"\n"
"Tutorial.Functor> :t ($>)\n"
"Prelude.$> : Functor f => f a -> b -> f b\n"
"\n"
"Tutorial.Functor> :t (<$)\n"
"Prelude.<$ : Functor f => b -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t ignore\n"
"Prelude.ignore : Functor f => f a -> f ()\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:235
#, no-wrap
msgid ""
"`(<$>)` is an operator alias for `map` and allows you to sometimes\n"
"drop some parentheses. For instance:\n"
msgstr "`(<$>)` 是 `map` 的运算符别名，有时您可以去掉一些括号。例如：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:236
#, no-wrap
msgid ""
"tailShowReversNoOp : Show a => List1 a -> List String\n"
"tailShowReversNoOp xs = map (reverse . show) (tail xs)\n"
"\n"
"tailShowReverse : Show a => List1 a -> List String\n"
"tailShowReverse xs = reverse . show <$> tail xs\n"
msgstr ""
"tailShowReversNoOp : Show a => List1 a -> List String\n"
"tailShowReversNoOp xs = map (reverse . show) (tail xs)\n"
"\n"
"tailShowReverse : Show a => List1 a -> List String\n"
"tailShowReverse xs = reverse . show <$> tail xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:249
#, no-wrap
msgid ""
"`(<&>)` is an alias for `(<$>)` with the arguments flipped.\n"
"The other three (`ignore`, `($>)`, and `(<$)`) are all used\n"
"to replace the values in a context with a constant. They are often useful\n"
"when you don't care about the values themselves but\n"
"want to keep the underlying structure.\n"
msgstr "`(<&>)` 是 `(<$>)` 参数被翻转后的别名，。其他三个（`ignore`、`($>)` 和 `(<$)`）都用于将上下文中的值替换为常量。当您不关心值本身但想要保留底层结构时，它们通常很有用。\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:250
#, no-wrap
msgid "Functors with more than one Type Parameter"
msgstr "具有多个类型参数的函子"

#. type: Plain text
#: ../src/Tutorial/Functor.md:259
#, no-wrap
msgid ""
"The type constructors we looked at so far were all\n"
"of type `Type -> Type`. However, we can also implement `Functor`\n"
"for other type constructors. The only prerequisite is that\n"
"the type parameter we'd like to change with function `map` must\n"
"be the last in the argument list. For instance, here is the\n"
"`Functor` implementation for `Either e` (note, that `Either e`\n"
"has of course type `Type -> Type` as required):\n"
msgstr "到目前为止，我们看到的类型构造函数都是 `Type -> Type`。但是，我们也可以为其他类型的构造函数实现 `Functor`。唯一的先决条件是我们想用函数 `map` 更改的类型参数必须是参数列表中的最后一个。例如，这里是 `Either e` 的 `Functor` 实现（注意， `Either e` 当然有类型 `Type -> Type` 为必要条件）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:260
#, no-wrap
msgid ""
"implementation Functor' (Either e) where\n"
"  map' _ (Left ve)  = Left ve\n"
"  map' f (Right va) = Right $ f va\n"
msgstr ""
"implementation Functor' (Either e) where\n"
"  map' _ (Left ve)  = Left ve\n"
"  map' f (Right va) = Right $ f va\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:269
#, no-wrap
msgid ""
"Here is another example, this time for a type constructor of\n"
"type `Bool -> Type -> Type` (you might remember this from\n"
"the exercises in the [last chapter](IO.md)):\n"
msgstr "这是另一个例子，这次是一个类型为 `Bool -> Type -> Type` 的类型构造函数（你可能还记得 [上一章](IO.md) 的练习中的这个）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:270
#, no-wrap
msgid ""
"data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"  Nil  : List01 False a\n"
"  (::) : a -> List01 False a -> List01 ne a\n"
"\n"
"implementation Functor (List01 ne) where\n"
"  map _ []        = []\n"
"  map f (x :: xs) = f x :: map f xs\n"
msgstr ""
"data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"  Nil  : List01 False a\n"
"  (::) : a -> List01 False a -> List01 ne a\n"
"\n"
"implementation Functor (List01 ne) where\n"
"  map _ []        = []\n"
"  map f (x :: xs) = f x :: map f xs\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:280
#, no-wrap
msgid "Functor Composition"
msgstr "函子组合"

#. type: Plain text
#: ../src/Tutorial/Functor.md:284
#, no-wrap
msgid ""
"The nice thing about functors is how they can be paired and\n"
"nested with other functors and the results are functors again:\n"
msgstr "函子的好处是它们可以如何与其他函子配对和嵌套，结果又是函子：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:285
#, no-wrap
msgid ""
"record Product (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkProduct\n"
"  fst : f a\n"
"  snd : g a\n"
"\n"
"implementation Functor f => Functor g => Functor (Product f g) where\n"
"  map f (MkProduct l r) = MkProduct (map f l) (map f r)\n"
msgstr ""
"record Product (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkProduct\n"
"  fst : f a\n"
"  snd : g a\n"
"\n"
"implementation Functor f => Functor g => Functor (Product f g) where\n"
"  map f (MkProduct l r) = MkProduct (map f l) (map f r)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:297
#, no-wrap
msgid ""
"The above allows us to conveniently map over a pair of functors. Note,\n"
"however, that Idris needs some help with inferring the types involved:\n"
msgstr "以上允许我们方便地映射一对函子。但是请注意，Idris 需要一些帮助来推断所涉及的类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:298
#, no-wrap
msgid ""
"toPair : Product f g a -> (f a, g a)\n"
"toPair (MkProduct fst snd) = (fst, snd)\n"
"\n"
"fromPair : (f a, g a) -> Product f g a\n"
"fromPair (x,y) = MkProduct x y\n"
"\n"
"productExample :  Show a\n"
"               => (Either e a, List a)\n"
"               -> (Either e String, List String)\n"
"productExample = toPair . map show . fromPair {f = Either e, g = List}\n"
msgstr ""
"toPair : Product f g a -> (f a, g a)\n"
"toPair (MkProduct fst snd) = (fst, snd)\n"
"\n"
"fromPair : (f a, g a) -> Product f g a\n"
"fromPair (x,y) = MkProduct x y\n"
"\n"
"productExample :  Show a\n"
"               => (Either e a, List a)\n"
"               -> (Either e String, List String)\n"
"productExample = toPair . map show . fromPair {f = Either e, g = List}\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:313
#, no-wrap
msgid ""
"More often, we'd like to map over several layers of nested functors\n"
"at once. Here's how to do this with an example:\n"
msgstr "更多时候，我们想一次映射多层嵌套函子。以下是如何通过示例执行此操作：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:314
#, no-wrap
msgid ""
"record Comp (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkComp\n"
"  unComp  : f (g a)\n"
"\n"
"implementation Functor f => Functor g => Functor (Comp f g) where\n"
"  map f (MkComp v) = MkComp $ map f <$> v\n"
"\n"
"compExample :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample = unComp . map show . MkComp {f = List, g = Either e}\n"
msgstr ""
"record Comp (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkComp\n"
"  unComp  : f (g a)\n"
"\n"
"implementation Functor f => Functor g => Functor (Comp f g) where\n"
"  map f (MkComp v) = MkComp $ map f <$> v\n"
"\n"
"compExample :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample = unComp . map show . MkComp {f = List, g = Either e}\n"

#. type: Title ####
#: ../src/Tutorial/Functor.md:326
#, no-wrap
msgid "Named Implementations"
msgstr "命名实现"

#. type: Plain text
#: ../src/Tutorial/Functor.md:334
#, no-wrap
msgid ""
"Sometimes, there are more ways to implement an interface for\n"
"a given type. For instance, for numeric types we can have\n"
"a `Monoid` representing addition and one representing multiplication.\n"
"Likewise, for nested functors, `map` can be interpreted as a mapping\n"
"over only the first layer of values, or a mapping over several layers\n"
"of values.\n"
msgstr "有时，有更多方法可以为给定类型实现接口。例如，对于数字类型，我们可以有一个 `Monoid` 代表加法和一个代表乘法。同样，对于嵌套函子，`map` 可以解释为仅对第一层值的映射，或对若干层值的映射。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:339
#, no-wrap
msgid ""
"One way to go about this is to define single-field wrappers as\n"
"shown with data type `Comp` above. However, Idris also allows us\n"
"to define additional interface implementations, which must then\n"
"be given a name. For instance:\n"
msgstr "解决此问题的一种方法是定义单字段包装器，如上面的数据类型 `Comp` 所示。然而，Idris 也允许我们定义额外的接口实现，然后必须给它一个名字。例如：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:340
#, no-wrap
msgid ""
"[Compose'] Functor f => Functor g => Functor (f . g) where\n"
"  map f = (map . map) f\n"
msgstr ""
"[Compose'] Functor f => Functor g => Functor (f . g) where\n"
"  map f = (map . map) f\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:350
#, no-wrap
msgid ""
"Note, that this defines a new implementation of `Functor`, which will\n"
"*not* be considered during implicit resolution in order\n"
"to avoid ambiguities. However,\n"
"it is possible to explicitly choose to use this implementation\n"
"by passing it as an explicit argument to `map`, prefixed with an `@`:\n"
msgstr "请注意，这定义了 `Functor` 的新实现，在隐式解析期间将 *不* 细化以避免歧义。但是，可以通过将其作为显式参数传递给 `map` 来显式选择使用此实现，并以 `@` 为前缀：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:351
#, no-wrap
msgid ""
"compExample2 :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample2 = map @{Compose} show\n"
msgstr ""
"compExample2 :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample2 = map @{Compose} show\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:358
#, no-wrap
msgid ""
"In the example above, we used `Compose` instead of `Compose'`, since\n"
"the former is already exported by the *Prelude*.\n"
msgstr "在上面的示例中，我们使用 `Compose` 代替 `Compose'`，因为前者已经由 *Prelude* 导出。\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:359
#, no-wrap
msgid "Functor Laws"
msgstr "函子定律"

#. type: Plain text
#: ../src/Tutorial/Functor.md:365
#, no-wrap
msgid ""
"Implementations of `Functor` are supposed to adhere to certain laws,\n"
"just like implementations of `Eq` or `Ord`. Again, these laws are\n"
"not verified by Idris, although it would be possible (and\n"
"often cumbersome) to do so.\n"
msgstr "`Functor` 的实现应该遵守某些规律，就像 `Eq` 或 `Ord` 的实现一样。同样，这些法律并未得到 Idris 的验证，尽管这样做是可能的（而且通常很麻烦）。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:370
#, no-wrap
msgid ""
"1. `map id = id`: Mapping the identity function over a functor\n"
"    must not have any visible effect such as changing a container's\n"
"    structure or affecting the side effects perfomed when\n"
"    running an `IO` action.\n"
msgstr ""
"1. `map id = id`：将恒等函数映射到函子上\n"
"    不得有任何可见的副作用，例如更改容器的\n"
"    结构或影响运行 `IO` 动作的副作用\n"
"    。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:373
#, no-wrap
msgid ""
"`map (f . g) = map f . map g`: Sequencing two mappings must be identical\n"
"to a single mapping using the composition of the two functions.\n"
msgstr "`map (f . g) = map f . map g`: "
"两个映射的顺序必须与使用两个函数组合后的单个映射相同。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:380
#, no-wrap
msgid ""
"Both of these laws request, that `map` is preserving the *structure*\n"
"of values. This is easier to understand with container types like\n"
"`List`, `Maybe`, or `Either e`, where `map` is not allowed to\n"
"add or remove any wrapped value, nor - in case of `List` -\n"
"change their order. With `IO`, this can best be described as `map`\n"
"not performing additional side effects.\n"
msgstr "这两条定律都要求 `map` 保留值的 *结构*。使用 `List`、`Maybe` 或 `Either e` 等容器类型更容易理解，其中 `map` 不允许添加或删除任何包装的值，也不 - 在 `List` 的情况下 - 更改它们的顺序。对于使用 `IO`，最好地描述为 `map` 没有执行额外的副作用。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:385
#, no-wrap
msgid ""
"Write your own implementations of `Functor'` for `Maybe`, `List`,\n"
"`List1`, `Vect n`, `Either e`, and `Pair a`.\n"
msgstr ""
"为 `Maybe`、`List`、`List1`、`Vect n`、`Either e` 和 `Pair a` 编写自己的 "
"`Functor'` 实现。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:388
#, no-wrap
msgid ""
"Write a named implementation of `Functor` for pairs of functors\n"
"(similar to the one implemented for `Product`).\n"
msgstr "为 pairs 函数编写 `Functor` 的命名实现（类似于为 `Product` 实现的实现）。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:391
#, no-wrap
msgid ""
"Implement `Functor` for data type `Identity` (which is available\n"
"from `Control.Monad.Identity` in *base*):\n"
msgstr ""
"为数据类型 `Identity` 实现 `Functor`（可从 *base* 中的 `Control.Monad."
"Identity` 获得）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:392
#, no-wrap
msgid ""
"   record Identity a where\n"
"     constructor Id\n"
"     value : a\n"
msgstr ""
"   record Identity a where\n"
"     constructor Id\n"
"     value : a\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:404
#, no-wrap
msgid ""
"Here is a curious one: Implement `Functor` for `Const e` (which is also\n"
"available from `Control.Applicative.Const` in *base*). You might be\n"
"confused about the fact that the second type parameter has absolutely\n"
"no relevance at runtime, as there is no value of that type. Such\n"
"types are sometimes called *phantom types*. They can be quite useful\n"
"for tagging values with additional typing information.\n"
msgstr ""
"这是一个奇怪的问题：为 `Const e` 实现 `Functor`（也可以从 *base* 中的 "
"`Control.Applicative.Const` 获得）。您可能会对第二个类型参数在运行时绝对没有"
"相关性这一事实感到困惑，因为没有该类型的值。这种类型有时被称为 "
"*幻像类型*。它们对于使用附加类型信息标记值非常有用。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:407
#, no-wrap
msgid ""
"   Don't let the above confuse you: There is only one possible implementation.\n"
"   As usual, use holes and let the compiler guide you if you get lost.\n"
msgstr ""
"   不要让上述内容使您感到困惑：只有一种可能的实现。\n"
"   像往常一样，使用孔，如果你迷路了，让编译器指导你。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:408
#, no-wrap
msgid ""
"   record Const (e,a : Type) where\n"
"     constructor MkConst\n"
"     value : e\n"
msgstr ""
"   record Const (e,a : Type) where\n"
"     constructor MkConst\n"
"     value : e\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:416
#, no-wrap
msgid ""
"Here is a sum type for describing CRUD operations\n"
"(Create, Read, Update, and Delete) in a data store:\n"
msgstr "这是用于描述数据存储中的 CRUD 操作（创建、读取、更新和删除）的和类型：\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:426
#, no-wrap
msgid "   Implement `Functor` for `Crud i`.\n"
msgstr "   为 `Crud i` 实现 `Functor`。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:428
#, no-wrap
msgid "Here is a sum type for describing responses from a data server:\n"
msgstr "以下是用于描述来自数据服务器的响应的和类型：\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:439
#, no-wrap
msgid "   Implement `Functor` for `Repsonse e i`.\n"
msgstr "   为 `Repsonse e i` 实现 `Functor`。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Functor.md:441
#, no-wrap
msgid "Implement `Functor` for `Validated e`:\n"
msgstr "为 `Validated e` 实现 `Functor`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:442
#, no-wrap
msgid ""
"   data Validated : (e,a : Type) -> Type where\n"
"     Invalid : (err : e) -> Validated e a\n"
"     Valid   : (val : a) -> Validated e a\n"
msgstr ""
"   data Validated : (e,a : Type) -> Type where\n"
"     Invalid : (err : e) -> Validated e a\n"
"     Valid   : (val : a) -> Validated e a\n"

#. type: Title ##
#: ../src/Tutorial/Functor.md:448
#, no-wrap
msgid "Applicative"
msgstr "应用子"

#. type: Plain text
#: ../src/Tutorial/Functor.md:453
#, no-wrap
msgid ""
"While `Functor` allows us to map a pure, unary function\n"
"over a value in a context, it doesn't allow us to combine\n"
"n such values under an n-ary function.\n"
msgstr "虽然 `Functor` 允许我们将纯的一元函数映射到上下文中的值上，但它不允许我们在 n 元函数下组合 n 个这样的值。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:455
#, no-wrap
msgid "For instance, consider the following functions:\n"
msgstr "例如，考虑以下函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:456
#, no-wrap
msgid ""
"liftMaybe2 : (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\n"
"liftMaybe2 f (Just va) (Just vb) = Just $ f va vb\n"
"liftMaybe2 _ _         _         = Nothing\n"
"\n"
"liftVect2 : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"liftVect2 _ []        []        = []\n"
"liftVect2 f (x :: xs) (y :: ys) = f x y :: liftVect2 f xs ys\n"
"\n"
"liftIO2 : (a -> b -> c) -> IO a -> IO b -> IO c\n"
"liftIO2 f ioa iob = fromPrim $ go (toPrim ioa) (toPrim iob)\n"
"  where go : PrimIO a -> PrimIO b -> PrimIO c\n"
"        go pa pb w =\n"
"          let MkIORes va w2 = pa w\n"
"              MkIORes vb w3 = pb w2\n"
"           in MkIORes (f va vb) w3\n"
msgstr ""
"liftMaybe2 : (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\n"
"liftMaybe2 f (Just va) (Just vb) = Just $ f va vb\n"
"liftMaybe2 _ _         _         = Nothing\n"
"\n"
"liftVect2 : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"liftVect2 _ []        []        = []\n"
"liftVect2 f (x :: xs) (y :: ys) = f x y :: liftVect2 f xs ys\n"
"\n"
"liftIO2 : (a -> b -> c) -> IO a -> IO b -> IO c\n"
"liftIO2 f ioa iob = fromPrim $ go (toPrim ioa) (toPrim iob)\n"
"  where go : PrimIO a -> PrimIO b -> PrimIO c\n"
"        go pa pb w =\n"
"          let MkIORes va w2 = pa w\n"
"              MkIORes vb w3 = pb w2\n"
"           in MkIORes (f va vb) w3\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:478
#, no-wrap
msgid ""
"This behavior is not covered by `Functor`, yet it is a very\n"
"common thing to do. For instance, we might want to read two numbers\n"
"from standard input (both operations might fail), calculating the\n"
"product of the two. Here's the code:\n"
msgstr "`Functor` 没有涵盖这种行为，但这是很常见的事情。例如，我们可能想从标准输入中读取两个数字（这两个操作都可能失败），计算两者的乘积。这是代码：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:479
#, no-wrap
msgid ""
"multNumbers : Num a => Neg a => IO (Maybe a)\n"
"multNumbers = do\n"
"  s1 <- getLine\n"
"  s2 <- getLine\n"
"  pure $ liftMaybe2 (*) (parseInteger s1) (parseInteger s2)\n"
msgstr ""
"multNumbers : Num a => Neg a => IO (Maybe a)\n"
"multNumbers = do\n"
"  s1 <- getLine\n"
"  s2 <- getLine\n"
"  pure $ liftMaybe2 (*) (parseInteger s1) (parseInteger s2)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:490
#, no-wrap
msgid ""
"And it won't stop here. We might just as well want to have\n"
"`liftMaybe3` for ternary functions and three `Maybe` arguments\n"
"and so on, for arbitrary numbers of arguments.\n"
msgstr "它不会止步于此。对于三元函数，我们可能还希望有 `liftMaybe3` 和三个 `Maybe` 参数等等，对于任意数量的参数。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:493
#, no-wrap
msgid ""
"But there is more: We'd also like to lift pure values into\n"
"the context in question. With this, we could do the following:\n"
msgstr "但还有更多：我们还想将纯的值提升到所讨论的上下文中。有了这个，我们可以做以下事情：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:494
#, no-wrap
msgid ""
"liftMaybe3 : (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"
"liftMaybe3 f (Just va) (Just vb) (Just vc) = Just $ f va vb vc\n"
"liftMaybe3 _ _         _         _         = Nothing\n"
"\n"
"pureMaybe : a -> Maybe a\n"
"pureMaybe = Just\n"
"\n"
"multAdd100 : Num a => Neg a => String -> String -> Maybe a\n"
"multAdd100 s t = liftMaybe3 calc (parseInteger s) (parseInteger t) (pure 100)\n"
"  where calc : a -> a -> a -> a\n"
"        calc x y z = x * y + z\n"
msgstr ""
"liftMaybe3 : (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"
"liftMaybe3 f (Just va) (Just vb) (Just vc) = Just $ f va vb vc\n"
"liftMaybe3 _ _         _         _         = Nothing\n"
"\n"
"pureMaybe : a -> Maybe a\n"
"pureMaybe = Just\n"
"\n"
"multAdd100 : Num a => Neg a => String -> String -> Maybe a\n"
"multAdd100 s t = liftMaybe3 calc (parseInteger s) (parseInteger t) (pure 100)\n"
"  where calc : a -> a -> a -> a\n"
"        calc x y z = x * y + z\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:511
#, no-wrap
msgid ""
"As you'll of course already know, I am now going to present a new\n"
"interface to encapsulate this behavior. It's called `Applicative`.\n"
"Here is its definition and an example implementation:\n"
msgstr "正如您当然已经知道的那样，我现在将提供一个新接口来封装这种行为。它被称为 `Applicative`。这是它的定义和示例实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:512
#, no-wrap
msgid ""
"interface Functor' f => Applicative' f where\n"
"  app   : f (a -> b) -> f a -> f b\n"
"  pure' : a -> f a\n"
"\n"
"implementation Applicative' Maybe where\n"
"  app (Just fun) (Just val) = Just $ fun val\n"
"  app _          _          = Nothing\n"
"\n"
"  pure' = Just\n"
msgstr ""
"interface Functor' f => Applicative' f where\n"
"  app   : f (a -> b) -> f a -> f b\n"
"  pure' : a -> f a\n"
"\n"
"implementation Applicative' Maybe where\n"
"  app (Just fun) (Just val) = Just $ fun val\n"
"  app _          _          = Nothing\n"
"\n"
"  pure' = Just\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:527
#, no-wrap
msgid ""
"Interface `Applicative` is of course already exported by the *Prelude*.\n"
"There, function `app` is an operator sometimes called *app* or *apply*:\n"
"`(<*>)`.\n"
msgstr "接口 `Applicative` 当然已经由 *Prelude* 导出。在那里，函数 `app` 是一个有时称为 *app* 或 *apply* 的运算符：`(<*>)`。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:530
#, no-wrap
msgid ""
"You may wonder, how functions like `liftMaybe2` or `liftIO3` are related\n"
"to operator *apply*. Let me demonstrate this:\n"
msgstr "您可能想知道，像 `liftMaybe2` 或 `liftIO3` 这样的函数如何与运算符 *apply* 相关联。让我演示一下：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:531
#, no-wrap
msgid ""
"liftA2 : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2 fun fa fb = pure fun <*> fa <*> fb\n"
"\n"
"liftA3 : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3 fun fa fb fc = pure fun <*> fa <*> fb <*> fc\n"
msgstr ""
"liftA2 : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2 fun fa fb = pure fun <*> fa <*> fb\n"
"\n"
"liftA3 : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3 fun fa fb fc = pure fun <*> fa <*> fb <*> fc\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:544
#, no-wrap
msgid ""
"It is really important for you to understand what's going on here, so let's\n"
"break these down. If we specialize `liftA2` to use `Maybe` for `f`,\n"
"`pure fun` is of type `Maybe (a -> b -> c)`. Likewise, `pure fun <*> fa`\n"
"is of type `Maybe (b -> c)`, as `(<*>)` will apply the value stored\n"
"in `fa` to the function stored in `pure fun` (currying!).\n"
msgstr "了解这里发生的事情对您来说非常重要，所以让我们分解这些内容。如果我们将 `liftA2` 中的 `f` 用于 `Maybe`，则 `pure fun` 的类型为 `Maybe (a -> b -> c)`。同样，`pure fun <*> fa` 是 ` 类型为 `Maybe (b -> c)`，因为 `(<*>)` 将应用存储在 `f a` 到存储在 `pure fun` 中的函数（柯里化！）。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:550
#, no-wrap
msgid ""
"You'll often see such chains of applications of *apply*, the number\n"
"of *applies* corresponding to the arity of the function we lift.\n"
"You'll sometimes also see the following, which allows us to drop\n"
"the initial call to `pure`, and use the operator version of `map`\n"
"instead:\n"
msgstr "你会经常看到 *apply* 这样的应用链，*applies* 的数量对应于我们提升的函数的数量。您有时还会看到以下内容，这使我们可以放弃对 `pure` 的初始调用，并改用 `map` 的运算符版本：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:551
#, no-wrap
msgid ""
"liftA2' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2' fun fa fb = fun <$> fa <*> fb\n"
"\n"
"liftA3' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3' fun fa fb fc = fun <$> fa <*> fb <*> fc\n"
msgstr ""
"liftA2' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2' fun fa fb = fun <$> fa <*> fb\n"
"\n"
"liftA3' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3' fun fa fb fc = fun <$> fa <*> fb <*> fc\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:564
#, no-wrap
msgid ""
"So, interface `Applicative` allows us to lift values (and functions!)\n"
"into computational contexts and apply them to values in the same\n"
"contexts. Before we will see an extended example why this is\n"
"useful, I'll quickly introduce some syntactic sugar for working\n"
"with applicative functors.\n"
msgstr "因此，接口 `Applicative` 允许我们将值（和函数！）提升到计算上下文中，并将它们应用于相同上下文中的值。在我们将看到一个扩展示例为什么这很有用之前，我将快速介绍一些用于使用应用函子的语法糖。\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:565
#, no-wrap
msgid "Idiom Brackets"
msgstr "习语括号"

#. type: Plain text
#: ../src/Tutorial/Functor.md:571
#, no-wrap
msgid ""
"The programming style used for implementing `liftA2'` and `liftA3'`\n"
"is also referred to as *applicative style* and is used a lot\n"
"in Haskell for combining several effectful computations\n"
"with a single pure function.\n"
msgstr "用于实现 `liftA2'` 和 `liftA3'` 的编程风格也称为 *应用函子风格*，在 Haskell 中被大量用于将单一的纯函数应用于几个副作用计算。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:575
#, no-wrap
msgid ""
"In Idris, there is an alternative to using such chains of\n"
"operator applications: Idiom brackets. Here's another\n"
"reimplementation of `liftA2` and `liftA3`:\n"
msgstr "在 Idris 中，有一个替代使用这种运算符应用程序链的方法：习语括号。这是 `liftA2` 和 `liftA3` 的另一个重新实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:576
#, no-wrap
msgid ""
"liftA2'' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2'' fun fa fb = [| fun fa fb |]\n"
"\n"
"liftA3'' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3'' fun fa fb fc = [| fun fa fb fc |]\n"
msgstr ""
"liftA2'' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2'' fun fa fb = [| fun fa fb |]\n"
"\n"
"liftA3'' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3'' fun fa fb fc = [| fun fa fb fc |]\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:590
#, no-wrap
msgid ""
"The above implementations will be desugared to the one given\n"
"for `liftA2` and `liftA3`, again *before disambiguating,\n"
"type checking, and filling in of implicit values*. Like with the\n"
"*bind* operator, we can therefore write custom implementations\n"
"for `pure` and `(<*>)`, and Idris will use these if it\n"
"can disambiguate between the overloaded function names.\n"
msgstr "在消除歧义、类型检查和填充隐式值 *之前*，上述实现将被简化为 `liftA2` 和 `liftA3` 给定的实现。与 *bind* 运算符一样，我们因此可以为 `pure` 和 `(<*>)` 编写自定义实现，如果 Idris 可以消除重载函数名称之间的歧义，它将使用这些名称。。\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:591
#, no-wrap
msgid "Use Case: CSV Reader"
msgstr "用例：CSV 阅读器"

#. type: Plain text
#: ../src/Tutorial/Functor.md:604
#, no-wrap
msgid ""
"In order to understand the power and versatility that comes\n"
"with applicative functors, we will look at a slightly\n"
"extended example. We are going to write some utilities\n"
"for parsing and decoding content from CSV files. These\n"
"are files where each line holds a list of values separated\n"
"by commas (or some other delimiter). Typically, they are\n"
"used to store tabular data, for instance from spread sheet\n"
"applications. What we would like to do is convert\n"
"lines in a CSV file and store the result in custom\n"
"records, where each record field corresponds to a column\n"
"in the table.\n"
msgstr "为了理解应用函子的强大功能和多功能性，我们将看一个稍微扩展的示例。我们将编写一些实用程序来解析和解码 CSV 文件中的内容。这些文件的每一行都包含一个由逗号（或其他分隔符）分隔的值列表。通常，它们用于存储表格数据，例如来自电子表格应用程序的数据。我们想要做的是转换 CSV 文件中的行并将结果存储在自定义记录中，其中每个记录字段对应于表中的一列。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:609
#, no-wrap
msgid ""
"For instance, here is a simple example\n"
"file, containing tabular user information from a web\n"
"store: First name, last name, age (optional), email address,\n"
"gender, and password.\n"
msgstr "例如，这是一个简单的示例文件，其中包含来自网络商店的表格用户信息：名字、姓氏、年龄（可选）、电子邮件地址、性别和密码。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:610
#, no-wrap
msgid ""
"Jon,Doe,42,jon@doe.ch,m,weijr332sdk\n"
"Jane,Doe,,jane@doe.ch,f,aa433sd112\n"
"Stefan,Hoeck,,nope@goaway.ch,m,password123\n"
msgstr ""
"Jon,Doe,42,jon@doe.ch,m,weijr332sdk\n"
"Jane,Doe,,jane@doe.ch,f,aa433sd112\n"
"Stefan,Hoeck,,nope@goaway.ch,m,password123\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:621
#, no-wrap
msgid ""
"And here are the Idris data types necessary to hold\n"
"this information at runtime. We use again custom\n"
"string wrappers for increased type safety and\n"
"because it will allow us to define for each data type\n"
"what we consider to be valid input:\n"
msgstr "以下是在运行时保存此信息所必需的 Idris 数据类型。我们再次使用自定义字符串包装器来提高类型安全性，因为它允许我们为每种数据类型定义我们认为是有效输入的内容：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:622
#, no-wrap
msgid ""
"data Gender = Male | Female | Other\n"
"\n"
"record Name where\n"
"  constructor MkName\n"
"  value : String\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  firstName : Name\n"
"  lastName  : Name\n"
"  age       : Maybe Nat\n"
"  email     : Email\n"
"  gender    : Gender\n"
"  password  : Password\n"
msgstr ""
"data Gender = Male | Female | Other\n"
"\n"
"record Name where\n"
"  constructor MkName\n"
"  value : String\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  firstName : Name\n"
"  lastName  : Name\n"
"  age       : Maybe Nat\n"
"  email     : Email\n"
"  gender    : Gender\n"
"  password  : Password\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:650
#, no-wrap
msgid ""
"We start by defining an interface for reading fields\n"
"in a CSV file and writing implementations for\n"
"the data types we'd like to read:\n"
msgstr "我们首先定义一个用于读取 CSV 文件中的字段的接口，并为我们想要读取的数据类型编写实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:651
#, no-wrap
msgid ""
"interface CSVField a where\n"
"  read : String -> Maybe a\n"
msgstr ""
"interface CSVField a where\n"
"  read : String -> Maybe a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:659
#, no-wrap
msgid ""
"Below are implementations for `Gender` and `Bool`. I decided\n"
"to in these cases encode each value with a single lower\n"
"case character:\n"
msgstr "下面是 `Gender` 和 `Bool` 的实现。在这些情况下，我决定使用单个小写字符对每个值进行编码：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:660
#, no-wrap
msgid ""
"CSVField Gender where\n"
"  read \"m\" = Just Male\n"
"  read \"f\" = Just Female\n"
"  read \"o\" = Just Other\n"
"  read _   = Nothing\n"
"\n"
"CSVField Bool where\n"
"  read \"t\" = Just True\n"
"  read \"f\" = Just False\n"
"  read _   = Nothing\n"
msgstr ""
"CSVField Gender where\n"
"  read \"m\" = Just Male\n"
"  read \"f\" = Just Female\n"
"  read \"o\" = Just Other\n"
"  read _   = Nothing\n"
"\n"
"CSVField Bool where\n"
"  read \"t\" = Just True\n"
"  read \"f\" = Just False\n"
"  read _   = Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:675
#, no-wrap
msgid ""
"For numeric types, we can use the parsing functions\n"
"from `Data.String`:\n"
msgstr "对于数值类型，我们可以使用 `Data.String` 中的解析函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:676
#, no-wrap
msgid ""
"CSVField Nat where\n"
"  read = parsePositive\n"
"\n"
"CSVField Integer where\n"
"  read = parseInteger\n"
"\n"
"CSVField Double where\n"
"  read = parseDouble\n"
msgstr ""
"CSVField Nat where\n"
"  read = parsePositive\n"
"\n"
"CSVField Integer where\n"
"  read = parseInteger\n"
"\n"
"CSVField Double where\n"
"  read = parseDouble\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:692
#, no-wrap
msgid ""
"For optional values, the stored type must itself\n"
"come with an instance of `CSVField`. We can then treat\n"
"the empty string `\"\"` as `Nothing`, while a non-empty\n"
"string will be passed to the encapsulated type's field reader.\n"
"(Remember that `(<$>)` is an alias for `map`.)\n"
msgstr "对于可选值，存储的类型本身必须带有 `CSVField` 的实例。然后我们可以将空字符串 `\"\"` 视为 `Nothing`，而将非空字符串传递给封装类型的字段读取器。 （记住 `(<$>)` 是 `map` 的别名。）\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:693
#, no-wrap
msgid ""
"CSVField a => CSVField (Maybe a) where\n"
"  read \"\" = Just Nothing\n"
"  read s  = Just <$> read s\n"
msgstr ""
"CSVField a => CSVField (Maybe a) where\n"
"  read \"\" = Just Nothing\n"
"  read s  = Just <$> read s\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:703
#, no-wrap
msgid ""
"Finally, for our string wrappers, we need to decide what\n"
"we consider to be valid values. For simplicity, I decided\n"
"to limit the length of allowed strings and the set of\n"
"valid characters.\n"
msgstr "最后，对于我们的字符串包装器，我们需要决定我们认为什么是有效值。为简单起见，我决定限制允许的字符串长度和有效字符集。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:704
#, no-wrap
msgid ""
"readIf : (String -> Bool) -> (String -> a) -> String -> Maybe a\n"
"readIf p mk s = if p s then Just (mk s) else Nothing\n"
"\n"
"isValidName : String -> Bool\n"
"isValidName s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isAlpha (unpack s)\n"
"\n"
"CSVField Name where\n"
"  read = readIf isValidName MkName\n"
"\n"
"isEmailChar : Char -> Bool\n"
"isEmailChar '.' = True\n"
"isEmailChar '@' = True\n"
"isEmailChar c   = isAlphaNum c\n"
"\n"
"isValidEmail : String -> Bool\n"
"isValidEmail s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isEmailChar (unpack s)\n"
"\n"
"CSVField Email where\n"
"  read = readIf isValidEmail MkEmail\n"
"\n"
"isPasswordChar : Char -> Bool\n"
"isPasswordChar ' ' = True\n"
"isPasswordChar c   = not (isControl c) && not (isSpace c)\n"
"\n"
"isValidPassword : String -> Bool\n"
"isValidPassword s =\n"
"  let len = length s\n"
"   in 8 < len && len <= 100 && all isPasswordChar (unpack s)\n"
"\n"
"CSVField Password where\n"
"  read = readIf isValidPassword MkPassword\n"
msgstr ""
"readIf : (String -> Bool) -> (String -> a) -> String -> Maybe a\n"
"readIf p mk s = if p s then Just (mk s) else Nothing\n"
"\n"
"isValidName : String -> Bool\n"
"isValidName s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isAlpha (unpack s)\n"
"\n"
"CSVField Name where\n"
"  read = readIf isValidName MkName\n"
"\n"
"isEmailChar : Char -> Bool\n"
"isEmailChar '.' = True\n"
"isEmailChar '@' = True\n"
"isEmailChar c   = isAlphaNum c\n"
"\n"
"isValidEmail : String -> Bool\n"
"isValidEmail s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isEmailChar (unpack s)\n"
"\n"
"CSVField Email where\n"
"  read = readIf isValidEmail MkEmail\n"
"\n"
"isPasswordChar : Char -> Bool\n"
"isPasswordChar ' ' = True\n"
"isPasswordChar c   = not (isControl c) && not (isSpace c)\n"
"\n"
"isValidPassword : String -> Bool\n"
"isValidPassword s =\n"
"  let len = length s\n"
"   in 8 < len && len <= 100 && all isPasswordChar (unpack s)\n"
"\n"
"CSVField Password where\n"
"  read = readIf isValidPassword MkPassword\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:745
#, no-wrap
msgid ""
"In a later chapter, we will learn about refinement types and\n"
"how to store an erased proof of validity together with\n"
"a validated value.\n"
msgstr "在后面的章节中，我们将学习细化类型以及如何将已擦除的有效性证明与验证值一起存储。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:749
#, no-wrap
msgid ""
"We can now start to decode whole lines in a CSV file.\n"
"In order to do so, we first introduce a custom error\n"
"type encapsulating how things can go wrong:\n"
msgstr "我们现在可以开始解码 CSV 文件中的整行。为了做到这一点，我们首先引入一个自定义错误类型来封装事情是如何出错的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:750
#, no-wrap
msgid ""
"data CSVError : Type where\n"
"  FieldError           : (line, column : Nat) -> (str : String) -> CSVError\n"
"  UnexpectedEndOfInput : (line, column : Nat) -> CSVError\n"
"  ExpectedEndOfInput   : (line, column : Nat) -> CSVError\n"
msgstr ""
"data CSVError : Type where\n"
"  FieldError           : (line, column : Nat) -> (str : String) -> CSVError\n"
"  UnexpectedEndOfInput : (line, column : Nat) -> CSVError\n"
"  ExpectedEndOfInput   : (line, column : Nat) -> CSVError\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:760
#, no-wrap
msgid ""
"We can now use `CSVField` to read a single field at a given\n"
"line and position in a CSV file, and return a `FieldError` in case\n"
"of a failure.\n"
msgstr "我们现在可以使用 `CSVField` 读取 CSV 文件中给定行和位置的单个字段，并在失败的情况下返回 `FieldError`。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:761
#, no-wrap
msgid ""
"readField : CSVField a => (line, column : Nat) -> String -> Either CSVError a\n"
"readField line col str =\n"
"  maybe (Left $ FieldError line col str) Right (read str)\n"
msgstr ""
"readField : CSVField a => (line, column : Nat) -> String -> Either CSVError a\n"
"readField line col str =\n"
"  maybe (Left $ FieldError line col str) Right (read str)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:772
#, no-wrap
msgid ""
"If we know in advance the number of fields we need to read,\n"
"we can try and convert a list of strings to a `Vect` of\n"
"the given length. This facilitates reading record values of\n"
"a known number of fields, as we get the correct number\n"
"of string variables when pattern matching on the vector:\n"
msgstr "如果我们事先知道需要读取的字段数量，我们可以尝试将字符串列表转换为给定长度的 `Vect`。这有助于读取已知数量字段的记录值，因为我们在向量上进行模式匹配时得到正确数量的字符串变量：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:773
#, no-wrap
msgid ""
"toVect : (n : Nat) -> (line, col : Nat) -> List a -> Either CSVError (Vect n a)\n"
"toVect 0     line _   []        = Right []\n"
"toVect 0     line col _         = Left (ExpectedEndOfInput line col)\n"
"toVect (S k) line col []        = Left (UnexpectedEndOfInput line col)\n"
"toVect (S k) line col (x :: xs) = (x ::) <$> toVect k line (S col) xs\n"
msgstr ""
"toVect : (n : Nat) -> (line, col : Nat) -> List a -> Either CSVError (Vect n a)\n"
"toVect 0     line _   []        = Right []\n"
"toVect 0     line col _         = Left (ExpectedEndOfInput line col)\n"
"toVect (S k) line col []        = Left (UnexpectedEndOfInput line col)\n"
"toVect (S k) line col (x :: xs) = (x ::) <$> toVect k line (S col) xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:783
#, no-wrap
msgid ""
"Finally, we can implement function `readUser` to try and convert\n"
"a single line in a CSV-file to a value of type `User`:\n"
msgstr "最后，我们可以实现函数 `readUser` 来尝试将 CSV 文件中的一行转换为 `User` 类型的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:784
#, no-wrap
msgid ""
"readUser' : (line : Nat) -> List String -> Either CSVError User\n"
"readUser' line ss = do\n"
"  [fn,ln,a,em,g,pw] <- toVect 6 line 0 ss\n"
"  [| MkUser (readField line 1 fn)\n"
"            (readField line 2 ln)\n"
"            (readField line 3 a)\n"
"            (readField line 4 em)\n"
"            (readField line 5 g)\n"
"            (readField line 6 pw) |]\n"
"\n"
"readUser : (line : Nat) -> String -> Either CSVError User\n"
"readUser line = readUser' line . forget . split (',' ==)\n"
msgstr ""
"readUser' : (line : Nat) -> List String -> Either CSVError User\n"
"readUser' line ss = do\n"
"  [fn,ln,a,em,g,pw] <- toVect 6 line 0 ss\n"
"  [| MkUser (readField line 1 fn)\n"
"            (readField line 2 ln)\n"
"            (readField line 3 a)\n"
"            (readField line 4 em)\n"
"            (readField line 5 g)\n"
"            (readField line 6 pw) |]\n"
"\n"
"readUser : (line : Nat) -> String -> Either CSVError User\n"
"readUser line = readUser' line . forget . split (',' ==)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:800 ../src/Tutorial/Traverse.md:122
#, no-wrap
msgid "Let's give this a go at the REPL:\n"
msgstr "让我们在 REPL 上试一试：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:801
#, no-wrap
msgid ""
"Tutorial.Functor> readUser 1 \"Joe,Foo,46,j@f.ch,m,pw1234567\"\n"
"Right (MkUser (MkName \"Joe\") (MkName \"Foo\")\n"
"  (Just 46) (MkEmail \"j@f.ch\") Male (MkPassword \"pw1234567\"))\n"
"Tutorial.Functor> readUser 7 \"Joe,Foo,46,j@f.ch,m,shortPW\"\n"
"Left (FieldError 7 6 \"shortPW\")\n"
msgstr ""
"Tutorial.Functor> readUser 1 \"Joe,Foo,46,j@f.ch,m,pw1234567\"\n"
"Right (MkUser (MkName \"Joe\") (MkName \"Foo\")\n"
"  (Just 46) (MkEmail \"j@f.ch\") Male (MkPassword \"pw1234567\"))\n"
"Tutorial.Functor> readUser 7 \"Joe,Foo,46,j@f.ch,m,shortPW\"\n"
"Left (FieldError 7 6 \"shortPW\")\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:816
#, no-wrap
msgid ""
"Note, how in the implementation of `readUser'` we used\n"
"an idiom bracket to map a function of six arguments (`MkUser`)\n"
"over six values of type `Either CSVError`. This will automatically\n"
"succeed, if and only if all of the parsings have\n"
"succeeded. It would have been notoriously cumbersome resulting\n"
"in much less readable code to implement\n"
"`readUser'` with a succession of six nested pattern matches.\n"
msgstr "请注意，在 `readUser'` 的实现中，我们如何使用习语括号将六个参数 (`MkUser`) 的函数映射到 `Either CSVError` 类型的六个值上。当且仅当所有解析都成功时，这将自动成功。众所周知，使用连续六个嵌套模式匹配来实现 `readUser'` 的代码的可读性会大大降低。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:819
#, no-wrap
msgid ""
"However, the idiom bracket above looks still quite repetitive.\n"
"Surely, we can do better?\n"
msgstr "但是，上面的习语括号看起来仍然非常重复。当然，我们可以做得更好吗？\n"

#. type: Title ####
#: ../src/Tutorial/Functor.md:820
#, no-wrap
msgid "A Case for Heterogeneous Lists"
msgstr "异构列表的案例"

#. type: Plain text
#: ../src/Tutorial/Functor.md:827
#, no-wrap
msgid ""
"It is time to learn about a family of types, which can\n"
"be used as a generic representation for record types, and\n"
"which will allow us to represent and read rows in\n"
"heterogeneous tables with a minimal amount of code: Heterogeneous\n"
"lists.\n"
msgstr "是时候学习一组类型了，它们可以用作记录类型的通用表示，并且允许我们用最少的代码表示和读取异构表中的行：异构列表。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:828
#, no-wrap
msgid ""
"namespace HList\n"
"  public export\n"
"  data HList : (ts : List Type) -> Type where\n"
"    Nil  : HList Nil\n"
"    (::) : (v : t) -> (vs : HList ts) -> HList (t :: ts)\n"
msgstr ""
"namespace HList\n"
"  public export\n"
"  data HList : (ts : List Type) -> Type where\n"
"    Nil  : HList Nil\n"
"    (::) : (v : t) -> (vs : HList ts) -> HList (t :: ts)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:841
#, no-wrap
msgid ""
"A heterogeneous list is a list type indexed over a *list of types*.\n"
"This allows us to at each position store a value of the\n"
"type at the same position in the list index. For instance,\n"
"here is a variant, which stores three values of types\n"
"`Bool`, `Nat`, and `Maybe String` (in that order):\n"
msgstr "异构列表是在 *类型列表* 上索引的列表类型。这允许我们在每个位置将类型的值存储在列表索引中的相同位置。例如，这里有一个变体，它存储了 `Bool`、`Nat` 和 `Maybe String` 类型的三个值（按此顺序）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:842
#, no-wrap
msgid ""
"hlist1 : HList [Bool, Nat, Maybe String]\n"
"hlist1 = [True, 12, Nothing]\n"
msgstr ""
"hlist1 : HList [Bool, Nat, Maybe String]\n"
"hlist1 = [True, 12, Nothing]\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:854
#, no-wrap
msgid ""
"You could argue that heterogeneous lists are just tuples\n"
"storing values of the given types. That's right, of course,\n"
"however, as you'll learn the hard way in the exercises,\n"
"we can use the list index to perform compile-time computations\n"
"on `HList`, for instance when concatenating two such lists\n"
"to keep track of the types stored in the result at the\n"
"same time.\n"
msgstr "您可能会争辩说，异构列表只是存储给定类型值的元组。没错，当然，但是，因为您将在练习中学习困难的方法，我们可以使用列表索引对 `HList` 执行编译时计算，例如连接两个这样的列表以保持同时跟踪结果中存储的类型。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:859
#, no-wrap
msgid ""
"But first, we'll make use of `HList` as a means to\n"
"concisely parse CSV-lines. In order to do that, we\n"
"need to introduce a new interface for types corresponding\n"
"to whole lines in a CSV-file:\n"
msgstr "但首先，我们将使用 `HList` 作为简洁解析 CSV 行的方法。为此，我们需要为对应于 CSV 文件中整行的类型引入一个新接口：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:860
#, no-wrap
msgid ""
"interface CSVLine a where\n"
"  decodeAt : (line, col : Nat) -> List String -> Either CSVError a\n"
msgstr ""
"interface CSVLine a where\n"
"  decodeAt : (line, col : Nat) -> List String -> Either CSVError a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:871
#, no-wrap
msgid ""
"We'll now write two implementations of `CSVLine` for `HList`:\n"
"One for the `Nil` case, which will succeed if and only if\n"
"the current list of strings is empty. The other for the *cons*\n"
"case, which will try and read a single field from the head\n"
"of the list and the remainder from its tail. We use\n"
"again an idiom bracket to concatenate the results:\n"
msgstr "现在，我们将为 `HList` 编写 `CSVLine` 的两个实现：一个针对 `Nil` 的情况，当且仅当当前字符串列表为空时才会成功.另一个用于 *cons* 的情况，它将尝试从列表的头部读取单个字段，并从其尾部读取剩余部分。我们再次使用惯用括号来连接结果：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:872
#, no-wrap
msgid ""
"CSVLine (HList []) where\n"
"  decodeAt _ _ [] = Right Nil\n"
"  decodeAt l c _  = Left (ExpectedEndOfInput l c)\n"
"\n"
"CSVField t => CSVLine (HList ts) => CSVLine (HList (t :: ts)) where\n"
"  decodeAt l c []        = Left (UnexpectedEndOfInput l c)\n"
"  decodeAt l c (s :: ss) = [| readField l c s :: decodeAt l (S c) ss |]\n"
msgstr ""
"CSVLine (HList []) where\n"
"  decodeAt _ _ [] = Right Nil\n"
"  decodeAt l c _  = Left (ExpectedEndOfInput l c)\n"
"\n"
"CSVField t => CSVLine (HList ts) => CSVLine (HList (t :: ts)) where\n"
"  decodeAt l c []        = Left (UnexpectedEndOfInput l c)\n"
"  decodeAt l c (s :: ss) = [| readField l c s :: decodeAt l (S c) ss |]\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:887
#, no-wrap
msgid ""
"And that's it! All we need to add is two utility function\n"
"for decoding whole lines before they have been split into\n"
"tokens, one of which is specialized to `HList` and takes an\n"
"erased list of types as argument to make it more convenient to\n"
"use at the REPL:\n"
msgstr "就是这样！我们需要添加的是两个实用函数，用于在将整行拆分为标记之前对其进行解码，其中一个专用于 `HList` 并将已擦除的类型列表作为参数，以使其更方便使用在 REPL：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:888
#, no-wrap
msgid ""
"decode : CSVLine a => (line : Nat) -> String -> Either CSVError a\n"
"decode line = decodeAt line 1 . forget . split (',' ==)\n"
"\n"
"hdecode :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => (line : Nat)\n"
"        -> String\n"
"        -> Either CSVError (HList ts)\n"
"hdecode _ = decode\n"
msgstr ""
"decode : CSVLine a => (line : Nat) -> String -> Either CSVError a\n"
"decode line = decodeAt line 1 . forget . split (',' ==)\n"
"\n"
"hdecode :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => (line : Nat)\n"
"        -> String\n"
"        -> Either CSVError (HList ts)\n"
"hdecode _ = decode\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:902
#, no-wrap
msgid ""
"It's time to reap the fruits of our labour and give this a go at\n"
"the REPL:\n"
msgstr "是时候收获我们的劳动成果并在 REPL 上试一试了：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:903
#, no-wrap
msgid ""
"Tutorial.Functor> hdecode [Bool,Nat,Double] 1 \"f,100,12.123\"\n"
"Right [False, 100, 12.123]\n"
"Tutorial.Functor> hdecode [Name,Name,Gender] 3 \"Idris,,f\"\n"
"Left (FieldError 3 2 \"\")\n"
msgstr ""
"Tutorial.Functor> hdecode [Bool,Nat,Double] 1 \"f,100,12.123\"\n"
"Right [False, 100, 12.123]\n"
"Tutorial.Functor> hdecode [Name,Name,Gender] 3 \"Idris,,f\"\n"
"Left (FieldError 3 2 \"\")\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:910
#, no-wrap
msgid "Applicative Laws"
msgstr "应用函子法律"

#. type: Plain text
#: ../src/Tutorial/Functor.md:914
#, no-wrap
msgid ""
"Again, `Applicative` implementations must follow certain\n"
"laws. Here they are:\n"
msgstr "同样，`Applicative` 的实现必须遵循一定的规律。他们来了：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:917
#, no-wrap
msgid ""
"`pure id <*> fa = fa`: Lifting and applying the identity\n"
"function has no visible effect.\n"
msgstr "`pure id <*> fa = fa`：提升和应用恒等函数没有可见作用。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:922
#, no-wrap
msgid ""
"`[| f . g |] <*> v = f <*> (g <*> v)`:\n"
"I must not matter, whether we compose our functions\n"
"first and then apply them, or whether we apply\n"
"our functions first and then compose them.\n"
msgstr ""
"`[| f . g |] <*> v = f <*> (g <*> "
"v)`：不管是先组合函数然后应用它们，还是先应用函数然后组合它们，结果应该相同。"
"\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:925
#, no-wrap
msgid ""
"  The above might be hard to understand, so here\n"
"  they are again with explicit types and implementations:\n"
msgstr ""
"  上面的可能很难理解，所以这里\n"
"  它们再次具有显式类型和实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:926
#, no-wrap
msgid ""
"  compL : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compL f g v = [| f . g |] <*> v\n"
"\n"
"  compR : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compR f g v = f <*> (g <*> v)\n"
msgstr ""
"  compL : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compL f g v = [| f . g |] <*> v\n"
"\n"
"  compR : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compR f g v = f <*> (g <*> v)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:936
#, no-wrap
msgid ""
"  The second applicative law states, that the two implementations\n"
"  `compL` and `compR` should behave identically.\n"
msgstr ""
"  第二个应用函子法律规定，这两个实施\n"
"  `compL` 和 `compR` 的行为应该相同。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:939
#, no-wrap
msgid ""
"`pure f <*> pure x = pure (f x)`. This is also called the\n"
"*homomorphism* law. It should be pretty self-explaining.\n"
msgstr "`pure f <*> pure x = pure (f x)`。这也称为 *同态* 定律。这应该是不言自明的。"
"\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:942
#, no-wrap
msgid ""
"`f <*> pure v = pure ($ v) <*> f`. This is called the law\n"
"of *interchange*.\n"
msgstr "`f <*> pure v = pure ($ v) <*> f`。这称为*交换*律。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:944
#, no-wrap
msgid "  This should again be explained with a concrete example:\n"
msgstr "  这应该再次用一个具体的例子来解释：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:945
#, no-wrap
msgid ""
"  interL : Maybe (a -> b) -> a -> Maybe b\n"
"  interL f v = f <*> pure v\n"
"\n"
"  interR : Maybe (a -> b) -> a -> Maybe b\n"
"  interR f v = pure ($ v) <*> f\n"
msgstr ""
"  interL : Maybe (a -> b) -> a -> Maybe b\n"
"  interL f v = f <*> pure v\n"
"\n"
"  interR : Maybe (a -> b) -> a -> Maybe b\n"
"  interR f v = pure ($ v) <*> f\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:957
#, no-wrap
msgid ""
"  Note, that `($ v)` has type `(a -> b) -> b`, so this\n"
"  is a function type being applied to `f`, which has\n"
"  a function of type `a -> b` wrapped in a `Maybe`\n"
"  context.\n"
msgstr ""
"  注意，`($ v)` 的类型是 `(a -> b) -> b`，所以这个\n"
"  是应用于 `f` 的函数类型，它有一个\n"
"  `a -> b` 类型的函数，被包裹在 `Maybe` 上下文中。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:961
#, no-wrap
msgid ""
"  The law of interchange states that it must not matter\n"
"  whether we apply a pure value from the left or\n"
"  right of the *apply* operator.\n"
msgstr "  交换律指出， 我们是从左边应用一个纯值还是 *apply* 运算符的右侧。它必须无关紧要\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:965
#, no-wrap
msgid "Implement `Applicative'` for `Either e` and `Identity`.\n"
msgstr "为 `Either e` 和 `Identity` 实现 `Applicative'`。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:970
#, no-wrap
msgid ""
"Implement `Applicative'` for `Vect n`. Note: In order to\n"
"implement `pure`, the length must be known at runtime.\n"
"This can be done by passing it as an unerased implicit\n"
"to the interface implementation:\n"
msgstr ""
"为 `Vect n` 实现 `Applicative'`。注意：为了实现 `pure`，必须在运行时知道长度"
"。这可以通过将其作为未擦除的隐式传递给接口实现来完成：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:971
#, no-wrap
msgid "   implementation {n : _} -> Applicative' (Vect n) where\n"
msgstr "   implementation {n : _} -> Applicative' (Vect n) where\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:977
#, no-wrap
msgid ""
"Implement `Applicative'` for `Pair e`, with `e` having\n"
"a `Monoid` constraint.\n"
msgstr "为 `Pair e` 实现 `Applicative'`，其中 `e` 具有 `Monoid` 约束。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:980
#, no-wrap
msgid ""
"Implement `Applicative` for `Const e`, with `e` having\n"
"a `Monoid` constraint.\n"
msgstr "为 `Const e` 实现 `Applicative`，其中 `e` 具有 `Monoid` 约束。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:985
#, no-wrap
msgid ""
"Implement `Applicative` for `Validated e`, with `e` having\n"
"a `Semigroup` constraint. This will allow us to use `(<+>)`\n"
"to accumulate errors in case of two `Invalid` values in\n"
"the implementation of *apply*.\n"
msgstr ""
"为 `Validated e` 实现 `Applicative`，其中 `e` 具有 `Semigroup` 约束。"
"这将允许我们在 *apply* 的实现中使用 `(<+>)` 来累积两个 `Invalid` 值的错误。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:990
#, no-wrap
msgid ""
"Add an additional data constructor of\n"
"type `CSVError -> CSVError -> CSVError`\n"
"to `CSVError` and use this to implement `Semigroup` for\n"
"`CSVError`.\n"
msgstr ""
"添加一个 `CSVError -> CSVError -> CSVError` 到 `CSVError` "
"类型的附加数据构造函数，并使用它为 `CSVError` 实现 `Semigroup`。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Functor.md:994
#, no-wrap
msgid ""
"Refactor our CSV-parsers and all related functions so that\n"
"they return `Validated` instead of `Either`. This will only\n"
"work, if you solved exercise 6.\n"
msgstr ""
"重构我们的 CSV 解析器和所有相关函数，使它们返回 `Validated` 而不是 `Either`。"
"这只有在你解决了练习 6 的情况下才有效。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1000
#, no-wrap
msgid ""
"   Two things to note: You will have to adjust very little of\n"
"   the existing code, as we can still use applicative syntax\n"
"   with `Validated`. Also, with this change, we enhanced our CSV-parsers\n"
"   with the ability of error accumulation. Here are some examples\n"
"   from a REPL session:\n"
msgstr ""
"   需要注意的两件事：您将不得不调整很少的\n"
"   现有代码，因为我们仍然可以通过使用 `Validated`使用应用语法\n"
"   。此外，通过此更改，我们增强了 CSV 解析器\n"
"   具有累积误差的能力。这里有些来自 REPL 会话的例子：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1001
#, no-wrap
msgid ""
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"t,12,f\"\n"
"   Valid [True, 12, Female]\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,f\"\n"
"   Invalid (App (FieldError 1 1 \"o\") (FieldError 1 2 \"-12\"))\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,foo\"\n"
"   Invalid (App (FieldError 1 1 \"o\")\n"
"     (App (FieldError 1 2 \"-12\") (FieldError 1 3 \"foo\")))\n"
msgstr ""
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"t,12,f\"\n"
"   Valid [True, 12, Female]\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,f\"\n"
"   Invalid (App (FieldError 1 1 \"o\") (FieldError 1 2 \"-12\"))\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,foo\"\n"
"   Invalid (App (FieldError 1 1 \"o\")\n"
"     (App (FieldError 1 2 \"-12\") (FieldError 1 3 \"foo\")))\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1015
#, no-wrap
msgid ""
"   Behold the power of applicative functors and heterogeneous lists: With\n"
"   only a few lines of code we wrote a pure, type-safe, and total\n"
"   parser with error accumulation for lines in CSV-files, which is\n"
"   very convenient to use at the same time!\n"
msgstr ""
"   看看应用函子和异构列表的力量：\n"
"   仅仅几行代码，我们就编写了一个纯粹的、类型安全的、完全的\n"
"   对 CSV 文件中的行进行错误累积的解析器，同时使用非常方便！\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Functor.md:1018
#, no-wrap
msgid ""
"Since we introduced heterogeneous lists in this chapter, it\n"
"would be a pity not to experiment with them a little.\n"
msgstr "由于我们在本章中介绍了异构列表，很遗憾没有对它们进行一些实验。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1027
#, no-wrap
msgid ""
"   This exercise is meant to sharpen your skills in type wizardry.\n"
"   It therefore comes with very few hints. Try to decide yourself\n"
"   what behavior you'd expect from a given function, how to express\n"
"   this in the types, and how to implement it afterwards.\n"
"   If your types are correct and precise enough, the implementations\n"
"   will almost come for free. Don't give up too early if you get stuck.\n"
"   Only if you truly run out of ideas should you have a glance\n"
"   at the solutions (and then, only at the types at first!)\n"
msgstr ""
"   这个练习旨在提高你的类型技巧的技能。\n"
"   因此，它带有很少的提示。您期望从给定函数中获得什么行为试着自己做决定\n"
"   ，这在类型中如何表达，以及之后如何实现它。\n"
"   如果您的类型足够正确和精确，那么实现\n"
"   几乎是轻而易举的。如果遇到困难，不要过早放弃。\n"
"   只有当你真的没有想法时，你才应该瞥一眼\n"
"   在解决方案上（然后，首先只在类型上！）\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/Functor.md:1029
#, no-wrap
msgid "Implement `head` for `HList`.\n"
msgstr "为 `HList` 实现 `head`。\n"

#. type: Bullet: '   2. '
#: ../src/Tutorial/Functor.md:1031
#, no-wrap
msgid "Implement `tail` for `HList`.\n"
msgstr "为 `HList` 实现 `tail`。\n"

#. type: Bullet: '   3. '
#: ../src/Tutorial/Functor.md:1033
#, no-wrap
msgid "Implement `(++)` for `HList`.\n"
msgstr "为 `HList` 实现 `(++)`。\n"

#. type: Bullet: '   4. '
#: ../src/Tutorial/Functor.md:1037
#, no-wrap
msgid ""
"Implement `index` for `HList`. This might be harder than the other three.\n"
"Go back and look how we implemented `indexList` in an\n"
"[earlier exercise](Dependent.md) and start from there.\n"
msgstr ""
"为 `HList` 实现 `index`。这可能比其他三个更难。回过头来看看我们如何在 "
"[前面的练习](Dependent.md) 中实现 `indexList` 并从那里开始。\n"

#. type: Bullet: '   5. '
#: ../src/Tutorial/Functor.md:1043
#, no-wrap
msgid ""
"Package *contrib*, which is part of the Idris project, provides\n"
"`Data.HVect.HVect`, a data type for heterogeneous vectors. The only difference\n"
"to our own `HList` is, that `HVect` is indexed over a vector of\n"
"types instead of a list of types. This makes it easier to express certain\n"
"operations at the type level.\n"
msgstr ""
"*contrib* 包是 Idris 项目的一部分，它提供了 `Data.HVect."
"HVect`，一种异构向量的数据类型。与我们自己的 `HList` 的唯一区别是，`HVect` 是"
"通过类型向量而不是类型列表来索引的。这使得在类型级别表达某些操作变得更容易。"
"\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1046
#, no-wrap
msgid ""
"      Write your own implementation of `HVect` together with functions\n"
"      `head`, `tail`, `(++)`, and `index`.\n"
msgstr ""
"      编写您自己的 `HVect` 实现以及函数\n"
"      `head`、`tail`、`(++)` 和 `index`。\n"

#. type: Bullet: '   6. '
#: ../src/Tutorial/Functor.md:1050
#, no-wrap
msgid ""
"For a real challenge, try implementing a function for\n"
"transposing a `Vect m (HVect ts)`. You'll first have to\n"
"be creative about how to even express this in the types.\n"
msgstr "对于真正的挑战，尝试实现一个函数来转置 `Vect m (HVect "
"ts)`。您首先必须对如何在类型中表达这一点有创意。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1057
#, no-wrap
msgid ""
"      Note: In order to implement this, you'll need to pattern match\n"
"      on an erased argument in at least one case to help Idris with\n"
"      type inference. Pattern matching on erased arguments is forbidden\n"
"      (they are erased after all, so we can't inspect them at runtime),\n"
"      *unless* the structure of the value being matched on can be derived\n"
"      from another, un-erased argument.\n"
msgstr ""
"      注意：为了实现这一点，您需要在至少一个案例中的一个被抹去的参数上进行模式匹配，以帮助 Idris 进行类型推断。禁止对已擦除参数进行模式匹配\n"
"      （它们毕竟被删除了，所以我们不能在运行时检查它们），\n"
"      *除非* 可以通过另一个未被抹去的参数推导出被匹配的值的结构。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1061
#, no-wrap
msgid ""
"      Also, don't worry if you get stuck on this one. It took me several\n"
"      tries to figure it out. But I enjoyed the experience, so I just *had*\n"
"      to include it here. :-)\n"
msgstr "      另外，如果您卡在这个上，请不要担心。我花了好几次才试图把他弄清楚。但是我很享受这种体验，所以我 *必须* 把它包括在这里。 :-)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1065
#, no-wrap
msgid ""
"      Note, however, that such a function might be useful when working with\n"
"      CSV-files, as it allows us to convert a table represented as\n"
"      rows (a vector of tuples) to one represented as columns (a tuple of vectors).\n"
msgstr "      但是请注意，当使用 CSV 文件时这样的函数会很有用，因为它允许我们将表示为行（元组向量）的表转换到表示为列（向量元组）的表。\n"

#. type: Bullet: '9. '
#: ../src/Tutorial/Functor.md:1069
#, no-wrap
msgid ""
"Show, that the composition of two applicative functors is\n"
"again an applicative functor by implementing `Applicative`\n"
"for `Comp f g`.\n"
msgstr "通过为 `Comp f g` 实现 `Applicative` "
"来证明两个应用函子的组合再次是一个应用函子。\n"

#. type: Bullet: '10. '
#: ../src/Tutorial/Functor.md:1073
#, no-wrap
msgid ""
"Show, that the product of two applicative functors is\n"
"again an applicative functor by implementing `Applicative`\n"
"for `Prod f g`.\n"
msgstr "通过为 `Prod f g` 实现 `Applicative` "
"证明两个应用函子的乘积再次是一个应用函子。\n"

#. type: Title ##
#: ../src/Tutorial/Functor.md:1074
#, no-wrap
msgid "Monad"
msgstr "单子"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1081
#, no-wrap
msgid ""
"Finally, `Monad`. A lot of ink has been spilled about this one.\n"
"However, after what we already saw in the [chapter about `IO`](IO.md),\n"
"there is not much left to discuss here. `Monad` extends\n"
"`Applicative` and adds two new related functions: The *bind*\n"
"operator (`(>>=)`) and function `join`. Here is its definition:\n"
msgstr "最后，`Monad`。关于这一点已经泼了很多墨水。然而，在我们已经在 [关于 `IO`](IO.md) 的章节中看到之后，这里就没有太多要讨论的内容了。`Monad` 扩展了 `Applicative` 并添加了两个新的相关函数：*bind* 运算符 (`(>>=)`) 和函数 `join `。这是它的定义：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1082
#, no-wrap
msgid ""
"interface Applicative' m => Monad' m where\n"
"  bind  : m a -> (a -> m b) -> m b\n"
"  join' : m (m a) -> m a\n"
msgstr ""
"interface Applicative' m => Monad' m where\n"
"  bind  : m a -> (a -> m b) -> m b\n"
"  join' : m (m a) -> m a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1091
#, no-wrap
msgid ""
"Implementers of `Monad` are free to choose to either implement\n"
"`(>>=)` or `join` or both. You will show in an exercise, how\n"
"`join` can be implemented in terms of *bind* and vice versa.\n"
msgstr "`Monad` 的实现者可以自由选择实现 `(>>=)` 或 `join` 或两者。您将在练习中展示如何根据 *bind* 来实现 `join`，反之亦然。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1099
#, no-wrap
msgid ""
"The big difference between `Monad` and `Applicative` is, that the\n"
"former allows a computation to depend on the result of an\n"
"earlier computation. For instance, we could decide based on\n"
"a string read from standard input whether to delete a file\n"
"or play a song. The result of the first `IO` action\n"
"(reading some user input) will affect, which `IO` action to run next.\n"
"This is not possible with the *apply* operator:\n"
msgstr "`Monad` 和 `Applicative` 之间的最大区别在于，前者允许计算依赖于早期计算的结果。例如，我们可以根据从标准输入中读取的字符串来决定是删除文件还是播放歌曲。第一个 `IO` 动作（读取一些用户输入）的结果将影响下一个要运行的 `IO` 动作。这对于 *apply* 运算符是不可能的：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1100
#, no-wrap
msgid "(<*>) : IO (a -> b) -> IO a -> IO b\n"
msgstr "(<*>) : IO (a -> b) -> IO a -> IO b\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1115
#, no-wrap
msgid ""
"The two `IO` actions have already been decided on when they\n"
"are being passed as arguments to `(<*>)`. The result of the first\n"
"cannot - in the general case - affect which computation to\n"
"run in the second. (Actually, with `IO` this would theoretically be\n"
"possible via side effects: The first action could write some\n"
"command to a file or overwrite some mutable state, and the\n"
"second action could read from that file or state, thus\n"
"deciding on the next thing to do. But this is a speciality\n"
"of `IO`, not of applicative functors in general. If the functor in\n"
"question was `Maybe`, `List`, or `Vector`, no such thing\n"
"would be possible.)\n"
msgstr "两个 `IO` 动作在作为参数传递给 `(<*>)` 时已经确定。在一般情况下，第一个结果不能影响在第二个中运行哪个计算。 （实际上，使用 `IO` 理论上可以通过副作用实现：第一个操作可以将某些命令写入文件或覆盖某些可变状态，而第二个操作可以从该文件或状态读取，从而决定接下来要做的事情。但这是 `IO` 的特长，而不是一般的应用函子。如果有问题的函子是 `Maybe`，`List`，或 `Vector`，这是不可能的。）\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1121
#, no-wrap
msgid ""
"Let's demonstrate the difference with an example. Assume\n"
"we'd like to enhance our CSV-reader with the ability to\n"
"decode a line of tokens to a sum type. For instance,\n"
"we'd like to decode CRUD requests from the lines of a\n"
"CSV-file:\n"
msgstr "让我们用一个例子来演示一下区别。假设我们想增强我们的 CSV 阅读器，使其能够将一行标记解码为和型。例如，我们想从 CSV 文件的行中解码 CRUD 请求：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1122
#, no-wrap
msgid ""
"data Crud : (i : Type) -> (a : Type) -> Type where\n"
"  Create : (value : a) -> Crud i a\n"
"  Update : (id : i) -> (value : a) -> Crud i a\n"
"  Read   : (id : i) -> Crud i a\n"
"  Delete : (id : i) -> Crud i a\n"
msgstr ""
"data Crud : (i : Type) -> (a : Type) -> Type where\n"
"  Create : (value : a) -> Crud i a\n"
"  Update : (id : i) -> (value : a) -> Crud i a\n"
"  Read   : (id : i) -> Crud i a\n"
"  Delete : (id : i) -> Crud i a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1134
#, no-wrap
msgid ""
"We need a way to on each line decide, which data constructor\n"
"to choose for our decoding. One way to do this is to\n"
"put the name of the data constructor (or some other\n"
"tag of identification) in the first column of the CSV-file:\n"
msgstr "我们需要一种方法来在每一行上决定为我们的解码选择哪个数据构造函数。一种方法是将数据构造函数的名称（或其他标识标签）放在 CSV 文件的第一列中：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1135
#, no-wrap
msgid ""
"hlift : (a -> b) -> HList [a] -> b\n"
"hlift f [x] = f x\n"
"\n"
"hlift2 : (a -> b -> c) -> HList [a,b] -> c\n"
"hlift2 f [x,y] = f x y\n"
"\n"
"decodeCRUD :  CSVField i\n"
"           => CSVField a\n"
"           => (line : Nat)\n"
"           -> (s    : String)\n"
"           -> Either CSVError (Crud i a)\n"
"decodeCRUD l s =\n"
"  let h ::: t = split (',' ==) s\n"
"   in do\n"
"     MkName n <- readField l 1 h\n"
"     case n of\n"
"       \"Create\" => hlift  Create  <$> decodeAt l 2 t\n"
"       \"Update\" => hlift2 Update  <$> decodeAt l 2 t\n"
"       \"Read\"   => hlift  Read    <$> decodeAt l 2 t\n"
"       \"Delete\" => hlift  Delete  <$> decodeAt l 2 t\n"
"       _        => Left (FieldError l 1 n)\n"
msgstr ""
"hlift : (a -> b) -> HList [a] -> b\n"
"hlift f [x] = f x\n"
"\n"
"hlift2 : (a -> b -> c) -> HList [a,b] -> c\n"
"hlift2 f [x,y] = f x y\n"
"\n"
"decodeCRUD :  CSVField i\n"
"           => CSVField a\n"
"           => (line : Nat)\n"
"           -> (s    : String)\n"
"           -> Either CSVError (Crud i a)\n"
"decodeCRUD l s =\n"
"  let h ::: t = split (',' ==) s\n"
"   in do\n"
"     MkName n <- readField l 1 h\n"
"     case n of\n"
"       \"Create\" => hlift  Create  <$> decodeAt l 2 t\n"
"       \"Update\" => hlift2 Update  <$> decodeAt l 2 t\n"
"       \"Read\"   => hlift  Read    <$> decodeAt l 2 t\n"
"       \"Delete\" => hlift  Delete  <$> decodeAt l 2 t\n"
"       _        => Left (FieldError l 1 n)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1164
#, no-wrap
msgid ""
"I added two utility function for helping with type inference\n"
"and to get slightly nicer syntax. The important thing to note\n"
"is, how we pattern match on the result of the first\n"
"parsing function to decide on the data constructor\n"
"and thus the next parsing function to use.\n"
msgstr "我添加了两个实用函数来帮助进行类型推断并获得更好的语法。需要注意的重要一点是，我们如何对第一个解析函数的结果进行模式匹配，以决定数据构造函数，从而决定下一个要使用的解析函数。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1166
#, no-wrap
msgid "Here's how this works at the REPL:\n"
msgstr "在 REPL 中看一下工作原理：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1167
#, no-wrap
msgid ""
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Create,jon@doe.ch\"\n"
"Right (Create (MkEmail \"jon@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Update,12,jane@doe.ch\"\n"
"Right (Update 12 (MkEmail \"jane@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Delete,jon@doe.ch\"\n"
"Left (FieldError 1 2 \"jon@doe.ch\")\n"
msgstr ""
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Create,jon@doe.ch\"\n"
"Right (Create (MkEmail \"jon@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Update,12,jane@doe.ch\"\n"
"Right (Update 12 (MkEmail \"jane@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Delete,jon@doe.ch\"\n"
"Left (FieldError 1 2 \"jon@doe.ch\")\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1184
#, no-wrap
msgid ""
"To conclude, `Monad`, unlike `Applicative`, allows us to\n"
"chain computations sequentially, where intermediary\n"
"results can affect the behavior of later computations.\n"
"So, if you have n unrelated effectful computations and want\n"
"to combine them under a pure, n-ary function, `Applicative`\n"
"will be sufficient. If, however, you want to decide\n"
"based on the result of an effectful computation what\n"
"computation to run next, you need a `Monad`.\n"
msgstr "总而言之，`Monad` 与 `Applicative` 不同，它允许我们按顺序链接计算，其中中间结果会影响后续计算的行为。因此，如果您有 n 个不相关的有效计算并希望将它们组合在一个纯 n 元函数下，`Applicative` 就足够了。但是，如果您想根据有效计算的结果来决定接下来要运行什么计算，则需要 `Monad`。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1190
#, no-wrap
msgid ""
"Note, however, that `Monad` has one important drawback\n"
"compared to `Applicative`: In general, monads don't compose.\n"
"For instance, there is no `Monad` instance for `Either e . IO`.\n"
"We will later learn about monad transformers, which can\n"
"be composed with other monads.\n"
msgstr "但是请注意，与 `Applicative` 相比，`Monad` 有一个重要的缺点：通常，monad 不能组合。例如， `Either e . IO` 没有 `Monad` 实例。稍后我们将了解可以与其他 monad 组合的 monad 转换器。\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:1191
#, no-wrap
msgid "Monad Laws"
msgstr "单子定律"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1194
#, no-wrap
msgid "Without further ado, here are the laws for `Monad`:\n"
msgstr "事不宜迟，以下是 `Monad` 的定律：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1198
#, no-wrap
msgid ""
"`ma >>= pure = ma` and `pure v >>= f = f v`.\n"
"These are monad's identity laws. Here they are as\n"
"concrete examples:\n"
msgstr "`ma >>= pure = ma` 和 `pure v >>= f = f v`。这些是 monad "
"的恒等律。下面是具体的例子：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1199
#, no-wrap
msgid ""
"  id1L : Maybe a -> Maybe a\n"
"  id1L ma = ma >>= pure\n"
"\n"
"  id2L : a -> (a -> Maybe b) -> Maybe b\n"
"  id2L v f = pure v >>= f\n"
"\n"
"  id2R : a -> (a -> Maybe b) -> Maybe b\n"
"  id2R v f = f v\n"
msgstr ""
"  id1L : Maybe a -> Maybe a\n"
"  id1L ma = ma >>= pure\n"
"\n"
"  id2L : a -> (a -> Maybe b) -> Maybe b\n"
"  id2L v f = pure v >>= f\n"
"\n"
"  id2R : a -> (a -> Maybe b) -> Maybe b\n"
"  id2R v f = f v\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1212
#, no-wrap
msgid ""
"  These two laws state that `pure` should behave\n"
"  neutrally w.r.t. *bind*.\n"
msgstr "  这两条定律规定 `pure` 在 *bind* 中应该表现为中立。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1218
#, no-wrap
msgid ""
"`(m >>= f) >>= g = m >>= (f >=> g)`.\n"
"This is the law of associativity for monad.\n"
"You might not have seen the second operator `(>=>)`.\n"
"It can be used to sequence effectful computations\n"
"and has the following type:\n"
msgstr ""
"`(m >>= f) >>= g = m >>= (f >=> g)` 是 monad 的结合律。"
"您可能没有见过第二个运算符 "
"`(>=>)`。它可用于对副作用计算进行排序，并具有以下类型：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1219
#, no-wrap
msgid ""
"  Tutorial.Functor> :t (>=>)\n"
"  Prelude.>=> : Monad m => (a -> m b) -> (b -> m c) -> a -> m c\n"
msgstr ""
"  Tutorial.Functor> :t (>=>)\n"
"  Prelude.>=> : Monad m => (a -> m b) -> (b -> m c) -> a -> m c\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1229
#, no-wrap
msgid ""
"The above are the *official* monad laws. However, we need to\n"
"consider a third one, given that in Idris (and Haskell)\n"
"`Monad` extends `Applicative`: As `(<*>)` can be implemented\n"
"in terms of `(>>=)`, the actual implementation of `(<*>)`\n"
"must behave the same as the implementation in terms of `(>>=)`:\n"
msgstr "以上是 *官方的* monad 定律。但是，我们需要考虑第三个，因为在 Idris（和 Haskell）中，`Monad` 扩展自 `Applicative`: 由于 `(<*>)` 可以由 `(>>=)` 实现，`(<*>)` 的实际实现必须与 `(>>=)` 的实现表现相同：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1231
#, no-wrap
msgid "`mf <*> ma = mf >>= (\\fun => map (fun $) ma)`.\n"
msgstr "`mf <*> ma = mf >>= (\\fun => map (fun $) ma)`.\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:1237
#, no-wrap
msgid ""
"`Applicative` extends `Functor`, because every `Applicative`\n"
"is also a `Functor`. Proof this by implementing `map` in\n"
"terms of `pure` and `(<*>)`.\n"
msgstr ""
"`Applicative` 扩展了 `Functor`，因为每个 `Applicative` 也是一个 `Functor`。"
"通过根据 `pure` 和 `(<*>)` 实现 `map` 来证明这一点。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:1241
#, no-wrap
msgid ""
"`Monad` extends `Applicative`, because every `Monad` is\n"
"also an `Applicative`. Proof this by implementing\n"
"`(<*>)` in terms of `(>>=)` and `pure`.\n"
msgstr ""
"`Monad` 扩展了 `Applicative`，因为每个 `Monad` 也是一个 `Applicative`。"
"通过根据 `(>>=)` 和 `pure` 实现 `(<*>)` 来证明这一点。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:1244
#, no-wrap
msgid ""
"Implement `(>>=)` in terms of `join` and other functions\n"
"in the `Monad` hierarchy.\n"
msgstr "根据 `join` 和 `Monad` 层次结构中的其他函数实现 `(>>=)`。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:1247
#, no-wrap
msgid ""
"Implement `join` in terms of `(>>=)` and other functions\n"
"in the `Monad` hierarchy.\n"
msgstr "根据 `(>>=)` 和 `Monad` 层次结构中的其他函数实现 `join`。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:1250
#, no-wrap
msgid ""
"There is no lawful `Monad` implementation for `Validated e`.\n"
"Why?\n"
msgstr "`Validated e` 没有合法的 `Monad` 实现。为什么？\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:1256
#, no-wrap
msgid ""
"In this slightly extended exercise, we are going to simulate\n"
"CRUD operations on a data store. We will use a mutable\n"
"reference (imported from `Data.IORef` from the *base* library)\n"
"holding a list of `User`s paired with a unique ID\n"
"of type `Nat` as our user data base:\n"
msgstr ""
"在这个稍微扩展的练习中，我们将在数据存储上模拟 CRUD "
"操作。我们将使用一个可变引用（从 *base* 库中的 `Data.IORef` 导入），"
"其中包含一个 `User` 列表和一个类型为 `Nat` 的唯一 ID 作为我们的用户数据库：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1257
#, no-wrap
msgid ""
"   DB : Type\n"
"   DB = IORef (List (Nat,User))\n"
msgstr ""
"   DB : Type\n"
"   DB = IORef (List (Nat,User))\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1267
#, no-wrap
msgid ""
"   Most operations on a database come with a risk of failure:\n"
"   When we try to update or delete a user, the entry in question\n"
"   might no longer be there. When we add a new user, a user\n"
"   with the given email address might already exist. Here is\n"
"   a custom error type to deal with this:\n"
msgstr ""
"   数据库上的大多数操作都有失败的风险：\n"
"   当我们尝试更新或删除用户时，有问题的条目\n"
"   可能不再存在。当我们添加一个新用户时，一个用户\n"
"   与给定的电子邮件地址可能已经存在。这是\n"
"   处理此问题的自定义错误类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1268
#, no-wrap
msgid ""
"   data DBError : Type where\n"
"     UserExists        : Email -> Nat -> DBError\n"
"     UserNotFound      : Nat -> DBError\n"
"     SizeLimitExceeded : DBError\n"
msgstr ""
"   data DBError : Type where\n"
"     UserExists        : Email -> Nat -> DBError\n"
"     UserNotFound      : Nat -> DBError\n"
"     SizeLimitExceeded : DBError\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1277
#, no-wrap
msgid ""
"   In general, our functions will therefore have a\n"
"   type similar to the following:\n"
msgstr ""
"   一般来说，我们的函数因此会有一个\n"
"   类似于以下内容的类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1278
#, no-wrap
msgid "   someDBProg : arg1 -> arg2 -> DB -> IO (Either DBError a)\n"
msgstr "   someDBProg : arg1 -> arg2 -> DB -> IO (Either DBError a)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1284
#, no-wrap
msgid ""
"   We'd like to abstract over this, by introducing a new wrapper\n"
"   type:\n"
msgstr ""
"   我们想通过引入一个新的包装器来抽象这个\n"
"   类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1285
#, no-wrap
msgid ""
"   record Prog a where\n"
"     constructor MkProg\n"
"     runProg : DB -> IO (Either DBError a)\n"
msgstr ""
"   record Prog a where\n"
"     constructor MkProg\n"
"     runProg : DB -> IO (Either DBError a)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1294
#, no-wrap
msgid ""
"   We are now ready to write us some utility functions. Make sure\n"
"   to follow the following business rules when implementing the\n"
"   functions below:\n"
msgstr ""
"   我们现在准备为我们编写一些实用函数。确保\n"
"   在实施时遵循以下业务规则\n"
"   以下功能：\n"

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1297
#, no-wrap
msgid ""
"Email addresses in the DB must be unique. (Consider\n"
"implementing `Eq Email` to verify this).\n"
msgstr "数据库中的电子邮件地址必须是唯一的。 （考虑实现 `Eq Email` 来验证这一点）。\n"

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1299
#, no-wrap
msgid "The size limit of 1000 entries must not be exceeded.\n"
msgstr "不得超过 1000 个条目的大小限制。\n"

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1303
#, no-wrap
msgid ""
"Operations trying to lookup a user by their ID must\n"
"fail with `UserNotFound` in case no entry was found\n"
"in the DB.\n"
msgstr "如果在 DB 中找不到条目，则尝试通过 ID 查找用户的操作必须失败并显示 "
"`UserNotFound`。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1308
#, no-wrap
msgid ""
"   You'll need the following functions from `Data.IORef` when working\n"
"   with mutable references: `newIORef`, `readIORef`, and `writeIORef`.\n"
"   In addition, functions `Data.List.lookup` and `Data.List.find` might\n"
"   be useful to implement some of the functions below.\n"
msgstr ""
"   工作时需要 `Data.IORef` 中的以下功能\n"
"   具有可变引用：`newIORef`、`readIORef` 和 `writeIORef`。\n"
"   此外，函数 `Data.List.lookup` 和 `Data.List.find` 可能\n"
"   对实现以下某些功能很有用。\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/Functor.md:1310
#, no-wrap
msgid "Implement interfaces `Functor`, `Applicative`, and `Monad` for `Prog`.\n"
msgstr "为 `Prog` 实现接口 `Functor`、`Applicative` 和 `Monad`。\n"

#. type: Bullet: '   2. '
#: ../src/Tutorial/Functor.md:1312
#, no-wrap
msgid "Implement interface `HasIO` for `Prog`.\n"
msgstr "为 `Prog` 实现接口 `HasIO`。\n"

#. type: Bullet: '   3. '
#: ../src/Tutorial/Functor.md:1314
#, no-wrap
msgid "Implement the following utility functions:\n"
msgstr "实现以下实用函数：\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1317
#, no-wrap
msgid ""
"      ```idris\n"
"      throw : DBError -> Prog a\n"
msgstr ""
"      ```idris\n"
"      throw : DBError -> Prog a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1319
#, no-wrap
msgid "      getUsers : Prog (List (Nat,User))\n"
msgstr "      getUsers : Prog (List (Nat,User))\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1322
#, no-wrap
msgid ""
"      -- check the size limit!\n"
"      putUsers : List (Nat,User) -> Prog ()\n"
msgstr ""
"      -- check the size limit!\n"
"      putUsers : List (Nat,User) -> Prog ()\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1326
#, no-wrap
msgid ""
"      -- implement this in terms of `getUsers` and `putUsers`\n"
"      modifyDB : (List (Nat,User) -> List (Nat,User)) -> Prog ()\n"
"      ```\n"
msgstr ""
"      -- implement this in terms of `getUsers` and `putUsers`\n"
"      modifyDB : (List (Nat,User) -> List (Nat,User)) -> Prog ()\n"
"      ```\n"

#. type: Bullet: '   4. '
#: ../src/Tutorial/Functor.md:1330
#, no-wrap
msgid ""
"Implement function `lookupUser`. This should fail\n"
"with an appropriate error, if a user with the given ID\n"
"cannot be found.\n"
msgstr "实现函数`lookupUser`。如果找不到具有给定 ID "
"的用户，这应该会失败并出现适当的错误。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1334
#, no-wrap
msgid ""
"      ```idris\n"
"      lookupUser : (id : Nat) -> Prog User\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      lookupUser : (id : Nat) -> Prog User\n"
"      ```\n"

#. type: Bullet: '   5. '
#: ../src/Tutorial/Functor.md:1339
#, no-wrap
msgid ""
"Implement function `deleteUser`. This should fail\n"
"with an appropriate error, if a user with the given ID\n"
"cannot be found. Make use of `lookupUser` in your\n"
"implementation.\n"
msgstr ""
"实现函数 `deleteUser`。如果找不到具有给定 ID "
"的用户，这应该会失败并出现适当的错误。在您的实现中使用 `lookupUser`。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1343
#, no-wrap
msgid ""
"      ```idris\n"
"      deleteUser : (id : Nat) -> Prog ()\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      deleteUser : (id : Nat) -> Prog ()\n"
"      ```\n"

#. type: Bullet: '   6. '
#: ../src/Tutorial/Functor.md:1349
#, no-wrap
msgid ""
"Implement function `addUser`. This should fail, if\n"
"a user with the given `Email` already exists, or\n"
"if the data banks size limit of 1000 entries is exceeded.\n"
"In addition, this should create and return a unique\n"
"ID for the new user entry.\n"
msgstr ""
"实现函数 `addUser`。如果具有给定 `Email` 的用户已经存在，或者超过了 1000 "
"个条目的数据库大小限制，这应该会失败。此外，"
"这应该为新用户条目创建并返回一个唯一 ID。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1353
#, no-wrap
msgid ""
"      ```idris\n"
"      addUser : (new : User) -> Prog Nat\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      addUser : (new : User) -> Prog Nat\n"
"      ```\n"

#. type: Bullet: '   7. '
#: ../src/Tutorial/Functor.md:1358
#, no-wrap
msgid ""
"Implement function `updateUser`. This should fail, if\n"
"the user in question cannot be found or\n"
"a user with the updated user's `Email` already exists.\n"
"The returned value should be the updated user.\n"
msgstr ""
"实现函数 `updateUser`。如果找不到相关用户或更新用户的 `Email` "
"的用户已经存在，这应该会失败。返回的值应该是更新的用户。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1362
#, no-wrap
msgid ""
"      ```idris\n"
"      updateUser : (id : Nat) -> (mod : User -> User) -> Prog User\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      updateUser : (id : Nat) -> (mod : User -> User) -> Prog User\n"
"      ```\n"

#. type: Bullet: '   8. '
#: ../src/Tutorial/Functor.md:1366
#, no-wrap
msgid ""
"Data type `Prog` is actually too specific. We could just\n"
"as well abstract over the error type and the `DB`\n"
"environment:\n"
msgstr "数据类型 `Prog` 实际上太具体了。我们也可以抽象出错误类型和 `DB` 环境：\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1372
#, no-wrap
msgid ""
"      ```idris\n"
"      record Prog' env err a where\n"
"        constructor MkProg'\n"
"        runProg' : env -> IO (Either err a)\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      record Prog' env err a where\n"
"        constructor MkProg'\n"
"        runProg' : env -> IO (Either err a)\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1378
#, no-wrap
msgid ""
"      Verify, that all interface implementations you wrote\n"
"      for `Prog` can be used verbatim to implement the same\n"
"      interfaces for `Prog' env err`. The same goes for\n"
"      `throw` with only a slight adjustment in the function's\n"
"      type.\n"
msgstr ""
"      验证您编写的所有接口实现\n"
"      对于 `Prog` 可以逐字使用来实现相同的\n"
"      `Prog' env err` 的接口。这同样适用于\n"
"      `throw` 只需稍微调整函数的\n"
"      类型。\n"

#. type: Title ##
#: ../src/Tutorial/Functor.md:1379
#, no-wrap
msgid "Background and further Reading"
msgstr "背景和延伸阅读"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1388
#, no-wrap
msgid ""
"Concepts like *functor* and *monad* have their origin in *category theory*,\n"
"a branch of mathematics. That is also where their laws come from.\n"
"Category theory was found to have applications in\n"
"programming language theory, especially functional programming.\n"
"It is a highly abstract topic, but there is a pretty accessible\n"
"introduction for programmers, written by\n"
"[Bartosz Milewski](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/).\n"
msgstr "*functor* 和 *monad* 等概念起源于数学分支 *范畴论*。这也是他们的定律的来源。范畴理论被发现在程序设计语言理论，特别是函数式程序设计中有应用。这是一个高度抽象的主题，但有一个非常容易理解的程序员介绍，由 [Bartosz Milewski](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/) 编写。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1394
#, no-wrap
msgid ""
"The usefulness of applicative functors as a middle ground between\n"
"functor and monad was discovered several years after monads had\n"
"already been in use in Haskell. They where introduced in the\n"
"article [*Applicative Programming with Effects*](https://www.staff.city.ac.uk/~ross/papers/Applicative.html),\n"
"which is freely available online and a highly recommended read.\n"
msgstr "应用函子作为函子和单子之间的中间地带的有用性是在单子已经在 Haskell 中使用几年之后才发现的。它们在文章 [*Applicative Programming with Effects*](https://www.staff.city.ac.uk/~ross/papers/Applicative.html) 中进行了介绍，该文章可在线免费获得，并且强烈推荐阅读。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1401
#, no-wrap
msgid ""
"Interfaces `Functor`, `Applicative`, and `Monad` abstract over\n"
"programming patterns that come up when working with type\n"
"constructors of type `Type -> Type`. Such data types are also\n"
"referred to as *values in a context*, or *effectful computations*.\n"
msgstr ""
"接口 `Functor`、`Applicative` 和 `Monad` 抽象了使用 `Type -> Type` "
"类型的类型构造函数时出现的编程模式。此类数据类型也称为上下文中的 *值*，或 "
"*副作用计算*。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1404
#, no-wrap
msgid ""
"`Functor` allows us to *map* over values in a context without\n"
"affecting the context's underlying structure.\n"
msgstr "`Functor` 允许我们在上下文中的值上*映射*而不影响上下文的底层结构。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1407
#, no-wrap
msgid ""
"`Applicative` allows us to apply n-ary functions to n effectful\n"
"computations and to lift pure values into a context.\n"
msgstr "`Applicative` 允许我们将 n 元函数应用于 n "
"个有效计算，并将纯值提升到上下文中。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1411
#, no-wrap
msgid ""
"`Monad` allows us to chain effectful computations, where the\n"
"intermediary results can affect, which computation to run\n"
"further down the chain.\n"
msgstr "`Monad` "
"允许我们链接有效的计算，其中中间结果可能会影响，哪些计算在链中运行得更远。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1415
#, no-wrap
msgid ""
"Unlike `Monad`, `Functor` and `Applicative` compose: The\n"
"product and composition of two functors or applicatives\n"
"are again functors or applicatives, respectively.\n"
msgstr ""
"与 `Monad` 不同，`Functor` 和 `Applicative` "
"组合：两个函子或应用程序的乘积和组合再次分别是函子或应用程序。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1419
#, no-wrap
msgid ""
"Idris provides syntactic sugar for working with some of\n"
"the interfaces presented here: Idiom brackets for `Applicative`,\n"
"*do blocks* and the bang operator for `Monad`.\n"
msgstr ""
"Idris 为使用此处介绍的一些接口提供了语法糖：`Applicative` 的习语括号、*do 块*"
" 和 `Monad` 的感叹号运算符。\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:1420 ../src/Tutorial/Intro.md:430
#, no-wrap
msgid "What's next?"
msgstr "下一步是什么？"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1425
#, no-wrap
msgid ""
"In the [next chapter](Folds.md) we get to learn more about\n"
"recursion, totality checking, and an interface for\n"
"collapsing container types: `Foldable`.\n"
msgstr "在[下一章](Folds.md) 中，我们将了解更多关于递归、完全性检查和折叠容器类型的接口：`Foldable`。\n"

#. type: Title #
#: ../src/Tutorial/Interfaces.md:1
#, no-wrap
msgid "Interfaces"
msgstr "接口"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:9
#, no-wrap
msgid ""
"Function overloading - the definition of functions\n"
"with the same name but different implementations - is a concept\n"
"found in many programming languages. Idris natively supports overloading\n"
"of functions: Two functions with the same name can be defined in\n"
"different modules or namespaces, and Idris will try to disambiguate\n"
"between these based on the types involved. Here is an example:\n"
msgstr "函数重载——定义同名但实现不同的函数——是许多编程语言中的一个概念。 Idris 原生支持函数的重载：两个同名的函数可以定义在不同的模块或命名空间中，Idris 将尝试根据所涉及的类型消除它们之间的歧义。这是一个例子：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:10
#, no-wrap
msgid ""
"module Tutorial.Interfaces\n"
"\n"
"%default total\n"
"\n"
"namespace Bool\n"
"  export\n"
"  size : Bool -> Integer\n"
"  size True  = 1\n"
"  size False = 0\n"
"\n"
"namespace Integer\n"
"  export\n"
"  size : Integer -> Integer\n"
"  size = id\n"
"\n"
"namespace List\n"
"  export\n"
"  size : List a -> Integer\n"
"  size = cast . length\n"
msgstr ""
"module Tutorial.Interfaces\n"
"\n"
"%default total\n"
"\n"
"namespace Bool\n"
"  export\n"
"  size : Bool -> Integer\n"
"  size True  = 1\n"
"  size False = 0\n"
"\n"
"namespace Integer\n"
"  export\n"
"  size : Integer -> Integer\n"
"  size = id\n"
"\n"
"namespace List\n"
"  export\n"
"  size : List a -> Integer\n"
"  size = cast . length\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:35
#, no-wrap
msgid ""
"Here, we defined three different functions\n"
"called `size`, each in its own namespace. We can disambiguate between\n"
"these by prefixing them with their namespace:\n"
msgstr "在这里，我们定义了三个不同的函数，称为 `size`，每个函数都在自己的命名空间中。我们可以通过在它们前面加上它们的命名空间来消除它们之间的歧义：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:36
#, no-wrap
msgid ""
"Tutorial.Interfaces> :t Bool.size\n"
"Tutorial.Interfaces.Bool.size : Bool -> Integer\n"
msgstr ""
"Tutorial.Interfaces> :t Bool.size\n"
"Tutorial.Interfaces.Bool.size : Bool -> Integer\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:42
#, no-wrap
msgid "However, this is usually not necessary:\n"
msgstr "但是，这通常不是必需的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:43
#, no-wrap
msgid ""
"mean : List Integer -> Integer\n"
"mean xs = sum xs `div` size xs\n"
msgstr ""
"mean : List Integer -> Integer\n"
"mean xs = sum xs `div` size xs\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:51
#, no-wrap
msgid ""
"As you can see, Idris can disambiguate between the different\n"
"`size` functions, since `xs` is of type `List Integer`, which\n"
"unifies only with `List a`, the argument type of `List.size`.\n"
msgstr "如您所见，Idris 可以区分不同的 `size` 函数，因为 `xs` 是 `List Integer` 类型，它仅与 `List a` 的参数类型为 `List.size`。\n"

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:52
#, no-wrap
msgid "Interface Basics"
msgstr "接口基础"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:57
#, no-wrap
msgid ""
"While function overloading as described above\n"
"works well, there are use cases, where\n"
"this form of overloaded functions leads to a lot of code duplication.\n"
msgstr "虽然如上所述的函数重载效果很好，但在某些用例中，这种形式的重载函数会导致大量代码重复。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:61
#, no-wrap
msgid ""
"As an example, consider a function `cmp` (short for *compare*, which is\n"
"already exported by the *Prelude*), for describing an ordering\n"
"for the values of type `String`:\n"
msgstr "例如，考虑一个函数 `cmp` （*compare* 的缩写，已由 *Prelude* 导出），用于描述 `String` 类型值的顺序：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:62
#, no-wrap
msgid "cmp : String -> String -> Ordering\n"
msgstr "cmp : String -> String -> Ordering\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:70
#, no-wrap
msgid ""
"We'd also like to have similar functions for many other data types.\n"
"Function overloading allows us to do just that, but `cmp` is not an\n"
"isolated piece of functionality. From it, we can derive functions\n"
"like `greaterThan'`, `lessThan'`, `minimum'`, `maximum'`, and many others:\n"
msgstr "我们还希望为许多其他数据类型提供类似的函数。函数重载允许我们这样做，但 `cmp` 不是一个孤立的函数。从中，我们可以推导出 `greaterThan'`、`lessThan'`、`minimum'`、`maximum'` 等函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:71
#, no-wrap
msgid ""
"lessThan' : String -> String -> Bool\n"
"lessThan' s1 s2 = LT == cmp s1 s2\n"
"\n"
"greaterThan' : String -> String -> Bool\n"
"greaterThan' s1 s2 = GT == cmp s1 s2\n"
"\n"
"minimum' : String -> String -> String\n"
"minimum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum' : String -> String -> String\n"
"maximum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"
msgstr ""
"lessThan' : String -> String -> Bool\n"
"lessThan' s1 s2 = LT == cmp s1 s2\n"
"\n"
"greaterThan' : String -> String -> Bool\n"
"greaterThan' s1 s2 = GT == cmp s1 s2\n"
"\n"
"minimum' : String -> String -> String\n"
"minimum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum' : String -> String -> String\n"
"maximum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:94
#, no-wrap
msgid ""
"We'd need to implement all of these again for the other types with a `cmp`\n"
"function, and most if not all of these implementations would be identical\n"
"to the ones written above. That's a lot of code repetition.\n"
msgstr "我们需要使用 `cmp` 函数为其他类型再次实现所有这些，并且大多数（如果不是全部）这些实现将与上面编写的相同。这会有很多代码重复。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:99
#, no-wrap
msgid ""
"One way to solve this is to use higher-order functions.\n"
"For instance, we could define function `minimumBy`, which takes\n"
"a comparison function as its first argument and returns the smaller\n"
"of the two remaining arguments:\n"
msgstr "解决这个问题的一种方法是使用高阶函数。例如，我们可以定义函数 `minimumBy`，它将比较函数作为其第一个参数并返回剩余两个参数中较小的一个：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:100
#, no-wrap
msgid ""
"minimumBy : (a -> a -> Ordering) -> a -> a -> a\n"
"minimumBy f a1 a2 =\n"
"  case f a1 a2 of\n"
"    LT => a1\n"
"    _  => a2\n"
msgstr ""
"minimumBy : (a -> a -> Ordering) -> a -> a -> a\n"
"minimumBy f a1 a2 =\n"
"  case f a1 a2 of\n"
"    LT => a1\n"
"    _  => a2\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:114
#, no-wrap
msgid ""
"This solution is another proof of how higher-order functions\n"
"allow us to reduce code duplication. However, the need to explicitly\n"
"pass around the comparison function all the time\n"
"can get tedious as well.\n"
"It would be nice, if we could teach Idris to come up with\n"
"such a function on its own.\n"
msgstr "这个解决方案是高阶函数如何让我们减少代码重复的另一个证明。但是，始终需要显式传递比较函数也会变得乏味。如果我们能教 Idris 自己想出这样的功能，那就太好了。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:116
#, no-wrap
msgid "Interfaces solve exactly this issue. Here's an example:\n"
msgstr "接口正好解决了这个问题。这是一个例子：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:117
#, no-wrap
msgid ""
"interface Comp a where\n"
"  comp : a -> a -> Ordering\n"
"\n"
"implementation Comp Bits8 where\n"
"  comp = compare\n"
"\n"
"implementation Comp Bits16 where\n"
"  comp = compare\n"
msgstr ""
"interface Comp a where\n"
"  comp : a -> a -> Ordering\n"
"\n"
"implementation Comp Bits8 where\n"
"  comp = compare\n"
"\n"
"implementation Comp Bits16 where\n"
"  comp = compare\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:133
#, no-wrap
msgid ""
"The code above defines *interface* `Comp` providing\n"
"function `comp` for calculating the\n"
"ordering for two values of a type `a`, followed by two *implementations*\n"
"of this interface for types `Bits8` and `Bits16`. Note, that the\n"
"`implementation` keyword is optional.\n"
msgstr "上面的代码定义了 *接口* `Comp` ，提供函数 `comp` 用于计算类型为 `a` 的两个值的排序，然后是 `Bits8` 和 `Bits16` 类型接口的两个 *实现*。请注意，`implementation` 关键字是可选的。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:137
#, no-wrap
msgid ""
"The `comp` implementations for `Bits8` and `Bits16` both use\n"
"function `compare`, which is part of a similar interface\n"
"from the *Prelude* called `Ord`.\n"
msgstr "`Bits8` 和 `Bits16` 的 `comp` 实现都使用函数 `compare`，它是 *Prelude* 中类似接口的一部分，称为 `Ord`。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:139
#, no-wrap
msgid "The next step is to look at the type of `comp` at the REPL:\n"
msgstr "下一步是查看 REPL 中 `comp` 的类型：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:140
#, no-wrap
msgid ""
"Tutorial.Interfaces> :t comp\n"
"Tutorial.Interfaces.comp : Comp a => a -> a -> Ordering\n"
msgstr ""
"Tutorial.Interfaces> :t comp\n"
"Tutorial.Interfaces.comp : Comp a => a -> a -> Ordering\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:154
#, no-wrap
msgid ""
"The interesting part in the type signature of `comp` is\n"
"the initial `Comp a =>` argument. Here, `Comp` is a *constraint* on\n"
"type parameter `a`. This signature can be read as:\n"
"\"For any type `a`, given an implementation\n"
"of interface `Comp` for `a`, we can compare two values\n"
"of type `a` and return an `Ordering` for these.\"\n"
"Whenever we invoke `comp`, we expect Idris to come up with a\n"
"value of type `Comp a` on its own, hence the new `=>` arrow.\n"
"If Idris fails to do so, it will answer with a type error.\n"
msgstr ""
"`comp` 的类型签名中有趣的部分是初始的 `Comp a =>` 参数。这里，`Comp` 是类型参数 `a` 上的 *约束*。该签名可以读作：“对于任何类型 `a`，给定 `a` 的接口 `Comp` 的实现，我们可以比较 `a` 类型的两个值并返回一个 `Ordering` ”。\n"
"每当我们调用 `comp` 时，我们希望 Idris 自己得出一个 `Comp a` 类型的值，因此这里需要新的 `=>` 箭头。如果 Idris 没有推断出来，它将返回类型错误。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:158
#, no-wrap
msgid ""
"We can now use `comp` in the implementations of related functions.\n"
"All we have to do is to also prefix these derived functions\n"
"with a `Comp` constraint:\n"
msgstr "我们现在可以在相关函数的实现中使用`comp`。我们所要做的就是在这些派生函数前面加上一个 `Comp` 约束：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:159
#, no-wrap
msgid ""
"lessThan : Comp a => a -> a -> Bool\n"
"lessThan s1 s2 = LT == comp s1 s2\n"
"\n"
"greaterThan : Comp a => a -> a -> Bool\n"
"greaterThan s1 s2 = GT == comp s1 s2\n"
"\n"
"minimum : Comp a => a -> a -> a\n"
"minimum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum : Comp a => a -> a -> a\n"
"maximum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"
msgstr ""
"lessThan : Comp a => a -> a -> Bool\n"
"lessThan s1 s2 = LT == comp s1 s2\n"
"\n"
"greaterThan : Comp a => a -> a -> Bool\n"
"greaterThan s1 s2 = GT == comp s1 s2\n"
"\n"
"minimum : Comp a => a -> a -> a\n"
"minimum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum : Comp a => a -> a -> a\n"
"maximum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:185
#, no-wrap
msgid ""
"Note, how the definition of `minimum` is almost identical\n"
"to `minimumBy`. The only difference being that in case of\n"
"`minimumBy` we had to pass the comparison function as an\n"
"explicit argument, while for `minimum` it is provided as\n"
"part of the `Comp` implementation, which is passed around\n"
"by Idris for us.\n"
msgstr "请注意，`minimum` 的定义与 `minimumBy` 的定义几乎相同。唯一的区别是，在 `minimumBy` 的情况下，我们必须将比较函数作为显式参数传递，而对于 `minimum`，它作为 `Comp` 的一部分提供实现，由 Idris 为我们传递。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:188
#, no-wrap
msgid ""
"Thus, we have defined all these utility functions once and for\n"
"all for every type with an implementation of interface `Comp`.\n"
msgstr "因此，我们用接口 `Comp` 的实现为每种类型一劳永逸地定义了所有这些实用函数。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:195
#, no-wrap
msgid ""
"1. Implement function `anyLarger`, which should return `True`,\n"
"if and only if a list of values contains at least one element larger\n"
"than a given reference value. Use interface `Comp` in your\n"
"implementation.\n"
msgstr ""
"1. 实现函数`anyLarger`，应该返回`True` 的条件为，\n"
"当且仅当值列表包含至少一个比给定的参考值更大的元素。使用接口 `Comp` 在你的实现中。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:200
#, no-wrap
msgid ""
"2. Implement function `allLarger`, which should return `True`,\n"
"if and only if a list of values contains *only* elements larger\n"
"than a given reference value. Note, that this is trivially true\n"
"for the empty list. Use interface `Comp` in your implementation.\n"
msgstr ""
"2. 实现函数`allLarger`，应该返回`True` 的条件为，\n"
"当且仅当值列表的 *只* 包含比给定的参考值更大的元素。请注意，对于空列表总是返回 true。在您的实现中使用接口 `Comp`。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:206
#, no-wrap
msgid ""
"3. Implement function `maxElem`, which tries to extract the\n"
"largest element from a list of values with a `Comp` implementation.\n"
"Likewise for `minElem`, which tries to extract the smallest element.\n"
"Note, that the possibility of the list being empty must be considered\n"
"when deciding on the output type.\n"
msgstr ""
"3. 实现函数`maxElem`，试图提取\n"
"具有 `Comp` 实现的值列表中的最大元素。\n"
"对于 `minElem` 也是如此，它试图提取最小的元素。\n"
"请注意，在决定输出类型时必须考虑列表为空的可能性。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:210
#, no-wrap
msgid ""
"4. Define an interface `Concat` for values like lists or\n"
"strings, which can be concatenated. Provide implementations\n"
"for lists and strings.\n"
msgstr "4. 为列表或列表等值定义一个接口 `Concat`，可以串联的字符串。提供实对于列表和字符串的实现。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:215
#, no-wrap
msgid ""
"5. Implement function `concatList` for concatenating the\n"
"values in a list holding values with a `Concat` implementation.\n"
"Make sure to reflect the possibility of the list being empty in your\n"
"output type.\n"
msgstr ""
"5. 实现函数 `concatList` 用于连接使用 `Concat` 实现的列表中的值。\n"
"确保在您的列表中反映列表为空的可能输出类型。\n"

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:216
#, no-wrap
msgid "More about Interfaces"
msgstr "更多关于接口的信息"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:224
#, no-wrap
msgid ""
"In the last section, we learned about the very basics\n"
"of interfaces: Why they are useful and how to define and\n"
"implement them.\n"
"In this section, we will learn about some slightly\n"
"advanced concepts: Extending interfaces, interfaces with\n"
"constraints, and default implementations.\n"
msgstr "在上一节中，我们了解了接口的基础知识：为什么它们有用以及如何定义和实现它们。在本节中，我们将学习一些稍微高级的概念：扩展接口、带约束的接口和默认实现。\n"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:225
#, no-wrap
msgid "Extending Interfaces"
msgstr "扩展接口"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:233
#, no-wrap
msgid ""
"Some interfaces form a kind of hierarchy. For instance, for\n"
"the `Concat` interface used in exercise 4, there might\n"
"be a child interface called `Empty`, for those types,\n"
"which have a neutral element with relation to concatenation.\n"
"In such a case, we make an implementation of `Concat` a\n"
"prerequisite for implementing `Empty`:\n"
msgstr "一些接口会形成一种层次结构。例如，对于练习 4 中使用的 `Concat` 接口，可能有一个名为 `Empty` 的子接口，用于那些具有与串联相关的中性元素的类型。在这种情况下，我们将 `Concat` 的实现作为实现 `Empty` 的先决条件：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:234
#, no-wrap
msgid ""
"interface Concat a where\n"
"  concat : a -> a -> a\n"
"\n"
"implementation Concat String where\n"
"  concat = (++)\n"
"\n"
"interface Concat a => Empty a where\n"
"  empty : a\n"
"\n"
"implementation Empty String where\n"
"  empty = \"\"\n"
msgstr ""
"interface Concat a where\n"
"  concat : a -> a -> a\n"
"\n"
"implementation Concat String where\n"
"  concat = (++)\n"
"\n"
"interface Concat a => Empty a where\n"
"  empty : a\n"
"\n"
"implementation Empty String where\n"
"  empty = \"\"\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:254
#, no-wrap
msgid ""
"`Concat a => Empty a` should be read as: \"An implementation\n"
"of `Concat` for type `a` is a *prerequisite* for there being\n"
"an implementation of `Empty` for `a`.\"\n"
"But this also means that, whenever we have an implementation\n"
"of interface `Empty`, we *must* also have an implementation of `Concat`\n"
"and can invoke the corresponding functions:\n"
msgstr "`Concat a => Empty a` 应读作：“`Concat` 类型 `a` 的实现是 *先决条件*，才能为 `a` 实现 `Empty` 接口”。但这也意味着，只要我们有接口 `Empty` 的实现，我们 *必须* 也有 `Concat` 的实现，并且可以调用相应的函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:255
#, no-wrap
msgid ""
"concatListE : Empty a => List a -> a\n"
"concatListE []        = empty\n"
"concatListE (x :: xs) = concat x (concatListE xs)\n"
msgstr ""
"concatListE : Empty a => List a -> a\n"
"concatListE []        = empty\n"
"concatListE (x :: xs) = concat x (concatListE xs)\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:264
#, no-wrap
msgid ""
"Note, how in the type of `concatListE` we only used an `Empty`\n"
"constraint, and how in the implementation we were still able\n"
"to invoke both `empty` and `concat`.\n"
msgstr "请注意，在 `concatListE` 的类型中，我们如何只使用 `Empty` 约束，以及在实现中我们如何仍然能够调用 `empty` 和 `concat`。\n"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:265
#, no-wrap
msgid "Constrained Implementations"
msgstr "受约束的实现"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:273
#, no-wrap
msgid ""
"Sometimes, it is only possible to implement an interface\n"
"for a generic type, if its type parameters implement\n"
"this interface as well. For instance, implementing interface `Comp`\n"
"for `Maybe a` makes sense only if type `a` itself implements\n"
"`Comp`. We can constrain interface implementations with\n"
"the same syntax we use for constrained functions:\n"
msgstr "有时，只有泛型类型的类型参数也实现了该接口，才能实现该接口。例如，为 `Maybe a` 实现接口 `Comp` 时，只有当类型 `a` 本身实现 `Comp` 时才有意义。我们可以使用与约束函数相同的语法来约束接口实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:274
#, no-wrap
msgid ""
"implementation Comp a => Comp (Maybe a) where\n"
"  comp Nothing  Nothing  = EQ\n"
"  comp (Just _) Nothing  = GT\n"
"  comp Nothing  (Just _) = LT\n"
"  comp (Just x) (Just y) = comp x y\n"
msgstr ""
"implementation Comp a => Comp (Maybe a) where\n"
"  comp Nothing  Nothing  = EQ\n"
"  comp (Just _) Nothing  = GT\n"
"  comp Nothing  (Just _) = LT\n"
"  comp (Just x) (Just y) = comp x y\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:292
#, no-wrap
msgid ""
"This is not the same as extending an interface, although\n"
"the syntax looks very similar. Here, the constraint lies\n"
"on a *type parameter* instead of the full type.\n"
"The last line in the implementation of `Comp (Maybe a)`\n"
"compares the values stored in the two `Just`s. This is\n"
"only possible, if there is a `Comp` implementation for\n"
"these values as well. Go ahead, and remove the `Comp a`\n"
"constraint from the above implementation. Learning to\n"
"read and understand Idris' type errors is important\n"
"for fixing them.\n"
msgstr "这与扩展接口不同，尽管语法看起来非常相似。在这里，约束位于 * 类型参数 * 而不是完整类型。 `Comp (Maybe a)` 实现的最后一行比较了存储在两个 `Just` 中的值。这只有在这些值也有 `Comp` 实现的情况下才有可能。继续，让我们试试从上述实现中删除 `Comp a` 约束。学习阅读和理解 Idris 的类型错误对于修复它们很重要。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:295
#, no-wrap
msgid ""
"The good thing is, that Idris will solve all these\n"
"constraints for us:\n"
msgstr "好消息是，Idris 将为我们解决所有这些限制：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:296
#, no-wrap
msgid ""
"maxTest : Maybe Bits8 -> Ordering\n"
"maxTest = comp (Just 12)\n"
msgstr ""
"maxTest : Maybe Bits8 -> Ordering\n"
"maxTest = comp (Just 12)\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:305
#, no-wrap
msgid ""
"Here, Idris tries to find an implementation for `Comp (Maybe Bits8)`.\n"
"In order to do so, it needs an implementation for `Comp Bits8`.\n"
"Go ahead, and replace `Bits8` in the type of `maxTest` with `Bits64`,\n"
"and have a look at the error message Idris produces.\n"
msgstr "在这里，Idris 试图找到 `Comp (Maybe Bits8)` 的实现。为此，它需要 `Comp Bits8` 的实现。继续，将 `maxTest` 类型中的 `Bits8` 替换为 `Bits64`，并查看 Idris 产生的错误消息。\n"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:306
#, no-wrap
msgid "Default Implementations"
msgstr "默认实现"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:320
#, no-wrap
msgid ""
"Sometimes, we'd like to pack several related functions\n"
"in an interface to allow programmers to implement each\n"
"in the most efficient way, although they *could* be\n"
"implemented in terms of each other. For instance,\n"
"consider an interface `Equals` for comparing two\n"
"values for equality, with functions `eq` returning\n"
"`True` if two values are equal and `neq` returning\n"
"`True` if they are not. Surely, we can implement `neq`\n"
"in terms of `eq`, so most of the time when implementing\n"
"`Equals`, we will only implement the latter.\n"
"In this case, we can give an implementation for `neq`\n"
"already in the definition of `Equals`:\n"
msgstr "有时，我们希望将几个相关的函数打包到一个接口中，以便程序员以最有效的方式实现每个函数，尽管它们 *可以* 相互实现。例如，考虑一个接口 `Equals` 用于比较两个值是否相等，如果两个值相等，则函数 `eq` 返回 `True` ，如果不相等则 `neq` 返回 `True`。当然，我们可以用 `eq` 来实现 `neq`，所以大多数时候在实现 `Equals` 时，我们只会实现后者。在这种情况下，我们可以在 `Equals` 的定义中给出 `neq` 的实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:321
#, no-wrap
msgid ""
"interface Equals a where\n"
"  eq : a -> a -> Bool\n"
"\n"
"  neq : a -> a -> Bool\n"
"  neq a1 a2 = not (eq a1 a2)\n"
msgstr ""
"interface Equals a where\n"
"  eq : a -> a -> Bool\n"
"\n"
"  neq : a -> a -> Bool\n"
"  neq a1 a2 = not (eq a1 a2)\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:332
#, no-wrap
msgid ""
"If in an implementation of `Equals` we only implement `eq`,\n"
"Idris will use the default implementation for `neq` as\n"
"shown above:\n"
msgstr "如果在 `Equals` 的实现中我们只实现 `eq`，Idris 将使用 `neq` 的默认实现，如上所示：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:333
#, no-wrap
msgid ""
"Equals String where\n"
"  eq = (==)\n"
msgstr ""
"Equals String where\n"
"  eq = (==)\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:340
#, no-wrap
msgid ""
"If on the other hand we'd like to provide explicit implementations\n"
"for both functions, we can do so as well:\n"
msgstr "另一方面，如果我们想为这两个函数提供显式实现，我们也可以这样做：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:341
#, no-wrap
msgid ""
"Equals Bool where\n"
"  eq True True   = True\n"
"  eq False False = True\n"
"  eq _ _         = False\n"
"\n"
"  neq True  False = True\n"
"  neq False True  = True\n"
"  neq _ _         = False\n"
msgstr ""
"Equals Bool where\n"
"  eq True True   = True\n"
"  eq False False = True\n"
"  eq _ _         = False\n"
"\n"
"  neq True  False = True\n"
"  neq False True  = True\n"
"  neq _ _         = False\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:358
#, no-wrap
msgid ""
"1. Implement interfaces `Equals`, `Comp`, `Concat`, and\n"
"  `Empty` for pairs, constraining your implementations as necessary.\n"
"  (Note, that multiple constraints can be given sequentially like\n"
"  other function arguments: `Comp a => Comp b => Comp (a,b)`.)\n"
msgstr "1. 实现接口`Equals`、`Comp`、`Concat` 和 `Empty` 用于 pairs，根据需要限制您的实现。（请注意，可以按顺序给出多个约束，例如其他函数参数：`Comp a => Comp b => Comp (a,b)`。）\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Interfaces.md:361
#, no-wrap
msgid ""
"Below is an implementation of a binary tree. Implement\n"
"interfaces `Equals` and `Concat` for this type.\n"
msgstr "下面是二叉树的实现。为此类型实现接口 `Equals` 和 `Concat`。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:362
#, no-wrap
msgid ""
"   data Tree : Type -> Type where\n"
"     Leaf : a -> Tree a\n"
"     Node : Tree a -> Tree a -> Tree a\n"
msgstr ""
"   data Tree : Type -> Type where\n"
"     Leaf : a -> Tree a\n"
"     Node : Tree a -> Tree a -> Tree a\n"

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:368
#, no-wrap
msgid "Interfaces in the *Prelude*"
msgstr "*Prelude* 中的接口"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:374
#, no-wrap
msgid ""
"The Idris *Prelude* provides several interfaces plus implementations\n"
"that are useful in almost every non-trivial program. I'll introduce\n"
"the basic ones here. The more advanced ones will be discussed in later\n"
"chapters.\n"
msgstr "Idris *Prelude* 提供了几个接口和实现，它们在几乎所有重要的程序中都很有用。我将在这里介绍基本的。更高级的将在后面的章节中讨论。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:378
#, no-wrap
msgid ""
"Most of these interfaces come with associated mathematical laws,\n"
"and implementations are assumed to adhere to these laws. These\n"
"laws will be given here as well.\n"
msgstr "这些接口中的大多数都带有相关的数学定律，并且假设实现遵守这些定律。这些法律也将在这里给出。\n"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:379
#, no-wrap
msgid "`Eq`"
msgstr "`Eq`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:389
#, no-wrap
msgid ""
"Probably the most often used interface, `Eq` corresponds to\n"
"interface `Equals` we used above as an example. Instead of\n"
"`eq` and `neq`, `Eq` provides two operators `(==)` and `(/=)`\n"
"for comparing two values of the same type for being equal\n"
"or not. Most of the data types defined in the *Prelude* come\n"
"with an implementation of `Eq`, and whenever programmers define\n"
"their own data types, `Eq` is typically one of the first\n"
"interfaces they implement.\n"
msgstr "可能是最常用的接口，`Eq`对应我们上面举例的接口`Equals`。代替 `eq` 和 `neq`，`Eq` 提供了两个运算符 `(==)` 和 `(/=)`比较两个相同类型的值是否相等。 *Prelude* 中定义的大多数数据类型都带有 `Eq` 的实现，每当程序员定义自己的数据类型时，`Eq` 通常是第一个他们实现的接口。\n"

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:390
#, no-wrap
msgid "`Eq` Laws"
msgstr "`Eq` 定律"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:393
#, no-wrap
msgid "We expect the following laws to hold for all implementations of `Eq`:\n"
msgstr "我们期望以下定律适用于 `Eq` 的所有实现：\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:396
#, no-wrap
msgid ""
"* `(==)` is *reflexive*: `x == x = True` for all `x`. This means, that\n"
"every value is equal to itself.\n"
msgstr "* `(==)` 具有 *自反性*：对于所有 `x`，`x == x = True`。这意味着每个值都等于它自己。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:399
#, no-wrap
msgid ""
"* `(==)` is *symmetric*: `x == y = y == x` for all `x` and `y`.\n"
"This means, that the order of arguments passed to `(==)` does not matter.\n"
msgstr ""
"* `(==)` 具有 *交换律*：对于所有 `x` 和 `y`，`x == y = y == x`。\n"
"这意味着，传递给 `(==)` 的参数顺序无关紧要。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:402
#, no-wrap
msgid ""
"* `(==)` is *transitive*: From `x == y = True` and `y == z = True` follows\n"
"`x == z = True`.\n"
msgstr "* `(==)` 具有 *传递性*：从 `x == y = True` 和 `y == z = True` 可以得出 `x == z = True`。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:405
#, no-wrap
msgid ""
"* `(/=)` is the negation of `(==)`: `x == y = not (x /= y)`\n"
"for all `x` and `y`.\n"
msgstr "* `(/=)` 是 `(==)` 的否定：对于所有 `x` 和 `y` 都有 `x == y = not (x /= y)` 。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:410
#, no-wrap
msgid ""
"In theory, Idris has the power to verify these laws at compile time\n"
"for many non-primitive types. However, out of pragmatism this is not\n"
"required when implementing `Eq`, since writing such proofs can be\n"
"quite involved.\n"
msgstr "理论上，Idris 有能力在编译时为许多非原始类型验证这些定律。但是，出于实用主义考虑，在实现 `Eq` 时不需要这样做，因为编写这样的证明可能非常复杂。\n"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:411
#, no-wrap
msgid "`Ord`"
msgstr "`Ord`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:419
#, no-wrap
msgid ""
"The pendant to `Comp` in the *Prelude* is interface `Ord`. In addition\n"
"to `compare`, which is identical to our own `comp` it provides comparison\n"
"operators `(>=)`, `(>)`, `(<=)`, and `(<)`, as well as utility functions\n"
"`max` and `min`. Unlike `Comp`, `Ord` extends `Eq`,\n"
"so whenever there is an `Ord` constraint, we also have access to operators\n"
"`(==)` and `(/=)` and related functions.\n"
msgstr "*Prelude* 中 `Comp` 的对应接口是 `Ord`。除了 `compare` 会与我们自己的 `comp` 相同之外，它还提供了比较运算符 `(>=)`、`(>)`、`(<=)` 和 `(<)`，以及工具函数 `max` 和 `min`。与 `Comp` 不同，`Ord` 扩展了 `Eq`，因此只要存在 `Ord` 约束，我们还可以访问运算符 `(= =)` 和 `(/=)` 及相关函数。\n"

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:420
#, no-wrap
msgid "`Ord` Laws"
msgstr "`Ord` 定律"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:423
#, no-wrap
msgid "We expect the following laws to hold for all implementations of `Ord`:\n"
msgstr "我们期望以下定律适用于 `Ord` 的所有实现：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:433
#, no-wrap
msgid "`(<=)` is *reflexive* and *transitive*.\n"
msgstr "`(<=)` 具有 *自反性* 和 *传递性*。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:433
#, no-wrap
msgid ""
"* `(<=)` is *antisymmetric*: From `x <= y = True` and `y <= x = True`\n"
"follows `x == y = True`.\n"
"* `x <= y = y >= x`.\n"
"* `x < y = not (y <= x)`\n"
"* `x > y = not (y >= x)`\n"
"* `compare x y = EQ` => `x == y = True`\n"
"* `compare x y == GT = x > y`\n"
"* `compare x y == LT = x < y`\n"
msgstr ""
"* `(<=)` 具有 *反对称性*：从 `x <= y = True` 和 `y <= x = True` 可以得到 `x == y = True`。\n"
"* `x <= y = y >= x`。\n"
"* `x < y = not (y <= x)`\n"
"* `x > y = not (y >= x)`\n"
"* `compare x y = EQ` => `x == y = True`\n"
"* `compare x y == GT = x > y`\n"
"* `compare x y == LT = x < y`\n"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:434
#, no-wrap
msgid "`Semigroup` and `Monoid`"
msgstr "`Semigroup` 和 `Monoid`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:439
#, no-wrap
msgid ""
"`Semigroup` is the pendant to our example interface `Concat`,\n"
"with operator `(<+>)` (also called *append*) corresponding\n"
"to function `concat`.\n"
msgstr "`Semigroup` 是我们示例接口 `Concat` 的附属物，运算符 `(<+>)`（也称为 *append*）对应于函数 `concat`。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:442
#, no-wrap
msgid ""
"Likewise, `Monoid` corresponds to `Empty`,\n"
"with `neutral` corresponding to `empty`.\n"
msgstr "同样，`Monoid` 对应 `Empty`，`neutral` 对应 `empty`。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:449
#, no-wrap
msgid ""
"These are incredibly important interfaces, which can be used\n"
"to combine two or more values of a data type into a single\n"
"value of the same type. Examples include but are not limited\n"
"to addition or multiplication\n"
"of numeric types, concatenation of sequences of data, or\n"
"sequencing of computations.\n"
msgstr "这些是非常重要的接口，可用于将数据类型的两个或多个值组合成同一类型的单个值。示例包括但不限于数字类型的加法或乘法、数据序列的串联或计算的序列。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:455
#, no-wrap
msgid ""
"As an example, consider a data type for representing\n"
"distances in a geometric application. We could just use `Double`\n"
"for this, but that's not very type safe. It would be better\n"
"to use a single field record wrapping values type `Double`,\n"
"to give such values clear semantics:\n"
msgstr "例如，考虑在几何应用程序中表示距离的数据类型。我们可以为此使用 `Double` ，但这不是很安全的类型。最好使用单个字段记录包装值类型 `Double`，以便为这些值提供清晰的语义：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:456
#, no-wrap
msgid ""
"record Distance where\n"
"  constructor MkDistance\n"
"  meters : Double\n"
msgstr ""
"record Distance where\n"
"  constructor MkDistance\n"
"  meters : Double\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:465
#, no-wrap
msgid ""
"There is a natural way for combining two distances: We sum up\n"
"the values they hold. This immediately leads to an implementation\n"
"of `Semigroup`:\n"
msgstr "有一种结合两个距离的自然方法：我们将它们持有的值相加。这就产生了 `Semigroup` 的实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:466
#, no-wrap
msgid ""
"Semigroup Distance where\n"
"  x <+> y = MkDistance $ x.meters + y.meters\n"
msgstr ""
"Semigroup Distance where\n"
"  x <+> y = MkDistance $ x.meters + y.meters\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:474
#, no-wrap
msgid ""
"It is also immediately clear, that zero is the neutral element of this\n"
"operation: Adding zero to any value does not affect the value at all.\n"
"This allows us to implement `Monoid` as well:\n"
msgstr "也很明显，零是此操作的中性元素：将零添加到任何值都不会影响该值。这也允许我们实现 `Monoid` ：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:475
#, no-wrap
msgid ""
"Monoid Distance where\n"
"  neutral = MkDistance 0\n"
msgstr ""
"Monoid Distance where\n"
"  neutral = MkDistance 0\n"

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:480
#, no-wrap
msgid "`Semigroup` and `Monoid` Laws"
msgstr "`Semigroup` 和 `Monoid` 定律"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:484
#, no-wrap
msgid ""
"We expect the following laws to hold for all implementations of `Semigroup`\n"
"and `Monoid`:\n"
msgstr "我们期望以下定律适用于 `Semigroup` 和 `Monoid` 的所有实现：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:489
#, no-wrap
msgid ""
"`(<+>)` is *associative*: `x <+> (y <+> z) = (x <+> y) <+> z`, for all\n"
"values `x`, `y`, and `z`.\n"
msgstr ""
"`(<+>)` 具有 *交换律*: 对于所有值 `x`、`y` 和 `z`，都有 `x <+> (y <+> z) = ("
"x <+> y) <+> z`,。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:489
#, no-wrap
msgid ""
"`neutral` is the *neutral element* with relation to `(<+>)`:\n"
"`neutral <+> x = x <+> neutral = x`, for all `x`.\n"
msgstr ""
"`neutral` 是 *中性元素* 与 `(<+>)` 的关系： `neutral <+> x = x <+> neutral = "
"x`，适用于所有 `x`。\n"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:490
#, no-wrap
msgid "`Show`"
msgstr "`Show`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:497
#, no-wrap
msgid ""
"The `Show` interface is mainly used for debugging purposes, and is\n"
"supposed to display values of a given type as a string, typically closely\n"
"resembling the Idris code used to create the value. This includes the\n"
"proper wrapping of arguments in parentheses where necessary. For instance,\n"
"experiment with the output of the following function at the REPL:\n"
msgstr "`Show` 接口主要用于调试目的，并且应该将给定类型的值显示为字符串，通常非常类似于用于创建值的 Idris 代码。这包括在必要时将参数正确包装在括号中。例如，在 REPL 中试验以下函数的输出：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:498
#, no-wrap
msgid ""
"showExample : Maybe (Either String (List (Maybe Integer))) -> String\n"
"showExample = show\n"
msgstr ""
"showExample : Maybe (Either String (List (Maybe Integer))) -> String\n"
"showExample = show\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:505
#, no-wrap
msgid ""
"Tutorial.Interfaces> showExample (Just (Right [Just 12, Nothing]))\n"
"\"Just (Right [Just 12, Nothing])\"\n"
msgstr ""
"Tutorial.Interfaces> showExample (Just (Right [Just 12, Nothing]))\n"
"\"Just (Right [Just 12, Nothing])\"\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:511
#, no-wrap
msgid "We will learn how to implement instances of `Show` in an exercise.\n"
msgstr "我们将在练习中学习如何实现 `Show` 的实例。\n"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:512
#, no-wrap
msgid "Overloaded Literals"
msgstr "字面量重载"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:524
#, no-wrap
msgid ""
"Literal values in Idris, such as integer literals (`12001`), string\n"
"literals (`\"foo bar\"`), floating point literals (`12.112`), and\n"
"character literals  (`'$'`) can be overloaded. This means, that we\n"
"can create values of types other than `String` from just a string\n"
"literal. The exact workings of this has to wait for another section,\n"
"but for many common cases, it is sufficient for a value to implement\n"
"interfaces `FromString` (for using string literals), `FromChar` (for using\n"
"character literals), or `FromDouble` (for using floating point literals).\n"
"The case of integer literals is special, and will be discussed in the next\n"
"section.\n"
msgstr "Idris 中的字面量，例如整数字面量 (`12001`)、字符串字面量 (`\"foo bar\"`)、浮点字面量 (`12.112`) 和字符字面量(`'$'`) 都可以重载。这意味着，我们可以仅从字符串字面量创建 `String` 以外的类型的值。其具体工作原理必须等待另一部分，但对于许多常见情况，一个值足以实现接口 `FromString`（用于使用字符串文字面量）、`FromChar`（用于使用字符字面量）或 `FromDouble` （用于使用浮点字面量）。整数字面量的情况很特殊，将在下一节中讨论。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:531
#, no-wrap
msgid ""
"Here is an example of using `FromString`. Assume, we write an application\n"
"where users can identify themselves with a username and password. Both\n"
"consist of strings of characters, so it is pretty easy to confuse and mix\n"
"up the two things, although they clearly have very different semantics.\n"
"In these cases, it is advisable to come up with new types for the two,\n"
"especially since getting these things wrong is a security concern.\n"
msgstr "这是使用 `FromString` 的示例。假设我们编写了一个应用程序，用户可以在其中使用用户名和密码来识别自己。两者都由字符串组成，因此很容易混淆这两件事，尽管它们显然具有非常不同的语义。在这些情况下，建议为这两种情况提供新类型，特别是因为弄错这些东西是一个安全问题。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:533
#, no-wrap
msgid "Here are three example record types to do this:\n"
msgstr "以下是执行此操作的三种示例记录类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:534
#, no-wrap
msgid ""
"record UserName where\n"
"  constructor MkUserName\n"
"  name : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : UserName\n"
"  password : Password\n"
msgstr ""
"record UserName where\n"
"  constructor MkUserName\n"
"  name : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : UserName\n"
"  password : Password\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:551
#, no-wrap
msgid ""
"In order to create a value of type `User`, even for testing, we'd have\n"
"to wrap all strings using the given constructors:\n"
msgstr "为了创建 `User` 类型的值，即使是为了测试，我们也必须使用给定的构造函数包装所有字符串：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:552
#, no-wrap
msgid ""
"hock : User\n"
"hock = MkUser (MkUserName \"hock\") (MkPassword \"not telling\")\n"
msgstr ""
"hock : User\n"
"hock = MkUser (MkUserName \"hock\") (MkPassword \"not telling\")\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:560
#, no-wrap
msgid ""
"This is rather cumbersome, and some people might think this to be too high\n"
"a price to pay just for an increase in type safety (I'd tend to disagree).\n"
"Luckily, we can get the convenience of string literals back very easily:\n"
msgstr "这是相当麻烦的，有些人可能认为这对于仅仅为了增加类型安全性而付出的代价太高了（我倾向于不同意）。幸运的是，我们可以很容易地恢复字符串字面量的便利性：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:561
#, no-wrap
msgid ""
"FromString UserName where\n"
"  fromString = MkUserName\n"
"\n"
"FromString Password where\n"
"  fromString = MkPassword\n"
"\n"
"hock2 : User\n"
"hock2 = MkUser \"hock\" \"not telling\"\n"
msgstr ""
"FromString UserName where\n"
"  fromString = MkUserName\n"
"\n"
"FromString Password where\n"
"  fromString = MkPassword\n"
"\n"
"hock2 : User\n"
"hock2 = MkUser \"hock\" \"not telling\"\n"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:572
#, no-wrap
msgid "Numeric Interfaces"
msgstr "数字接口"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:577
#, no-wrap
msgid ""
"The *Prelude* also exports several interfaces providing the usual arithmetic\n"
"operations. Below is a comprehensive list of the interfaces and the\n"
"functions each provides:\n"
msgstr "*Prelude* 还导出了几个提供常用算术运算的接口。下面是一个完整的接口列表和每个提供的函数：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:582
#, no-wrap
msgid "`Num`\n"
msgstr "`Num`\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
#, no-wrap
msgid "`(+)` : Addition\n"
msgstr "`(+)`：加法\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
#, no-wrap
msgid "`(*)` : Multiplication\n"
msgstr "`(*)`：乘法\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
#, no-wrap
msgid "`fromInteger` : Overloaded integer literals\n"
msgstr "`fromInteger` ：整数字面量的重载\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:586
#, no-wrap
msgid "`Neg`\n"
msgstr "`Neg`\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:586
#, no-wrap
msgid "`negate` : Negation\n"
msgstr "`negate` : 否定\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:586
#, no-wrap
msgid "`(-)` : Subtraction\n"
msgstr "`(-)`：减法\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:590
#, no-wrap
msgid "`Integral`\n"
msgstr "`Integral`\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:590
#, no-wrap
msgid "`div` : Integer division\n"
msgstr "`div `：整数除法。\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:590
#, no-wrap
msgid "`mod` : Modulo operation\n"
msgstr "`mod `：模运算\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:594
#, no-wrap
msgid "`Fractional`\n"
msgstr "`Fractional`\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:594
#, no-wrap
msgid "`(/)` : Division\n"
msgstr "`(/)`：除法\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:594
#, no-wrap
msgid "`recip` : Calculates the reciprocal of a value\n"
msgstr "`recip` : 计算值的倒数\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:599
#, no-wrap
msgid ""
"As you can see: We need to implement interface `Num` to\n"
"use integer literals for a given type. In order to use\n"
"negative integer literals like `-12`, we also have to\n"
"implement interface `Neg`.\n"
msgstr "如您所见：我们需要实现接口 `Num` 以对给定类型使用整数文字。为了使用像 `-12` 这样的负整数字面量，我们还必须实现接口 `Neg`。\n"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:600
#, no-wrap
msgid "`Cast`"
msgstr "`Cast`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:607
#, no-wrap
msgid ""
"The last interface we will quickly discuss in this section is `Cast`. It\n"
"is used to convert values of one type to values of another via\n"
"function `cast`. `Cast` is special, since it is parameterized\n"
"over *two* type parameters unlike the other interfaces we looked\n"
"at so far, with only one type parameter.\n"
msgstr "我们将在本节中快速讨论的最后一个接口是 `Cast`。它用于通过函数 `cast` 将一种类型的值转换为另一种类型的值。 `Cast` 是特殊的，因为它是通过 *两* 类型参数参数化的，这与我们目前看到的其他接口不同，只有一个类型参数。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:614
#, no-wrap
msgid ""
"So far, `Cast` is mainly used for interconversion\n"
"between primitive types in the standard libraries,\n"
"especially numeric types. When you look\n"
"at the implementations exported from the *Prelude* (for instance,\n"
"by invoking `:doc Cast` at the REPL), you'll see that there are\n"
"dozens of implementations for most pairings of primitive types.\n"
msgstr "到目前为止，`Cast`主要用于标准库中基本类型之间的相互转换，尤其是数值类型。当您查看从 *Prelude* 导出的实现时（例如，通过在 REPL 中调用 `:doc Cast`），您会看到几十个种原语类型的实现。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:623
#, no-wrap
msgid ""
"Although `Cast` would also be useful for other conversions (for\n"
"going from `Maybe` to `List` or for going from `Either e` to `Maybe`,\n"
"for instance), the *Prelude* and\n"
"*base* seem not to introduce these consistently. For instance,\n"
"there are `Cast` implementations from going from `SnocList` to\n"
"`List` and vice versa, but not for going from `Vect n` to `List`,\n"
"or for going from `List1` to `List`, although these would\n"
"be just as feasible.\n"
msgstr "尽管 `Cast` 也可用于其他转换（用于从 `Maybe` 到 `List` 或从 `Either e` 到 `Maybe`），*Prelude* 和 *base* 似乎没有一致地引入这些。例如，从 `SnocList` 到 `List` 有 `Cast` 实现，反之亦然，但没有从 `Vect n` 到 `List`，或者从 `List1` 到 `List`，尽管这些都是可行的。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:629
#, no-wrap
msgid ""
"These exercises are meant to make you comfortable with\n"
"implementing interfaces for your own data types, as you\n"
"will have to do so regularly when writing Idris code.\n"
msgstr "这些练习旨在让您熟悉为自己的数据类型实现接口，因为您在编写 Idris 代码时必须定期这样做。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:635
#, no-wrap
msgid ""
"While it is immediately clear why interfaces like\n"
"`Eq`, `Ord`, or `Num` are useful, the usability of\n"
"`Semigroup` and `Monoid` may be harder to appreciate at first.\n"
"Therefore, there are several exercises where you'll implement\n"
"different instances for these.\n"
msgstr "虽然很清楚为什么像 `Eq`、`Ord` 或 `Num` 这样的接口很有用，但 `Semigroup` 和 `Monoid` 的可用性一开始可能更难欣赏。因此，有几个练习可以为这些练习实现不同的实例。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Interfaces.md:639
#, no-wrap
msgid ""
"Define a record type `Complex` for complex numbers, by pairing\n"
"two values of type `Double`.\n"
"Implement interfaces `Eq`, `Num`, `Neg`, and `Fractional` for `Complex`.\n"
msgstr ""
"通过配对 `Double` 类型的两个值，为复数定义记录类型 `Complex`。为 `Complex` "
"实现接口 `Eq`、`Num`、`Neg` 和 `Fractional`。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Interfaces.md:643
#, no-wrap
msgid ""
"Implement interface `Show` for `Complex`. Have a look at data type `Prec`\n"
"and function `showPrec` and how these are used in the\n"
"*Prelude* to implement instances for `Either` and `Maybe`.\n"
msgstr ""
"为 `Complex` 实现接口 `Show`。查看数据类型 `Prec` 和函数 `showPrec` "
"以及如何使用它们来实现在 *Prelude* 中的 `Either` 和 `Maybe` 的实例。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:647
#, no-wrap
msgid ""
"   Verify the correct behavior of your implementation by wrapping\n"
"   a value of type `Complex` in a `Just` and `show` the result at\n"
"   the REPL.\n"
msgstr "   通过在 `Just` 和 `show` 中包装`Complex` 类型的值来实现，并在 REPL 中验证正确的行为。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Interfaces.md:649
#, no-wrap
msgid "Consider the following wrapper for optional values:\n"
msgstr "考虑以下可选值的包装器：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:650
#, no-wrap
msgid ""
"   record First a where\n"
"     constructor MkFirst\n"
"     value : Maybe a\n"
msgstr ""
"   record First a where\n"
"     constructor MkFirst\n"
"     value : Maybe a\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:660
#, no-wrap
msgid ""
"   Implement interfaces `Eq`, `Ord`, `Show`, `FromString`, `FromChar`, `FromDouble`,\n"
"   `Num`, `Neg`, `Integral`, and `Fractional` for `First a`. All of these will require\n"
"   corresponding constraints on type parameter `a`. Consider implementing and\n"
"   using the following utility functions where they make sense:\n"
msgstr "   实现接口 `Eq`, `Ord`, `Show`, `FromString`, `FromChar`, `FromDouble`, `Num`、`Neg`、`Integral` 和 `Fractional` 用于 `First a`。所有这些都需要类型参数 `a` 的相应约束。考虑在有意义的地方实现并使用以下实用函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:661
#, no-wrap
msgid ""
"   pureFirst : a -> First a\n"
"\n"
"   mapFirst : (a -> b) -> First a -> First b\n"
"\n"
"   mapFirst2 : (a -> b -> c) -> First a -> First b -> First c\n"
msgstr ""
"   pureFirst : a -> First a\n"
"\n"
"   mapFirst : (a -> b) -> First a -> First b\n"
"\n"
"   mapFirst2 : (a -> b -> c) -> First a -> First b -> First c\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Interfaces.md:673
#, no-wrap
msgid ""
"Implement interfaces `Semigroup` and `Monoid` for `First a` in such a way,\n"
"that `(<+>)` will return the first non-nothing argument and `neutral` is\n"
"the corresponding neutral element. There must be no constraints on type\n"
"parameter `a` in these implementations.\n"
msgstr ""
"为 `First a` 实现接口 `Semigroup` 和 `Monoid`，使 `(<+>)` "
"返回第一个非空参数， `neutral` 是相应的中性元素。在这些实现中，类型参数 `a` "
"必须没有约束。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Interfaces.md:676
#, no-wrap
msgid ""
"Repeat exercises 3 and 4 for record `Last`. The `Semigroup` implementation\n"
"should return the last non-nothing value.\n"
msgstr "对记录 `Last` 重复练习 3 和 4。 `Semigroup` 实现应该返回最后一个非空值。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:677
#, no-wrap
msgid ""
"   record Last a where\n"
"     constructor MkLast\n"
"     value : Maybe a\n"
msgstr ""
"   record Last a where\n"
"     constructor MkLast\n"
"     value : Maybe a\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Interfaces.md:687
#, no-wrap
msgid ""
"Function `foldMap` allows us to map a function returning a `Monoid` over\n"
"a list of values and accumulate the result using `(<+>)` at the same time.\n"
"This is a very powerful way to accumulate the values stored in a list.\n"
"Use `foldMap` and `Last` to extract the last element (if any) from a list.\n"
msgstr ""
"函数 `foldMap` 允许我们将返回 `Monoid` 的函数映射到值列表上，并同时使用 "
"`(<+>)` 累加结果。这是累积存储在列表中的值的一种非常有效的方法。使用 "
"`foldMap` 和 `Last` 从列表中提取最后一个元素（如果有）。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:692
#, no-wrap
msgid ""
"   Note, that the type of `foldMap` is more general and not specialized\n"
"   to lists only. It works also for `Maybe`, `Either` and other container\n"
"   types we haven't looked at so far. We will learn about\n"
"   interface `Foldable` in a later section.\n"
msgstr "   请注意，`foldMap` 的类型更通用，不是专门用于列表的。它也适用于 `Maybe`、`Either` 和到目前为止我们还没有看过的其它容器类型。在后面的部分我们将了解接口 `Foldable` 。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Interfaces.md:694
#, no-wrap
msgid "Consider record wrappers `Any` and `All` for boolean values:\n"
msgstr "考虑记录包装器 `Any` 和 `All` 用于布尔值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:695
#, no-wrap
msgid ""
"   record Any where\n"
"     constructor MkAny\n"
"     any : Bool\n"
"\n"
"   record All where\n"
"     constructor MkAll\n"
"     all : Bool\n"
msgstr ""
"   record Any where\n"
"     constructor MkAny\n"
"     any : Bool\n"
"\n"
"   record All where\n"
"     constructor MkAll\n"
"     all : Bool\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:708
#, no-wrap
msgid ""
"   Implement `Semigroup` and `Monoid` for `Any`, so that the result of\n"
"   `(<+>)` is `True`, if and only if at least one of the arguments is `True`.\n"
"   Make sure that `neutral` is indeed the neutral element for this operation.\n"
msgstr "   对 `Any` 实现 `Semigroup` 和 `Monoid`，仅当至少一个参数是 `True` 时，`(<+>)` 的结果是 `True`。确保 `neutral` 确实是此操作的中性元素。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:712
#, no-wrap
msgid ""
"   Likewise, implement `Semigroup` and `Monoid` for `All`, so that the result of\n"
"   `(<+>)` is `True`, if and only if both of the arguments are `True`.\n"
"   Make sure that `neutral` is indeed the neutral element for this operation.\n"
msgstr "   同样，为 `All` 实现 `Semigroup` 和 `Monoid`，当且仅当两个参数都是 `True`， `(<+>)` 的结果为 `True`，确保 `neutral` 确实是此操作的中性元素。\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Interfaces.md:715
#, no-wrap
msgid ""
"Implement functions `anyElem` and `allElems` using `foldMap` and\n"
"`Any` or `All`, respectively:\n"
msgstr "分别使用 `foldMap` 为 `Any` 或 `All` 实现函数 `anyElem` 和 `allElems`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:716
#, no-wrap
msgid ""
"   -- True, if the predicate holds for at least one element\n"
"   anyElem : (a -> Bool) -> List a -> Bool\n"
"\n"
"   -- True, if the predicate holds for all elements\n"
"   allElems : (a -> Bool) -> List a -> Bool\n"
msgstr ""
"   -- True, if the predicate holds for at least one element\n"
"   anyElem : (a -> Bool) -> List a -> Bool\n"
"\n"
"   -- True, if the predicate holds for all elements\n"
"   allElems : (a -> Bool) -> List a -> Bool\n"

#. type: Bullet: '9. '
#: ../src/Tutorial/Interfaces.md:726
#, no-wrap
msgid ""
"Record wrappers `Sum` and `Product` are mainly used to hold\n"
"numeric types.\n"
msgstr "记录包装器 `Sum` 和 `Product` 主要用于保存数字类型。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:727
#, no-wrap
msgid ""
"   record Sum a where\n"
"     constructor MkSum\n"
"     value : a\n"
"\n"
"   record Product a where\n"
"     constructor MkProduct\n"
"     value : a\n"
msgstr ""
"   record Sum a where\n"
"     constructor MkSum\n"
"     value : a\n"
"\n"
"   record Product a where\n"
"     constructor MkProduct\n"
"     value : a\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:739
#, no-wrap
msgid ""
"   Given an implementation of `Num a`, implement `Semigroup (Sum a)`\n"
"   and `Monoid (Sum a)`, so that `(<+>)` corresponds to addition.\n"
msgstr ""
"   给定 `Num a` 的实现，实现 `Semigroup (Sum a)`\n"
"   和 `Monoid (Sum a)`，因此 `(<+>)` 对应于加法。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:742
#, no-wrap
msgid ""
"   Likewise, implement `Semigroup (Product a)` and `Monoid (Product a)`,\n"
"   so that `(<+>)` corresponds to multiplication.\n"
msgstr ""
"   同样，实现 `Semigroup (Product a)` 和 `Monoid (Product a)`，\n"
"   因此 `(<+>)` 对应于乘法。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:745
#, no-wrap
msgid ""
"   When implementing `neutral`, remember that you can use integer\n"
"   literals when working with numeric types.\n"
msgstr "   在实现 `neutral` 时，在处理数字类型时，可以使用整数字面量。\n"

#. type: Bullet: '10. '
#: ../src/Tutorial/Interfaces.md:748
#, no-wrap
msgid ""
"Implement `sumList` and `productList` by using `foldMap` together\n"
"with the wrappers from Exercise 9:\n"
msgstr "通过使用 `foldMap` 和练习 9 中的包装器来实现 `sumList` 和 `productList`：\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:751
#, no-wrap
msgid ""
"    ```idris\n"
"    sumList : Num a => List a -> a\n"
msgstr ""
"    ```idris\n"
"    sumList : Num a => List a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:754
#, no-wrap
msgid ""
"    productList : Num a => List a -> a\n"
"    ```\n"
msgstr ""
"    productList : Num a => List a -> a\n"
"    ```\n"

#. type: Bullet: '11. '
#: ../src/Tutorial/Interfaces.md:760
#, no-wrap
msgid ""
"To appreciate the power and versatility of `foldMap`, after\n"
"solving exercises 6 to 10 (or by loading `Solutions.Inderfaces`\n"
"in a REPL session), run the following at the REPL, which will -\n"
"in a single list traversal! - calculate the first and last\n"
"element of the list as well as the sum and product of all values.\n"
msgstr ""
"要了解 `foldMap` 的强大功能和多功能性，在解决练习 6 到 10 之后（或通过在 "
"REPL 会话中加载 `Solutions.Inderfaces`），在 REPL 中运行以下命令，这将 "
"在单列表中遍历！ - 计算列表的第一个和最后一个元素以及所有值的总和和乘积。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:765
#, no-wrap
msgid ""
"    ```repl\n"
"    > foldMap (\\x => (pureFirst x, pureLast x, MkSum x, MkProduct x)) [3,7,4,12]\n"
"    (MkFirst (Just 3), (MkLast (Just 12), (MkSum 26, MkProduct 1008)))\n"
"    ```\n"
msgstr ""
"    ```repl\n"
"    > foldMap (\\x => (pureFirst x, pureLast x, MkSum x, MkProduct x)) [3,7,4,12]\n"
"    (MkFirst (Just 3), (MkLast (Just 12), (MkSum 26, MkProduct 1008)))\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:772
#, no-wrap
msgid ""
"    Note, that there are also `Semigroup` implementations for\n"
"    types with an `Ord` implementation, which will return\n"
"    the smaller or larger of two values. In case of types\n"
"    with an absolute minimum or maximum (for instance, 0 for\n"
"    natural numbers, or 0 and 255 for `Bits8`), these can even\n"
"    be extended to `Monoid`.\n"
msgstr "    请注意，对于具有 `Ord` 实现，也有 `Semigroup` 实现的类型，它将返回两个值中的较小值或较大值。对于具有绝对最小值或最大值的类型（例如，自然数中的0，或 `Bits8` 中的 0 和 255），还可以可以被可以扩展到为 `Monoid`。\n"

#. type: Bullet: '12. '
#: ../src/Tutorial/Interfaces.md:778
#, no-wrap
msgid ""
"In an earlier exercise, you implemented a data type representing\n"
"chemical elements and wrote a function for calculating their\n"
"atomic masses. Define a new single field record type for\n"
"representing atomic masses, and implement interfaces\n"
"`Eq`, `Ord`, `Show`, `FromDouble`, `Semigroup`, and `Monoid` for this.\n"
msgstr ""
"在之前的练习中，您实现了一个表示化学元素的数据类型并编写了一个用于计算其原子"
"质量的函数。定义一个新的单字段记录类型来表示原子质量，并为它实现接口 `Eq`, "
"`Ord`, `Show`, `FromDouble`, `Semigroup` 和 `Monoid` 。\n"

#. type: Bullet: '13. '
#: ../src/Tutorial/Interfaces.md:782
#, no-wrap
msgid ""
"Use the new data type from exercise 12 to calculate the atomic\n"
"mass of an element and compute the molecular mass\n"
"of a molecule given by its formula.\n"
msgstr "使用练习 12 "
"中的新数据类型来计算元素的原子质量并计算由其公式给出的分子的分子质量。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:785
#, no-wrap
msgid ""
"    Hint: With a suitable utility function, you can use `foldMap`\n"
"    once again for this.\n"
msgstr "    提示：使用合适的实用程序函数，您可以再次使用 `foldMap` 来实现此目的。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:791
#, no-wrap
msgid ""
"Final notes: If you are new to functional programming, make sure\n"
"to give your implementations of exercises 6 to 10 a try at the REPL.\n"
"Note, how we can implement all of these functions with a minimal amount\n"
"of code and how, as shown in exercise 11, these behaviors can be\n"
"combined in a single list traversal.\n"
msgstr "最后注意事项：如果您是函数式编程的新手，请确保在 REPL 中尝试您的练习 6 到 10 的实现。请注意，我们如何用最少的代码实现所有这些功能，以及如练习 11 所示，如何将这些行为组合在一个列表遍历中。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
#, no-wrap
msgid ""
"Interfaces allow us to implement the same function with different\n"
"behavior for different types.\n"
msgstr "接口允许我们为不同类型实现具有不同行为的相同功能。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
#, no-wrap
msgid ""
"Functions taking one or more interface implementations as\n"
"arguments are called *constrained functions*.\n"
msgstr "将一个或多个接口实现作为参数的函数称为*约束函数*。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
#, no-wrap
msgid ""
"Interfaces can be organized hierarchically by *extending*\n"
"other interfaces.\n"
msgstr "接口可以通过*扩展*其他接口来组织层次。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
#, no-wrap
msgid ""
"Interfaces implementations can themselves be *constrained*\n"
"requiring other implementations to be available.\n"
msgstr "接口实现本身可以具有*约束*，需要其他实现可用。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
#, no-wrap
msgid ""
"Interface functions can be given a *default implementation*,\n"
"which can be overridden by implementers, for instance for reasons\n"
"of efficiency.\n"
msgstr "接口函数可以被赋予一个*默认实现*，它可以被实现者覆盖，例如出于效率的原因。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
#, no-wrap
msgid ""
"Certain interfaces allow us to use literal values such as\n"
"string or integer literals for our own data types.\n"
msgstr "某些接口允许我们为我们自己的数据类型使用字符串或整数等字面量。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:812
#, no-wrap
msgid ""
"Note, that I did not yet tell the whole story about literal values\n"
"in this section. More details for using literals with types that\n"
"accept only a restricted set of values can be found in the\n"
"chapter about [primitives](Prim.md).\n"
msgstr "请注意，我还没有在本节中讲述有关字面量的全部故事。关于使用只接受一组受限值的类型的字面量的更多细节可以在关于 [原语](Prim.md) 章节中找到。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:819
#, no-wrap
msgid ""
"In the [next chapter](Functions2.md), we have a closer look\n"
"at functions and their types. We will learn about named arguments,\n"
"implicit arguments, and erased arguments as well as some\n"
"constructors for implementing more complex functions.\n"
msgstr "在 [下一章](Functions2.md) 中，我们将仔细研究函数及其类型。我们将学习命名参数、隐式参数和擦除参数以及一些用于实现更复杂函数的构造函数。\n"

#. type: Title #
#: ../src/Tutorial/Intro.md:1
#, no-wrap
msgid "Introduction"
msgstr "介绍"

#. type: Plain text
#: ../src/Tutorial/Intro.md:15
#, no-wrap
msgid ""
"Welcome to my Idris 2 tutorial. I'll try and treat as many aspects\n"
"of the Idris 2 programming language as possible here.\n"
"All `.md` files in here a literate Idris files: They consist of\n"
"Markdown (hence the `.md` ending), which is being pretty printed\n"
"by GitHub together with Idris code blocks, which can be\n"
"type checked and built by the Idris compiler (more on this later).\n"
"Note, however, that regular Idris source files use an `.idr` ending,\n"
"and that you go with that file type unless you end up writing\n"
"much more prose than code as I do at the moment. Later in this\n"
"tutorial, you'll have to solve some exercises, the solutions of\n"
"which can be found in the `src/Solutions` subfolder. There, I\n"
"use regular `.idr` files.\n"
msgstr "欢迎来到我的 Idris 2 教程。我将在这里尽可能多地处理 Idris 2 编程语言的各个方面。这里的每个 `.md` 文件都是一个 Idris 的文学编程文件：它们由 Markdown 组成（因此以 `.md` 结尾），Idris 代码块会被 GitHub 美观的打印出来，同时也可以由 Idris 编译器进行类型检查和构建（稍后会详细介绍）。但是请注意，常规的 Idris 源文件使用 `.idr` 结尾，并且除非您最终编写的代码比我现在所做的更复杂，否则您将继续使用本文件类型。在本教程的后面，您将需要解答一些习题，这些习题的答案可以在 `src/Solutions` 文件夹中找到。在那里，我会使用常规的 `.idr` 文件。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:19
#, no-wrap
msgid ""
"Every Idris source file should typically start with a module\n"
"name plus some necessary imports, and this document is no\n"
"exception:\n"
msgstr "每个 Idris 源文件通常应该以模块名称和一些必要的导入开头，本文档也不例外。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:20
#, no-wrap
msgid "module Tutorial.Intro\n"
msgstr "module Tutorial.Intro\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:27
#, no-wrap
msgid ""
"A module name consists of a list of identifiers separated\n"
"by dots and must reflect the folder structure plus the module\n"
"file's name.\n"
msgstr "模块名称由以点分隔的标识符列表组成，并且必须反映文件夹结构加上模块文件的名称。\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:28
#, no-wrap
msgid "About the Idris Programming Language"
msgstr "关于 Idris 编程语言"

#. type: Plain text
#: ../src/Tutorial/Intro.md:33
#, no-wrap
msgid ""
"Idris is a *pure*, *dependently typed*, *total* *functional*\n"
"programming language. I'll quickly explain each of these adjectives\n"
"in this section.\n"
msgstr "Idris 是一种具有*依赖类型*的、*完全*的*纯**函数式*编程语言。我将在本节中快速解释这些形容词。\n"

#. type: Title ###
#: ../src/Tutorial/Intro.md:34
#, no-wrap
msgid "Functional Programming"
msgstr "函数式编程"

#. type: Plain text
#: ../src/Tutorial/Intro.md:42
#, no-wrap
msgid ""
"In functional programming languages, functions are first-class\n"
"constructs, meaning that they can be assigned to variables,\n"
"passed as arguments to other functions, and returned as results\n"
"from functions. Unlike for instance in\n"
"object-oriented programming languages, in functional programming,\n"
"functions are the main form of abstraction.\n"
msgstr "在函数式编程语言中，函数是一等结构，这意味着它们可以分配给变量，作为参数传递给其他函数，并作为函数的结果返回。与面向对象的编程语言不同，在函数式编程中，函数是抽象的主要形式。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:46
#, no-wrap
msgid ""
"Functional programming languages are concerned with the evaluation\n"
"of functions, unlike classical imperative languages, which are\n"
"concerned with the execution of statements.\n"
msgstr "函数式编程语言关注函数的求值，不像经典的命令式语言关注语句的执行。\n"

#. type: Title ###
#: ../src/Tutorial/Intro.md:47
#, no-wrap
msgid "Pure Functional Programming"
msgstr "纯函数式编程"

#. type: Plain text
#: ../src/Tutorial/Intro.md:57
#, no-wrap
msgid ""
"Pure functional programming languages come with an additional\n"
"important guarantee: Functions don't have side effects like\n"
"writing to a file or mutating global state. They can only\n"
"compute a result from their arguments possibly by invoking other\n"
"pure functions, *and nothing else*. As a consequence, given\n"
"the same input, they will *always* generate the same output.\n"
"This property is known as\n"
"[referential transparency](https://en.wikipedia.org/wiki/Referential_transparency).\n"
msgstr "纯函数式编程语言有一个额外的重要保证：函数不会产生像写入文件或改变全局状态这样的副作用。他们只能通过调用其他纯函数，给定参数来获取计算结果，*而没有其它的途径*。因此，给定相同的输入，它们将*总是*生成相同的输出。此属性称为 [引用透明](https://en.wikipedia.org/wiki/Referential_transparency)。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:59
#, no-wrap
msgid "Pure functions have several advantages:\n"
msgstr "纯函数有几个优点：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:62
#, no-wrap
msgid ""
"They can easily be tested by specifying (possibly randomly generated)\n"
"sets of input arguments together with the expected results.\n"
msgstr "它们可以通过指定（可能是随机生成的）输入参数集以及预期结果来轻松测试。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:66
#, no-wrap
msgid ""
"They are thread-safe, since the don't mutate global state, and\n"
"as such can be freely used in several computations running\n"
"in parallel.\n"
msgstr "它们是线程安全的，因为不会改变全局状态，因此可以在并行运行的多个计算中自由使"
"用。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:68
#, no-wrap
msgid "There are, of course, also some disadvantages:\n"
msgstr "当然，也有一些缺点：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:71
#, no-wrap
msgid ""
"Some algorithms are hard to implement efficiently using\n"
"only pure functions.\n"
msgstr "仅使用纯函数很难有效地实现某些算法。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:75
#, no-wrap
msgid ""
"Writing programs that actually *do* something\n"
"(have some observable effect) is a bit trickier but certainly\n"
"possible.\n"
msgstr "编写实际上*做*某些事情（具有一些可观察到的效果）的程序有点棘手，但肯定是可能"
"的。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:83
#, no-wrap
msgid ""
"Idris is a strongly, statically typed programming language. This\n"
"means, that ever Idris expression is given a *type* (for instance:\n"
"integer, list of strings, boolean, function from integer to boolean, etc.)\n"
"and types are verified at compile time to rule out certain\n"
"common programming errors.\n"
msgstr "Idris 是一种强静态类型的编程语言。这意味着，给 Idris 表达式一个*类型*（例如：整数、字符串列表、布尔值、从整数到布尔值的函数等），并且在编译时验证类型以排除某些常见的编程错误。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:89
#, no-wrap
msgid ""
"For instance, if a function expects an argument of type `String`\n"
"(a sequence of unicode characters, such as `\"Hello123\"`), it\n"
"is a *type error* to invoke this function with an argument of\n"
"type `Integer`, and the Idris compiler will refuse to\n"
"generate an executable from such an ill-typed program.\n"
msgstr "例如，如果一个函数需要 `String` 类型的参数（Unicode 字符序列，例如 `\"Hello123\"`），使用 `Integer` 类型的参数调用此函数是*类型错误*的，Idris 编译器将拒绝从此类错误类型的程序生成可执行文件。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:97
#, no-wrap
msgid ""
"Even more, Idris is *dependently typed*, which is one of its most\n"
"characteristic properties in the landscape of programming\n"
"languages. In Idris, types are *first class*: Types can be passed\n"
"as arguments to functions, and functions can return types as\n"
"their results. Even more, types can *depend* on other *values*.\n"
"What this means, and why this is incredibly useful, we'll explore\n"
"in due time.\n"
msgstr "更重要的是，Idris 具有*依赖类型*，这是它在编程语言领域中最具特色的属性之一。在 Idris 中，类型是*一等*的：类型可以作为参数传递给函数，函数可以返回类型作为结果。更重要的是，类型可以*依赖于*其他*值*。这意味着什么，以及为什么这非常有用，我们将在适当的时候进行探索。\n"

#. type: Title ###
#: ../src/Tutorial/Intro.md:98
#, no-wrap
msgid "Total Functions"
msgstr "全函数"

#. type: Plain text
#: ../src/Tutorial/Intro.md:104
#, no-wrap
msgid ""
"A *total* function is a pure function, that is guaranteed to return\n"
"a value of the expected return type for every possible input in\n"
"a finite amount of time. A total function will never fail with an\n"
"exception or loop infinitely.\n"
msgstr "*全*函数是一个纯函数，它保证在有限的时间内为每个可能的输入返回一个预期返回类型的值。一个全函数永远不会因异常或无限循环而失败。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:113
#, no-wrap
msgid ""
"Idris comes with a totality checker built in, which enables us to\n"
"verify the functions we write to be provably total. Totality\n"
"in Idris is opt-in, as in general, checking the totality of\n"
"an arbitrary computer program is undecidable\n"
"(see also the [halting problem](https://en.wikipedia.org/wiki/Halting_problem)).\n"
"However, if we annotate a function with the `total` keyword,\n"
"Idris will fail with a type error, if its totality checker\n"
"cannot verify that the function in question is indeed total.\n"
msgstr "Idris 内置了一个完全性检查器，它使我们能够验证我们编写的函数是否是可证明的完全性。 Idris 中的完全性是可选的，因为一般来说，检查任意计算机程序的完全性是无法确定的（另请参见 [停机问题](https://en.wikipedia.org/wiki/Halting_problem)）。但是，如果我们使用 `total` 关键字注释函数，如果 Idris 的完全性检查器无法验证所讨论的函数确实是完全的，则 Idris 将失败并出现类型错误。\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:114
#, no-wrap
msgid "Using the REPL"
msgstr "使用 REPL"

#. type: Plain text
#: ../src/Tutorial/Intro.md:121
#, no-wrap
msgid ""
"Idris comes with a useful REPL (an acronym for *Read Evaluate\n"
"Print Loop*), which we will use for tinkering with small\n"
"ideas, and for quickly experimenting with the code we just wrote.\n"
"In order to start a REPL session, run the following command\n"
"in a terminal.\n"
msgstr "Idris 附带了一个有用的 REPL（*Read Evaluate Print Loop* 的首字母缩写词），我们将使用它来修补小想法，并快速试验我们刚刚编写的代码。要启动 REPL 会话，请在终端中运行以下命令。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:122
#, no-wrap
msgid "rlwrap idris2\n"
msgstr "rlwrap idris2\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:131
#, no-wrap
msgid ""
"(Using command-line utility `rlwrap` is optional. It\n"
"leads to a somewhat nicer user experience, as it allows us\n"
"to use the up and down arrow keys to scroll through a history\n"
"of commands and expressions we entered. It should be available\n"
"for most Linux distributions.)\n"
msgstr "（使用命令行实用程序 `rlwrap` 是可选的。它带来了更好的用户体验，因为它允许我们使用向上和向下箭头键滚动浏览我们输入的命令和表达式的历史记录。它应该适用于大多数 Linux 发行版。）\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:133
#, no-wrap
msgid "Idris should now be ready to accept you commands:\n"
msgstr "Idris 现在应该准备好接受你的命令了：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:134
#, no-wrap
msgid ""
"     ____    __     _         ___\n"
"    /  _/___/ /____(_)____   |__ \\\n"
"    / // __  / ___/ / ___/   __/ /     Version 0.5.1-3c532ea35\n"
"  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org\n"
" /___/\\__,_/_/  /_/____/   /____/      Type :? for help\n"
"\n"
"Welcome to Idris 2.  Enjoy yourself!\n"
"Main>\n"
msgstr ""
"     ____    __     _         ___\n"
"    /  _/___/ /____(_)____   |__ \\\n"
"    / // __  / ___/ / ___/   __/ /     Version 0.5.1-3c532ea35\n"
"  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org\n"
" /___/\\__,_/_/  /_/____/   /____/      Type :? for help\n"
"\n"
"Welcome to Idris 2.  Enjoy yourself!\n"
"Main>\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:147
#, no-wrap
msgid ""
"We can go ahead and enter some simple arithmetic expressions. Idris\n"
"will *evaluate* these and print the result:\n"
msgstr "我们可以继续输入一些简单的算术表达式。 Idris 将进行*求值*并打印结果：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:148
#, no-wrap
msgid ""
"Main> 2 * 4\n"
"8\n"
"Main> 3 * (7 + 100)\n"
"321\n"
msgstr ""
"Main> 2 * 4\n"
"8\n"
"Main> 3 * (7 + 100)\n"
"321\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:157
#, no-wrap
msgid ""
"Since every expression in Idris has an associated *type*,\n"
"we might want to inspect these as well:\n"
msgstr "由于 Idris 中的每个表达式都有一个关联的*类型*，我们可能还想检查这些：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:158
#, no-wrap
msgid ""
"Main> :t 2\n"
"2 : Integer\n"
msgstr ""
"Main> :t 2\n"
"2 : Integer\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:166
#, no-wrap
msgid ""
"Here `:t` is a command of the Idris REPL (it is not part of the\n"
"Idris programming language), and it is used to inspect the type\n"
"of an expression.\n"
msgstr "这里的 `:t` 是 Idris REPL 的命令（它不是 Idris 编程语言的一部分），它用于检查表达式的类型。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:167
#, no-wrap
msgid ""
"Main> :t 2 * 4\n"
"2 * 4 : Integer\n"
msgstr ""
"Main> :t 2 * 4\n"
"2 * 4 : Integer\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:182
#, no-wrap
msgid ""
"Whenever we perform calculations with integer literals without\n"
"being explicit about the types we want to use, Idris will\n"
"use `Integer` as a default. `Integer` is an arbitrary precision\n"
"signed integer type. It is one of the *primitive types* built\n"
"into the language. Other primitives include fixed precision\n"
"signed and unsigned integral types (`Bits8`, `Bits16`, `Bits32`\n"
"`Bits64`, `Int8`, `Int16`, `Int32`, and `Int64`), double\n"
"precision (64 bit) floating point numbers (`Double`), unicode\n"
"characters (`Char`) and strings of unicode characters (`String`).\n"
"We will use many of these in due time.\n"
msgstr "每当我们使用整数字面量执行计算而没有明确说明我们想要使用的类型时，Idris 将使用 `Integer` 作为默认值。 `Integer` 是任意精度的有符号整数类型。它是语言中内置的*原语类型*之一。其他原语包括固定精度有符号和无符号整数类型（`Bits8`、`Bits16`、`Bits32` `Bits64`、`Int8`、 `Int16`、`Int32` 和 `Int64`）、双精度（64 位）浮点数（`Double`）、Unicode 字符（`Char`) 和 Unicode 字符串 (`String`)。我们将在适当的时候会使用到大多数。\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:183
#, no-wrap
msgid "A First Idris Program"
msgstr "第一个 Idris 程序"

#. type: Plain text
#: ../src/Tutorial/Intro.md:190
#, no-wrap
msgid ""
"We will often start up a REPL for tinkering with small parts\n"
"of the Idris language, for reading some documentation, or\n"
"for inspecting the content of an Idris module, but now we will\n"
"write a minimal Idris program to get started with\n"
"the language. Here comes the mandatory *Hello World*:\n"
msgstr "我们经常会启动一个 REPL 来修补 Idris 语言的一小部分，阅读一些文档，或检查 Idris 模块的内容，但现在我们将编写一个最小的 Idris 程序来开始使用该语言。这是强制性的 *Hello World*：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:191
#, no-wrap
msgid ""
"main : IO ()\n"
"main = putStrLn \"Hello World!\"\n"
msgstr ""
"main : IO ()\n"
"main = putStrLn \"Hello World!\"\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:199
#, no-wrap
msgid ""
"We will inspect the code above in some detail in a moment,\n"
"but first we'd like to compile and run it. From this project's\n"
"root directory, run the following:\n"
msgstr "稍后我们将详细检查上面的代码，但首先我们要编译并运行它。在此项目的根目录中，运行以下命令：\n"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:199
#, no-wrap
msgid "idris2 --find-ipkg -o hello src/Tutorial/Intro.md\n"
msgstr "idris2 --find-ipkg -o hello src/Tutorial/Intro.md\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:207
#, no-wrap
msgid ""
"This will create executable `hello` in directory `build/exec`,\n"
"which can be invoked from the command-line like so (without the\n"
"dollar prefix; this is used here to distinguish the terminal command\n"
"from its output):\n"
msgstr "这将在目录 `build/exec` 中创建可执行文件 `hello`，可以像这样从命令行调用它（没有美元前缀；这里用来区分终端命令和它的输出）：\n"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:208
#, no-wrap
msgid ""
"$ build/exec/hello\n"
"Hello World!\n"
msgstr ""
"$ build/exec/hello\n"
"Hello World!\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:219
#, no-wrap
msgid ""
"The `--find-ipkg` option will look for an `.ipkg` file in the\n"
"current directory or one of its parent directories, from which\n"
"it will get other settings like the source directory to use\n"
"(`src` in our case). The `-o` option gives the name of the\n"
"executable to be generated. Type `idris2 --help` for a list\n"
"of available command-line options and environment variables.\n"
msgstr "`--find-ipkg` 选项将在当前目录或其父目录之一中查找 `.ipkg` 文件，从中获取其他设置，如要使用的源码目录（在我们的例子中是 `src`）。 `-o` 选项给出要生成的可执行文件的名称。输入 `idris2 --help` 以获取可用命令行选项和环境变量的列表。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:222
#, no-wrap
msgid ""
"As an alternative, you can also load this source file in a REPL\n"
"session and invoke function `main` from there:\n"
msgstr "作为替代方案，您还可以在 REPL 会话中加载此源文件并从那里调用函数 `main`：\n"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:223
#, no-wrap
msgid "rlwrap idris2 --find-ipkg src/Tutorial/Intro.md\n"
msgstr "rlwrap idris2 --find-ipkg src/Tutorial/Intro.md\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:227
#, no-wrap
msgid ""
"Tutorial.Intro> :exec main\n"
"Hello World!\n"
msgstr ""
"Tutorial.Intro> :exec main\n"
"Hello World!\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:234
#, no-wrap
msgid ""
"Go ahead and try both ways of building and running function `main`\n"
"on your system!\n"
msgstr "继续尝试在您的系统上构建和运行函数 `main` 的两种方法！\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:239
#, no-wrap
msgid ""
"Note: It might be instructive to omit the `--find-ipkg` option.\n"
"You will get an error message about the module name `Tutorial.Intro`\n"
"not matching the file path `src/Tutorial/Intro.md`. You can\n"
"also use option `--source-dir src` to silence this error.\n"
msgstr "注意：省略 `--find-ipkg` 选项可能会有帮助。因为您将收到有关模块名称 `Tutorial.Intro` 与文件路径 `src/Tutorial/Intro.md` 不匹配的错误信息。您还可以使用选项 `--source-dir src` 来消除此错误。\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:240
#, no-wrap
msgid "The Shape of an Idris Definition"
msgstr "如何声明一个 Idris 定义"

#. type: Plain text
#: ../src/Tutorial/Intro.md:244
#, no-wrap
msgid ""
"Now that we executed our first Idris program, we will talk\n"
"a bit more about the code we had to write to define it.\n"
msgstr "现在我们执行了第一个 Idris 程序，接下来我们将更多地讨论我们如何编写代码来定义它。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:251
#, no-wrap
msgid ""
"A typical top level function in Idris consists of three things:\n"
"The function's name (`main` in our case), its type (`IO ()`)\n"
"plus its implementation (`putStrLn \"Hello World\"`). It is easier\n"
"to explain these things with a couple of simple examples. Below,\n"
"we define a top level constant for the largest unsigned eight bit\n"
"integer:\n"
msgstr "Idris 中一个典型的顶级函数由三部分组成：函数的名称（在我们的例子中是 `main`），它的类型（`IO ()`）加上它的实现（`putStrLn \"你好世界”`）。用几个简单的例子来解释这些事情会更容易。下面，我们为最大的无符号八位整数定义一个顶级常量：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:252
#, no-wrap
msgid ""
"maxBits8 : Bits8\n"
"maxBits8 = 255\n"
msgstr ""
"maxBits8 : Bits8\n"
"maxBits8 = 255\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:266
#, no-wrap
msgid ""
"The first line can be read as: \"We'd like to declare  (nullary)\n"
"function `maxBits8`. It is of type `Bits8`\". This is\n"
"called the *function declaration*: We declare, that there\n"
"shall be a function of the given name and type. The second line\n"
"reads: \"The result of invoking `maxBits8` should be `255`.\"\n"
"(As you can see, we can use integer literals for other integral\n"
"types than just `Integer`.) This is called the *function definition*:\n"
"Function `maxBits8` should behave as described here when being\n"
"evaluated.\n"
msgstr "第一行可以读作：“我们想声明（零元）函数 `maxBits8`。它的类型是 `Bits8`”。这称为*函数声明*：我们声明，应该有一个给定名称和类型的函数。第二行读作：“调用 `maxBits8` 的结果应该是 `255`。” （如您所见，我们可以将整数字面量用于其他整数类型，而不仅仅是 `Integer`。）第二行称为*函数定义*：此处应该描述函数 `maxBits8` 在求值时的表现。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:269
#, no-wrap
msgid ""
"We can inspect this at the REPL. Load this source file into\n"
"an Idris REPL (as described above), and run the following tests.\n"
msgstr "我们可以在 REPL 进行检查。将此源文件加载到 Idris REPL 中（如上所述），然后运行以下测试。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:270
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8\n"
"255\n"
"Tutorial.Intro> :t maxBits8\n"
"Tutorial.Intro.maxBits8 : Bits8\n"
msgstr ""
"Tutorial.Intro> maxBits8\n"
"255\n"
"Tutorial.Intro> :t maxBits8\n"
"Tutorial.Intro.maxBits8 : Bits8\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:278
#, no-wrap
msgid "We can also use `maxBits8` as part of another expression:\n"
msgstr "我们也可以使用 `maxBits8` 作为另一个表达式的一部分：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:279
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8 - 100\n"
"155\n"
msgstr ""
"Tutorial.Intro> maxBits8 - 100\n"
"155\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:286
#, no-wrap
msgid ""
"I called `maxBits8` a *nullary function*, which is just a fancy\n"
"word for *constant*. Let's write and test our first *real* function:\n"
msgstr "我将 `maxBits8` 称为*零元函数*，它只是*常量*的一个花哨的同义词。让我们编写并测试我们的第一个*真实*的函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:287
#, no-wrap
msgid ""
"distanceToMax : Bits8 -> Bits8\n"
"distanceToMax n = maxBits8 - n\n"
msgstr ""
"distanceToMax : Bits8 -> Bits8\n"
"distanceToMax n = maxBits8 - n\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:299
#, no-wrap
msgid ""
"This introduces some new syntax and a new kind of type: Function\n"
"types. `distanceToMax : Bits8 -> Bits8` can be read as follows:\n"
"\"`distanceToMax` is a function of one argument of type `Bits8`, which\n"
"returns a result of type `Bits8`\". In the implementation, the argument\n"
"is given a local identifier `n`, which is then used in the\n"
"calculation on the right hand side. Again, go ahead and try this\n"
"function at the REPL:\n"
msgstr "这引入了一些新语法和一种新类型：函数类型。 `distanceToMax : Bits8 -> Bits8` 可以这样读：“`distanceToMax` 是具有一个 `Bits8` 类型参数的函数，它返回 `Bits8` 类型的结果”。在实现中，参数给定一个本地标识符 `n`，然后在右侧计算。再次在 REPL 中尝试函数：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:300
#, no-wrap
msgid ""
"Tutorial.Intro> distanceToMax 12\n"
"243\n"
"Tutorial.Intro> :t distanceToMax\n"
"Tutorial.Intro.distanceToMax : Bits8 -> Bits8\n"
"Tutorial.Intro> :t distanceToMax 12\n"
"distanceToMax 12 : Bits8\n"
msgstr ""
"Tutorial.Intro> distanceToMax 12\n"
"243\n"
"Tutorial.Intro> :t distanceToMax\n"
"Tutorial.Intro.distanceToMax : Bits8 -> Bits8\n"
"Tutorial.Intro> :t distanceToMax 12\n"
"distanceToMax 12 : Bits8\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:311
#, no-wrap
msgid ""
"As a final example, let's implement a function to calculate\n"
"the square of an integer:\n"
msgstr "作为最后一个例子，让我们实现一个计算整数平方的函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:312
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
msgstr ""
"square : Integer -> Integer\n"
"square n = n * n\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:325
#, no-wrap
msgid ""
"We now learn a very important aspect of programming\n"
"in Idris: Idris is\n"
"a *statically typed* programming language. We are not\n"
"allowed to freely mix types as we please. Doing so\n"
"will result in an error message from the type checker\n"
"(which is part of the compilation process of Idris).\n"
"For instance, if we try the following at the REPL,\n"
"we will get a type error:\n"
msgstr "我们现在学习 Idris 编程的一个非常重要的方面：Idris 是一种*静态类型*的编程语言。我们不允许随意混合类型。这样做会导致来自类型检查器的错误消息（这是 Idris 编译过程的一部分）。例如，如果我们在 REPL 中尝试以下操作，我们将收到类型错误：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:326
#, no-wrap
msgid ""
"Tutorial.Intro> square maxBits8\n"
"Error: ...\n"
msgstr ""
"Tutorial.Intro> square maxBits8\n"
"Error: ...\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:336
#, no-wrap
msgid ""
"The reason: `square` expects an argument of type `Integer`,\n"
"but `maxBits8` is of type `Bits8`. Many primitive types\n"
"are interconvertible (sometimes with the risk of loss\n"
"of precision) using function `cast` (more on the details\n"
"later):\n"
msgstr "原因：`square` 需要 `Integer` 类型的参数，但 `maxBits8` 的类型是 `Bits8`。许多原语类型可以使用函数 `cast` 相互转换（有时会有精度损失的风险）（稍后会详细介绍）：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:337
#, no-wrap
msgid ""
"Tutorial.Intro> square (cast maxBits8)\n"
"65025\n"
msgstr ""
"Tutorial.Intro> square (cast maxBits8)\n"
"65025\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:348
#, no-wrap
msgid ""
"Note, that in the example above the result is much larger\n"
"that `maxBits8`. The reason is, that `maxBits8` is first\n"
"converted to an `Integer` of the same value, which is\n"
"then squared. If on the other hand we squared `maxBits8`\n"
"directly, the result would be truncated to still fit the\n"
"valid range of `Bits8`:\n"
msgstr "请注意，在上面的示例中，结果比 `maxBits8` 大得多。原因是，首先将 `maxBits8` 转换为相同值的 `Integer`，然后对其进行平方。另一方面，如果我们直接将 `maxBits8` 平方，结果将被截断以适应 `Bits8` 的有效范围：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:349
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8 * maxBits8\n"
"1\n"
msgstr ""
"Tutorial.Intro> maxBits8 * maxBits8\n"
"1\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:354
#, no-wrap
msgid "Where to get Help"
msgstr "在哪里可以获得帮助"

#. type: Plain text
#: ../src/Tutorial/Intro.md:359
#, no-wrap
msgid ""
"There are several resources available online and in print, where\n"
"you can find help and documentation about the Idris programming\n"
"language. Here is a non-comprehensive list of them:\n"
msgstr "有多种在线资源和印刷资源，您可以在其中找到有关 Idris 编程语言的帮助和文档。以下是它们的非全面列表：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:361
#, no-wrap
msgid "[Type-Driven Development with Idris](https://www.manning.com/books/type-driven-development-with-idris)\n"
msgstr ""
"[使用 Idris 进行类型驱动开发](https://www.manning.com/books/type-driven-"
"development-with-idris)\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:368
#, no-wrap
msgid ""
"  *The* Idris book! This describes in great detail\n"
"  the core concepts for using Idris and dependent types\n"
"  to write robust and concise code. It uses Idris 1 in\n"
"  its examples, so parts of it have to be slightly adjusted\n"
"  when using Idris 2. There is also a\n"
"  [list of required updates](https://idris2.readthedocs.io/en/latest/typedd/typedd.html).\n"
msgstr "  *专门*讲 Idris 的书！这描述得很详细。使用 Idris 和依赖类型的核心概念编写健壮和简洁的代码。它使用 Idris 1 实现书中的例子，所以使用 Idris 2 时它的一部分必须稍微调整，有一个[所需更新列表](https://idris2.readthedocs.io/en/latest/typedd/typedd.html)。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:370
#, no-wrap
msgid "[A Crash Course in Idris 2](https://idris2.readthedocs.io/en/latest/tutorial/index.html)\n"
msgstr ""
"[Idris 2 速成课程](https://idris2.readthedocs.io/en/latest/tutorial/index."
"html)\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:375
#, no-wrap
msgid ""
"  The official Idris 2 tutorial. A comprehensive but dense explanation of\n"
"  all features of Idris 2. I find this to be useful as a reference, and as such\n"
"  it is highly accessible. However, it is not an introduction to functional\n"
"  programming or type-driven development in general.\n"
msgstr "  Idris 2 官方教程。全面而密集的解释 Idris 2 的所有功能。我发现这作为参考很有用，因此它是高度可访问的。但是，它不是函数式编程或类型驱动开发的入门介绍\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:377
#, no-wrap
msgid "[The Idris 2 GitHub Repository](https://github.com/idris-lang/Idris2)\n"
msgstr "[Idris 2 GitHub 存储库](https://github.com/idris-lang/Idris2)\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:384
#, no-wrap
msgid ""
"  Look here for detailed installation instructions and some\n"
"  introductory material. There is also a [wiki](https://github.com/idris-lang/Idris2/wiki),\n"
"  where you can find a [list of editor plugins](https://github.com/idris-lang/Idris2/wiki/The-Idris-editor-experience),\n"
"  a [list of community libraries](https://github.com/idris-lang/Idris2/wiki/Libraries),\n"
"  a [list of external backends](https://github.com/idris-lang/Idris2/wiki/External-backends),\n"
"  and other useful information.\n"
msgstr ""
"  在这里查看详细的安装说明和一些介绍材料。还有一个[wiki](https://github.com/idris-lang/Idris2/wiki)，\n"
"  在这里你可以找到[编辑器插件列表](https://github.com/idris-lang/Idris2/wiki/The-Idris-editor-experience)，\n"
"  [社区库列表](https://github.com/idris-lang/Idris2/wiki/Libraries),\n"
"  [外部后端列表](https://github.com/idris-lang/Idris2/wiki/External-backends),\n"
"和其他有用的信息。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:386
#, no-wrap
msgid "[The Idris 2 Discord Channel](https://discord.gg/UX68fDs2jc)\n"
msgstr "[Idris 2 Discord 频道](https://discord.gg/UX68fDs2jc)\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:392
#, no-wrap
msgid ""
"  If you get stuck with a piece of code, want to ask about some\n"
"  obscure language feature, want to promote your new library,\n"
"  or want to just hang out with other Idris programmers, this\n"
"  is the place to go. The discord channel is pretty active and\n"
"  *very* friendly towards newcomers.\n"
msgstr "  如果你被一段代码卡住了，想问一些晦涩的语言功能，想推广你的新库，或者想和其他 Idris 程序员一起出去玩，可以来这个地方。Discord 频道非常活跃且对新人*非常*友好。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:394
#, no-wrap
msgid "The Idris REPL\n"
msgstr "Idris REPL\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:400
#, no-wrap
msgid ""
"  Finally, a lot of useful information can be provided by\n"
"  Idris itself. I tend to have at least one REPL session open all the\n"
"  time when programming in Idris. My editor (neovim) is set up\n"
"  to use the [language server for Idris 2](https://github.com/idris-community/idris2-lsp),\n"
"  which is incredibly useful. In the REPL,\n"
msgstr "  最后，Idris 本身可以提供很多有用的信息。在 Idris 编程的时间我倾向于至少打开一个 REPL 会话。我的编辑器（neovim）已设置使用 [Idris 2 的语言服务器](https://github.com/idris-community/idris2-lsp)，在 REPL 中这非常有用。\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
#, no-wrap
msgid ""
"use `:t` to inspect the type of an expression\n"
"or meta variable (hole): `:t foldl`,\n"
msgstr "使用 `:t` 检查表达式或元变量（孔）的类型：`:t foldl`,\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
#, no-wrap
msgid ""
"use `:ti` to inspect the type of a function\n"
"including implicit arguments: `:ti foldl`,\n"
msgstr "使用 `:ti` 检查包含隐式参数的函数类型：`:ti foldl`,\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
#, no-wrap
msgid "use `:m` to list all meta variables (holes) in scope,\n"
msgstr "使用 `:m` 列出作用域内的所有元变量（孔），\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
#, no-wrap
msgid ""
"use `:doc` to access the documentation of a\n"
"top level function (`:doc the`), a data type plus all its constructors\n"
"and available hints (`:doc Bool`), a language feature (`:doc case`,\n"
"`:doc let`, `:doc interface`, `:doc record`,\n"
"or even `:doc ?`), or an interface (`:doc Uninhabited`),\n"
msgstr ""
"使用 `:doc` 访问顶级函数 (`:doc the`) 的文档，"
"一种数据类型及其所有构造函数和可用提示 (`:doc Bool` )，语言特性（`:doc case`"
", `:doc let`, `:doc interface`, `:doc record`，甚至是 `:doc "
"?`)，或者一个接口（`:doc Uninhabited`），\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
#, no-wrap
msgid ""
"use `:module` to import a module from one of the available\n"
"packages: `:module Data.Vect`,\n"
msgstr "使用 `:module` 从可用包之一导入模块：`:module Data.Vect`,\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
#, no-wrap
msgid ""
"use `:browse` to list the names and types of all functions\n"
"exported by a loaded module: `:browse Data.Vect`,\n"
msgstr "使用 `:browse` 列出加载模块导出的所有函数的名称和类型： `:browse Data.Vect`,"
"\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
#, no-wrap
msgid ""
"use `:help` to get a list of other commands plus a short\n"
"description for each.\n"
msgstr "使用 `:help` 获取其他命令的列表以及每个命令的简短描述。\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:418
#, no-wrap
msgid "Summary"
msgstr "概括"

#. type: Plain text
#: ../src/Tutorial/Intro.md:425
#, no-wrap
msgid ""
"In this introduction we learned about the most basic\n"
"features of the Idris programming language. We used\n"
"the REPL to tinker with our ideas and inspect the\n"
"types of things in our code, and we used the Idris\n"
"compiler to compile an Idris source file to an executable.\n"
msgstr "在本介绍中，我们了解了 Idris 编程语言的最基本功能。我们使用 REPL 来修改我们的想法并检查代码中事物的类型，我们使用 Idris 编译器将 Idris 源文件编译为可执行文件。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:429
#, no-wrap
msgid ""
"We also learned about the basic shape of a top level\n"
"definition in Idris, which always consists of an identifier\n"
"(its name), a type, and an implementation.\n"
msgstr "我们还了解了 Idris 中顶级定义的基本形式，它始终由标识符（其名称）、类型和实现组成。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:436
#, no-wrap
msgid ""
"In the [next chapter](Functions1.md), we start programming\n"
"in Idris for real. We learn how to write our own pure\n"
"functions, how functions compose, and how we can treat\n"
"functions just like other values and pass them around\n"
"as arguments to other functions.\n"
msgstr "在[下一章](Functions1.md)中，我们开始在 Idris 中进行真正的编程。我们学习如何编写我们自己的纯函数，函数如何组合，以及我们如何像对待其他值一样对待函数并将它们作为参数传递给其他函数。\n"

#. type: Title #
#: ../src/Tutorial/IO.md:1
#, no-wrap
msgid "IO: Programming with Side Effects"
msgstr "IO：有副作用的编程"

#. type: Plain text
#: ../src/Tutorial/IO.md:7
#, no-wrap
msgid ""
"So far, all our examples and exercises dealt with pure, total functions.\n"
"We didn't read or write content from or to files, nor did\n"
"we write any messages to the standard output. It is time to change\n"
"that and learn, how we can write effectful programs in Idris.\n"
msgstr "到目前为止，我们所有的例子和练习都是关于纯函数的。我们没有从文件读取或写入内容，也没有将任何消息写入标准输出。是时候改变这一点并学习如何在 Idris 中编写有效的程序了。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:8
#, no-wrap
msgid ""
"module Tutorial.IO\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import System.File\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.IO\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import System.File\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/IO.md:20
#, no-wrap
msgid "Pure Side Effects?"
msgstr "纯副作用？"

#. type: Plain text
#: ../src/Tutorial/IO.md:24
#, no-wrap
msgid ""
"If we once again look at the *hello world* example from the\n"
"[introduction](Intro.md), it had the following type and implementation:\n"
msgstr "如果我们再次查看 [介绍](Intro.md) 中的 *hello world* 示例，它具有以下类型和实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:25
#, no-wrap
msgid ""
"hello : IO ()\n"
"hello = putStrLn \"Hello World!\"\n"
msgstr ""
"hello : IO ()\n"
"hello = putStrLn \"Hello World!\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:32
#, no-wrap
msgid ""
"If you load this module in a REPL session and evaluate `hello`,\n"
"you'll get the following:\n"
msgstr "如果您在 REPL 会话中加载此模块并求值 `hello`，您将获得以下信息：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:33
#, no-wrap
msgid ""
"Tutorial.IO> hello\n"
"MkIO (prim__putStr \"Hello World!\")\n"
msgstr ""
"Tutorial.IO> hello\n"
"MkIO (prim__putStr \"Hello World!\")\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:41
#, no-wrap
msgid ""
"This might not be what you expected, given that we'd actually wanted the\n"
"program to just print \"Hello World!\". In order to explain what's going\n"
"on here, we need to quickly look at how evaluation at the REPL works.\n"
msgstr "这可能不是您所期望的，因为我们实际上希望程序只打印“Hello World！”。为了解释这里发生了什么，我们需要快速了解 REPL 的求值是如何工作的。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:51
#, no-wrap
msgid ""
"When we evaluate some expression at the REPL, Idris tries to\n"
"reduce it to a value until it gets stuck somewhere. In the above case,\n"
"Idris gets stuck at function `prim__putStr`. This is\n"
"a *foreign function* defined in the *Prelude*, which has to be implemented\n"
"by each backend in order to be available there. At compile time (and at the REPL),\n"
"Idris knows nothing about the implementations of foreign functions\n"
"and therefore can't reduce foreign function calls, unless they are\n"
"built into the compiler itself. But even then, values of type `IO a`\n"
"(`a` being a type parameter) are typically not reduced.\n"
msgstr "当我们在 REPL 中求值某个表达式时，Idris 会尝试将其减少为一个值，直到它卡在某个地方。在上述情况下，Idris 卡在函数 `prim__putStr` 上。这是在 *Prelude* 中定义的 *外部函数*，必须由每个后端实现才能在那里可用。在编译时（以及在 REPL 中），Idris 对外部函数的实现一无所知，因此无法减少外部函数调用，除非它们内置于编译器本身中。但即便如此，`IO a` 类型的值（`a` 是一个类型参数）通常不会减少。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:61
#, no-wrap
msgid ""
"It is important to understand that values of type `IO a` *describe*\n"
"a program, which, when being *executed*, will return a value of type `a`,\n"
"after performing arbitrary side effects along the way. For instance,\n"
"`putStrLn` has type `String -> IO ()`. Read this as: \"`putStrLn` is a function,\n"
"which, when given a `String` argument, will return a description of\n"
"an effectful program with an output type of `()`\".\n"
"(`()` is syntactic sugar for type `Unit`, the\n"
"empty tuple defined at the *Prelude*, which has only one value called `MkUnit`,\n"
"for which we can also use `()` in our code.)\n"
msgstr "重要的是要理解 `IO a` 类型的值 *描述* 一个程序，当 *执行* 时，在一路执行任意副作用之后，将返回 `a` 类型的值。例如，`putStrLn` 的类型为 `String -> IO ()`。将其读作：“`putStrLn` 是一个函数，当给定一个 `String` 参数时，它将返回一个输出类型为 `()` 的有效程序的描述”。 (`()` 是 `Unit` 类型的语法糖，在 *Prelude* 中定义的空元组，它只有一个值称为 `MkUnit`，我们也可以在我们的代码中使用 `()`。）\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:72
#, no-wrap
msgid ""
"Since values of type `IO a` are mere descriptions of effectful computations,\n"
"functions returning such values or taking such values as\n"
"arguments are still *pure* and thus referentially transparent.\n"
"It is, however, not possible to extract a value of type `a` from\n"
"a value of type `IO a`, that is, there is no generic function `IO a -> a`,\n"
"as such a function would inadvertently execute the side\n"
"effects when extracting the result from its argument,\n"
"thus breaking referential transparency.\n"
"(Actually, there *is* such a function called `unsafePerformIO`.\n"
"Do not ever use it in your code unless you know what you are doing.)\n"
msgstr "由于 `IO a` 类型的值仅仅是对有效计算的描述，因此返回此类值或将此类值作为参数的函数仍然是 *纯 * 并且因此是引用透明的。但是，不可能从 `IO a` 类型的值中提取 `a` 类型的值，也就是说，没有通用函数 `IO a -> a `，因为这样的函数在从其参数中提取结果时会无意中执行副作用，从而破坏引用透明度。 （实际上，确实 *有* 这样一个名为 `unsafePerformIO` 的函数。除非您知道自己在做什么，否则不要在代码中使用它。）\n"

#. type: Title ###
#: ../src/Tutorial/IO.md:73
#, no-wrap
msgid "Do Blocks"
msgstr "Do 代码块"

#. type: Plain text
#: ../src/Tutorial/IO.md:83
#, no-wrap
msgid ""
"If you are new to pure functional programming, you might now - rightfully -\n"
"mumble something about how useless it is to\n"
"have descriptions of effectful programs without being able to run them.\n"
"So please, hear me out. While we are not able to run values of type\n"
"`IO a` when writing programs, that is, there is no function of\n"
"type `IO a -> a`, we are able to chain such computations and describe more\n"
"complex programs. Idris provides special syntax for this: *Do blocks*.\n"
"Here's an example:\n"
msgstr "如果您是纯函数式编程的新手，那么您现在可能会——理所当然地——咕哝一些关于如果无法运行有效程序的描述是多么无用的话。所以，请听我说完。虽然我们在编写程序时无法运行 `IO a` 类型的值，也就是说，没有 `IO a -> a` 类型的函数，但我们能够链接这样的计算并描述更复杂的程序。 Idris 为此提供了特殊语法：*Do 代码块*。这是一个例子：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:84
#, no-wrap
msgid ""
"readHello : IO ()\n"
"readHello = do\n"
"  name <- getLine\n"
"  putStrLn $ \"Hello \" ++ name ++ \"!\"\n"
msgstr ""
"readHello : IO ()\n"
"readHello = do\n"
"  name <- getLine\n"
"  putStrLn $ \"Hello \" ++ name ++ \"!\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:93
#, no-wrap
msgid ""
"Before we talk about what's going on here, let's give this a go at\n"
"the REPL:\n"
msgstr "在我们谈论这里发生的事情之前，让我们在 REPL 上试一试：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:94
#, no-wrap
msgid ""
"Tutorial.IO> :exec readHello\n"
"Stefan\n"
"Hello Stefan!\n"
msgstr ""
"Tutorial.IO> :exec readHello\n"
"Stefan\n"
"Hello Stefan!\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:104
#, no-wrap
msgid ""
"This is an interactive program, which will read a line from standard\n"
"input (`getLine`), assign the result to variable `name`, and then\n"
"use `name` to create a friendly greeting and write it to\n"
"standard output.\n"
msgstr "这是一个交互式程序，它将从标准输入 (`getLine`) 中读取一行，将结果赋值给变量 `name`，然后使用 `name` 创建一个友好的问候并将其写入标准输出。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:114
#, no-wrap
msgid ""
"Note the `do` keyword at the beginning of the implementation of `readHello`:\n"
"It starts a *do block*, where we can chain `IO` computations and bind\n"
"intermediary results to variables using arrows pointing\n"
"to the left (`<-`), which can then be used in later\n"
"`IO` actions. This concept is powerful enough to let us encapsulate arbitrary\n"
"programs with side effects in a single value of type `IO`. Such a\n"
"description can then be returned by function `main`, the main entry point\n"
"to an Idris program, which is being executed when we run a compiled\n"
"Idris binary.\n"
msgstr "注意 `readHello` 实现开始时的 `do` 关键字：它启动了一个 *do 代码块*，我们可以在其中链接 `IO` 计算和使用指向左侧的箭头 (`<-`) 将中间结果绑定到变量，然后可以在以后的 `IO` 操作中使用。这个概念足够强大，可以让我们将具有副作用的任意程序封装在 `IO` 类型的单个值中。然后可以通过函数 `main` 返回这样的描述，这是 Idris 程序的主入口点，当我们运行已编译的 Idris 二进制文件时，该程序正在执行。\n"

#. type: Title ###
#: ../src/Tutorial/IO.md:115
#, no-wrap
msgid "The Difference between Program Description and Execution"
msgstr "程序描述和执行的区别"

#. type: Plain text
#: ../src/Tutorial/IO.md:120
#, no-wrap
msgid ""
"In order to better understand the difference between *describing*\n"
"an effectful computation and *executing* or *running* it, here is a small\n"
"program:\n"
msgstr "为了更好地理解 *描述* 有效计算和 *执行* 或 *运行* 之间的区别，这里有一个小程序：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:121
#, no-wrap
msgid ""
"launchMissiles : IO ()\n"
"launchMissiles = putStrLn \"Boom! You're dead.\"\n"
"\n"
"friendlyReadHello : IO ()\n"
"friendlyReadHello = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
"\n"
"actions : Vect 3 (IO ())\n"
"actions = [launchMissiles, friendlyReadHello, friendlyReadHello]\n"
"\n"
"runActions : Vect (S n) (IO ()) -> IO ()\n"
"runActions (_ :: xs) = go xs\n"
"  where go : Vect k (IO ()) -> IO ()\n"
"        go []        = pure ()\n"
"        go (y :: ys) = do\n"
"          _ <- y\n"
"          go ys\n"
"\n"
"readHellos : IO ()\n"
"readHellos = runActions actions\n"
msgstr ""
"launchMissiles : IO ()\n"
"launchMissiles = putStrLn \"Boom! You're dead.\"\n"
"\n"
"friendlyReadHello : IO ()\n"
"friendlyReadHello = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
"\n"
"actions : Vect 3 (IO ())\n"
"actions = [launchMissiles, friendlyReadHello, friendlyReadHello]\n"
"\n"
"runActions : Vect (S n) (IO ()) -> IO ()\n"
"runActions (_ :: xs) = go xs\n"
"  where go : Vect k (IO ()) -> IO ()\n"
"        go []        = pure ()\n"
"        go (y :: ys) = do\n"
"          _ <- y\n"
"          go ys\n"
"\n"
"readHellos : IO ()\n"
"readHellos = runActions actions\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:153
#, no-wrap
msgid ""
"Before I explain what the code above does, please note function\n"
"`pure` used in the implementation of `runActions`. It is\n"
"a constrained function, about which we will learn in the next\n"
"chapter. Specialized to `IO`, it has generic type `a -> IO a`:\n"
"It allows us to wrap a value in an `IO` action. The resulting\n"
"`IO` program will just return the wrapped value without performing\n"
"any side effects. We can now look at the big picture of what's\n"
"going on in `readHellos`.\n"
msgstr "在我解释上面代码的作用之前，请注意 `runActions` 的实现中使用的函数 `pure`。它是一个受约束的函数，我们将在下一章中学习。专门用于 `IO`，它具有通用类型 `a -> IO a`：它允许我们将值包装在 `IO` 动作中。生成的 `IO` 程序将只返回包装后的值，而不会执行任何副作用。我们现在可以看一下 `readHellos` 中发生的事情的总体情况。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:160
#, no-wrap
msgid ""
"First, we define a friendlier version of `readHello`: When executed, this will\n"
"ask about our name explicitly. Since we will not use the result\n"
"of `putStrLn` any further, we can use an underscore as a catch-all\n"
"pattern here. Afterwards, `readHello` is invoked. We also define\n"
"`launchMissiles`, which, when being executed, will lead to the\n"
"destruction of planet earth.\n"
msgstr "首先，我们定义了一个更友好的 `readHello` 版本：当执行时，它会明确询问我们的名字。由于我们将不再使用 `putStrLn` 的结果，因此我们可以在这里使用下划线作为包罗万象的模式。之后，调用 `readHello`。我们还定义了`launchMissiles`，执行时会导致地球毁灭。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:169
#, no-wrap
msgid ""
"Now, `runActions` is the function we use to\n"
"demonstrate that *describing* an `IO` action is not the\n"
"same as *running* it. It will drop the first action from\n"
"the non-empty vector it takes as its\n"
"argument and return a new `IO` action, which describes the\n"
"execution of the remaining `IO` actions in sequence. If this behaves\n"
"as expected, the first `IO` action passed to `runActions` should be\n"
"silently dropped together with all its potential side effects.\n"
msgstr "现在，`runActions` 是我们用来证明 *描述* `IO` 动作与 *运行* 动作是不同的函数。它将从作为参数的非空向量中删除第一个动作，并返回一个新的 `IO` 动作，它描述了按顺序执行剩余的 `IO` 动作。如果这符合预期，则传递给 `runActions` 的第一个 `IO` 操作应连同其所有潜在副作用一起被静默删除。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:174
#, no-wrap
msgid ""
"When we execute `readHellos` at the REPL, we will be asked for our\n"
"name twice, although `actions` also contains `launchMissiles` at the\n"
"beginning. Luckily, although we described how to destroy the planet,\n"
"the action was not executed, and we are (probably) still here.\n"
msgstr "当我们在 REPL 中执行 `readHellos` 时，我们会被要求输入我们的名字两次，尽管 `actions` 开头也包含 `launchMissiles`。幸运的是，虽然我们描述了如何摧毁地球，但行动并未执行，我们（可能）还在这里。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:176
#, no-wrap
msgid "From this example we learn several things:\n"
msgstr "从这个例子中，我们学到了几件事：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:180
#, no-wrap
msgid ""
"Values of type `IO a` are *pure descriptions* of programs, which,\n"
"when being *executed*, perform arbitrary side effects before\n"
"returning a value of type `a`.\n"
msgstr "`IO a` 类型的值是程序的*纯描述*，当被*执行*时，在返回 `a` "
"类型的值之前执行任意副作用。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:184
#, no-wrap
msgid ""
"Values of type `IO a` can be safely returned from functions and\n"
"passed around as arguments or in data structures, without\n"
"the risk of them being executed.\n"
msgstr "`IO a` 类型的值可以安全地从函数返回并作为参数或在数据结构中传递，而不会有被执"
"行的风险。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:187
#, no-wrap
msgid ""
"Values of type `IO a` can be safely combined in *do blocks* to\n"
"*describe* new `IO` actions.\n"
msgstr "`IO a` 类型的值可以安全地在 *do 块* 中组合到*描述* `IO` 的新动作中。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:191
#, no-wrap
msgid ""
"An `IO` action will only ever get executed when it's passed to\n"
"`:exec` at the REPL, or when it is the `main` function of\n"
"a compiled Idris program that is being executed.\n"
msgstr ""
"一个 `IO` 动作只会在它被传递给 REPL 的 `:exec` 或者当它是已编译的 Idris "
"程序的 `main` 函数时才会被执行。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:196
#, no-wrap
msgid ""
"It is not possible to ever break out of the `IO` context: There\n"
"is no function of type `IO a -> a`, as such a function would\n"
"need to execute its argument in order to extract the final\n"
"result, and this would break referential transparency.\n"
msgstr ""
"永远不可能跳出 `IO` 上下文：没有 `IO a -> a` 类型的函数，因为这样的函数需要执"
"行它的参数才能提取最终结果，这将破坏引用透明。\n"

#. type: Title ###
#: ../src/Tutorial/IO.md:197
#, no-wrap
msgid "Combining Pure Code with `IO` Actions"
msgstr "组合纯代码和 `IO` 动作"

#. type: Plain text
#: ../src/Tutorial/IO.md:202
#, no-wrap
msgid ""
"The title of this subsection is somewhat misleading. `IO` actions\n"
"*are* pure values, but what is typically meant here, is that we\n"
"combine non-`IO` functions with effectful computations.\n"
msgstr "本小节的标题有些误导。 `IO` 动作 *是* 纯值，但这里通常的意思是我们将非 `IO` 函数与有效计算相结合。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:208
#, no-wrap
msgid ""
"As a demonstration, in this section we are going to write a small\n"
"program for evaluating arithmetic expressions. We are going to\n"
"keep things simple and allow only expressions with a single\n"
"operator and two arguments, both of which must be integers,\n"
"for instance `12 + 13`.\n"
msgstr "作为演示，在本节中，我们将编写一个用于计算算术表达式的小程序。我们将保持简单，只允许具有单个运算符和两个参数的表达式，这两个参数都必须是整数，例如 `12 + 13`。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:216
#, no-wrap
msgid ""
"We are going to use function `split` from `Data.String` in\n"
"*base* to tokenize arithmetic expressions. We are then trying\n"
"to parse the two integer values and the operator. These operations\n"
"might fail, since user input can be invalid, so we also need an\n"
"error type. We could actually just use `String`, but I\n"
"consider it to be good practice to use custom sum types\n"
"for erroneous conditions.\n"
msgstr "我们将使用 *base* 中 `Data.String` 中的函数 `split` 来标记算术表达式。然后我们尝试解析两个整数值和运算符。这些操作可能会失败，因为用户输入可能无效，所以我们还需要一个错误类型。我们实际上可以只使用 `String`，但我认为对错误条件使用自定义求和类型是一种好习惯。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:217
#, no-wrap
msgid ""
"data Error : Type where\n"
"  NotAnInteger    : (value : String) -> Error\n"
"  UnknownOperator : (value : String) -> Error\n"
"  ParseError      : (input : String) -> Error\n"
"\n"
"dispError : Error -> String\n"
"dispError (NotAnInteger v)    = \"Not an integer: \" ++ v ++ \".\"\n"
"dispError (UnknownOperator v) = \"Unknown operator: \" ++ v ++ \".\"\n"
"dispError (ParseError v)      = \"Invalid expression: \" ++ v ++ \".\"\n"
msgstr ""
"data Error : Type where\n"
"  NotAnInteger    : (value : String) -> Error\n"
"  UnknownOperator : (value : String) -> Error\n"
"  ParseError      : (input : String) -> Error\n"
"\n"
"dispError : Error -> String\n"
"dispError (NotAnInteger v)    = \"Not an integer: \" ++ v ++ \".\"\n"
"dispError (UnknownOperator v) = \"Unknown operator: \" ++ v ++ \".\"\n"
"dispError (ParseError v)      = \"Invalid expression: \" ++ v ++ \".\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:231
#, no-wrap
msgid ""
"In order to parse integer literals, we use function `parseInteger`\n"
"from `Data.String`:\n"
msgstr "为了解析整数字面量，我们使用来自 `Data.String` 的函数 `parseInteger`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:232
#, no-wrap
msgid ""
"readInteger : String -> Either Error Integer\n"
"readInteger s = maybe (Left $ NotAnInteger s) Right $ parseInteger s\n"
msgstr ""
"readInteger : String -> Either Error Integer\n"
"readInteger s = maybe (Left $ NotAnInteger s) Right $ parseInteger s\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:239
#, no-wrap
msgid ""
"Likewise, we declare and implement a function for parsing\n"
"arithmetic operators:\n"
msgstr "同样，我们声明并实现了一个解析算术运算符的函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:240
#, no-wrap
msgid ""
"readOperator : String -> Either Error (Integer -> Integer -> Integer)\n"
"readOperator \"+\" = Right (+)\n"
"readOperator \"*\" = Right (*)\n"
"readOperator s   = Left (UnknownOperator s)\n"
msgstr ""
"readOperator : String -> Either Error (Integer -> Integer -> Integer)\n"
"readOperator \"+\" = Right (+)\n"
"readOperator \"*\" = Right (*)\n"
"readOperator s   = Left (UnknownOperator s)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:254
#, no-wrap
msgid ""
"We are now ready to parse and evaluate simple arithmetic\n"
"expressions. This consists of several steps (splitting the\n"
"input string, parsing each literal), each of which can fail.\n"
"Later, when we learn about monads, we will see that do\n"
"blocks can be used in such occasions just as well. However,\n"
"in this case we can use an alternative syntactic convenience:\n"
"Pattern matching in let bindings. Here is the code:\n"
msgstr "我们现在准备解析和求值简单的算术表达式。这包括几个步骤（拆分输入字符串，解析每个字面量），每个步骤都可能失败。稍后，当我们了解 monad 时，我们会看到 do 块也可以在这种情况下使用。但是，在这种情况下，我们可以使用另一种语法便利：let 绑定中的模式匹配。这是代码：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:255
#, no-wrap
msgid ""
"eval : String -> Either Error Integer\n"
"eval s =\n"
"  let [x,y,z]  := forget $ split isSpace s | _ => Left (ParseError s)\n"
"      Right v1 := readInteger x  | Left e => Left e\n"
"      Right op := readOperator y | Left e => Left e\n"
"      Right v2 := readInteger z  | Left e => Left e\n"
"   in Right $ op v1 v2\n"
msgstr ""
"eval : String -> Either Error Integer\n"
"eval s =\n"
"  let [x,y,z]  := forget $ split isSpace s | _ => Left (ParseError s)\n"
"      Right v1 := readInteger x  | Left e => Left e\n"
"      Right op := readOperator y | Left e => Left e\n"
"      Right v2 := readInteger z  | Left e => Left e\n"
"   in Right $ op v1 v2\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:280
#, no-wrap
msgid ""
"Let's break this down a bit. On the first line, we split\n"
"the input string at all whitespace occurrences. Since\n"
"`split` returns a `List1` (a type for non-empty lists\n"
"exported from `Data.List1` in *base*) but pattern matching\n"
"on `List` is more convenient, we convert the result using\n"
"`Data.List1.forget`. Note, how we use a pattern match\n"
"on the left hand side of the assignment operator `:=`.\n"
"This is a partial pattern match (*partial* meaning,\n"
"that it doesn't cover all possible cases), therefore we have\n"
"to deal with the other possibilities as well, which is\n"
"done after the vertical line. This can be read as follows:\n"
"\"If the pattern match on the left hand side is successful,\n"
"and we get a list of exactly three tokens, continue with\n"
"the `let` expression, otherwise return a `ParseError` in\n"
"a `Left` immediately\".\n"
msgstr "让我们分解一下。在第一行，我们在所有出现的空格处拆分输入字符串。由于 `split` 返回 `List1` （从 *base* 中的 `Data.List1` 导出的非空列表的类型），但用 `List`更方便，我们使用`Data.List1.forget` 转换结果。请注意，我们如何在赋值运算符 `:=` 的左侧使用模式匹配。这是一个部分模式匹配（*部分* 的意思，它没有涵盖所有可能的情况），因此我们还必须处理其他可能性，这是在垂直线之后完成的。可以这样理解：“如果左侧的模式匹配成功，并且我们得到一个正好包含三个标记的列表，则继续使用 `let` 表达式，否则立即返回 在 `Left` 中的 `ParseError` \"。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:286
#, no-wrap
msgid ""
"The other three lines behave exactly the same: Each has\n"
"a partial pattern match on the left hand side with\n"
"instructions what to return in case of invalid input after\n"
"the vertical bar. We will later see, that this syntax is also\n"
"available in *do blocks*.\n"
msgstr "其他三行的行为完全相同：每一行在左侧都有一个部分模式匹配，指示在竖线后输入无效时返回的内容。我们稍后会看到，这种语法也可以在 *do blocks* 中使用。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:294
#, no-wrap
msgid ""
"Note, how all of the functionality implemented so far is\n"
"*pure*, that is, it does not describe computations with\n"
"side effects. (One could argue that already the possibility\n"
"of failure is an observable *effect*, but even then, the code above\n"
"is still referentially transparent,\n"
"can be easily tested at the REPL, and evaluated at\n"
"compile time, which is the important thing here.)\n"
msgstr "请注意，到目前为止实现的所有功能都是 *纯的*，也就是说，它没有描述具有副作用的计算。 （有人可能会争辩说，失败的可能性已经是可观察到的 *副作用*，但即便如此，上面的代码仍然是引用透明的，可以在 REPL 轻松测试，并在编译时求值，这是这里很重要。）\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:298
#, no-wrap
msgid ""
"Finally, we can wrap this functionality in an `IO`\n"
"action, which reads a string from standard input\n"
"and tries to evaluate the arithmetic expression:\n"
msgstr "最后，我们可以将此功能包装在 `IO` 操作中，该操作从标准输入读取字符串并尝试计算算术表达式：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:299
#, no-wrap
msgid ""
"exprProg : IO ()\n"
"exprProg = do\n"
"  s <- getLine\n"
"  case eval s of\n"
"    Left err  => do\n"
"      putStrLn \"An error occured:\"\n"
"      putStrLn (dispError err)\n"
"    Right res => putStrLn (s ++ \" = \" ++ show res)\n"
msgstr ""
"exprProg : IO ()\n"
"exprProg = do\n"
"  s <- getLine\n"
"  case eval s of\n"
"    Left err  => do\n"
"      putStrLn \"An error occured:\"\n"
"      putStrLn (dispError err)\n"
"    Right res => putStrLn (s ++ \" = \" ++ show res)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:316
#, no-wrap
msgid ""
"Note, how in `exprProg` we were forced to deal with the\n"
"possibility of failure and handle both constructors\n"
"of `Either` differently in order to print a result.\n"
"Note also, that *do blocks* are ordinary expressions,\n"
"and we can, for instance, start a new *do block* on\n"
"the right hand side of a case expression.\n"
msgstr "请注意，在 `exprProg` 中，我们如何被迫处理失败的可能性并以不同方式处理 `Either` 的两个构造函数以打印结果。还要注意，*do blocks* 是普通表达式，例如，我们可以在 case 表达式的右侧开始一个新的 *do block*。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:329
#, no-wrap
msgid ""
"In these exercises, you are going to implement some\n"
"small command-line applications. Some of these will potentially\n"
"run forever, as they will only stop when the user enters\n"
"a keyword for quitting the application. Such programs\n"
"are no longer provably total. If you added the\n"
"`%default total` pragma at the top of your source file,\n"
"you'll need to annotate these functions with `covering`,\n"
"meaning that you covered all cases in all pattern matches\n"
"but your program might still loop due to unrestricted\n"
"recursion.\n"
msgstr "在这些练习中，您将实现一些小型命令行应用程序。其中一些可能会永远运行，因为它们只会在用户输入退出应用程序的关键字时停止。这样的程序不再是可证明的全部。如果您在源文件的顶部添加了 `%default total` 杂注，则需要使用 `covering` 注释这些函数，这意味着您涵盖了所有模式匹配中的所有情况，但由于不受限制的递归，您的程序可能仍会循环。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:333
#, no-wrap
msgid ""
"Implement function `rep`, which will read a line\n"
"of input from the terminal, evaluate it using the\n"
"given function, and print the result to standard output:\n"
msgstr "实现函数 `rep`，它将从终端读取一行输入，使用给定函数对其进行求值，并将结果打"
"印到标准输出：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:334
#, no-wrap
msgid "   rep : (String -> String) -> IO ()\n"
msgstr "   rep : (String -> String) -> IO ()\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:341
#, no-wrap
msgid ""
"Implement function `repl`, which behaves just like `rep`\n"
"but will repeat itself forever (or until being forcefully\n"
"terminated):\n"
msgstr "实现函数 `repl`，其行为类似于 `rep`，但会永远重复（或直到被强制终止）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:342
#, no-wrap
msgid ""
"   covering\n"
"   repl : (String -> String) -> IO ()\n"
msgstr ""
"   covering\n"
"   repl : (String -> String) -> IO ()\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/IO.md:351
#, no-wrap
msgid ""
"Implement function `replTill`, which behaves just like `repl`\n"
"but will only continue looping if the given function returns\n"
"a `Right`. If it returns a `Left`, `replTill` should print\n"
"the final message wrapped in the `Left` and then stop.\n"
msgstr ""
"实现函数 `replTill`，其行为类似于 `repl`，但只有在给定函数返回 `Right` "
"时才会继续循环。如果它返回 `Left`，`replTill` 应该打印包装在 `Left` "
"中的最终消息，然后停止。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:352
#, no-wrap
msgid ""
"   covering\n"
"   replTill : (String -> Either String String) -> IO ()\n"
msgstr ""
"   covering\n"
"   replTill : (String -> Either String String) -> IO ()\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/IO.md:364
#, no-wrap
msgid ""
"Write a program, which reads arithmetic\n"
"expressions from standard input, evaluates them\n"
"using `eval`, and prints the result to standard\n"
"output. The program should loop until\n"
"users stops it by entering \"done\", in which case\n"
"the program should terminate with a friendly greeting.\n"
"Use `replTill` in your implementation.\n"
msgstr ""
"编写一个程序，从标准输入读取算术表达式，使用 `eval` "
"计算它们，并将结果打印到标准输出。程序应该循环，直到用户通过输入“完成” "
"停止它，在这种情况下，程序应该以友好的问候终止。在您的实现中使用 `replTill`。"
"\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/IO.md:373
#, no-wrap
msgid ""
"Implement function `replWith`, which behaves just like `repl`\n"
"but uses some internal state to accumulate values.\n"
"At each iteration (including the very first one!),\n"
"the current state should be printed\n"
"to standard output using function `dispState`, and\n"
"the next state should be computed using function `next`.\n"
"The loop should terminate in case of a `Left` and\n"
"print a final message using `dispResult`:\n"
msgstr ""
"实现函数 `replWith`，其行为类似于 "
"`repl`，但使用一些内部状态来累积值。在每次迭代中（包括第一次迭代！），"
"当前状态应该使用函数 `dispState` 打印到标准输出，并且应该使用函数 `next` "
"计算下一个状态。如果出现 `Left`，循环应该终止，并使用 `dispResult` "
"打印最终消息：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:374
#, no-wrap
msgid ""
"   covering\n"
"   replWith :  (state      : s)\n"
"            -> (next       : s -> String -> Either res s)\n"
"            -> (dispState  : s -> String)\n"
"            -> (dispResult : res -> s -> String)\n"
"            -> IO ()\n"
msgstr ""
"   covering\n"
"   replWith :  (state      : s)\n"
"            -> (next       : s -> String -> Either res s)\n"
"            -> (dispState  : s -> String)\n"
"            -> (dispResult : res -> s -> String)\n"
"            -> IO ()\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/IO.md:388
#, no-wrap
msgid ""
"Use `replWith` from Exercise 5 to write a program\n"
"for reading natural numbers from standard input and\n"
"printing the accumulated sum of these numbers.\n"
"The program should terminate in case of invalid input\n"
"and if a user enters \"done\".\n"
msgstr ""
"使用练习 5 中的 `replWith` 编写一个程序，用于从标准输入读取自然数并打印这些数"
"字的累加和。如果输入无效并且用户输入“完成”，程序应该终止。\n"

#. type: Title ##
#: ../src/Tutorial/IO.md:389
#, no-wrap
msgid "Do Blocks, Desugared"
msgstr "Do 语法块，脱糖"

#. type: Plain text
#: ../src/Tutorial/IO.md:402
#, no-wrap
msgid ""
"Here's an important piece of information: There is nothing\n"
"special about *do blocks*. They are just syntactic sugar,\n"
"which is converted to a sequence of operator applications.\n"
"With [syntactic sugar](https://en.wikipedia.org/wiki/Syntactic_sugar),\n"
"we mean syntax in a programming language that makes it\n"
"easier to express certain things in that language without\n"
"making the language itself any more powerful or expressive.\n"
"Here, it means you could write all the `IO` programs\n"
"without using `do` notation, but the code you'll write\n"
"will sometimes be harder to read, so *do blocks* provide\n"
"nicer syntax for these occasions.\n"
msgstr "这里有一条重要信息：*do blocks* 没有什么特别之处。它们只是语法糖，被转换为一系列运算符应用程序。使用 [语法糖](https://en.wikipedia.org/wiki/Syntactic_sugar)，我们指的是一种编程语言中的语法，它可以更容易地用该语言表达某些事物，而不会使语言本身更强大或更具表现力。在这里，这意味着您可以编写所有 `IO` 程序而不使用 `do` 符号，但是您编写的代码有时会更难阅读，因此 *do blocks* 为这些场合提供更好的语法。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:404
#, no-wrap
msgid "Consider the following example program:\n"
msgstr "考虑以下示例程序：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:405
#, no-wrap
msgid ""
"sugared1 : IO ()\n"
"sugared1 = do\n"
"  str1 <- getLine\n"
"  str2 <- getLine\n"
"  str3 <- getLine\n"
"  putStrLn (str1 ++ str2 ++ str3)\n"
msgstr ""
"sugared1 : IO ()\n"
"sugared1 = do\n"
"  str1 <- getLine\n"
"  str2 <- getLine\n"
"  str3 <- getLine\n"
"  putStrLn (str1 ++ str2 ++ str3)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:416
#, no-wrap
msgid ""
"The compiler will convert this to the following program\n"
"*before disambiguating function names and type checking*:\n"
msgstr "*在消除函数名称歧义和类型检查之前*，编译器会将其转换为以下程序：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:417
#, no-wrap
msgid ""
"desugared1 : IO ()\n"
"desugared1 =\n"
"  getLine >>= (\\str1 =>\n"
"    getLine >>= (\\str2 =>\n"
"      getLine >>= (\\str3 =>\n"
"        putStrLn (str1 ++ str2 ++ str3)\n"
"      )\n"
"    )\n"
"  )\n"
msgstr ""
"desugared1 : IO ()\n"
"desugared1 =\n"
"  getLine >>= (\\str1 =>\n"
"    getLine >>= (\\str2 =>\n"
"      getLine >>= (\\str3 =>\n"
"        putStrLn (str1 ++ str2 ++ str3)\n"
"      )\n"
"    )\n"
"  )\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:432
#, no-wrap
msgid ""
"There is a new operator (`(>>=)`) called *bind* in the\n"
"implementation of `desugared1`. If you look at its type\n"
"at the REPL, you'll see the following:\n"
msgstr "在 `desugared1` 的实现中有一个称为 *bind* 的新运算符 (`(>>=)`)。如果您在 REPL 中查看它的类型，您将看到以下内容：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:433
#, no-wrap
msgid ""
"Main> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
msgstr ""
"Main> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:441
#, no-wrap
msgid ""
"This is a constrained function requiring an interface called `Monad`.\n"
"We will talk about `Monad` and some of its friends in the next\n"
"chapter. Specialized to `IO`, *bind* has the following type:\n"
msgstr "这是一个受约束的函数，需要一个名为 `Monad` 的接口。我们将在下一章讨论 `Monad` 和它的一些朋友。专门针对`IO`，*bind*有以下类型：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:442
#, no-wrap
msgid ""
"Main> :t (>>=) {m = IO}\n"
">>= : IO a -> (a -> IO b) -> IO b\n"
msgstr ""
"Main> :t (>>=) {m = IO}\n"
">>= : IO a -> (a -> IO b) -> IO b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:451
#, no-wrap
msgid ""
"This describes a sequencing of `IO` actions. Upon execution,\n"
"the first `IO` action is being run and its result is\n"
"being passed as an argument to the function generating\n"
"the second `IO` action, which is then also being executed.\n"
msgstr "这描述了 `IO` 动作的顺序。执行时，第一个 `IO` 动作正在运行，其结果作为参数传递给生成第二个 `IO` 动作的函数，然后也将执行该动作。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:466
#, no-wrap
msgid ""
"You might remember, that you already implemented something\n"
"similar in an earlier exercise: In [Algebraic Data Types](DataTypes.md),\n"
"you implemented *bind* for `Maybe` and `Either e`. We will\n"
"learn in the next chapter, that `Maybe` and `Either e` too come\n"
"with an implementation of `Monad`. For now, suffice to say\n"
"that `Monad` allows us to run computations with some kind\n"
"of effect in sequence by passing the *result* of the\n"
"first computation to the function returning the\n"
"second computation. In `desugared1` you can see, how\n"
"we first perform an `IO` action and use its result\n"
"to compute the next `IO` action and so on. The code is somewhat\n"
"hard to read, since we use several layers of nested\n"
"anonymous function, that's why in such cases, *do blocks*\n"
"are a nice alternative to express the same functionality.\n"
msgstr "您可能还记得，您已经在之前的练习中实现了类似的东西：在 [代数数据类型](DataTypes.md) 中，您为 `Maybe` 和 `Either e` 实现了 *bind* 。我们将在下一章中了解到，`Maybe` 和 `Either e` 也都带有 `Monad` 的实现。现在，可以说 `Monad` 允许我们通过将第一次计算的 返回 *结果* 传递给第二次计算的函数来按顺序运行具有某种副作用的计算。在 `desugared1` 中，您可以看到，我们如何首先执行 `IO` 动作并使用其结果来计算下一个 `IO` 动作等等。代码有点难以阅读，因为我们使用了多层嵌套匿名函数，这就是为什么在这种情况下，*do 块* 是表达相同功能的不错选择。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:471
#, no-wrap
msgid ""
"Since *do block* are always desugared to sequences of\n"
"applied *bind* operators, we can use them to chain\n"
"any monadic computation. For instance, we can rewrite\n"
"function `eval` by using a *do block* like so:\n"
msgstr "由于 *do 块* 总是与应用的 *bind* 运算符序列脱糖，因此我们可以使用它们链接任何一元计算。例如，我们可以使用 *do 块 * 重写函数 `eval`，如下所示：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:472
#, no-wrap
msgid ""
"evalDo : String -> Either Error Integer\n"
"evalDo s = case forget $ split isSpace s of\n"
"  [x,y,z] => do\n"
"    v1 <- readInteger x\n"
"    op <- readOperator y\n"
"    v2 <- readInteger z\n"
"    Right $ op v1 v2\n"
"  _       => Left (ParseError s)\n"
msgstr ""
"evalDo : String -> Either Error Integer\n"
"evalDo s = case forget $ split isSpace s of\n"
"  [x,y,z] => do\n"
"    v1 <- readInteger x\n"
"    op <- readOperator y\n"
"    v2 <- readInteger z\n"
"    Right $ op v1 v2\n"
"  _       => Left (ParseError s)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:488
#, no-wrap
msgid ""
"Don't worry, if this doesn't make too much sense yet. We will\n"
"see many more examples, and you'll get the hang of this\n"
"soon enough. The important thing to remember is how *do\n"
"blocks* are always converted to sequences of *bind*\n"
"operators as shown in `desugared1`.\n"
msgstr "别担心，如果这还没有太大意义。我们将看到更多示例，您很快就会掌握其中的窍门。要记住的重要一点是 *do 块* 总是转换为 *bind* 运算符的序列，如 `desugared1` 所示。\n"

#. type: Title ###
#: ../src/Tutorial/IO.md:489
#, no-wrap
msgid "Binding Unit"
msgstr "Unit 绑定"

#. type: Plain text
#: ../src/Tutorial/IO.md:492
#, no-wrap
msgid "Remember our implementation of `friendlyReadHello`? Here it is again:\n"
msgstr "还记得我们对 `friendlyReadHello` 的实现吗？这里又是：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:493
#, no-wrap
msgid ""
"friendlyReadHello' : IO ()\n"
"friendlyReadHello' = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
msgstr ""
"friendlyReadHello' : IO ()\n"
"friendlyReadHello' = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:505
#, no-wrap
msgid ""
"The underscore in there is a bit ugly and unnecessary. In fact,\n"
"a common use case is to just chain effectful computations with\n"
"result type `Unit` (`()`), merely for the side\n"
"effects they perform. For instance, we could repeat `friendlyReadHello`\n"
"three times, like so:\n"
msgstr "那里的下划线有点丑陋和不必要。事实上，一个常见的用例是将有效计算与结果类型 `Unit` (`()`) 链接起来，只是为了它们执行的副作用。例如，我们可以重复 `friendlyReadHello` 三次，如下所示：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:506
#, no-wrap
msgid ""
"friendly3 : IO ()\n"
"friendly3 = do\n"
"  _ <- friendlyReadHello\n"
"  _ <- friendlyReadHello\n"
"  friendlyReadHello\n"
msgstr ""
"friendly3 : IO ()\n"
"friendly3 = do\n"
"  _ <- friendlyReadHello\n"
"  _ <- friendlyReadHello\n"
"  friendlyReadHello\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:516
#, no-wrap
msgid ""
"This is such a common thing to do, that Idris allows us to\n"
"drop the bound underscores altogether:\n"
msgstr "这是很常见的事情，Idris 允许我们完全放弃绑定的下划线：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:517
#, no-wrap
msgid ""
"friendly4 : IO ()\n"
"friendly4 = do\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
msgstr ""
"friendly4 : IO ()\n"
"friendly4 = do\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:527
#, no-wrap
msgid "Note, however, that the above gets desugared slightly differently:\n"
msgstr "但是请注意，上述内容的脱糖略有不同：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:528
#, no-wrap
msgid ""
"friendly4Desugared : IO ()\n"
"friendly4Desugared =\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello\n"
msgstr ""
"friendly4Desugared : IO ()\n"
"friendly4Desugared =\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:538
#, no-wrap
msgid "Operator `(>>)` has the following type:\n"
msgstr "运算符 `(>>)` 具有以下类型：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:539
#, no-wrap
msgid ""
"Main> :t (>>)\n"
"Prelude.>> : Monad m => m () -> Lazy (m b) -> m b\n"
msgstr ""
"Main> :t (>>)\n"
"Prelude.>> : Monad m => m () -> Lazy (m b) -> m b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:550
#, no-wrap
msgid ""
"Note the `Lazy` keyword in the type signature. This means,\n"
"that the wrapped argument will be *lazily evaluated*. This\n"
"makes sense in many occasions. For instance, if the `Monad`\n"
"in question is `Maybe` the result will be `Nothing` if\n"
"the first argument is `Nothing`, in which case there is no\n"
"need to even evaluate the second argument.\n"
msgstr "注意类型签名中的 `Lazy` 关键字。这意味着，包装的参数将被 *延迟求值*。这在很多场合都是有道理的。例如，如果所讨论的 `Monad` 是 `Maybe` 如果第一个参数是 `Nothing`，那么结果将是 `Nothing`，在这种情况下甚至不需要求值第二个参数。\n"

#. type: Title ###
#: ../src/Tutorial/IO.md:551
#, no-wrap
msgid "Do, Overloaded"
msgstr "Do和重载"

#. type: Plain text
#: ../src/Tutorial/IO.md:562
#, no-wrap
msgid ""
"Because Idris supports function and operator overloading, we\n"
"can write custom *bind* operators, which allows us to\n"
"use *do notation* for types without an implementation\n"
"of `Monad`. For instance, here is a custom implementation of\n"
"`(>>=)` for sequencing computations returning vectors.\n"
"Every value in the first vector (of length `m`)\n"
"will be converted to a vector of length `n`, and\n"
"the results will be concatenated leading to\n"
"a vector of length `m * n`:\n"
msgstr "因为 Idris 支持函数和运算符重载，我们可以编写自定义的 *bind* 运算符，这允许我们对没有实现 `Monad` 的类型使用 *do notation*。例如，这是 `(>>=)` 的自定义实现，用于对返回向量的计算进行排序。第一个向量（长度为 `m`）中的每个值都将转换为长度为 `n` 的向量，结果将被连接到长度为 `m * n ` 的向量：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:563
#, no-wrap
msgid ""
"flatten : Vect m (Vect n a) -> Vect (m * n) a\n"
"flatten []        = []\n"
"flatten (x :: xs) = x ++ flatten xs\n"
"\n"
"(>>=) : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"as >>= f = flatten (map f as)\n"
msgstr ""
"flatten : Vect m (Vect n a) -> Vect (m * n) a\n"
"flatten []        = []\n"
"flatten (x :: xs) = x ++ flatten xs\n"
"\n"
"(>>=) : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"as >>= f = flatten (map f as)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:580
#, no-wrap
msgid ""
"It is not possible to write an implementation of `Monad`,\n"
"which encapsulates this behavior, as the types wouldn't\n"
"match: Monadic *bind* specialized to `Vect` has\n"
"type `Vect k a -> (a -> Vect k b) -> Vect k b`. As you\n"
"see, the sizes of all three occurrences of `Vect`\n"
"have to be the same, which is not what we expressed\n"
"in our custom version of *bind*. Here is an example to\n"
"see this in action:\n"
msgstr "无法编写封装此行为的 `Monad` 的实现，因为类型不匹配：专用于 `Vect` 的 Monadic *bind* 具有类型 `Vect k a -> (a -> Vect k b) -> Vect k b`。如您所见，所有三个 `Vect` 的大小必须相同，这不是我们在自定义版本的 *bind* 中表达的。下面是一个例子，可以看到这一点：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:581
#, no-wrap
msgid ""
"modString : String -> Vect 4 String\n"
"modString s = [s, reverse s, toUpper s, toLower s]\n"
"\n"
"testDo : Vect 24 String\n"
"testDo = IO.do\n"
"  s1 <- [\"Hello\", \"World\"]\n"
"  s2 <- [1, 2, 3]\n"
"  modString (s1 ++ show s2)\n"
msgstr ""
"modString : String -> Vect 4 String\n"
"modString s = [s, reverse s, toUpper s, toLower s]\n"
"\n"
"testDo : Vect 24 String\n"
"testDo = IO.do\n"
"  s1 <- [\"Hello\", \"World\"]\n"
"  s2 <- [1, 2, 3]\n"
"  modString (s1 ++ show s2)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:601
#, no-wrap
msgid ""
"Try to figure out how `testDo` works by desugaring it\n"
"manually and then comparing its result with what you\n"
"expected at the REPL. Note, how we helped Idris disambiguate,\n"
"which version of the *bind* operator to use by prefixing\n"
"the `do` keyword with part of the operator's namespace.\n"
"In this case, this wasn't strictly necessary, although\n"
"`Vect k` does have an implementation of `Monad`, but it is\n"
"still good to know that it is possible to help\n"
"the compiler with disambiguating do blocks.\n"
msgstr "尝试通过手动对 `testDo` 进行脱糖，然后将其结果与您在 REPL 中的预期结果进行比较来弄清楚 `testDo` 是如何工作的。请注意，我们如何帮助 Idris 消除歧义，通过在 `do` 关键字前加上运算符名称空间的一部分来使用哪个版本的 *bind* 运算符。在这种情况下，这不是绝对必要的，虽然 `Vect k` 确实有 `Monad` 的实现，但知道它可以帮助编译器消除歧义对 do 语法块来说仍然是件好事。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:605
#, no-wrap
msgid ""
"Of course, we can (and should!) overload `(>>)` in the\n"
"same manner as `(>>=)`, if we want to overload the\n"
"behavior of *do blocks*.\n"
msgstr "当然，如果我们想重载 *do 语法块* 的行为，我们可以（并且应该！）重载 `(>>)` 和 `(>>=)`。\n"

#. type: Title ####
#: ../src/Tutorial/IO.md:606
#, no-wrap
msgid "Modules and Namespaces"
msgstr "模块和命名空间"

#. type: Plain text
#: ../src/Tutorial/IO.md:614
#, no-wrap
msgid ""
"Every data type, function, or operator can be unambiguously\n"
"identified by prefixing it with its *namespace*. A function's\n"
"namespace typically is the same as the module where it was defined.\n"
"For instance, the fully qualified name of function `eval`\n"
"would be `Tutorial.IO.eval`. Function and operator names must\n"
"be unique in their namespace.\n"
msgstr "每个数据类型、函数或运算符都可以通过为其 *命名空间* 加上前缀来明确标识。函数的命名空间通常与定义它的模块相同。例如，函数 `eval` 的完全限定名称将是 `Tutorial.IO.eval`。函数和运算符名称在其命名空间中必须是唯一的。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:620
#, no-wrap
msgid ""
"As we already learned, Idris can often disambiguate between\n"
"functions with the same name but defined in different namespaces\n"
"based on the types involved. If this is not possible, we can help\n"
"the compiler by *prefixing* the function or operator name with\n"
"a *suffix* of the full namespace. Let's demonstrate this at the REPL:\n"
msgstr "正如我们已经了解到的那样，Idris 通常可以消除具有相同名称但根据所涉及的类型在不同命名空间中定义的函数之间的歧义。如果这还是不行的话，我们可以通过 *前缀* 使用完整命名空间的 *后缀* 的函数或运算符名称来帮助编译器。让我们在 REPL 上演示一下：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:621
#, no-wrap
msgid ""
"Tutorial.IO> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
msgstr ""
"Tutorial.IO> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:633
#, no-wrap
msgid ""
"As you can see, if we load this module in a REPL session and\n"
"inspect the type of `(>>=)`, we get two results as two\n"
"operators with this name are in scope. If we only want\n"
"the REPL to print the type of our custom *bind* operator,\n"
"is is sufficient to prefix it with `IO`, although we could\n"
"also prefix it with its full namespace:\n"
msgstr "如您所见，如果我们在 REPL 会话中加载此模块并检查 `(>>=)` 的类型，我们会得到两个结果，因为具有此名称的两个运算符都在范围内。如果我们只希望 REPL 打印我们自定义的 *bind* 运算符的类型，那么在它前面加上 `IO` 就足够了，尽管我们也可以在它前面加上完整的命名空间：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:634
#, no-wrap
msgid ""
"Tutorial.IO> :t IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"Tutorial.IO> :t Tutorial.IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
msgstr ""
"Tutorial.IO> :t IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"Tutorial.IO> :t Tutorial.IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:649
#, no-wrap
msgid ""
"Since function names must be unique in their namespace and\n"
"we still may want to define two overloaded versions of a function\n"
"in an Idris module, Idris makes it possible to add\n"
"additional namespaces to modules. For instance, in order\n"
"to define another function called `eval`, we need to add\n"
"it to its own namespace (note, that all definitions in a\n"
"namespace must be indented by the same amount of\n"
"white space):\n"
msgstr "由于函数名称在它们的命名空间中必须是唯一的，而且我们仍然可能希望在 Idris 模块中定义函数的两个重载版本，因此 Idris 可以为模块添加额外的命名空间。例如，为了定义另一个名为 `eval` 的函数，我们需要将它添加到它自己的命名空间中（注意，命名空间中的所有定义必须缩进相同数量的空格）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:650
#, no-wrap
msgid ""
"namespace Foo\n"
"  export\n"
"  eval : Nat -> Nat -> Nat\n"
"  eval = (*)\n"
"\n"
"-- prefixing `eval` with its namespace is not strictly necessary here\n"
"testFooEval : Nat\n"
"testFooEval = Foo.eval 12 100\n"
msgstr ""
"namespace Foo\n"
"  export\n"
"  eval : Nat -> Nat -> Nat\n"
"  eval = (*)\n"
"\n"
"-- prefixing `eval` with its namespace is not strictly necessary here\n"
"testFooEval : Nat\n"
"testFooEval = Foo.eval 12 100\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:665
#, no-wrap
msgid ""
"Now, here is an important thing: For functions and data types to\n"
"be accessible from outside their namespace or module, they need to\n"
"be *exported* by annotating them with the `export` or `public export`\n"
"keywords.\n"
msgstr "现在，这里有一件重要的事情：对于要从其命名空间或模块外部访问的函数和数据类型，需要通过使用 `export` 或 `public export` 关键字注释它们来 *导出*。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:674
#, no-wrap
msgid ""
"The difference between `export` and `public export` is the following:\n"
"A function annotated with `export` exports its type and can be\n"
"called from other namespaces. A data type annotated with `export`\n"
"exports its type constructor but not its data constructors.\n"
"A function annotated with `public export` also exports its\n"
"implementation. This is necessary to use the function in compile-time\n"
"computations. A data type annotated with `public export`\n"
"exports its data constructors as well.\n"
msgstr "`export` 和 `public export` 的区别如下：用 `export` 注解的函数导出其类型，可以从其他命名空间调用。使用 `export` 注释的数据类型导出其类型构造函数，但不导出其数据构造函数。使用 `public export` 注释的函数也会导出其实现。这是在编译时计算中使用该函数所必需的。使用 `public export` 注释的数据类型也会导出其数据构造函数。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:680
#, no-wrap
msgid ""
"In general, consider annotating data types with `public export`,\n"
"since otherwise you will not be able to create values of these\n"
"types or deconstruct them in pattern matches. Likewise, unless you\n"
"plan to use your functions in compile-time computations, annotate\n"
"them with `export`.\n"
msgstr "通常，请考虑使用 `public export` 注释数据类型，否则您将无法创建这些类型的值或在模式匹配中解构它们。同样，除非您打算在编译时计算中使用您的函数，否则请使用 `export` 注释它们。\n"

#. type: Title ###
#: ../src/Tutorial/IO.md:681
#, no-wrap
msgid "Bind, with a Bang"
msgstr "绑定，砰的一声"

#. type: Plain text
#: ../src/Tutorial/IO.md:688
#, no-wrap
msgid ""
"Sometimes, even *do blocks* are too noisy to express a\n"
"combination of effectful computations. In this case, we\n"
"can prefix the effectful parts with an exclamation mark\n"
"(wrapping them in parentheses if they contain additional\n"
"white space), while leaving pure expressions unmodified:\n"
msgstr "有时，即使是 *do 块* 也过于嘈杂，无法表达有效计算的组合。在这种情况下，我们可以在副作用部分前面加上一个感叹号（如果它们包含额外的空格，则将它们括在括号中），同时保持纯表达式不变：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:689
#, no-wrap
msgid ""
"getHello : IO ()\n"
"getHello = putStrLn $ \"Hello \" ++ !getLine ++ \"!\"\n"
msgstr ""
"getHello : IO ()\n"
"getHello = putStrLn $ \"Hello \" ++ !getLine ++ \"!\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:695
#, no-wrap
msgid "The above gets desugared to the following *do block*:\n"
msgstr "上面的内容被分解为以下 *do 块*：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:696
#, no-wrap
msgid ""
"getHello' : IO ()\n"
"getHello' = do\n"
"  s <- getLine\n"
"  putStrLn $ \"Hello \" ++ s ++ \"!\"\n"
msgstr ""
"getHello' : IO ()\n"
"getHello' = do\n"
"  s <- getLine\n"
"  putStrLn $ \"Hello \" ++ s ++ \"!\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:704
#, no-wrap
msgid "Here is another example:\n"
msgstr "这是另一个例子：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:705
#, no-wrap
msgid ""
"bangExpr : String -> String -> String -> Maybe Integer\n"
"bangExpr s1 s2 s3 =\n"
"  Just $ !(parseInteger s1) + !(parseInteger s2) * !(parseInteger s3)\n"
msgstr ""
"bangExpr : String -> String -> String -> Maybe Integer\n"
"bangExpr s1 s2 s3 =\n"
"  Just $ !(parseInteger s1) + !(parseInteger s2) * !(parseInteger s3)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:712
#, no-wrap
msgid "And here is the desugared *do block*:\n"
msgstr "这是脱糖的 *do 块*：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:713
#, no-wrap
msgid ""
"bangExpr' : String -> String -> String -> Maybe Integer\n"
"bangExpr' s1 s2 s3 = do\n"
"  x1 <- parseInteger s1\n"
"  x2 <- parseInteger s2\n"
"  x3 <- parseInteger s3\n"
"  Just $ x1 + x2 * x3\n"
msgstr ""
"bangExpr' : String -> String -> String -> Maybe Integer\n"
"bangExpr' s1 s2 s3 = do\n"
"  x1 <- parseInteger s1\n"
"  x2 <- parseInteger s2\n"
"  x3 <- parseInteger s3\n"
"  Just $ x1 + x2 * x3\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:727
#, no-wrap
msgid ""
"Please remember the following: Syntactic sugar has been introduced\n"
"to make code more readable or more convenient to write. If\n"
"it is abused just to show how clever you are, you make things\n"
"harder for other people (including your future self!)\n"
"reading and trying to understand your code.\n"
msgstr "请记住以下几点： 已引入语法糖以使代码更具可读性或更方便编写。如果它被滥用只是为了展示你有多聪明，你会让其他人（包括你未来的自己！）阅读和试图理解你的代码变得更加困难。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:733
#, no-wrap
msgid ""
"Reimplement the following *do blocks*, once by using\n"
"*bang notation*, and once by writing them in their\n"
"desugared form with nested *bind*s:\n"
msgstr "重新实现以下 *do "
"块*，一次使用*感叹号*，一次通过嵌套*绑定*以脱糖形式编写它们：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:734
#, no-wrap
msgid ""
"   ex1a : IO String\n"
"   ex1a = do\n"
"     s1 <- getLine\n"
"     s2 <- getLine\n"
"     s3 <- getLine\n"
"     pure $ s1 ++ reverse s2 ++ s3\n"
"\n"
"   ex1b : Maybe Integer\n"
"   ex1b = do\n"
"     n1 <- parseInteger \"12\"\n"
"     n2 <- parseInteger \"300\"\n"
"     Just $ n1 + n2 * 100\n"
msgstr ""
"   ex1a : IO String\n"
"   ex1a = do\n"
"     s1 <- getLine\n"
"     s2 <- getLine\n"
"     s3 <- getLine\n"
"     pure $ s1 ++ reverse s2 ++ s3\n"
"\n"
"   ex1b : Maybe Integer\n"
"   ex1b = do\n"
"     n1 <- parseInteger \"12\"\n"
"     n2 <- parseInteger \"300\"\n"
"     Just $ n1 + n2 * 100\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:752
#, no-wrap
msgid ""
"Below is the definition of an indexed family of types,\n"
"the index of which keeps track of whether the value in\n"
"question is possibly empty or provably non-empty:\n"
msgstr "下面是索引类型族的定义，其索引跟踪所讨论的值是否可能为空或可证明非空：\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:766
#, no-wrap
msgid ""
"   Please note, that the `Nil` case *must* have the `nonEmpty`\n"
"   tag set to `False`, while with the *cons* case, this is\n"
"   optional. So, a `List01 False a` can be empty or non-empty,\n"
"   and we'll only find out, which is the case, by pattern\n"
"   matching on it. A `List01 True a` on the other hand *must*\n"
"   be a *cons*, as for the `Nil` case the `nonEmpty` tag is\n"
"   always set to `False`.\n"
msgstr ""
"   请注意，`Nil` 分支 *必须* 有一个值为 `False` 的 `nonEmpty` 标签，而在 *cons* 的情况下，这是可选的。因此，`List01 False a` 可以为空或非空，\n"
"   我们只会通过模式找出匹配它的情况。 另一方面， `List01 True a` *必须* 是 *cons*，对于 `Nil` 的情况， `nonEmpty` 标签应始终设置为 `False`。\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/IO.md:768
#, no-wrap
msgid "Declare and implement function `head` for non-empty lists:\n"
msgstr "为非空列表声明并实现函数 `head`：\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:772
#, no-wrap
msgid ""
"      ```idris\n"
"      head : List01 True a -> a\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      head : List01 True a -> a\n"
"      ```\n"

#. type: Bullet: '   2. '
#: ../src/Tutorial/IO.md:776
#, no-wrap
msgid ""
"Declare and implement function `weaken` for converting any `List01 ne a`\n"
"to a `List01 False a` of the same length and order\n"
"of values.\n"
msgstr "声明并实现函数 `weaken` 用于将任何 `List01 ne a` "
"转换为具有相同长度和值顺序的 `List01 False a`。\n"

#. type: Bullet: '   3. '
#: ../src/Tutorial/IO.md:779
#, no-wrap
msgid ""
"Declare and implement function `tail` for extracting the possibly\n"
"empty tail from a non-empty list.\n"
msgstr "声明并实现函数 `tail` 用于从非空列表中提取可能为空的尾部。\n"

#. type: Bullet: '   4. '
#: ../src/Tutorial/IO.md:784
#, no-wrap
msgid ""
"Implement function `(++)` for concatenating two\n"
"values of type `List01`. Note, how we use a type-level computation\n"
"to make sure the result is non-empty if and only if\n"
"at least one of the two arguments is non-empty:\n"
msgstr ""
"实现函数 `(++)` 以连接两个 `List01` 类型的值。请注意，当且仅当两个参数中的至"
"少一个非空时，我们如何使用类型级计算来确保结果非空：\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:788
#, no-wrap
msgid ""
"      ```idris\n"
"      (++) : List01 b1 a -> List01 b2 a -> List01 (b1 || b2) a\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      (++) : List01 b1 a -> List01 b2 a -> List01 (b1 || b2) a\n"
"      ```\n"

#. type: Bullet: '   5. '
#: ../src/Tutorial/IO.md:794
#, no-wrap
msgid ""
"Implement utility function `concat'` and use it in\n"
"the implementation of `concat`. Note, that in `concat` the\n"
"two boolean tags are passed as unrestricted implicits,\n"
"since you will need to pattern match on these to determine\n"
"whether the result is provably non-empty or not:\n"
msgstr ""
"实现实用函数 `concat'` 并在 `concat` 的实现中使用它。请注意，在 `concat` 中，"
"两个布尔标记作为不受限制的隐式传递，因为您需要对它们进行模式匹配以确定结果是"
"否可证明为非空：\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:797
#, no-wrap
msgid ""
"      ```idris\n"
"      concat' : List01 ne1 (List01 ne2 a) -> List01 False a\n"
msgstr ""
"      ```idris\n"
"      concat' : List01 ne1 (List01 ne2 a) -> List01 False a\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:802
#, no-wrap
msgid ""
"      concat :  {ne1, ne2 : _}\n"
"             -> List01 ne1 (List01 ne2 a)\n"
"             -> List01 (ne1 && ne2) a\n"
"      ```\n"
msgstr ""
"      concat :  {ne1, ne2 : _}\n"
"             -> List01 ne1 (List01 ne2 a)\n"
"             -> List01 (ne1 && ne2) a\n"
"      ```\n"

#. type: Bullet: '   6. '
#: ../src/Tutorial/IO.md:804
#, no-wrap
msgid "Implement `map01`:\n"
msgstr "实现 `map01`：\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:808
#, no-wrap
msgid ""
"      ```idris\n"
"      map01 : (a -> b) -> List01 ne a -> List01 ne b\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      map01 : (a -> b) -> List01 ne a -> List01 ne b\n"
"      ```\n"

#. type: Bullet: '   7. '
#: ../src/Tutorial/IO.md:811
#, no-wrap
msgid ""
"Implement a custom *bind* operator in namespace `List01`\n"
"for sequencing computations returning `List01`s.\n"
msgstr "在命名空间 `List01` 中实现自定义*绑定*运算符，用于对返回 `List01`s "
"的计算进行排序。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:814
#, no-wrap
msgid ""
"      Hint: Use `map01` and `concat` in your implementation and\n"
"      make sure to use unrestricted implicits where necessary.\n"
msgstr ""
"      提示：在你的实现中使用 `map01` 和 `concat`\n"
"      确保在必要时使用不受限制的隐式。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:817
#, no-wrap
msgid ""
"      You can use the following examples to test your\n"
"      custom *bind* operator:\n"
msgstr ""
"      您可以使用以下示例来测试您的\n"
"      自定义 *bind* 运算符：\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:823
#, no-wrap
msgid ""
"      ```idris\n"
"      -- this and lf are necessary to make sure, which tag to use\n"
"      -- when using list literals\n"
"      lt : List01 True a -> List01 True a\n"
"      lt = id\n"
msgstr ""
"      ```idris\n"
"      -- this and lf are necessary to make sure, which tag to use\n"
"      -- when using list literals\n"
"      lt : List01 True a -> List01 True a\n"
"      lt = id\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:826
#, no-wrap
msgid ""
"      lf : List01 False a -> List01 False a\n"
"      lf = id\n"
msgstr ""
"      lf : List01 False a -> List01 False a\n"
"      lf = id\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:833
#, no-wrap
msgid ""
"      test : List01 True Integer\n"
"      test = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- lt [4,5,6,7]\n"
"        op <- lt [(*), (+), (-)]\n"
"        [op x y]\n"
msgstr ""
"      test : List01 True Integer\n"
"      test = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- lt [4,5,6,7]\n"
"        op <- lt [(*), (+), (-)]\n"
"        [op x y]\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:841
#, no-wrap
msgid ""
"      test2 : List01 False Integer\n"
"      test2 = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- Nil {a = Integer}\n"
"        op <- lt [(*), (+), (-)]\n"
"        lt [op x y]\n"
"      ```\n"
msgstr ""
"      test2 : List01 False Integer\n"
"      test2 = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- Nil {a = Integer}\n"
"        op <- lt [(*), (+), (-)]\n"
"        lt [op x y]\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:857
#, no-wrap
msgid ""
"Some notes on Exercise 2: Here, we combined the capabilities\n"
"of `List` and `Data.List1` in a single indexed type family.\n"
"This allowed us to treat list concatenation correctly: If\n"
"at least one of the arguments is provably non-empty, the\n"
"result is also non-empty. To tackle this correctly with\n"
"`List` and `List1`, a total of four concatenation functions\n"
"would have to be written. So, while it is often possible to\n"
"define distinct data types instead of indexed families,\n"
"the latter allow us to perform type-level computations to\n"
"be more precise about the pre- and postconditions of the functions\n"
"we write, at the cost of more-complex type signatures.\n"
"In addition, sometimes it's not possible to derive the\n"
"values of the indices from pattern matching on the data\n"
"values alone, so they have to be passed as unerased\n"
"(possibly implicit) arguments.\n"
msgstr "练习 2 的一些注意事项：在这里，我们将 `List` 和 `Data.List1` 的函数组合在一个索引类型族中。这使我们能够正确处理列表连接：如果至少有一个参数可证明是非空的，则结果也是非空的。为了用 `List` 和 `List1` 正确解决这个问题，总共需要编写四个连接函数。因此，虽然通常可以定义不同的数据类型而不是索引族，但后者允许我们执行类型级计算，以更精确地了解我们编写的函数的前置条件和后置条件，但代价是更复杂类型签名。此外，有时不可能仅从数据值的模式匹配中导出索引的值，因此必须将它们作为未擦除（可能是隐式）参数传递。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:864
#, no-wrap
msgid ""
"Please remember, that *do blocks* are first desugared, before\n"
"type-checking, disambiguating which *bind* operator to use,\n"
"and filling in implicit arguments. It is therefore perfectly fine\n"
"to define *bind* operators with arbitrary constraints or\n"
"implicit arguments as was shown above. Idris will handle\n"
"all the details, *after* desugaring the *do blocks*.\n"
msgstr "请记住，首先对 *do 块* 进行脱糖，然后再进行类型检查、消除使用哪个 *bind* 运算符的歧义以及填充隐式参数。因此，使用任意约束或隐式参数定义 *bind* 运算符是非常好的，如上所示。 Idris 将脱糖 *do 块* *之后*处理所有细节。\n"

#. type: Title ##
#: ../src/Tutorial/IO.md:865
#, no-wrap
msgid "Working with Files"
msgstr "使用文件"

#. type: Plain text
#: ../src/Tutorial/IO.md:872
#, no-wrap
msgid ""
"Module `System.File` from the *base* library exports utilities necessary\n"
"to work with file handles and read and write from and to files. When\n"
"you have a file path (for instance \"/home/hock/idris/tutorial/tutorial.ipkg\"),\n"
"the first thing we will typically do is to try and create a file handle\n"
"(of type `System.File.File` by calling `fileOpen`).\n"
msgstr "*base* 库中的模块 `System.File` 导出处理文件句柄和读取和写入文件所需的实用程序。当您有一个文件路径（例如“/home/hock/idris/tutorial/tutorial.ipkg”）时，我们通常会做的第一件事是尝试创建一个文件句柄（类型为 `System.File.File` ，可以通过通过调用 `fileOpen` 获得）。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:874
#, no-wrap
msgid "Here is a program for counting all empty lines in a Unix/Linux-file:\n"
msgstr "这是一个计算 Unix/Linux 文件中所有空行的程序：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:875
#, no-wrap
msgid ""
"covering\n"
"countEmpty : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty path = openFile path Read >>= either (pure . Left) (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => closeFile file $> Right k\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => closeFile file $> Left err\n"
"          go (k + 1) file\n"
msgstr ""
"covering\n"
"countEmpty : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty path = openFile path Read >>= either (pure . Left) (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => closeFile file $> Right k\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => closeFile file $> Left err\n"
"          go (k + 1) file\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:894
#, no-wrap
msgid ""
"In the example above, I invoked `(>>=)` without starting a *do block*.\n"
"Make sure you understand what's going on here. Reading concise functional\n"
"code is important in order to understand other people's code.\n"
"Have a look at function `either` at the REPL, try figuring out what\n"
"`(pure . Left)` does, and note how we use a curried version of `go`\n"
"as the second argument to `either`.\n"
msgstr "在上面的示例中，我调用了 `(>>=)` 而不启动 *do 块*。确保你了解这里发生了什么。阅读简洁的函数代码对于理解其他人的代码很重要。查看 REPL 中的函数 `either`，尝试弄清楚 `(pure . Left)` 做了什么，并注意我们如何使用 `go` 的柯里化版本`either` 的第二个参数。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:905
#, no-wrap
msgid ""
"Function `go` calls for some additional explanations. First, note how\n"
"we used the same syntax for pattern matching intermediary results\n"
"as we also saw for `let` bindings. As you can see, we can use several\n"
"vertical bars to handle more than one additional pattern. In order to\n"
"read a single line from a file, we use function `fGetLine`. As with\n"
"most operations working with the file system, this function might fail\n"
"with a `FileError`, which we have to handle correctly. Note also, that\n"
"`fGetLine` will return the line including its trailing newline character\n"
"`'\\n'`, so in order to check for empty lines, we have to match against\n"
"`\"\\n\"` instead of the empty string `\"\"`.\n"
msgstr "函数 `go` 需要一些额外的解释。首先，请注意我们如何使用与 `let` 绑定相同的语法来进行模式匹配中间结果。如您所见，我们可以使用多个垂直条来处理多个附加模式。为了从文件中读取单行，我们使用函数 `fGetLine`。与使用文件系统的大多数操作一样，此函数可能会因 `FileError` 而失败，我们必须正确处理。另请注意，`fGetLine` 将返回包含其尾随换行符 `'\\n'` 的行，因此为了检查空行，我们必须匹配 `\"\\ n\"` 而不是空字符串 `\"\"`。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:910
#, no-wrap
msgid ""
"Finally, `go` is not provably total and rightfully so.\n"
"Files like `/dev/urandom` or `/dev/zero` provide infinite\n"
"streams of data, so `countEmpty` will never\n"
"terminate when invoked with such a file path.\n"
msgstr "最后，`go` 不能被证明是完全的并且是正确的。像 `/dev/urandom` 或 `/dev/zero` 这样的文件提供了无限的数据流，所以当使用这样的文件路径调用时，`countEmpty` 永远不会终止。\n"

#. type: Title ###
#: ../src/Tutorial/IO.md:911
#, no-wrap
msgid "Safe Resource Handling"
msgstr "安全资源处理"

#. type: Plain text
#: ../src/Tutorial/IO.md:919
#, no-wrap
msgid ""
"Note, how we had to manually open and close the file handle in\n"
"`countEmpty`. This is error-prone and tedious. Resource handling\n"
"is a big topic, and we definitely won't be going into the\n"
"details here, but there is a convenient function exported\n"
"from `System.File`: `withFile`, which handles the opening,\n"
"closing and handling of file errors for us.\n"
msgstr "注意，我们必须手动打开和关闭 `countEmpty` 中的文件句柄。这是容易出错且乏味的。资源处理是一个很大的话题，这里肯定不赘述，但是从`System.File`导出一个方便的函数：`withFile`，处理打开，为我们关闭和处理文件错误。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:920
#, no-wrap
msgid ""
"covering\n"
"countEmpty' : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty' path = withFile path Read pure (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => pure (Right k)\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => pure (Left err)\n"
"          go (k + 1) file\n"
msgstr ""
"covering\n"
"countEmpty' : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty' path = withFile path Read pure (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => pure (Right k)\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => pure (Left err)\n"
"          go (k + 1) file\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:937
#, no-wrap
msgid ""
"Go ahead, and have a look at the type of `withFile`, then\n"
"have a look how we use it to simplify the implementation of\n"
"`countEmpty'`. Reading and understanding slightly more complex\n"
"function types is important when learning to program in Idris.\n"
msgstr "来吧，看看 `withFile` 的类型，然后看看我们如何使用它来简化 `countEmpty'` 的实现。在学习 Idris 编程时，阅读和理解稍微复杂的函数类型很重要。\n"

#. type: Title ####
#: ../src/Tutorial/IO.md:938
#, no-wrap
msgid "Interface `HasIO`"
msgstr "`HasIO` 接口"

#. type: Plain text
#: ../src/Tutorial/IO.md:948
#, no-wrap
msgid ""
"When you look at the `IO` functions we used so far, you'll\n"
"notice that most if not all of them actually don't work\n"
"with `IO` itself but with a type parameter `io` with a\n"
"constraint of `HasIO`. This interface allows us to *lift*\n"
"a value of type `IO a` into another context. We will see\n"
"use cases for this in later chapters, especially when we\n"
"talk about monad transformers. For now, you can treat these\n"
"`io` parameters as being specialized to `IO`.\n"
msgstr "当您查看我们目前使用的 `IO` 函数时，您会注意到大多数（如果不是全部）实际上不适用于 `IO` 本身，而是使用类型参数 `io`，约束为 `HasIO`。该接口允许我们将 *提升* 类型为 `IO a` 的值放入另一个上下文中。我们将在后面的章节中看到这方面的用例，尤其是当我们谈论 monad 转换器时。现在，您可以将这些 `io` 参数视为专用于 `IO`。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:959
#, no-wrap
msgid ""
"As we have seen in the examples above, `IO` actions\n"
"working with file handles often come with the risk\n"
"of failure. We can therefore simplify things by\n"
"writing some utility functions and a custom *bind*\n"
"operator to work with these nested effects. In\n"
"a new namespace `IOErr`, implement the following\n"
"utility functions and use these to further cleanup\n"
"the implementation of `countEmpty'`:\n"
msgstr ""
"正如我们在上面的示例中所看到的，使用文件句柄的 `IO` "
"操作通常会带来失败的风险。因此，我们可以通过编写一些实用函数和自定义 *bind* "
"运算符来处理这些嵌套效果来简化事情。在新的命名空间 `IOErr` 中，"
"实现以下实用函数并使用它们进一步清理 `countEmpty'` 的实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:960
#, no-wrap
msgid ""
"   pure : a -> IO (Either e a)\n"
"\n"
"   fail : e -> IO (Either e a)\n"
"\n"
"   lift : IO a -> IO (Either e a)\n"
"\n"
"   catch : IO (Either e1 a) -> (e1 -> IO (Either e2 a)) -> IO (Either e2 a)\n"
"\n"
"   (>>=) : IO (Either e a) -> (a -> IO (Either e b)) -> IO (Either e b)\n"
"\n"
"   (>>) : IO (Either e ()) -> Lazy (IO (Either e a)) -> IO (Either e a)\n"
msgstr ""
"   pure : a -> IO (Either e a)\n"
"\n"
"   fail : e -> IO (Either e a)\n"
"\n"
"   lift : IO a -> IO (Either e a)\n"
"\n"
"   catch : IO (Either e1 a) -> (e1 -> IO (Either e2 a)) -> IO (Either e2 a)\n"
"\n"
"   (>>=) : IO (Either e a) -> (a -> IO (Either e b)) -> IO (Either e b)\n"
"\n"
"   (>>) : IO (Either e ()) -> Lazy (IO (Either e a)) -> IO (Either e a)\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:977
#, no-wrap
msgid ""
"Write a function `countWords` for counting the words in a file.\n"
"Consider using `Data.String.words` and the utilities from\n"
"exercise 1 in your implementation.\n"
msgstr ""
"编写一个函数 `countWords` 用于计算文件中的单词。考虑在您的实现中使用 `Data."
"String.words` 和练习 1 中的实用程序。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/IO.md:983
#, no-wrap
msgid ""
"We can generalize the functionality used in `countEmpty`\n"
"and `countWords`, by implementing a helper function for\n"
"iterating over the lines in a file and accumulating some\n"
"state along the way. Implement `withLines` and use it to\n"
"reimplement `countEmpty` and `countWords`:\n"
msgstr ""
"我们可以概括 `countEmpty` 和 `countWords` "
"中使用的功能，通过实现一个辅助函数来迭代文件中的行并在此过程中累积一些状态。"
"实现 `withLines` 并用它重新实现 `countEmpty` 和 `countWords`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:984
#, no-wrap
msgid ""
"   covering\n"
"   withLines :  (path : String)\n"
"             -> (accum : s -> String -> s)\n"
"             -> (initialState : s)\n"
"             -> IO (Either FileError s)\n"
msgstr ""
"   covering\n"
"   withLines :  (path : String)\n"
"             -> (accum : s -> String -> s)\n"
"             -> (initialState : s)\n"
"             -> IO (Either FileError s)\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/IO.md:996
#, no-wrap
msgid ""
"We often use a `Monoid` for accumulating values.\n"
"It is therefore convenient to specialize `withLines`\n"
"for this case. Use `withLines` to implement\n"
"`foldLines` according to the type given below:\n"
msgstr ""
"我们经常使用 `Monoid` 来累加值。因此在这种情况下特化 `withLines` 很方便。"
"使用 `withLines` 根据下面给出的类型实现 `foldLines`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:997
#, no-wrap
msgid ""
"   covering\n"
"   foldLines :  Monoid s\n"
"             => (path : String)\n"
"             -> (f    : String -> s)\n"
"             -> IO (Either FileError s)\n"
msgstr ""
"   covering\n"
"   foldLines :  Monoid s\n"
"             => (path : String)\n"
"             -> (f    : String -> s)\n"
"             -> IO (Either FileError s)\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/IO.md:1012
#, no-wrap
msgid ""
"Implement function `wordCount` for counting\n"
"the number of lines, words, and characters in\n"
"a text document. Define a custom record type\n"
"together with an implementation of `Monoid`\n"
"for storing and accumulating these values\n"
"and use `foldLines` in your implementation of\n"
"`wordCount`.\n"
msgstr ""
"实现函数 `wordCount` 用于计算文本文档中的行数、单词数和字符数。"
"定义自定义记录类型以及 `Monoid` 的实现，用于存储和累积这些值，并在 "
"`wordCount` 的实现中使用 `foldLines`。\n"

#. type: Title ##
#: ../src/Tutorial/IO.md:1013
#, no-wrap
msgid "How `IO` is Implemented"
msgstr "`IO` 是如何实现的"

#. type: Plain text
#: ../src/Tutorial/IO.md:1019
#, no-wrap
msgid ""
"In this final section of an already lengthy chapter, we will risk\n"
"a glance at how `IO` is implemented in Idris. It is interesting\n"
"to note, that `IO` is not a built-in type but a regular data type\n"
"with only one minor speciality. Let's learn about it at the REPL:\n"
msgstr "在已经很长的一章的最后一节中，我们将冒险看一眼 `IO` 在 Idris 中是如何实现的。有趣的是，`IO` 不是内置类型，而是只有一个小特性的常规数据类型。让我们在 REPL 中了解它：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1020
#, no-wrap
msgid ""
"Tutorial.IO> :doc IO\n"
"data PrimIO.IO : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIO : (1 _ : PrimIO a) -> IO a\n"
"  Hints:\n"
"    Applicative IO\n"
"    Functor IO\n"
"    HasLinearIO IO\n"
"    Monad IO\n"
msgstr ""
"Tutorial.IO> :doc IO\n"
"data PrimIO.IO : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIO : (1 _ : PrimIO a) -> IO a\n"
"  Hints:\n"
"    Applicative IO\n"
"    Functor IO\n"
"    HasLinearIO IO\n"
"    Monad IO\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1037
#, no-wrap
msgid ""
"Here, we learn that `IO` has a single data constructor\n"
"called `MkIO`, which takes a single argument of type\n"
"`PrimIO a` with quantity *1*. We are not going to\n"
"talk about the quantities here, as in fact they are not\n"
"important to understand how `IO` works.\n"
msgstr "在这里，我们了解到 `IO` 有一个名为 `MkIO` 的单个数据构造函数，它采用类型为 `PrimIO a` 的单个参数，定量为 *1* .我们不打算在这里讨论定量，因为事实上它们对于理解 `IO` 的工作原理并不重要。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1039
#, no-wrap
msgid "Now, `PrimIO a` is a type alias for the following function:\n"
msgstr "现在，`PrimIO a` 是以下函数的类型别名：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1040
#, no-wrap
msgid ""
"Tutorial.IO> :printdef PrimIO\n"
"PrimIO.PrimIO : Type -> Type\n"
"PrimIO a = (1 _ : %World) -> IORes a\n"
msgstr ""
"Tutorial.IO> :printdef PrimIO\n"
"PrimIO.PrimIO : Type -> Type\n"
"PrimIO a = (1 _ : %World) -> IORes a\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1049
#, no-wrap
msgid ""
"Again, don't mind the quantities. There is only\n"
"one piece of the puzzle missing: `IORes a`, which is\n"
"a publicly exported record type:\n"
msgstr "同样，不要介意定量。只缺少一块拼图：`IORes a`，这是一种公开导出的记录类型：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1050
#, no-wrap
msgid ""
"Solutions.IO> :doc IORes\n"
"data PrimIO.IORes : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIORes : a -> (1 _ : %World) -> IORes a\n"
msgstr ""
"Solutions.IO> :doc IORes\n"
"data PrimIO.IORes : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIORes : a -> (1 _ : %World) -> IORes a\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1059
#, no-wrap
msgid ""
"So, to put this all together, `IO` is a wrapper around\n"
"something similar to the following function type:\n"
msgstr "所以，总而言之，`IO` 是一个类似于以下函数类型的包装器：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1060
#, no-wrap
msgid "%World -> (a, %World)\n"
msgstr "%World -> (a, %World)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1072
#, no-wrap
msgid ""
"You can think of type `%World` as a placeholder for the\n"
"state of the outside world of a program (file system,\n"
"memory, network connections, and so on). Conceptually,\n"
"to execute an `IO a` action, we pass it the current state\n"
"of the world, and in return get an updated world state\n"
"plus a result of type `a`. The world state being updated\n"
"represents all the side effects describable in a computer\n"
"program.\n"
msgstr "您可以将类型 `%World` 视为程序外部世界状态（文件系统、内存、网络连接等）的占位符。从概念上讲，要执行 `IO a` 动作，我们将世界的当前状态传递给它，并作为回报获得更新的世界状态加上 `a` 类型的结果。正在更新的世界状态代表了计算机程序中可描述的所有副作用。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1088
#, no-wrap
msgid ""
"Now, it is important to understand that there is no such\n"
"thing as the *state of the world*. The `%World` type is\n"
"just a placeholder, which is converted to some kind of\n"
"constant that's passed around and never inspected at\n"
"runtime. So, if we had a value of type `%World`, we could\n"
"pass it to an `IO a` action and execute it, and this is\n"
"exactly what happens at runtime: A single value of\n"
"type `%World` (an uninteresting placeholder like `null`,\n"
"`0`, or - in case of the JavaScript backends - `undefined`)\n"
"is passed to the `main` function, thus\n"
"setting the whole program in motion. However, it\n"
"is impossible to programmatically create a value of\n"
"type `%World` (it is an abstract, primitive type), and\n"
"therefore we cannot ever extract a value of type `a`\n"
"from an `IO a` action (modulo `unsafePerformIO`).\n"
msgstr "现在，重要的是要了解世界上没有 *状态* 这样的东西。 `%World` 类型只是一个占位符，它被转换为某种常量，在运行时不会被检查。因此，如果我们有一个 `%World` 类型的值，我们可以将它传递给 `IO a` 动作并执行它，这正是运行时发生的情况：类型 `%World`（一个无趣的占位符，如 `null`、`0`，或者 - 如果是 JavaScript 后端 - `undefined`）被传递给`main` 函数，从而使整个程序运行起来。但是，不可能以编程方式创建 `%World` 类型的值（它是一种抽象的原始类型），因此我们永远无法从 `IO a` 动作中提取 `a`（模 `unsafePerformIO`）。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1094
#, no-wrap
msgid ""
"Once we will talk about monad transformers and the state\n"
"monad, you will see that `IO` is nothing else but\n"
"a state monad in disguise but with an abstract state\n"
"type, which makes it impossible for us to run the\n"
"stateful computation.\n"
msgstr "一旦我们将讨论 monad 转换器和状态 monad，你会发现 `IO` 只不过是一个伪装的状态 monad，但具有抽象的状态类型，这使得我们无法运行有状态计算.\n"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1099
#, no-wrap
msgid ""
"Values of type `IO a` describe programs with side effects,\n"
"which will eventually result in a value of type `a`.\n"
msgstr "`IO a` 类型的值描述了具有副作用的程序，最终将导致 `a` 类型的值。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1104
#, no-wrap
msgid ""
"While we cannot safely extract a value of type `a`\n"
"from an `IO a`, we can use several combinators and\n"
"syntactic constructs to combine `IO` actions and\n"
"build more-complex programs.\n"
msgstr "虽然我们不能安全地从 `IO a` 中提取 `a` 类型的值，"
"但我们可以使用多个组合子和句法结构来组合 `IO` 动作并构建更复杂的程式。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1107
#, no-wrap
msgid ""
"*Do blocks* offer a convenient way to run and combine\n"
"`IO` actions sequentially.\n"
msgstr "*Do 语法块* 提供了一种方便的方式来顺序运行和组合 `IO` 动作。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1110
#, no-wrap
msgid ""
"*Do blocks* are desugared to nested applications of\n"
"*bind* operators (`(>>=)`).\n"
msgstr "*Do 语法块* 对*绑定*运算符 (`(>>=)`) 的嵌套应用程序进行去糖化。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1114
#, no-wrap
msgid ""
"*Bind* operators, and thus *do blocks*, can be overloaded\n"
"to achieve custom behavior instead of the default\n"
"(monadic) *bind*.\n"
msgstr "*绑定*运算符和 *do 语法块* "
"可以被重载以实现自定义行为，而不是默认的（单子）*绑定*。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1117
#, no-wrap
msgid ""
"Under the hood, `IO` actions are stateful computations\n"
"operating on a symbolic `%World` state.\n"
msgstr "在底层，`IO` 动作是在符号 `%World` 状态上运行的有状态计算。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1123
#, no-wrap
msgid ""
"Now, that we had a glimpse at *monads* and the *bind* operator,\n"
"it is time to in the [next chapter](Functor.md) introduce `Monad` and some\n"
"related interfaces for real.\n"
msgstr "现在，我们已经了解了 *monads* 和 *bind* 运算符，是时候在 [下一章](Functor.md) 中介绍 `Monad` 和一些和现实世界相关的接口。\n"

#. type: Title #
#: ../src/Tutorial/Predicates.md:1
#, no-wrap
msgid "Predicates and Proof Search"
msgstr "谓词和证明搜索"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:12
#, no-wrap
msgid ""
"In the [last chapter](Eq.md) we learned about propositional\n"
"equality, which allowed us to proof that two values are\n"
"equal. Equality is a relation between values, and we used\n"
"an indexed data type to encode this relation by limiting\n"
"the degrees of freedom of the indices in the sole data\n"
"constructor. There are other relations and contracts we\n"
"can encode this way. This will allow us to restrict the\n"
"values we accept as a function's arguments or the values\n"
"returned by functions.\n"
msgstr "在[上一章](Eq.md)中，我们了解了命题相等式，这使我们能够证明两个值相等。相等是值之间的关系，我们使用索引数据类型通过限制唯一数据构造函数中索引的自由度来编码这种关系。我们可以用这种方式编码其他关系和契约。这将允许我们限制我们接受作为函数参数的值或函数返回的值。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:13
#, no-wrap
msgid ""
"module Tutorial.Predicates\n"
"\n"
"import Data.Either\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"import Data.HList\n"
"import Decidable.Equality\n"
"\n"
"import Text.CSV\n"
"import System.File\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Predicates\n"
"\n"
"import Data.Either\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"import Data.HList\n"
"import Decidable.Equality\n"
"\n"
"import Text.CSV\n"
"import System.File\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Predicates.md:29
#, no-wrap
msgid "Preconditions"
msgstr "前置条件"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:38
#, no-wrap
msgid ""
"Often, when we implement functions operating on values\n"
"of a given type, not all values are considered to be\n"
"valid arguments for the function in question. For instance,\n"
"we typically do not allow division by zero, as the result\n"
"is undefined in the general case. This concept of putting\n"
"a *precondition* on a function argument comes up pretty often,\n"
"and there are several ways to go about this.\n"
msgstr "通常，当我们实现对给定类型的值进行操作的函数时，并非所有值都被认为是所讨论函数的有效参数。例如，我们通常不允许除以零，因为在一般情况下结果是未定义的。这种将 *前置条件* 放在函数参数上的概念经常出现，并且有几种方法可以解决这个问题。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:45
#, no-wrap
msgid ""
"A very common operation when working with lists or other\n"
"container types is to extract the first value in the sequence.\n"
"This function, however, cannot work in the general case, because\n"
"in order to extract a value from a list, the list must not\n"
"be empty. Here are a couple of ways to encode and implement\n"
"this, each with its own advantages and disadvantages:\n"
msgstr "使用列表或其他容器类型时，一个非常常见的操作是提取序列中的第一个值。然而，这个函数不能在一般情况下工作，因为为了从列表中提取值，列表不能为空。这里有几种编码和实现它的方法，每种方法都有自己的优点和缺点：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:57
#, no-wrap
msgid ""
"Wrap the result in a failure type, such as a `Maybe` or\n"
"`Either e` with some custom error type `e`. This makes it\n"
"immediately clear that the function might not be able to\n"
"return a result. It is a natural way to deal with unvalidated\n"
"input from unknown sources. The drawback of this approach is\n"
"that results will carry the `Maybe` stain, even in situations\n"
"when we *know* that the *nil* case is impossible, for instance because we\n"
"know the value of the list argument at compile-time,\n"
"or because we already *refined* the input value in such a\n"
"way that we can be sure it is not empty (due to an earlier\n"
"pattern match, for instance).\n"
msgstr ""
"将结果包装在故障类型中，例如 `Maybe` 或带有一些自定义错误类型 `e` 的 `Either "
"e`。这立即清楚地表明该函数可能无法返回结果。这是处理来自未知来源的未经验证的"
"输入的自然方式。这种方法的缺点是结果会带有 `Maybe` 污点，即使在我们 *知道 *"
"不可能为 *nil* 的情况下，例如因为我们知道list 参数在编译时的值，"
"或者因为我们已经 *改进了* "
"输入值，以确保它不为空（例如，由于较早的模式匹配）。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:67
#, no-wrap
msgid ""
"Define a new data type for non-empty lists and use this\n"
"as the function's argument. This is the approach taken in\n"
"module `Data.List1`. It allows us to return a pure value\n"
"(meaning \"not wrapped in a failure type\" here), because the\n"
"function cannot possibly fail, but it comes with the\n"
"burden of reimplementing many of the utility functions and\n"
"interfaces we already implemented for `List`. For a very common\n"
"data structure this can be a valid option, but for rare use cases\n"
"it is often too cumbersome.\n"
msgstr ""
"为非空列表定义一个新的数据类型并将其用作函数的参数。这是在模块 `Data.List1` "
"中采用的方法。它允许我们返回一个纯值（这里的意思是“不包含在失败类型中”），因"
"为函数不可能失败，但它带来了重新实现我们已经为 `List` 实现的许多实用函数和接"
"口的负担。对于非常常见的数据结构，这可能是一个有效的选项，但对于罕见的用例，"
"它通常太麻烦了。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:81
#, no-wrap
msgid ""
"Use an index to keep track of the property we are interested\n"
"in. This was the approach we took with type family `List01`,\n"
"which we saw in several examples and exercises in this guide\n"
"so far. This is also the approach taken with vectors,\n"
"where we use the exact length as our index, which is even\n"
"more expressive. While this allows us to implement many functions\n"
"only once and with greater precision at the type level, it\n"
"also comes with the burden of keeping track of changes\n"
"in the types, making for more complex function types\n"
"and forcing us to at times return existentially quantified\n"
"wrappers (for instance, dependent pairs),\n"
"because the outcome of a computation is not known until\n"
"runtime.\n"
msgstr ""
"使用索引来跟踪我们感兴趣的属性。这是我们对类型族 `List01` 采用的方法，到目前"
"为止，我们在本指南的几个示例和练习中看到了这种方法。这也是向量采用的方法，我"
"们使用精确的长度作为索引，这样更有表现力。虽然这允许我们在类型级别以更高的精"
"度实现许多函数，但它也带来了跟踪类型变化的负担，产生更复杂的函数类型并迫使我"
"们有时返回存在量化的包装器（例如，依赖对），因为直到运行时才知道计算的结果。"
"\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:87
#, no-wrap
msgid ""
"Fail with a runtime exception. This is a popular solution\n"
"in many programming languages (even Haskell), but in Idris\n"
"we try to avoid this, because it breaks totality in a way,\n"
"which also affects client code. Luckily, we can make use of\n"
"our powerful type system to avoid this situation in general.\n"
msgstr ""
"失败并出现运行时异常。这是许多编程语言（甚至是 Haskell）中流行的解决方案，"
"但在 Idris 中我们尽量避免这种情况，因为它在某种程度上破坏了完全性，这也会影响"
"客户端代码。幸运的是，我们可以利用我们强大的类型系统来避免这种情况。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:94
#, no-wrap
msgid ""
"Take an additional (possibly erased) argument of a type\n"
"we can use as a witness that the input value is of the\n"
"correct kind or shape. This is the solution we will discuss\n"
"in this chapter in great detail. It is an incredibly powerful way\n"
"to talk about restrictions on values without having to\n"
"replicate a lot of already existing functionality.\n"
msgstr ""
"取一个类型的附加（可能已删除）参数，我们可以将其用作输入值的类型或形状正确的"
"见证。这是我们将在本章中详细讨论的解决方案。这是一种非常强大的方式来讨论对值"
"的限制，而无需复制许多已经存在的功能。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:100
#, no-wrap
msgid ""
"There is a time and place for most if not all of the solutions\n"
"listed above in Idris, but we will often turn to the last one and\n"
"refine function arguments with predicates (so called\n"
"*preconditions*), because it makes our functions nice to use at\n"
"runtime *and* compile time.\n"
msgstr "Idris 中列出的大多数（如果不是全部）解决方案都有时间和地点，但我们经常会转向最后一个并使用谓词（所谓的 *前置条件*）优化函数参数，因为它使我们的函数在运行时 *和* 编译时更好用。\n"

#. type: Title ###
#: ../src/Tutorial/Predicates.md:101
#, no-wrap
msgid "Example: Non-empty Lists"
msgstr "示例：非空列表"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:107
#, no-wrap
msgid ""
"Remember how we implemented an indexed data type for\n"
"propositional equality: We restricted the valid\n"
"values of the indices in the constructors. We can do\n"
"the same thing for a predicate for non-empty lists:\n"
msgstr "记住我们是如何实现命题相等的索引数据类型的：我们限制了构造函数中索引的有效值。我们可以对非空列表的谓词做同样的事情：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:108
#, no-wrap
msgid ""
"data NotNil : (as : List a) -> Type where\n"
"  IsNotNil : NotNil (h :: t)\n"
msgstr ""
"data NotNil : (as : List a) -> Type where\n"
"  IsNotNil : NotNil (h :: t)\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:117
#, no-wrap
msgid ""
"This is a single-value data type, so we can always use it\n"
"as an erased function argument and still pattern match on\n"
"it. We can now use this to implement a safe and pure `head`\n"
"function:\n"
msgstr "这是一种单值数据类型，因此我们始终可以将其用作已擦除的函数参数并仍然对其进行模式匹配。我们现在可以使用它来实现一个安全且纯粹的 `head` 函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:118
#, no-wrap
msgid ""
"head1 : (as : List a) -> (0 _ : NotNil as) -> a\n"
"head1 (h :: _) _ = h\n"
"head1 [] IsNotNil impossible\n"
msgstr ""
"head1 : (as : List a) -> (0 _ : NotNil as) -> a\n"
"head1 (h :: _) _ = h\n"
"head1 [] IsNotNil impossible\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:129
#, no-wrap
msgid ""
"Note, how value `IsNotNil` is a *witness* that its index,\n"
"which corresponds to our list argument, is indeed non-empty,\n"
"because this is what we specified in its type.\n"
"The impossible case in the implementation of `head1` is not\n"
"strictly necessary here. It was given above for completeness.\n"
msgstr "请注意，值 `IsNotNil` 是 *witness* 的值，它对应于我们的列表参数，它的索引确实是非空的，因为这是我们在它的类型中指定的。 `head1` 实现中的不可能的情况在这里不是绝对必要的。上面给出的遵循完全性。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:134
#, no-wrap
msgid ""
"We call `NotNil` a *predicate* on lists, as it restricts\n"
"the values allowed in the index. We can express a function's\n"
"preconditions by adding additional (possibly erased) predicates\n"
"to the function's list of arguments.\n"
msgstr "我们将 `NotNil` 称为列表上的 *谓词*，因为它限制了索引中允许的值。我们可以通过在函数的参数列表中添加额外的（可能被删除的）谓词来表达函数的前置条件。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:138
#, no-wrap
msgid ""
"The first really cool thing is how we can safely use `head1`,\n"
"if we can at compile-time show that our list argument is\n"
"indeed non-empty:\n"
msgstr "第一个非常酷的事情是我们如何安全地使用 `head1`，如果我们可以在编译时显示我们的列表参数确实是非空的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:139
#, no-wrap
msgid ""
"headEx1 : Nat\n"
"headEx1 = head1 [1,2,3] IsNotNil\n"
msgstr ""
"headEx1 : Nat\n"
"headEx1 = head1 [1,2,3] IsNotNil\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:152
#, no-wrap
msgid ""
"It is a bit cumbersome that we have to pass the `IsNotNil` proof\n"
"manually. Before we scratch that itch, we will first discuss what\n"
"to do with lists, the values of which are not known until\n"
"runtime. For these cases, we have to try and produce a value\n"
"of the predicate programmatically by inspecting the runtime\n"
"list value. In the most simple case, we can wrap the proof\n"
"in a `Maybe`, but if we can show that our predicate is *decidable*,\n"
"we can get even stronger guarantees by returning a `Dec`:\n"
msgstr "我们必须手动通过 `IsNotNil` 证明有点麻烦。在我们解决这个问题之前，我们将首先讨论如何处理列表，其值直到运行时才知道。对于这些情况，我们必须通过检查运行时列表值来尝试以编程方式生成谓词的值。在最简单的情况下，我们可以将证明包装在 `Maybe` 中，但是如果我们可以证明我们的谓词是 *可判定的*，我们可以通过返回 `Dec` 来获得更强的保证：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:153
#, no-wrap
msgid ""
"Uninhabited (NotNil []) where\n"
"  uninhabited IsNotNil impossible\n"
"\n"
"nonEmpty : (as : List a) -> Dec (NotNil as)\n"
"nonEmpty (x :: xs) = Yes IsNotNil\n"
"nonEmpty []        = No uninhabited\n"
msgstr ""
"Uninhabited (NotNil []) where\n"
"  uninhabited IsNotNil impossible\n"
"\n"
"nonEmpty : (as : List a) -> Dec (NotNil as)\n"
"nonEmpty (x :: xs) = Yes IsNotNil\n"
"nonEmpty []        = No uninhabited\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:164
#, no-wrap
msgid ""
"With this, we can implement function `headMaybe`, which\n"
"is to be used with lists of unknown origin:\n"
msgstr "有了这个，我们可以实现函数 `headMaybe`，它可以用于未知来源的列表：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:165
#, no-wrap
msgid ""
"headMaybe1 : List a -> Maybe a\n"
"headMaybe1 as = case nonEmpty as of\n"
"  Yes prf => Just $ head1 as prf\n"
"  No  _   => Nothing\n"
msgstr ""
"headMaybe1 : List a -> Maybe a\n"
"headMaybe1 as = case nonEmpty as of\n"
"  Yes prf => Just $ head1 as prf\n"
"  No  _   => Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:176
#, no-wrap
msgid ""
"Of course, for trivial functions like `headMaybe` it makes\n"
"more sense to implement them directly by pattern matching on\n"
"the list argument, but we will soon see examples of predicates\n"
"the values of which are more cumbersome to create.\n"
msgstr "当然，对于像 `headMaybe` 这样的小函数，直接通过 list 参数上的模式匹配来实现它们更有意义，但是我们很快就会看到谓词的示例，其值创建起来更麻烦。\n"

#. type: Title ###
#: ../src/Tutorial/Predicates.md:177
#, no-wrap
msgid "Auto Implicits"
msgstr "自动隐式"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:187
#, no-wrap
msgid ""
"Having to manually pass a proof of being non-empty to\n"
"`head1` makes this function unnecessarily verbose to\n"
"use at compile time. Idris allows us to define implicit\n"
"function arguments, the values of which it tries to assemble\n"
"on its own by means of a technique called *proof search*. This is not\n"
"to be confused with type inference, which means inferring\n"
"values or types from the surrounding context. It's best\n"
"to look at some examples to explain the difference.\n"
msgstr "必须手动将非空证明传递给 `head1` 使得这个函数在编译时使用起来不必要地冗长。 Idris 允许我们定义隐式函数参数，它试图通过一种称为 *证明搜索* 的技术自行组装其值。这不要与类型推断混淆，类型推断意味着从周围的上下文推断值或类型。最好看一些例子来解释差异。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:190
#, no-wrap
msgid ""
"Let us first have a look at the following implementation of\n"
"`replicate` for vectors:\n"
msgstr "让我们首先看一下向量的 `replicate` 的以下实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:191
#, no-wrap
msgid ""
"replicate' : {n : _} -> a -> Vect n a\n"
"replicate' {n = 0}   _ = []\n"
"replicate' {n = S _} v = v :: replicate' v\n"
msgstr ""
"replicate' : {n : _} -> a -> Vect n a\n"
"replicate' {n = 0}   _ = []\n"
"replicate' {n = S _} v = v :: replicate' v\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:202
#, no-wrap
msgid ""
"Function `replicate'` takes an unerased implicit argument.\n"
"The *value* of this argument must be derivable from the surrounding\n"
"context. For instance, in the following example it is\n"
"immediately clear that `n` equals three, because that is\n"
"the length of the vector we want:\n"
msgstr "函数 `replicate'` 采用未擦除的隐式参数。此参数的 *值* 必须可从周围的上下文中派生。例如，在下面的示例中，很明显 `n` 等于 3，因为这是我们想要的向量的长度：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:203
#, no-wrap
msgid ""
"replicateEx1 : Vect 3 Nat\n"
"replicateEx1 = replicate' 12\n"
msgstr ""
"replicateEx1 : Vect 3 Nat\n"
"replicateEx1 = replicate' 12\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:211
#, no-wrap
msgid ""
"In the next example, the value of `n` is not known at compile time,\n"
"but it is available as an unerased implicit, so this can again\n"
"be passed as is to `replicate'`:\n"
msgstr "在下一个示例中，`n` 的值在编译时是未知的，但它可以作为未擦除的隐式使用，因此可以再次将其按原样传递给 `replicate'`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:212
#, no-wrap
msgid ""
"replicateEx2 : {n : _} -> Vect n Nat\n"
"replicateEx2 = replicate' 12\n"
msgstr ""
"replicateEx2 : {n : _} -> Vect n Nat\n"
"replicateEx2 = replicate' 12\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:223
#, no-wrap
msgid ""
"However, in the following example, the value of `n` can't\n"
"be inferred, as the intermediary vector is immediately converted\n"
"to a list of unknown length. Although Idris could try and insert\n"
"any value for `n` here, it won't do so, because it can't be\n"
"sure that this is the length we want. We therefore have to pass the\n"
"length explicitly:\n"
msgstr "但是，在以下示例中，无法推断 `n` 的值，因为中间向量会立即转换为未知长度的列表。尽管 Idris 可以尝试在这里为 `n` 插入任何值，但它不会这样做，因为它不能确定这是我们想要的长度。因此，我们必须明确地传递长度：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:224
#, no-wrap
msgid ""
"replicateEx3 : List Nat\n"
"replicateEx3 = toList $ replicate' {n = 17} 12\n"
msgstr ""
"replicateEx3 : List Nat\n"
"replicateEx3 = toList $ replicate' {n = 17} 12\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:234
#, no-wrap
msgid ""
"Note, how the *value* of `n` had to be inferable in\n"
"these examples, which means it had to make an appearance\n"
"in the surrounding context. With auto implicit arguments,\n"
"this works differently. Here is the `head` example, this\n"
"time with an auto implicit:\n"
msgstr "请注意，在这些示例中，`n` 的 *值* 必须是可推断的，这意味着它必须出现在周围的上下文中。使用自动隐式参数，这会有所不同。这是 `head` 示例，这次使用自动隐式：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:235
#, no-wrap
msgid ""
"head : (as : List a) -> {auto 0 prf : NotNil as} -> a\n"
"head (x :: _) = x\n"
"head [] impossible\n"
msgstr ""
"head : (as : List a) -> {auto 0 prf : NotNil as} -> a\n"
"head (x :: _) = x\n"
"head [] impossible\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:249
#, no-wrap
msgid ""
"Note the `auto` keyword before the quantity of implicit argument\n"
"`prf`. This means, we want Idris to construct this value\n"
"on its own, without it being visible in the surrounding context.\n"
"In order to do so, Idris will have to at compile time know the\n"
"structure of the list argument `as`. It will then try and build\n"
"such a value from the data type's constructors. If it succeeds,\n"
"this value will then be automatically filled in as the desired argument,\n"
"otherwise, Idris will fail with a type error.\n"
msgstr "注意隐式参数 `prf` 的数量之前的 `auto` 关键字。这意味着，我们希望 Idris 自己构造这个值，而不是在周围的上下文中可见。为此，Idris 必须在编译时知道列表参数 `as` 的结构。然后它将尝试从数据类型的构造函数中构建这样的值。如果成功，该值将自动填充为所需的参数，否则，Idris 将失败并出现类型错误。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:251
#, no-wrap
msgid "Let's see this in action:\n"
msgstr "让我们看看它的实际效果：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:252
#, no-wrap
msgid ""
"headEx3 : Nat\n"
"headEx3 = Predicates.head [1,2,3]\n"
msgstr ""
"headEx3 : Nat\n"
"headEx3 = Predicates.head [1,2,3]\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:258
#, no-wrap
msgid "The following example fails with an error:\n"
msgstr "以下示例因错误而失败：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:259
#, no-wrap
msgid ""
"failing \"Can't find an implementation\\nfor NotNil [].\"\n"
"  errHead : Nat\n"
"  errHead = Predicates.head []\n"
msgstr ""
"failing \"Can't find an implementation\\nfor NotNil [].\"\n"
"  errHead : Nat\n"
"  errHead = Predicates.head []\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:276
#, no-wrap
msgid ""
"Wait! \"Can't find an implementation for...\"? Is this not the\n"
"error message we get for missing interface implementations?\n"
"That's correct, and I'll show you that interface resolution\n"
"is just proof search at the end of this chapter. What I can\n"
"show you already, is that writing the lengthy `{auto prf : t} ->`\n"
"all the times can be cumbersome. Idris therefore allows us\n"
"to use the same syntax as for constrained functions instead:\n"
"`(prf : t) =>`, or even `t =>`, if we don't need to name the\n"
"constraint. As usual, we can then access a constraint in the\n"
"function body by its name (if any). Here is another implementation\n"
"of `head`:\n"
msgstr "等待！ “找不到...的实现”？这不是我们因缺少接口实现而得到的错误消息吗？没错，我将在本章末尾向您展示接口解析只是证明搜索。我已经可以向您展示的是，一直编写冗长的 `{auto prf : t} ->` 可能很麻烦。因此，Idris 允许我们使用与约束函数相同的语法：`(prf : t) =>`，或者如果我们不需要命名约束甚至可以写成 `t =>`。像往常一样，我们可以通过名称（如果有的话）访问函数体中的约束。这是 `head` 的另一个实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:277
#, no-wrap
msgid ""
"head' : (as : List a) -> (0 _ : NotNil as) => a\n"
"head' (x :: _) = x\n"
"head' [] impossible\n"
msgstr ""
"head' : (as : List a) -> (0 _ : NotNil as) => a\n"
"head' (x :: _) = x\n"
"head' [] impossible\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:287
#, no-wrap
msgid ""
"During proof search, Idris will also look for values of\n"
"the required type in the current function context. This allows\n"
"us to implement `headMaybe` without having to pass on\n"
"the `NotNil` proof manually:\n"
msgstr "在证明搜索期间，Idris 还将在当前函数上下文中查找所需类型的值。这允许我们实现 `headMaybe` 而无需手动传递 `NotNil` 证明：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:288
#, no-wrap
msgid ""
"headMaybe : List a -> Maybe a\n"
"headMaybe as = case nonEmpty as of\n"
"  -- `prf` is available during proof seach\n"
"  Yes prf => Just $ Predicates.head as\n"
"  No  _   => Nothing\n"
msgstr ""
"headMaybe : List a -> Maybe a\n"
"headMaybe as = case nonEmpty as of\n"
"  -- `prf` is available during proof seach\n"
"  Yes prf => Just $ Predicates.head as\n"
"  No  _   => Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:304
#, no-wrap
msgid ""
"To conclude: Predicates allow us to restrict the values\n"
"a function accepts as arguments. At runtime, we need to\n"
"build such *witnesses* by pattern matching on the function\n"
"arguments. These operations can typically fail. At compile\n"
"time, we can let Idris try and build these values for us\n"
"using a technique called *proof search*. This allows us\n"
"to make functions safe and convenient to use at the same\n"
"time.\n"
msgstr "总结：谓词允许我们限制函数接受作为参数的值。在运行时，我们需要通过函数参数的模式匹配来构建这样的 *witnesses*。这些操作通常会失败。在编译时，我们可以让 Idris 尝试使用称为 *证明搜索* 的技术为我们构建这些值。这使我们能够同时使函数安全和方便地使用。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:312
#, no-wrap
msgid ""
"In these exercises, you'll have to implement several\n"
"functions making use of auto implicits, to constrain\n"
"the values accepted as function arguments. The results\n"
"should be *pure*, that is, not wrapped in a failure type\n"
"like `Maybe`.\n"
msgstr "在这些练习中，您必须使用自动隐式实现几个函数，以约束作为函数参数接受的值。结果应该是 *纯的*，也就是说，没有包裹在像 `Maybe` 这样的失败类型中。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:314
#, no-wrap
msgid "Implement `tail` for lists.\n"
msgstr "为列表实现 `tail`。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:318
#, no-wrap
msgid ""
"Implement `concat1` and `foldMap1` for lists. These\n"
"should work like `concat` and `foldMap`, but taking only\n"
"a `Semigroup` constraint on the element type.\n"
msgstr ""
"为列表实现 `concat1` 和 `foldMap1`。这些应该像 `concat` 和 `foldMap` "
"一样工作，但对元素类型仅采用 `Semigroup` 约束。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:321
#, no-wrap
msgid ""
"Implement functions for returning the largest and smallest\n"
"element in a list.\n"
msgstr "实现用于返回列表中最大和最小元素的函数。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:325
#, no-wrap
msgid ""
"Define a predicate for strictly positive natural numbers\n"
"and use it to implement a safe and provably total division\n"
"function on natural numbers.\n"
msgstr "为严格的正自然数定义一个谓词，并用它来实现一个安全且可证明的自然数全除函数。"
"\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Predicates.md:330
#, no-wrap
msgid ""
"Define a predicate for a non-empty `Maybe` and use it to\n"
"safely extract the value stored in a `Just`. Show that this\n"
"predicate is decidable by implementing a corresponding\n"
"conversion function.\n"
msgstr "为非空 `Maybe` 定义一个谓词，并使用它安全地提取存储在 `Just` "
"中的值。通过实现相应的转换函数来证明这个谓词是可判定的。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Predicates.md:334
#, no-wrap
msgid ""
"Define and implement functions for safely extracting values\n"
"from a `Left` and a `Right` by using suitable predicates.\n"
"Show again that these predicates are decidable.\n"
msgstr "使用合适的谓词定义和实现从 `Left` 和 `Right` "
"安全地提取值的函数。再次证明这些谓词是可判定的。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:339
#, no-wrap
msgid ""
"The predicates you implemented in these exercises are already\n"
"available in the *base* library: `Data.List.NonEmpty`,\n"
"`Data.Maybe.IsJust`, `Data.Either.IsLeft`, `Data.Either.IsRight`,\n"
"and `Data.Nat.IsSucc`.\n"
msgstr "您在这些练习中实现的谓词已经在 *base* 库中可用：`Data.List.NonEmpty`、`Data.Maybe.IsJust`、`Data。 Either.IsLeft`、`Data.Either.IsRight` 和 `Data.Nat.IsSucc`。\n"

#. type: Title ##
#: ../src/Tutorial/Predicates.md:340
#, no-wrap
msgid "Contracts between Values"
msgstr "值之间的契约"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:346
#, no-wrap
msgid ""
"The predicates we saw so far restricted the values of\n"
"a single type, but it is also possible to define predicates\n"
"describing contracts between several values of possibly\n"
"distinct types.\n"
msgstr "到目前为止，我们看到的谓词限制了单一类型的值，但也可以定义谓词来描述可能不同类型的多个值之间的契约。\n"

#. type: Title ###
#: ../src/Tutorial/Predicates.md:347
#, no-wrap
msgid "The `Elem` Predicate"
msgstr "`Elem` 谓词"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:351
#, no-wrap
msgid ""
"Assume we'd like to extract a value of a given type from\n"
"a heterogeneous list:\n"
msgstr "假设我们想从异构列表中提取给定类型的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:352
#, no-wrap
msgid "get' : (0 t : Type) -> HList ts -> t\n"
msgstr "get' : (0 t : Type) -> HList ts -> t\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:358
#, no-wrap
msgid ""
"This can't work in general: If we could implement this we would\n"
"immediately have a proof of void:\n"
msgstr "这在一般情况下是行不通的：如果我们可以实现这一点，我们将立即获得无效证明：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:359
#, no-wrap
msgid ""
"voidAgain : Void\n"
"voidAgain = get' Void []\n"
msgstr ""
"voidAgain : Void\n"
"voidAgain = get' Void []\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:367
#, no-wrap
msgid ""
"The problem is obvious: The type of which we'd like to extract\n"
"a value must be an element of the index of the heterogeneous list.\n"
"Here is a predicate, with which we can express this:\n"
msgstr "问题很明显：我们要提取值的类型必须是异构列表索引的元素。这是一个谓词，我们可以用它来表达：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:368
#, no-wrap
msgid ""
"data Elem : (elem : a) -> (as : List a) -> Type where\n"
"  Here  : Elem x (x :: xs)\n"
"  There : Elem x xs -> Elem x (y :: xs)\n"
msgstr ""
"data Elem : (elem : a) -> (as : List a) -> Type where\n"
"  Here  : Elem x (x :: xs)\n"
"  There : Elem x xs -> Elem x (y :: xs)\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:386
#, no-wrap
msgid ""
"This is a predicate describing a contract between two values:\n"
"A value of type `a` and a list of `a`s. Values of this predicate\n"
"are witnesses that the value is an element of the list.\n"
"Note, how this is defined recursively: The case\n"
"where the value we look for is at the head of the list is\n"
"handled by the `Here` constructor, where the same variable (`x`) is used\n"
"for the element and the head of the list. The case where the value\n"
"is deeper within  the list is handled by the `There`\n"
"constructor. This can be read as follows: If `x` is and element\n"
"of `xs`, then `x` is also an element of `y :: xs` for any\n"
"value `y`. Let's write down some examples to get a feel\n"
"for these:\n"
msgstr "这是一个描述两个值之间的契约的谓词：一个 `a` 类型的值和一个 `a` 的列表。该谓词的值是该值是列表元素的见证。请注意，这是如何递归定义的：我们查找的值位于列表头部的情况由 `Here` 构造函数处理，其中相同的变量 (`x`) 是用于元素和列表的头部。值在列表中更深的情况由 `There` 构造函数处理。可以这样理解：如果 `x` 是 `xs` 的元素，那么 `x` 也是 `y :: xs` 的元素对于任何值 `y`。让我们写一些例子来感受一下：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:387
#, no-wrap
msgid ""
"MyList : List Nat\n"
"MyList = [1,3,7,8,4,12]\n"
"\n"
"oneElemMyList : Elem 1 MyList\n"
"oneElemMyList = Here\n"
"\n"
"sevenElemMyList : Elem 7 MyList\n"
"sevenElemMyList = There $ There Here\n"
msgstr ""
"MyList : List Nat\n"
"MyList = [1,3,7,8,4,12]\n"
"\n"
"oneElemMyList : Elem 1 MyList\n"
"oneElemMyList = Here\n"
"\n"
"sevenElemMyList : Elem 7 MyList\n"
"sevenElemMyList = There $ There Here\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:402
#, no-wrap
msgid ""
"Now, `Elem` is just another way of indexing into a list\n"
"of values. Instead of using a `Fin` index, which is limited\n"
"by the list's length, we use a proof that a value can be found\n"
"at a certain position.\n"
msgstr "现在，`Elem` 只是索引到值列表的另一种方式。我们不使用受列表长度限制的 `Fin` 索引，而是使用可以在特定位置找到值的证明。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:405
#, no-wrap
msgid ""
"We can use the `Elem` predicate to extract a value from\n"
"the desired type of a heterogeneous list:\n"
msgstr "我们可以使用 `Elem` 谓词从所需类型的异构列表中提取值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:406
#, no-wrap
msgid "get : (0 t : Type) -> HList ts -> (prf : Elem t ts) => t\n"
msgstr "get : (0 t : Type) -> HList ts -> (prf : Elem t ts) => t\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:415
#, no-wrap
msgid ""
"It is important to note that the auto implicit must not be\n"
"erased in this case. This is no longer a single value data type,\n"
"and we must be able to pattern match on this value in order to\n"
"figure out, how far within the heterogeneous list our value\n"
"is stored:\n"
msgstr "重要的是要注意在这种情况下不能删除自动隐式。这不再是单值数据类型，我们必须能够对这个值进行模式匹配，以便弄清楚我们的值在异构列表中存储多远：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:416
#, no-wrap
msgid ""
"get t (v :: vs) {prf = Here}    = v\n"
"get t (v :: vs) {prf = There p} = get t vs\n"
"get _ [] impossible\n"
msgstr ""
"get t (v :: vs) {prf = Here}    = v\n"
"get t (v :: vs) {prf = There p} = get t vs\n"
"get _ [] impossible\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:425
#, no-wrap
msgid ""
"It can be instructive to implement `get` yourself, using holes on\n"
"the right hand side to see the context and types of values Idris\n"
"infers based on the value of the `Elem` predicate.\n"
msgstr "自己实现 `get` 可能很有启发性，使用右侧的孔查看 Idris 根据 `Elem` 谓词的值推断的值的上下文和类型。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:427
#, no-wrap
msgid "Let's give this a spin at the REPL:\n"
msgstr "让我们在 REPL 上试一试：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:428
#, no-wrap
msgid ""
"Tutorial.Predicates> get Nat [\"foo\", Just \"bar\", S Z]\n"
"1\n"
"Tutorial.Predicates> get Nat [\"foo\", Just \"bar\"]\n"
"Error: Can't find an implementation for Elem Nat [String, Maybe String].\n"
"\n"
"(Interactive):1:1--1:28\n"
" 1 | get Nat [\"foo\", Just \"bar\"]\n"
"     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
msgstr ""
"Tutorial.Predicates> get Nat [\"foo\", Just \"bar\", S Z]\n"
"1\n"
"Tutorial.Predicates> get Nat [\"foo\", Just \"bar\"]\n"
"Error: Can't find an implementation for Elem Nat [String, Maybe String].\n"
"\n"
"(Interactive):1:1--1:28\n"
" 1 | get Nat [\"foo\", Just \"bar\"]\n"
"     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:446
#, no-wrap
msgid ""
"With this example we start to appreciate what *proof search*\n"
"actually means: Given a value `v` and a list of values `vs`, Idris tries\n"
"to find a proof that `v` is an element of `vs`.\n"
"Now, before we continue, please note that proof search is\n"
"not a silver bullet. The search algorithm has a reasonably limited\n"
"*search depth*, and will fail with the search if this limit\n"
"is exceeded. For instance:\n"
msgstr "通过这个例子，我们开始理解 *证明搜索* 的实际含义：给定一个值 `v` 和一个值列表 `vs`，Idris 试图找到一个 `v` 是 `vs` 中的元素的证明。现在，在我们继续之前，请注意证明搜索不是灵丹妙药。搜索算法具有合理限制的 *搜索深度*，如果超过此限制，搜索将失败。例如：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:447
#, no-wrap
msgid ""
"Tps : List Type\n"
"Tps = List.replicate 50 Nat ++ [Maybe String]\n"
"\n"
"hlist : HList Tps\n"
"hlist = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , Nothing ]\n"
msgstr ""
"Tps : List Type\n"
"Tps = List.replicate 50 Nat ++ [Maybe String]\n"
"\n"
"hlist : HList Tps\n"
"hlist = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , Nothing ]\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:462
#, no-wrap
msgid ""
"Tutorial.Predicates> get (Maybe String) hlist\n"
"Error: Can't find an implementation for Elem (Maybe String) [Nat,...\n"
msgstr ""
"Tutorial.Predicates> get (Maybe String) hlist\n"
"Error: Can't find an implementation for Elem (Maybe String) [Nat,...\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:474
#, no-wrap
msgid ""
"As you can see, Idris fails to find a proof that `Maybe String`\n"
"is an element of `Tps`. The search depth can be increased with\n"
"the `%auto_implicit_depth` directive, which will hold for the\n"
"rest of the source file or until set to a different value.\n"
"The default value is set at 25. In general, it is not advisable\n"
"to set this to a too large value as this can drastically increase\n"
"compile times.\n"
msgstr "如您所见，Idris 未能找到 `Maybe String` 是 `Tps` 的一个元素的证明。可以使用 `%auto_implicit_depth` 指令增加搜索深度，该指令将保留源文件的其余部分或直到设置为不同的值。默认值设置为 25。通常，不建议将其设置为太大的值，因为这会大大增加编译时间。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:475
#, no-wrap
msgid ""
"%auto_implicit_depth 100\n"
"aMaybe : Maybe String\n"
"aMaybe = get _ hlist\n"
"\n"
"%auto_implicit_depth 25\n"
msgstr ""
"%auto_implicit_depth 100\n"
"aMaybe : Maybe String\n"
"aMaybe = get _ hlist\n"
"\n"
"%auto_implicit_depth 25\n"

#. type: Title ###
#: ../src/Tutorial/Predicates.md:483
#, no-wrap
msgid "Use Case: A nicer Schema"
msgstr "用例：更好的模式"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:492
#, no-wrap
msgid ""
"In the chapter about [sigma types](DPair.md), we introduced\n"
"a schema for CSV files. This was not very nice to use, because\n"
"we had to use natural numbers to access a certain column. Even\n"
"worse, users of our small library had to do the same. There was\n"
"no way to define a name for each column and access columns by\n"
"name. We are going to change this. Here is an encoding\n"
"for this use case:\n"
msgstr "在关于 [sigma 类型](DPair.md) 的章节中，我们介绍了 CSV 文件的模式。这不是很好用，因为我们必须使用自然数来访问某个列。更糟糕的是，我们小型图书馆的用户也必须这样做。无法为每个列定义名称并按名称访问列。我们将改变这一点。这是此用例的编码：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:493
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"record Column where\n"
"  constructor MkColumn\n"
"  name : String\n"
"  type : ColType\n"
"\n"
"infixr 8 :>\n"
"\n"
"(:>) : String -> ColType -> Column\n"
"(:>) = MkColumn\n"
"\n"
"Schema : Type\n"
"Schema = List Column\n"
"\n"
"Show ColType where\n"
"  show I64     = \"I64\"\n"
"  show Str     = \"Str\"\n"
"  show Boolean = \"Boolean\"\n"
"  show Float   = \"Float\"\n"
"\n"
"Show Column where\n"
"  show (MkColumn n ct) = \"\\{n}:\\{show ct}\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map show\n"
msgstr ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"record Column where\n"
"  constructor MkColumn\n"
"  name : String\n"
"  type : ColType\n"
"\n"
"infixr 8 :>\n"
"\n"
"(:>) : String -> ColType -> Column\n"
"(:>) = MkColumn\n"
"\n"
"Schema : Type\n"
"Schema = List Column\n"
"\n"
"Show ColType where\n"
"  show I64     = \"I64\"\n"
"  show Str     = \"Str\"\n"
"  show Boolean = \"Boolean\"\n"
"  show Float   = \"Float\"\n"
"\n"
"Show Column where\n"
"  show (MkColumn n ct) = \"\\{n}:\\{show ct}\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map show\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:531
#, no-wrap
msgid ""
"As you can see, in a schema we now pair a column's type\n"
"with its name. Here is an example schema for a CSV file\n"
"holding information about employees in a company:\n"
msgstr "如您所见，在模式中，我们现在将列的类型与其名称配对。以下是保存公司员工信息的 CSV 文件的示例架构：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:532
#, no-wrap
msgid ""
"EmployeeSchema : Schema\n"
"EmployeeSchema = [ \"firstName\"  :> Str\n"
"                 , \"lastName\"   :> Str\n"
"                 , \"email\"      :> Str\n"
"                 , \"age\"        :> I64\n"
"                 , \"salary\"     :> Float\n"
"                 , \"management\" :> Boolean\n"
"                 ]\n"
msgstr ""
"EmployeeSchema : Schema\n"
"EmployeeSchema = [ \"firstName\"  :> Str\n"
"                 , \"lastName\"   :> Str\n"
"                 , \"email\"      :> Str\n"
"                 , \"age\"        :> I64\n"
"                 , \"salary\"     :> Float\n"
"                 , \"management\" :> Boolean\n"
"                 ]\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:549
#, no-wrap
msgid ""
"Such a schema could of course again be read from user\n"
"input, but we will wait with implementing a parser until\n"
"later in this chapter.\n"
"Using this new schema with an `HList` directly led to issues\n"
"with type inference, therefore I quickly wrote a custom\n"
"row type: A heterogeneous list indexed over a schema.\n"
msgstr "这样的模式当然可以再次从用户输入中读取，但我们将等到本章稍后再实现解析器。将这个新模式与 `HList` 一起使用会直接导致类型推断问题，因此我很快编写了一个自定义行类型：基于模式索引的异构列表。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:550
#, no-wrap
msgid ""
"data Row : Schema -> Type where\n"
"  Nil  : Row []\n"
"\n"
"  (::) :  {0 name : String}\n"
"       -> {0 type : ColType}\n"
"       -> (v : IdrisType type)\n"
"       -> Row ss\n"
"       -> Row (name :> type :: ss)\n"
msgstr ""
"data Row : Schema -> Type where\n"
"  Nil  : Row []\n"
"\n"
"  (::) :  {0 name : String}\n"
"       -> {0 type : ColType}\n"
"       -> (v : IdrisType type)\n"
"       -> Row ss\n"
"       -> Row (name :> type :: ss)\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:565
#, no-wrap
msgid ""
"In the signature of *cons*, I list the erased implicit arguments\n"
"explicitly. This is good practice, as otherwise Idris will often\n"
"issue shadowing warnings when using such data constructors in client\n"
"code.\n"
msgstr "在 *cons* 的签名中，我明确列出了已删除的隐式参数。这是一种很好的做法，否则 Idris 在客户端代码中使用此类数据构造函数时会经常发出阴影警告。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:567
#, no-wrap
msgid "We can now define a type alias for CSV rows representing employees:\n"
msgstr "我们现在可以为代表员工的 CSV 行定义一个类型别名：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:568
#, no-wrap
msgid ""
"0 Employee : Type\n"
"Employee = Row EmployeeSchema\n"
"\n"
"hock : Employee\n"
"hock = [ \"Stefan\", \"Höck\", \"hock@foo.com\", 46, 5443.2, False ]\n"
msgstr ""
"0 Employee : Type\n"
"Employee = Row EmployeeSchema\n"
"\n"
"hock : Employee\n"
"hock = [ \"Stefan\", \"Höck\", \"hock@foo.com\", 46, 5443.2, False ]\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:584
#, no-wrap
msgid ""
"Note, how I gave `Employee` a zero quantity. This means, we are\n"
"only ever allowed to use this function at compile time\n"
"but never at runtime. This is a safe way to make sure\n"
"our type-level functions and aliases do not leak into the\n"
"executable when we build our application. We are allowed\n"
"to use zero-quantity functions and values in type signatures\n"
"and when computing other erased values, but not for runtime-relevant\n"
"computations.\n"
msgstr "请注意，我如何给 `Employee` 一个定量 0。这意味着，我们只被允许在编译时使用这个函数，但绝不允许在运行时使用。这是一种确保我们的类型级函数和别名在构建应用程序时不会泄漏到可执行文件中的安全方法。我们可以在类型签名和计算其他擦除值时使用零数量的函数和值，但不能用于与运行时相关的计算。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:602
#, no-wrap
msgid ""
"We would now like to access a value in a row based on\n"
"the name given. For this, we write a custom predicate, which\n"
"serves as a witness that a column with the given name is\n"
"part of the schema. Now, here is an important thing to note:\n"
"In this predicate we include an index for the *type* of the\n"
"column with the given name. We need this, because when we\n"
"access a column by name, we need a way to figure out\n"
"the return type. But during proof search, this type will\n"
"have to be derived by Idris based on the column name and\n"
"schema in question (otherwise, the proof search will fail\n"
"unless the return type is known in advance).\n"
"We therefore *must* tell Idris, that\n"
"it can't include this type in the list of search criteria,\n"
"otherwise it will try and infer the column type from the\n"
"context (using type inference) before running the proof\n"
"search. This can be done by listing the indices to be used in\n"
"the search like so: `[search name schema]`.\n"
msgstr "我们现在想根据给定的名称访问一行中的值。为此，我们编写了一个自定义谓词，它可以证明具有给定名称的列是模式的一部分。现在，有一件重要的事情需要注意：在这个谓词中，我们包含一个索引，用于给定名称的列的 *类型*。我们需要这个，因为当我们按名称访问列时，我们需要一种方法来确定返回类型。但是在证明搜索期间，Idris 必须根据所讨论的列名和模式派生这种类型（否则，除非事先知道返回类型，否则证明搜索将失败）。因此，我们 *必须* 告诉 Idris，它不能将此类型包含在搜索条件列表中，否则它会在运行证明搜索之前尝试从上下文中推断列类型（使用类型推断）。这可以通过列出要在搜索中使用的索引来完成，如下所示：`[search name schema]`。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:603
#, no-wrap
msgid ""
"data InSchema :  (name    : String)\n"
"              -> (schema  : Schema)\n"
"              -> (colType : ColType)\n"
"              -> Type where\n"
"  [search name schema]\n"
"  IsHere  : InSchema n (n :> t :: ss) t\n"
"  IsThere : InSchema n ss t -> InSchema n (fld :: ss) t\n"
"\n"
"Uninhabited (InSchema n [] c) where\n"
"  uninhabited IsHere impossible\n"
"  uninhabited (IsThere _) impossible\n"
msgstr ""
"data InSchema :  (name    : String)\n"
"              -> (schema  : Schema)\n"
"              -> (colType : ColType)\n"
"              -> Type where\n"
"  [search name schema]\n"
"  IsHere  : InSchema n (n :> t :: ss) t\n"
"  IsThere : InSchema n ss t -> InSchema n (fld :: ss) t\n"
"\n"
"Uninhabited (InSchema n [] c) where\n"
"  uninhabited IsHere impossible\n"
"  uninhabited (IsThere _) impossible\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:619
#, no-wrap
msgid ""
"With this, we are now ready to access the value\n"
"at a given column based on the column's name:\n"
msgstr "有了这个，我们现在可以根据列的名称访问给定列的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:620
#, no-wrap
msgid ""
"getAt :  {0 ss : Schema}\n"
"      -> (name : String)\n"
"      -> (row  : Row ss)\n"
"      -> (prf  : InSchema name ss c)\n"
"      => IdrisType c\n"
"getAt name (v :: vs) {prf = IsHere}    = v\n"
"getAt name (_ :: vs) {prf = IsThere p} = getAt name vs\n"
msgstr ""
"getAt :  {0 ss : Schema}\n"
"      -> (name : String)\n"
"      -> (row  : Row ss)\n"
"      -> (prf  : InSchema name ss c)\n"
"      => IdrisType c\n"
"getAt name (v :: vs) {prf = IsHere}    = v\n"
"getAt name (_ :: vs) {prf = IsThere p} = getAt name vs\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:638
#, no-wrap
msgid ""
"Below is an example how to use this at compile time. Note\n"
"the amount of work Idris performs for us: It first comes\n"
"up with proofs that `firstName`, `lastName`, and `age`\n"
"are indeed valid names in the `Employee` schema. From\n"
"these proofs it automatically figures out the return types\n"
"of the calls to `getAt` and extracts the corresponding values\n"
"from the row. All of this happens in a provably total and type\n"
"safe way.\n"
msgstr "下面是一个如何在编译时使用它的示例。请注意 Idris 为我们执行的工作量：首先证明 `firstName`、`lastName` 和 `age` 确实是 `Employee` 模式中的有效名称。从这些证明中，它会自动计算出对 `getAt` 的调用的返回类型，并从行中提取相应的值。所有这些都以可证明的完全性和类型安全的方式发生。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:639
#, no-wrap
msgid ""
"shoeck : String\n"
"shoeck =  getAt \"firstName\" hock\n"
"       ++ \" \"\n"
"       ++ getAt \"lastName\" hock\n"
"       ++ \": \"\n"
"       ++ show (getAt \"age\" hock)\n"
"       ++ \" years old.\"\n"
msgstr ""
"shoeck : String\n"
"shoeck =  getAt \"firstName\" hock\n"
"       ++ \" \"\n"
"       ++ getAt \"lastName\" hock\n"
"       ++ \": \"\n"
"       ++ show (getAt \"age\" hock)\n"
"       ++ \" years old.\"\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:657
#, no-wrap
msgid ""
"In order to at runtime specify a column name, we need a way\n"
"for computing values of type `InSchema` by comparing\n"
"the column names with the schema in question. Since we have\n"
"to compare two string values for being propositionally equal,\n"
"we use the `DecEq` implementation for `String` here (Idris provides `DecEq`\n"
"implementations for all primitives). We extract the column type\n"
"at the same time and pair this (as a dependent pair) with\n"
"the `InSchema` proof:\n"
msgstr "为了在运行时指定列名，我们需要一种通过将列名与相关架构进行比较来计算 `InSchema` 类型值的方法。因为我们必须比较两个字符串值是否在命题上相等，所以我们在这里为 `String` 使用 `DecEq` 实现（Idris 为所有原语提供 `DecEq` 实现）。我们同时提取列类型并将其（作为依赖对）与 `InSchema` 证明配对：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:658
#, no-wrap
msgid ""
"inSchema : (ss : Schema) -> (n : String) -> Maybe (c ** InSchema n ss c)\n"
"inSchema []                    _ = Nothing\n"
"inSchema (MkColumn cn t :: xs) n = case decEq cn n of\n"
"  Yes Refl   => Just (t ** IsHere)\n"
"  No  contra => case inSchema xs n of\n"
"    Just (t ** prf) => Just $ (t ** IsThere prf)\n"
"    Nothing         => Nothing\n"
msgstr ""
"inSchema : (ss : Schema) -> (n : String) -> Maybe (c ** InSchema n ss c)\n"
"inSchema []                    _ = Nothing\n"
"inSchema (MkColumn cn t :: xs) n = case decEq cn n of\n"
"  Yes Refl   => Just (t ** IsHere)\n"
"  No  contra => case inSchema xs n of\n"
"    Just (t ** prf) => Just $ (t ** IsThere prf)\n"
"    Nothing         => Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:671
#, no-wrap
msgid ""
"At the end of this chapter we will use `InSchema` in\n"
"our CSV command-line application to list all values\n"
"in a column.\n"
msgstr "在本章的最后，我们将在 CSV 命令行应用程序中使用 `InSchema` 来列出列中的所有值。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:676
#, no-wrap
msgid ""
"Show that `InSchema` is decidable by changing the output type\n"
"of `inSchema` to `Dec (c ** InSchema n ss c)`.\n"
msgstr ""
"通过将 `inSchema` 的输出类型更改为 `Dec (c ** InSchema n ss c)` 来证明 "
"`InSchema` 是可判定的。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:679
#, no-wrap
msgid ""
"Declare and implement a function for modifying a field\n"
"in a row based on the column name given.\n"
msgstr "声明并实现一个函数，用于根据给定的列名修改行中的字段。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:684
#, no-wrap
msgid ""
"Define a predicate to be used as a witness that one\n"
"list contains only elements in the second list in the\n"
"same order and use this predicate to extract several columns\n"
"from a row at once.\n"
msgstr "定义一个谓词用作见证一个列表仅包含第二个列表中相同顺序的元素，并使用此谓词一"
"次从一行中提取几列。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:688
#, no-wrap
msgid ""
"   For instance, `[2,4,5]` contains elements from\n"
"   `[1,2,3,4,5,6]` in the correct order, but `[4,2,5]`\n"
"   does not.\n"
msgstr "   例如，`[1,2,3,4,5,6]` 包含的 `[2,4,5]` 顺序是正确的，但是 `[4,2,5]` 不是。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:694
#, no-wrap
msgid ""
"Improve the functionality from exercise 3 by defining a new\n"
"predicate, witnessing that all strings in a list correspond\n"
"to column names in a schema (in arbitrary order).\n"
"Use this to extract several columns from a row at once in\n"
"arbitrary order.\n"
msgstr ""
"通过定义一个新的谓词来改进练习 3 的功能，见证列表中的所有字符串都对应于模式中"
"的列名（以任意顺序）。使用它可以以任意顺序一次从一行中提取几列。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:698
#, no-wrap
msgid ""
"   Hint: Make sure to include the resulting schema as an index,\n"
"   but search only based on the list of names and the input\n"
"   schema.\n"
msgstr ""
"   提示：确保包含生成的模式作为索引，\n"
"   仅根据名称列表和输入模式进行搜索。\n"

#. type: Title ##
#: ../src/Tutorial/Predicates.md:699
#, no-wrap
msgid "Use Case: Flexible Error Handling"
msgstr "用例：灵活的错误处理"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:718
#, no-wrap
msgid ""
"A recurring pattern when writing larger applications is\n"
"the combination of different parts of a program each with\n"
"their own failure types in a larger effectful computation.\n"
"We saw this, for instance, when implementing a command-line\n"
"tool for handling CSV files. There, we read and wrote data\n"
"from and to files, we parsed column types and schemata,\n"
"we parsed row and column indices and command-line commands.\n"
"All these operations came with the potential of failure and\n"
"might be implemented in different parts of our application.\n"
"In order to unify these different failure types, we wrote\n"
"a custom sum type encapsulating each of them, and wrote a\n"
"single handler for this sum type. This approach was alright\n"
"then, but it does not scale well and is lacking in terms of\n"
"flexibility. We are therefore trying a different\n"
"approach here. Before we continue, we quickly implement a\n"
"couple of functions with the potential of failure plus\n"
"some custom error types:\n"
msgstr "编写大型应用程序时反复出现的模式是在更大的有效计算中组合程序的不同部分，每个部分都有自己的故障类型。例如，我们在实现用于处理 CSV 文件的命令行工具时就看到了这一点。在那里，我们从文件读取和写入数据，我们解析列类型和模式，我们解析行和列索引以及命令行命令。所有这些操作都有失败的可能性，并且可能在我们应用程序的不同部分中实现。为了统一这些不同的失败类型，我们编写了一个自定义的和类型来封装它们中的每一个，并为这个和类型编写了一个单独的处理程序。这种方法当时还可以，但它不能很好地扩展，并且缺乏灵活性。因此，我们在这里尝试不同的方法。在继续之前，我们快速实现了几个可能失败的函数以及一些自定义错误类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:719
#, no-wrap
msgid ""
"record NoNat where\n"
"  constructor MkNoNat\n"
"  str : String\n"
"\n"
"readNat' : String -> Either NoNat Nat\n"
"readNat' s = maybeToEither (MkNoNat s) $ parsePositive s\n"
"\n"
"record NoColType where\n"
"  constructor MkNoColType\n"
"  str : String\n"
"\n"
"readColType' : String -> Either NoColType ColType\n"
"readColType' \"I64\"     = Right I64\n"
"readColType' \"Str\"     = Right Str\n"
"readColType' \"Boolean\" = Right Boolean\n"
"readColType' \"Float\"   = Right Float\n"
"readColType' s         = Left $ MkNoColType s\n"
msgstr ""
"record NoNat where\n"
"  constructor MkNoNat\n"
"  str : String\n"
"\n"
"readNat' : String -> Either NoNat Nat\n"
"readNat' s = maybeToEither (MkNoNat s) $ parsePositive s\n"
"\n"
"record NoColType where\n"
"  constructor MkNoColType\n"
"  str : String\n"
"\n"
"readColType' : String -> Either NoColType ColType\n"
"readColType' \"I64\"     = Right I64\n"
"readColType' \"Str\"     = Right Str\n"
"readColType' \"Boolean\" = Right Boolean\n"
"readColType' \"Float\"   = Right Float\n"
"readColType' s         = Left $ MkNoColType s\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:746
#, no-wrap
msgid ""
"However, if we wanted to parse a `Fin n`, there'd be already\n"
"two ways how this could fail: The string in question could not\n"
"represent a natural number (leading to a `NoNat` error), or it\n"
"could be out of bounds (leading to an `OutOfBounds` error).\n"
"We have to somehow encode these two possibilities in the\n"
"return type, for instance, by using an `Either` as the error\n"
"type:\n"
msgstr "但是，如果我们想解析 `Fin n`，已经有两种方法会导致失败：有问题的字符串不能表示自然数（导致 `NoNat`错误），或者它可能超出范围（导致 `OutOfBounds` 错误）。我们必须以某种方式在返回类型中编码这两种可能性，例如，通过使用 `Either` 作为错误类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:747
#, no-wrap
msgid ""
"record OutOfBounds where\n"
"  constructor MkOutOfBounds\n"
"  size  : Nat\n"
"  index : Nat\n"
"\n"
"readFin' : {n : _} -> String -> Either (Either NoNat OutOfBounds) (Fin n)\n"
"readFin' s = do\n"
"  ix <- mapFst Left (readNat' s)\n"
"  maybeToEither (Right $ MkOutOfBounds n ix) $ natToFin ix n\n"
msgstr ""
"record OutOfBounds where\n"
"  constructor MkOutOfBounds\n"
"  size  : Nat\n"
"  index : Nat\n"
"\n"
"readFin' : {n : _} -> String -> Either (Either NoNat OutOfBounds) (Fin n)\n"
"readFin' s = do\n"
"  ix <- mapFst Left (readNat' s)\n"
"  maybeToEither (Right $ MkOutOfBounds n ix) $ natToFin ix n\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:767
#, no-wrap
msgid ""
"This is incredibly ugly. A custom sum type might have been slightly better,\n"
"but we still would have to use `mapFst` when invoking `readNat'`, and\n"
"writing custom sum types for every possible combination of errors\n"
"will get cumbersome very quickly as well.\n"
"What we are looking for, is a generalized sum type: A type\n"
"indexed by a list of types (the possible choices) holding\n"
"a single value of exactly one of the types in question.\n"
"Here is a first naive try:\n"
msgstr "这是难以置信的丑陋。自定义和类型可能会稍微好一些，但是在调用 `readNat'` 时我们仍然必须使用 `mapFst`，并且为每个可能的错误组合编写自定义和类型也会很快变得非常麻烦。我们正在寻找的是一种广义的和类型：一种由类型列表（可能的选择）索引的类型，其中包含所讨论类型之一的单个值。这是第一次天真的尝试：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:768
#, no-wrap
msgid ""
"data Sum : List Type -> Type where\n"
"  MkSum : (val : t) -> Sum ts\n"
msgstr ""
"data Sum : List Type -> Type where\n"
"  MkSum : (val : t) -> Sum ts\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:783
#, no-wrap
msgid ""
"However, there is a crucial piece of information missing:\n"
"We have not verified that `t` is an element of `ts`, nor\n"
"*which* type it actually is. In fact, this is another case\n"
"of an erased existential, and we will have no way to at runtime\n"
"learn something about `t`. What we need to do is to pair the value\n"
"with a proof, that its type `t` is an element of `ts`.\n"
"We could use `Elem` again for this, but for some use cases\n"
"we will require access to the number of types in the list.\n"
"We will therefore use a vector instead of a list as our index.\n"
"Here is a predicate similar to `Elem` but for vectors:\n"
msgstr "但是，缺少一条关键信息：我们尚未验证 `t` 是 `ts` 的元素，也没有验证它实际上是 *哪个* 类型。事实上，这是另一种被抹去的存在，我们将无法在运行时了解 `t`。我们需要做的是将值与证明配对，证明其类型 `t` 是 `ts` 的元素。为此，我们可以再次使用 `Elem`，但对于某些用例，我们将需要访问列表中的类型数量。因此，我们将使用向量而不是列表作为索引。这是一个类似于 `Elem` 的谓词，但用于向量：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:784
#, no-wrap
msgid ""
"data Has :  (v : a) -> (vs  : Vect n a) -> Type where\n"
"  Z : Has v (v :: vs)\n"
"  S : Has v vs -> Has v (w :: vs)\n"
"\n"
"Uninhabited (Has v []) where\n"
"  uninhabited Z impossible\n"
"  uninhabited (S _) impossible\n"
msgstr ""
"data Has :  (v : a) -> (vs  : Vect n a) -> Type where\n"
"  Z : Has v (v :: vs)\n"
"  S : Has v vs -> Has v (w :: vs)\n"
"\n"
"Uninhabited (Has v []) where\n"
"  uninhabited Z impossible\n"
"  uninhabited (S _) impossible\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:797
#, no-wrap
msgid ""
"A value of type `Has v vs` is a witness that `v` is an\n"
"element of `vs`. With this, we can now implement an indexed\n"
"sum type (also called an *open union*):\n"
msgstr "`Has v vs` 类型的值证明 `v` 是 `vs` 的一个元素。有了这个，我们现在可以实现一个索引和类型（也称为 *开放联合*）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:798
#, no-wrap
msgid ""
"data Union : Vect n Type -> Type where\n"
"  U : (ix : Has t ts) -> (val : t) -> Union ts\n"
"\n"
"Uninhabited (Union []) where\n"
"  uninhabited (U ix _) = absurd ix\n"
msgstr ""
"data Union : Vect n Type -> Type where\n"
"  U : (ix : Has t ts) -> (val : t) -> Union ts\n"
"\n"
"Uninhabited (Union []) where\n"
"  uninhabited (U ix _) = absurd ix\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:811
#, no-wrap
msgid ""
"Note the difference between `HList` and `Union`. `HList` is\n"
"a *generalized product type*: It holds a value for each type\n"
"in its index. `Union` is a *generalized sum type*: It holds\n"
"only a single value, which must be of a type listed in the index.\n"
"With this we can now define a much more flexible error type:\n"
msgstr "注意 `HList` 和 `Union` 之间的区别。 `HList` 是 * 广义积类型*：它在其索引中为每个类型保存一个值。 `Union` 是 * 广义和类型*：它只保存一个值，该值必须是索引中列出的类型。有了这个，我们现在可以定义一个更灵活的错误类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:812
#, no-wrap
msgid ""
"0 Err : Vect n Type -> Type -> Type\n"
"Err ts t = Either (Union ts) t\n"
msgstr ""
"0 Err : Vect n Type -> Type -> Type\n"
"Err ts t = Either (Union ts) t\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:820
#, no-wrap
msgid ""
"A function returning an `Err ts a` describes a computation, which\n"
"can fail with one of the errors listed in `ts`.\n"
"We first need some utility functions.\n"
msgstr "返回 `Err ts a` 的函数描述了一个计算，该计算可能会因 `ts` 中列出的错误之一而失败。我们首先需要一些实用函数。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:821
#, no-wrap
msgid ""
"inject : (prf : Has t ts) => (v : t) -> Union ts\n"
"inject v = U prf v\n"
"\n"
"fail : Has t ts => (err : t) -> Err ts a\n"
"fail err = Left $ inject err\n"
"\n"
"failMaybe : Has t ts => (err : Lazy t) -> Maybe a -> Err ts a\n"
"failMaybe err = maybeToEither (inject err)\n"
msgstr ""
"inject : (prf : Has t ts) => (v : t) -> Union ts\n"
"inject v = U prf v\n"
"\n"
"fail : Has t ts => (err : t) -> Err ts a\n"
"fail err = Left $ inject err\n"
"\n"
"failMaybe : Has t ts => (err : Lazy t) -> Maybe a -> Err ts a\n"
"failMaybe err = maybeToEither (inject err)\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:834
#, no-wrap
msgid ""
"Next, we can write more flexible versions of the\n"
"parsers we wrote above:\n"
msgstr "接下来，我们可以为上面编写的解析器编写更灵活的版本：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:835
#, no-wrap
msgid ""
"readNat : Has NoNat ts => String -> Err ts Nat\n"
"readNat s = failMaybe (MkNoNat s) $ parsePositive s\n"
"\n"
"readColType : Has NoColType ts => String -> Err ts ColType\n"
"readColType \"I64\"     = Right I64\n"
"readColType \"Str\"     = Right Str\n"
"readColType \"Boolean\" = Right Boolean\n"
"readColType \"Float\"   = Right Float\n"
"readColType s         = fail $ MkNoColType s\n"
msgstr ""
"readNat : Has NoNat ts => String -> Err ts Nat\n"
"readNat s = failMaybe (MkNoNat s) $ parsePositive s\n"
"\n"
"readColType : Has NoColType ts => String -> Err ts ColType\n"
"readColType \"I64\"     = Right I64\n"
"readColType \"Str\"     = Right Str\n"
"readColType \"Boolean\" = Right Boolean\n"
"readColType \"Float\"   = Right Float\n"
"readColType s         = fail $ MkNoColType s\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:849
#, no-wrap
msgid ""
"Before we implement `readFin`, we introduce a short cut for\n"
"specifying that several error types must be present:\n"
msgstr "在我们实现 `readFin` 之前，我们引入一个快捷方式来指定必须存在几种错误类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:850
#, no-wrap
msgid ""
"0 Errs : List Type -> Vect n Type -> Type\n"
"Errs []        _  = ()\n"
"Errs (x :: xs) ts = (Has x ts, Errs xs ts)\n"
msgstr ""
"0 Errs : List Type -> Vect n Type -> Type\n"
"Errs []        _  = ()\n"
"Errs (x :: xs) ts = (Has x ts, Errs xs ts)\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:860
#, no-wrap
msgid ""
"Function `Errs` returns a tuple of constraints. This can\n"
"be used as a witness that all listed types are present\n"
"in the vector of types: Idris will automatically extract\n"
"the proofs from the tuple as needed.\n"
msgstr "函数 `Errs` 返回一个约束元组。这可以用作所有列出的类型都存在于类型向量中的见证：Idris 将根据需要自动从元组中提取证明。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:862
#, no-wrap
msgid ""
"readFin : {n : _} -> Errs [NoNat, OutOfBounds] ts => String -> Err ts (Fin n)\n"
"readFin s = do\n"
"  S ix <- readNat s | Z => fail (MkOutOfBounds n Z)\n"
"  failMaybe (MkOutOfBounds n (S ix)) $ natToFin ix n\n"
msgstr ""
"readFin : {n : _} -> Errs [NoNat, OutOfBounds] ts => String -> Err ts (Fin n)\n"
"readFin s = do\n"
"  S ix <- readNat s | Z => fail (MkOutOfBounds n Z)\n"
"  failMaybe (MkOutOfBounds n (S ix)) $ natToFin ix n\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:871
#, no-wrap
msgid ""
"As a last example, here are parsers for schemata and\n"
"CSV rows:\n"
msgstr "作为最后一个示例，这里是模式和 CSV 行的解析器：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:872
#, no-wrap
msgid ""
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"record InvalidColumn where\n"
"  constructor MkInvalidColumn\n"
"  str : String\n"
"\n"
"readColumn : Errs [InvalidColumn, NoColType] ts => String -> Err ts Column\n"
"readColumn s = case forget $ split (':' ==) s of\n"
"  [n,ct] => MkColumn n <$> readColType ct\n"
"  _      => fail $ MkInvalidColumn s\n"
"\n"
"readSchema : Errs [InvalidColumn, NoColType] ts => String -> Err ts Schema\n"
"readSchema = traverse readColumn . fromCSV\n"
"\n"
"data RowError : Type where\n"
"  InvalidField  : (row, col : Nat) -> (ct : ColType) -> String -> RowError\n"
"  UnexpectedEOI : (row, col : Nat) -> RowError\n"
"  ExpectedEOI   : (row, col : Nat) -> RowError\n"
"\n"
"decodeField :  Has RowError ts\n"
"            => (row,col : Nat)\n"
"            -> (c : ColType)\n"
"            -> String\n"
"            -> Err ts (IdrisType c)\n"
"decodeField row col c s =\n"
"  let err = InvalidField row col c s\n"
"   in case c of\n"
"        I64     => failMaybe err $ read s\n"
"        Str     => failMaybe err $ read s\n"
"        Boolean => failMaybe err $ read s\n"
"        Float   => failMaybe err $ read s\n"
"\n"
"decodeRow :  Has RowError ts\n"
"          => {s : _}\n"
"          -> (row : Nat)\n"
"          -> (str : String)\n"
"          -> Err ts (Row s)\n"
"decodeRow row = go 1 s . fromCSV\n"
"  where go : Nat -> (cs : Schema) -> List String -> Err ts (Row cs)\n"
"        go k []       []                    = Right []\n"
"        go k []       (_ :: _)              = fail $ ExpectedEOI row k\n"
"        go k (_ :: _) []                    = fail $ UnexpectedEOI row k\n"
"        go k (MkColumn n c :: cs) (s :: ss) =\n"
"          [| decodeField row k c s :: go (S k) cs ss |]\n"
msgstr ""
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"record InvalidColumn where\n"
"  constructor MkInvalidColumn\n"
"  str : String\n"
"\n"
"readColumn : Errs [InvalidColumn, NoColType] ts => String -> Err ts Column\n"
"readColumn s = case forget $ split (':' ==) s of\n"
"  [n,ct] => MkColumn n <$> readColType ct\n"
"  _      => fail $ MkInvalidColumn s\n"
"\n"
"readSchema : Errs [InvalidColumn, NoColType] ts => String -> Err ts Schema\n"
"readSchema = traverse readColumn . fromCSV\n"
"\n"
"data RowError : Type where\n"
"  InvalidField  : (row, col : Nat) -> (ct : ColType) -> String -> RowError\n"
"  UnexpectedEOI : (row, col : Nat) -> RowError\n"
"  ExpectedEOI   : (row, col : Nat) -> RowError\n"
"\n"
"decodeField :  Has RowError ts\n"
"            => (row,col : Nat)\n"
"            -> (c : ColType)\n"
"            -> String\n"
"            -> Err ts (IdrisType c)\n"
"decodeField row col c s =\n"
"  let err = InvalidField row col c s\n"
"   in case c of\n"
"        I64     => failMaybe err $ read s\n"
"        Str     => failMaybe err $ read s\n"
"        Boolean => failMaybe err $ read s\n"
"        Float   => failMaybe err $ read s\n"
"\n"
"decodeRow :  Has RowError ts\n"
"          => {s : _}\n"
"          -> (row : Nat)\n"
"          -> (str : String)\n"
"          -> Err ts (Row s)\n"
"decodeRow row = go 1 s . fromCSV\n"
"  where go : Nat -> (cs : Schema) -> List String -> Err ts (Row cs)\n"
"        go k []       []                    = Right []\n"
"        go k []       (_ :: _)              = fail $ ExpectedEOI row k\n"
"        go k (_ :: _) []                    = fail $ UnexpectedEOI row k\n"
"        go k (MkColumn n c :: cs) (s :: ss) =\n"
"          [| decodeField row k c s :: go (S k) cs ss |]\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:925
#, no-wrap
msgid ""
"Here is an example REPL session, where I test `readSchema`. I defined\n"
"variable `ts` using the `:let` command to make this more convenient.\n"
"Note, how the order of error types is of no importance, as long\n"
"as types `InvalidColumn` and `NoColType` are present in the list of\n"
"errors:\n"
msgstr "这是一个示例 REPL 会话，我在其中测试 `readSchema`。我使用 `:let` 命令定义了变量 `ts` 以使其更方便。请注意，错误类型的顺序并不重要，只要错误列表中存在 `InvalidColumn` 和 `NoColType` 类型：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:926
#, no-wrap
msgid ""
"Tutorial.Predicates> :let ts = the (Vect 3 _) [NoColType,NoNat,InvalidColumn]\n"
"Tutorial.Predicates> readSchema {ts} \"foo:bar\"\n"
"Left (U Z (MkNoColType \"bar\"))\n"
"Tutorial.Predicates> readSchema {ts} \"foo:Float\"\n"
"Right [MkColumn \"foo\" Float]\n"
"Tutorial.Predicates> readSchema {ts} \"foo Float\"\n"
"Left (U (S (S Z)) (MkInvalidColumn \"foo Float\"))\n"
msgstr ""
"Tutorial.Predicates> :let ts = the (Vect 3 _) [NoColType,NoNat,InvalidColumn]\n"
"Tutorial.Predicates> readSchema {ts} \"foo:bar\"\n"
"Left (U Z (MkNoColType \"bar\"))\n"
"Tutorial.Predicates> readSchema {ts} \"foo:Float\"\n"
"Right [MkColumn \"foo\" Float]\n"
"Tutorial.Predicates> readSchema {ts} \"foo Float\"\n"
"Left (U (S (S Z)) (MkInvalidColumn \"foo Float\"))\n"

#. type: Title ###
#: ../src/Tutorial/Predicates.md:936
#, no-wrap
msgid "Error Handling"
msgstr "错误处理"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:943
#, no-wrap
msgid ""
"There are several techniques for handling errors, all of which\n"
"are useful at times. For instance, we might want to handle some\n"
"errors early on and individually, while dealing with others\n"
"much later in our application. Or we might want to handle\n"
"them all in one fell swoop. We look at both approaches here.\n"
msgstr "有几种处理错误的技术，所有这些技术有时都很有用。例如，我们可能希望在早期单独处理一些错误，而在我们的应用程序中处理其他错误。或者我们可能想一举解决所有问题。我们在这里看看这两种方法。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:950
#, no-wrap
msgid ""
"First, in order to handle a single error individually, we need\n"
"to *split* a union into one of two possibilities: A value of\n"
"the error type in question or a new union, holding one of the\n"
"other error types. We need a new predicate for this, which\n"
"not only encodes the presence of a value in a vector\n"
"but also the result of removing that value:\n"
msgstr "首先，为了单独处理单个错误，我们需要将联合 *拆分* 为以下两种可能性之一：所讨论的错误类型的值或新联合，包含其他错误类型之一。为此我们需要一个新的谓词，它不仅编码向量中值的存在，还编码删除该值的结果：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:951
#, no-wrap
msgid ""
"data Rem : (v : a) -> (vs : Vect (S n) a) -> (rem : Vect n a) -> Type where\n"
"  [search v vs]\n"
"  RZ : Rem v (v :: rem) rem\n"
"  RS : Rem v vs rem -> Rem v (w :: vs) (w :: rem)\n"
msgstr ""
"data Rem : (v : a) -> (vs : Vect (S n) a) -> (rem : Vect n a) -> Type where\n"
"  [search v vs]\n"
"  RZ : Rem v (v :: rem) rem\n"
"  RS : Rem v vs rem -> Rem v (w :: vs) (w :: rem)\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:962
#, no-wrap
msgid ""
"Once again, we want to use one of the indices (`rem`) in our\n"
"functions' return types, so we only use the other indices during\n"
"proof search. Here is a function for splitting off a value from\n"
"an open union:\n"
msgstr "再一次，我们希望在函数的返回类型中使用其中一个索引 (`rem`)，因此我们只在证明搜索期间使用其他索引。这是一个从开放联合中分离值的函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:963
#, no-wrap
msgid ""
"split : (prf : Rem t ts rem) => Union ts -> Either t (Union rem)\n"
"split {prf = RZ}   (U Z     val) = Left val\n"
"split {prf = RZ}   (U (S x) val) = Right (U x val)\n"
"split {prf = RS p} (U Z     val) = Right (U Z val)\n"
"split {prf = RS p} (U (S x) val) = case split {prf = p} (U x val) of\n"
"  Left vt        => Left vt\n"
"  Right (U ix y) => Right $ U (S ix) y\n"
msgstr ""
"split : (prf : Rem t ts rem) => Union ts -> Either t (Union rem)\n"
"split {prf = RZ}   (U Z     val) = Left val\n"
"split {prf = RZ}   (U (S x) val) = Right (U x val)\n"
"split {prf = RS p} (U Z     val) = Right (U Z val)\n"
"split {prf = RS p} (U (S x) val) = case split {prf = p} (U x val) of\n"
"  Left vt        => Left vt\n"
"  Right (U ix y) => Right $ U (S ix) y\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:977
#, no-wrap
msgid ""
"This tries to extract a value of type `t` from a union. If it works,\n"
"the result is wrapped in a `Left`, otherwise a new union is returned\n"
"in a `Right`, but this one has `t` removed from its list of possible\n"
"types.\n"
msgstr "这试图从联合中提取 `t` 类型的值。如果有效，则将结果包装在 `Left` 中，否则将在 `Right` 中返回一个新联合，但此联合已从其列表中删除了 `t`可能的类型。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:982
#, no-wrap
msgid ""
"With this, we can implement a handler for single errors.\n"
"Error handling often happens in an effectful context (we might want to\n"
"print a message to the console or write the error to a log file), so\n"
"we use an applicative effect type to handle errors in.\n"
msgstr "有了这个，我们可以实现单个错误的处理程序。错误处理通常发生在有效的上下文中（我们可能希望将消息打印到控制台或将错误写入日志文件），因此我们使用应用效果类型来处理错误。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:983
#, no-wrap
msgid ""
"handle :  Applicative f\n"
"       => Rem t ts rem\n"
"       => (h : t -> f a)\n"
"       -> Err ts a\n"
"       -> f (Err rem a)\n"
"handle h (Left x)  = case split x of\n"
"  Left v    => Right <$> h v\n"
"  Right err => pure $ Left err\n"
"handle _ (Right x) = pure $ Right x\n"
msgstr ""
"handle :  Applicative f\n"
"       => Rem t ts rem\n"
"       => (h : t -> f a)\n"
"       -> Err ts a\n"
"       -> f (Err rem a)\n"
"handle h (Left x)  = case split x of\n"
"  Left v    => Right <$> h v\n"
"  Right err => pure $ Left err\n"
"handle _ (Right x) = pure $ Right x\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:998
#, no-wrap
msgid ""
"For handling all errors at once, we can use a handler type\n"
"indexed by the vector of errors, and parameterized by the\n"
"output type:\n"
msgstr "为了一次处理所有错误，我们可以使用由错误向量索引并由输出类型参数化的处理程序类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:999
#, no-wrap
msgid ""
"namespace Handler\n"
"  public export\n"
"  data Handler : (ts : Vect n Type) -> (a : Type) -> Type where\n"
"    Nil  : Handler [] a\n"
"    (::) : (t -> a) -> Handler ts a -> Handler (t :: ts) a\n"
"\n"
"extract : Handler ts a -> Has t ts -> t -> a\n"
"extract (f :: _)  Z     val = f val\n"
"extract (_ :: fs) (S y) val = extract fs y val\n"
"extract []        ix    _   = absurd ix\n"
"\n"
"handleAll : Applicative f => Handler ts (f a) -> Err ts a -> f a\n"
"handleAll _ (Right v)       = pure v\n"
"handleAll h (Left $ U ix v) = extract h ix v\n"
msgstr ""
"namespace Handler\n"
"  public export\n"
"  data Handler : (ts : Vect n Type) -> (a : Type) -> Type where\n"
"    Nil  : Handler [] a\n"
"    (::) : (t -> a) -> Handler ts a -> Handler (t :: ts) a\n"
"\n"
"extract : Handler ts a -> Has t ts -> t -> a\n"
"extract (f :: _)  Z     val = f val\n"
"extract (_ :: fs) (S y) val = extract fs y val\n"
"extract []        ix    _   = absurd ix\n"
"\n"
"handleAll : Applicative f => Handler ts (f a) -> Err ts a -> f a\n"
"handleAll _ (Right v)       = pure v\n"
"handleAll h (Left $ U ix v) = extract h ix v\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1019
#, no-wrap
msgid ""
"Below, we will see an additional way of handling all\n"
"errors at once by defining a custom interface for\n"
"error handling.\n"
msgstr "下面，我们将看到另一种通过定义用于错误处理的自定义接口来一次处理所有错误的方法。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:1023
#, no-wrap
msgid "Implement the following utility functions for `Union`:\n"
msgstr "为 `Union` 实现以下实用函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1024
#, no-wrap
msgid ""
"   project : (0 t : Type) -> (prf : Has t ts) => Union ts -> Maybe t\n"
"\n"
"   project1 : Union [t] -> t\n"
"\n"
"   safe : Err [] a -> a\n"
msgstr ""
"   project : (0 t : Type) -> (prf : Has t ts) => Union ts -> Maybe t\n"
"\n"
"   project1 : Union [t] -> t\n"
"\n"
"   safe : Err [] a -> a\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:1034
#, no-wrap
msgid ""
"Implement the following two functions for embedding\n"
"an open union in a larger set of possibilities.\n"
"Note the unerased implicit in `extend`!\n"
msgstr "实现以下两个函数，以便在更大的可能性集合中嵌入开放联合。请注意 `extend` "
"中的未擦除隐式！\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1035
#, no-wrap
msgid ""
"   weaken : Union ts -> Union (ts ++ ss)\n"
"\n"
"   extend : {m : _} -> {0 pre : Vect m _} -> Union ts -> Union (pre ++ ts)\n"
msgstr ""
"   weaken : Union ts -> Union (ts ++ ss)\n"
"\n"
"   extend : {m : _} -> {0 pre : Vect m _} -> Union ts -> Union (pre ++ ts)\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:1043
#, no-wrap
msgid ""
"Find a general way to embed a `Union ts` in a `Union ss`,\n"
"so that the following is possible:\n"
msgstr "找到一种将 `Union ts` 嵌入到 `Union ss` 中的通用方法，以便可以进行以下操作："
"\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1044
#, no-wrap
msgid ""
"   embedTest :  Err [NoNat,NoColType] a\n"
"             -> Err [FileError, NoColType, OutOfBounds, NoNat] a\n"
"   embedTest = mapFst embed\n"
msgstr ""
"   embedTest :  Err [NoNat,NoColType] a\n"
"             -> Err [FileError, NoColType, OutOfBounds, NoNat] a\n"
"   embedTest = mapFst embed\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:1052
#, no-wrap
msgid ""
"Make `handle` more powerful, by letting the handler convert\n"
"the error in question to an `f (Err rem a)`.\n"
msgstr "通过让处理程序将有问题的错误转换为 `f (Err rem a)`，使 `handle` 更强大。\n"

#. type: Title ##
#: ../src/Tutorial/Predicates.md:1053
#, no-wrap
msgid "The Truth about Interfaces"
msgstr "关于接口的真相"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1065
#, no-wrap
msgid ""
"Well, here it finally is: The truth about interfaces. Internally,\n"
"an interface is just a record data type, with its fields corresponding\n"
"to the members of the interface. An interface implementation is\n"
"a *value* of such a record, annotated with a `%hint` pragma (see\n"
"below) to make the value available during proof search. Finally,\n"
"a constrained function is just a function with one or more auto implicit\n"
"arguments. For instance, here is the same function for looking up\n"
"an element in a list, once with the known syntax for constrained\n"
"functions, and once with an auto implicit argument. The code\n"
"produced by Idris is the same in both cases:\n"
msgstr "好吧，终于到了：关于接口的真相。在内部，接口只是一种记录数据类型，其字段对应于接口的成员。接口实现是此类记录的 *值*，使用 `%hint` pragma 注解（见下文）以使值在证明搜索期间可用。最后，受约束的函数只是具有一个或多个自动隐式参数的函数。例如，这里是在列表中查找元素的相同函数，一次使用已知语法的约束函数，一次使用自动隐式参数。 Idris 生成的代码在两种情况下都是相同的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1066
#, no-wrap
msgid ""
"isElem1 : Eq a => a -> List a -> Bool\n"
"isElem1 v []        = False\n"
"isElem1 v (x :: xs) = x == v || isElem1 v xs\n"
"\n"
"isElem2 : {auto _ : Eq a} -> a -> List a -> Bool\n"
"isElem2 v []        = False\n"
"isElem2 v (x :: xs) = x == v || isElem2 v xs\n"
msgstr ""
"isElem1 : Eq a => a -> List a -> Bool\n"
"isElem1 v []        = False\n"
"isElem1 v (x :: xs) = x == v || isElem1 v xs\n"
"\n"
"isElem2 : {auto _ : Eq a} -> a -> List a -> Bool\n"
"isElem2 v []        = False\n"
"isElem2 v (x :: xs) = x == v || isElem2 v xs\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1079
#, no-wrap
msgid ""
"Being mere records, we can also take interfaces as\n"
"regular function arguments and dissect them with a pattern\n"
"match:\n"
msgstr "作为单纯的记录，我们还可以将接口作为常规函数参数，并使用模式匹配对其进行剖析：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1080
#, no-wrap
msgid ""
"eq : Eq a -> a -> a -> Bool\n"
"eq (MkEq feq fneq) = feq\n"
msgstr ""
"eq : Eq a -> a -> a -> Bool\n"
"eq (MkEq feq fneq) = feq\n"

#. type: Title ###
#: ../src/Tutorial/Predicates.md:1085
#, no-wrap
msgid "A manual Interface Definition"
msgstr "手动接口定义"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1093
#, no-wrap
msgid ""
"I'll now demonstrate how we can achieve the same behavior\n"
"with proof search as with a regular interface definition\n"
"plus implementations. Since I want to finish the CSV\n"
"example with our new error handling tools, we are\n"
"going to implement some error handlers.\n"
"First, an interface is just a record:\n"
msgstr "我现在将演示我们如何使用证明搜索实现与使用常规接口定义和实现相同的行为。由于我想用我们的新错误处理工具完成 CSV 示例，我们将实现一些错误处理程序。首先，一个接口只是一个记录：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1094
#, no-wrap
msgid ""
"record Print a where\n"
"  constructor MkPrint\n"
"  print' : a -> String\n"
msgstr ""
"record Print a where\n"
"  constructor MkPrint\n"
"  print' : a -> String\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1104
#, no-wrap
msgid ""
"In order to access the record in a constrained function,\n"
"we use the `%search` keyword, which will try to conjure a\n"
"value of the desired type (`Print a` in this case) by\n"
"means of a proof search:\n"
msgstr "为了在受约束的函数中访问记录，我们使用 `%search` 关键字，它将尝试通过以下方式变出所需类型的值（在这种情况下为 `Print a`）证明搜索：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1105
#, no-wrap
msgid ""
"print : Print a => a -> String\n"
"print = print' %search\n"
msgstr ""
"print : Print a => a -> String\n"
"print = print' %search\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1112
#, no-wrap
msgid ""
"As an alternative, we could use a named constraint, and access\n"
"it directly via its name:\n"
msgstr "作为替代方案，我们可以使用命名约束，并通过其名称直接访问它：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1113
#, no-wrap
msgid ""
"print2 : (impl : Print a) => a -> String\n"
"print2 = print' impl\n"
msgstr ""
"print2 : (impl : Print a) => a -> String\n"
"print2 = print' impl\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1120
#, no-wrap
msgid ""
"As yet another alternative, we could use the syntax for auto\n"
"implicit arguments:\n"
msgstr "作为另一种选择，我们可以使用自动隐式参数的语法：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1121
#, no-wrap
msgid ""
"print3 : {auto impl : Print a} -> a -> String\n"
"print3 = print' impl\n"
msgstr ""
"print3 : {auto impl : Print a} -> a -> String\n"
"print3 = print' impl\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1129
#, no-wrap
msgid ""
"All three versions of `print` behave exactly the same at runtime.\n"
"So, whenever we write `{auto x : Foo} ->` we can just as well\n"
"write `(x : Foo) =>` and vice versa.\n"
msgstr "`print` 的所有三个版本在运行时的行为完全相同。所以，每当我们写 `{auto x : Foo} ->` 时，我们也可以写成 `(x : Foo) =>` ，反之亦然。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1133
#, no-wrap
msgid ""
"Interface implementations are just values of the given\n"
"record type, but in order to be available during proof search,\n"
"these need to be annotated with a `%hint` pragma:\n"
msgstr "接口实现只是给定记录类型的值，但为了在证明搜索期间可用，这些需要用 `%hint` pragma 注解：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1134
#, no-wrap
msgid ""
"%hint\n"
"noNatPrint : Print NoNat\n"
"noNatPrint = MkPrint $ \\e => \"Not a natural number: \\{e.str}\"\n"
"\n"
"%hint\n"
"noColTypePrint : Print NoColType\n"
"noColTypePrint = MkPrint $ \\e => \"Not a column type: \\{e.str}\"\n"
"\n"
"%hint\n"
"outOfBoundsPrint : Print OutOfBounds\n"
"outOfBoundsPrint = MkPrint $ \\e => \"Index is out of bounds: \\{show e.index}\"\n"
"\n"
"%hint\n"
"rowErrorPrint : Print RowError\n"
"rowErrorPrint = MkPrint $\n"
"  \\case InvalidField r c ct s =>\n"
"          \"Not a \\{show ct} in row \\{show r}, column \\{show c}. \\{s}\"\n"
"        UnexpectedEOI r c =>\n"
"          \"Unexpected end of input in row \\{show r}, column \\{show c}.\"\n"
"        ExpectedEOI r c =>\n"
"          \"Expected end of input in row \\{show r}, column \\{show c}.\"\n"
msgstr ""
"%hint\n"
"noNatPrint : Print NoNat\n"
"noNatPrint = MkPrint $ \\e => \"Not a natural number: \\{e.str}\"\n"
"\n"
"%hint\n"
"noColTypePrint : Print NoColType\n"
"noColTypePrint = MkPrint $ \\e => \"Not a column type: \\{e.str}\"\n"
"\n"
"%hint\n"
"outOfBoundsPrint : Print OutOfBounds\n"
"outOfBoundsPrint = MkPrint $ \\e => \"Index is out of bounds: \\{show e.index}\"\n"
"\n"
"%hint\n"
"rowErrorPrint : Print RowError\n"
"rowErrorPrint = MkPrint $\n"
"  \\case InvalidField r c ct s =>\n"
"          \"Not a \\{show ct} in row \\{show r}, column \\{show c}. \\{s}\"\n"
"        UnexpectedEOI r c =>\n"
"          \"Unexpected end of input in row \\{show r}, column \\{show c}.\"\n"
"        ExpectedEOI r c =>\n"
"          \"Expected end of input in row \\{show r}, column \\{show c}.\"\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1162
#, no-wrap
msgid ""
"We can also write an implementation of `Print` for\n"
"a union or errors. For this, we first come up with a\n"
"proof that all types in the union's index come with an\n"
"implementation of `Print`:\n"
msgstr "我们还可以为联合或错误编写 `Print` 的实现。为此，我们首先要证明联合索引中的所有类型都带有 `Print` 的实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1163
#, no-wrap
msgid ""
"0 All : (f : a -> Type) -> Vect n a -> Type\n"
"All f []        = ()\n"
"All f (x :: xs) = (f x, All f xs)\n"
"\n"
"unionPrintImpl : All Print ts => Union ts -> String\n"
"unionPrintImpl (U Z val)     = print val\n"
"unionPrintImpl (U (S x) val) = unionPrintImpl $ U x val\n"
"\n"
"%hint\n"
"unionPrint : All Print ts => Print (Union ts)\n"
"unionPrint = MkPrint unionPrintImpl\n"
msgstr ""
"0 All : (f : a -> Type) -> Vect n a -> Type\n"
"All f []        = ()\n"
"All f (x :: xs) = (f x, All f xs)\n"
"\n"
"unionPrintImpl : All Print ts => Union ts -> String\n"
"unionPrintImpl (U Z val)     = print val\n"
"unionPrintImpl (U (S x) val) = unionPrintImpl $ U x val\n"
"\n"
"%hint\n"
"unionPrint : All Print ts => Print (Union ts)\n"
"unionPrint = MkPrint unionPrintImpl\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1184
#, no-wrap
msgid ""
"Defining interfaces this way can be an advantage, as there\n"
"is much less magic going on, and we have more fine grained\n"
"control over the types and values of our fields. Note also,\n"
"that all of the magic comes from the search hints, with\n"
"which our \"interface implementations\" were annotated.\n"
"These made the corresponding values and functions available\n"
"during proof search.\n"
msgstr "以这种方式定义接口可能是一个优势，因为发生的魔法要少得多，而且我们对字段的类型和值有更细粒度的控制。还要注意，所有的魔法都来自搜索提示，我们的“接口实现” 带有注解。这会使相应的值和功能在证明搜索期间可用。\n"

#. type: Title ####
#: ../src/Tutorial/Predicates.md:1185
#, no-wrap
msgid "Parsing CSV Commands"
msgstr "解析 CSV 命令"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1195
#, no-wrap
msgid ""
"To conclude this chapter, we reimplement our CSV command\n"
"parser, using the flexible error handling approach from\n"
"the last section. While not necessarily less verbose than\n"
"the original parser, this approach decouples the handling\n"
"of errors and printing of error messages from the rest\n"
"of the application: Functions with a possibility of failure\n"
"are reusable in different contexts, as are the pretty\n"
"printers we use for the error messages.\n"
msgstr "为了结束本章，我们使用上一节中灵活的错误处理方法重新实现了 CSV 命令解析器。虽然不一定比原始解析器更冗长，但这种方法将错误处理和错误消息打印与应用程序的其余部分分离：可能失败的函数可以在不同的上下文中重用，就像我们使用的美观打印器一样错误信息。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1198
#, no-wrap
msgid ""
"First, we repeat some stuff from earlier chapters. I sneaked\n"
"in a new command for printing all values in a column:\n"
msgstr "首先，我们重复前面章节中的一些内容。我偷偷输入了一个新命令来打印列中的所有值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1199
#, no-wrap
msgid ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"data Command : (t : Table) -> Type where\n"
"  PrintSchema :  Command t\n"
"  PrintSize   :  Command t\n"
"  New         :  (newSchema : Schema) -> Command t\n"
"  Prepend     :  Row (schema t) -> Command t\n"
"  Get         :  Fin (size t) -> Command t\n"
"  Delete      :  Fin (size t) -> Command t\n"
"  Col         :  (name : String)\n"
"              -> (tpe  : ColType)\n"
"              -> (prf  : InSchema name t.schema tpe)\n"
"              -> Command t\n"
"  Quit        : Command t\n"
"\n"
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand t                 (Col _ _ _) = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"
msgstr ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"data Command : (t : Table) -> Type where\n"
"  PrintSchema :  Command t\n"
"  PrintSize   :  Command t\n"
"  New         :  (newSchema : Schema) -> Command t\n"
"  Prepend     :  Row (schema t) -> Command t\n"
"  Get         :  Fin (size t) -> Command t\n"
"  Delete      :  Fin (size t) -> Command t\n"
"  Col         :  (name : String)\n"
"              -> (tpe  : ColType)\n"
"              -> (prf  : InSchema name t.schema tpe)\n"
"              -> Command t\n"
"  Quit        : Command t\n"
"\n"
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand t                 (Col _ _ _) = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1235
#, no-wrap
msgid ""
"Next, below is the command parser reimplemented. In total,\n"
"it can fail in seven different was, at least some of which\n"
"might also be possible in other parts of a larger application.\n"
msgstr "接下来，下面是重新实现的命令解析器。总的来说，它可能在七种不同的情况下失败，至少其中一些可能在更大应用程序的其他部分中也可能出现。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1236
#, no-wrap
msgid ""
"record UnknownCommand where\n"
"  constructor MkUnknownCommand\n"
"  str : String\n"
"\n"
"%hint\n"
"unknownCommandPrint : Print UnknownCommand\n"
"unknownCommandPrint = MkPrint $ \\v => \"Unknown command: \\{v.str}\"\n"
"\n"
"record NoColName where\n"
"  constructor MkNoColName\n"
"  str : String\n"
"\n"
"%hint\n"
"noColNamePrint : Print NoColName\n"
"noColNamePrint = MkPrint $ \\v => \"Unknown column: \\{v.str}\"\n"
"\n"
"0 CmdErrs : Vect 7 Type\n"
"CmdErrs = [ InvalidColumn\n"
"          , NoColName\n"
"          , NoColType\n"
"          , NoNat\n"
"          , OutOfBounds\n"
"          , RowError\n"
"          , UnknownCommand ]\n"
"\n"
"readCommand : (t : Table) -> String -> Err CmdErrs (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow 1 (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  [\"column\", str] => case inSchema ts str of\n"
"    Just (ct ** prf) => Right $ Col str ct prf\n"
"    Nothing          => fail $ MkNoColName str\n"
"  _               => fail $ MkUnknownCommand s\n"
msgstr ""
"record UnknownCommand where\n"
"  constructor MkUnknownCommand\n"
"  str : String\n"
"\n"
"%hint\n"
"unknownCommandPrint : Print UnknownCommand\n"
"unknownCommandPrint = MkPrint $ \\v => \"Unknown command: \\{v.str}\"\n"
"\n"
"record NoColName where\n"
"  constructor MkNoColName\n"
"  str : String\n"
"\n"
"%hint\n"
"noColNamePrint : Print NoColName\n"
"noColNamePrint = MkPrint $ \\v => \"Unknown column: \\{v.str}\"\n"
"\n"
"0 CmdErrs : Vect 7 Type\n"
"CmdErrs = [ InvalidColumn\n"
"          , NoColName\n"
"          , NoColType\n"
"          , NoNat\n"
"          , OutOfBounds\n"
"          , RowError\n"
"          , UnknownCommand ]\n"
"\n"
"readCommand : (t : Table) -> String -> Err CmdErrs (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow 1 (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  [\"column\", str] => case inSchema ts str of\n"
"    Just (ct ** prf) => Right $ Col str ct prf\n"
"    Nothing          => fail $ MkNoColName str\n"
"  _               => fail $ MkUnknownCommand s\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1280
#, no-wrap
msgid ""
"Note, how we could invoke functions like `readFin` or\n"
"`readSchema` directly, because the necessary error types\n"
"are part of our list of possible errors.\n"
msgstr "请注意，我们如何直接调用像 `readFin` 或 `readSchema` 这样的函数，因为必要的错误类型是我们可能的错误列表的一部分。\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1286
#, no-wrap
msgid ""
"To conclude this sections, here is the functionality\n"
"for printing the result of a command plus the application's\n"
"main loop. Most of this is repeated from earlier chapters,\n"
"but note how we can handle all errors at once with a single\n"
"call to `print`:\n"
msgstr "总结本节，这里是打印命令结果和应用程序主循环的函数。其中大部分内容从前面的章节中重复，但请注意我们如何通过一次调用 `print` 来一次处理所有错误：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1287
#, no-wrap
msgid ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (s : Schema) -> Row s -> String\n"
"encodeRow s = concat . intersperse \",\" . go s\n"
"  where go : (s' : Schema) -> Row s' -> Vect (length s') String\n"
"        go []        []        = []\n"
"        go (MkColumn _ c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"encodeCol :  (name : String)\n"
"          -> (c    : ColType)\n"
"          -> InSchema name s c\n"
"          => Vect n (Row s)\n"
"          -> String\n"
"encodeCol name c = unlines . toList . map (\\r => encodeField c $ getAt name r)\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema   = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize     = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)      = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r)   = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)    = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit          = \"Goodbye.\"\n"
"result t (Col n c prf) = \"Column \\{n}:\\n\\{encodeCol n c t.rows}\"\n"
"result t (Get x)       =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (print err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"
msgstr ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (s : Schema) -> Row s -> String\n"
"encodeRow s = concat . intersperse \",\" . go s\n"
"  where go : (s' : Schema) -> Row s' -> Vect (length s') String\n"
"        go []        []        = []\n"
"        go (MkColumn _ c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"encodeCol :  (name : String)\n"
"          -> (c    : ColType)\n"
"          -> InSchema name s c\n"
"          => Vect n (Row s)\n"
"          -> String\n"
"encodeCol name c = unlines . toList . map (\\r => encodeField c $ getAt name r)\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema   = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize     = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)      = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r)   = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)    = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit          = \"Goodbye.\"\n"
"result t (Col n c prf) = \"Column \\{n}:\\n\\{encodeCol n c t.rows}\"\n"
"result t (Get x)       =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (print err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1336
#, no-wrap
msgid "Here is an example REPL session:\n"
msgstr "这是一个示例 REPL 会话：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:1337
#, no-wrap
msgid ""
"Tutorial.Predicates> :exec main\n"
"Enter a command: new name:Str,age:Int64,salary:Float\n"
"Not a column type: Int64\n"
"Enter a command: new name:Str,age:I64,salary:Float\n"
"Created table. Schema: name:Str,age:I64,salary:Float\n"
"Enter a command: add John Doe,44,3500\n"
"Row prepended: \"John Doe\",44,3500.0\n"
"Enter a command: add Jane Doe,50,4000\n"
"Row prepended: \"Jane Doe\",50,4000.0\n"
"Enter a command: get 1\n"
"Row 1: \"Jane Doe\",50,4000.0\n"
"Enter a command: column salary\n"
"Column salary:\n"
"4000.0\n"
"3500.0\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"
msgstr ""
"Tutorial.Predicates> :exec main\n"
"Enter a command: new name:Str,age:Int64,salary:Float\n"
"Not a column type: Int64\n"
"Enter a command: new name:Str,age:I64,salary:Float\n"
"Created table. Schema: name:Str,age:I64,salary:Float\n"
"Enter a command: add John Doe,44,3500\n"
"Row prepended: \"John Doe\",44,3500.0\n"
"Enter a command: add Jane Doe,50,4000\n"
"Row prepended: \"Jane Doe\",50,4000.0\n"
"Enter a command: get 1\n"
"Row 1: \"Jane Doe\",50,4000.0\n"
"Enter a command: column salary\n"
"Column salary:\n"
"4000.0\n"
"3500.0\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1367
#, no-wrap
msgid ""
"Predicates allow us to describe contracts between types\n"
"and to refine the values we accept as valid function arguments.\n"
"They allow us to make a function safe and convenient to use\n"
"at runtime *and* compile time by using them as auto implicit\n"
"arguments, which Idris should try to construct on its own if\n"
"it has enough information about the structure of a function's\n"
"arguments.\n"
msgstr "谓词允许我们描述类型之间的契约并细化我们接受为有效函数参数的值。它们允许我们通过将它们用作自动隐式参数来使函数在运行时 *和* 编译时安全且方便地使用 ，如果Idris有足够的关于函数参数结构的信息，Idris 应该尝试自己构造它。\n"

#. type: Title #
#: ../src/Tutorial/Prim.md:1
#, no-wrap
msgid "Primitives"
msgstr "原语"

#. type: Plain text
#: ../src/Tutorial/Prim.md:7
#, no-wrap
msgid ""
"In the topics we covered so far, we hardly ever talked about primitive\n"
"types in Idris. They where around and we used them in some computations,\n"
"but I never really explained how they work and where they come from,\n"
"nor did I show in detail what we can and can't do with them.\n"
msgstr "到目前为止，在我们讨论的主题中，我们几乎从未讨论过 Idris 中的原始类型。它们在哪里，我们在一些计算中使用它们，但我从来没有真正解释过它们是如何工作的以及它们来自哪里，我也没有详细说明我们可以用它们做什么和不能做什么。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:8
#, no-wrap
msgid ""
"module Tutorial.Prim\n"
"\n"
"import Data.Bits\n"
"import Data.String\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Prim\n"
"\n"
"import Data.Bits\n"
"import Data.String\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Prim.md:17
#, no-wrap
msgid "How Primitives are Implemented"
msgstr "原语是如何实现的"

#. type: Title ###
#: ../src/Tutorial/Prim.md:19
#, no-wrap
msgid "A Short Note on Backends"
msgstr "关于后端的简短说明"

#. type: Plain text
#: ../src/Tutorial/Prim.md:30
#, no-wrap
msgid ""
"According to [Wikipedia](https://en.wikipedia.org/wiki/Compiler),\n"
"a compiler is \"a computer program that translates computer code\n"
"written in one programming language (the source language) into\n"
"another language (the target language)\". The Idris compiler is\n"
"exactly that: A program translating programs written in Idris\n"
"into programs written in Chez Scheme. This scheme code is then\n"
"parsed and interpreted by a Chez Scheme interpreter, which must\n"
"be installed on the computers we use to run compiled Idris\n"
"programs.\n"
msgstr "根据 [Wikipedia](https://en.wikipedia.org/wiki/Compiler)，编译器是“一种计算机程序，它将以一种编程语言（源语言）编写的计算机代码翻译成另一种语言（目标语言） ”。 Idris 编译器就是这样：一个将 Idris 编写的程序翻译成 Chez Scheme 编写的程序的程序。然后这个 Scheme 代码由 Chez Scheme 解释器解析和解释，它必须安装在我们用来运行已编译 Idris 程序的计算机上。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:37
#, no-wrap
msgid ""
"But that's only part of the story. Idris 2 was from the beginning\n"
"designed to support different code generators (so called *backends*),\n"
"which allows us to write Idris code to target different platforms,\n"
"and your Idris installation comes with several additional\n"
"backends available. You can specify the backend to use with the `--cg` command\n"
"line argument (`cg` stands for *code generator*). For instance:\n"
msgstr "但这只是故事的一部分。 Idris 2 从一开始就设计为支持不同的代码生成器（所谓的 *后端*），这允许我们编写 Idris 代码以针对不同的平台，并且您的 Idris 安装附带了几个可用的附加后端。您可以指定要与 `--cg` 命令行参数一起使用的后端（`cg` 代表 *代码生成器*）。例如：\n"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Prim.md:38
#, no-wrap
msgid "idris2 --cg racket\n"
msgstr "idris2 --cg racket\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:45
#, no-wrap
msgid ""
"Here is a non-comprehensive list of the backends available with a\n"
"standard Idris installation (the name to be used in the command line\n"
"argument is given in parentheses):\n"
msgstr "以下是标准 Idris 安装可用的后端的非全面列表（在括号中给出命令行参数中使用的名称）：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
#, no-wrap
msgid ""
"Racket Scheme (`racket`): This is a different flavour of the scheme\n"
"programming language, which can be useful to use when Chez Scheme\n"
"is not available on your operating system.\n"
msgstr ""
"Racket Scheme (`racket`)：这是 Scheme 编程语言的另一种方言，当 Chez Scheme "
"在您的操作系统上不可用时，它很有用。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
#, no-wrap
msgid "Node.js (`node`): This converts an Idris program to JavaScript.\n"
msgstr "Node.js (`node`)：这会将 Idris 程序转换为 JavaScript。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
#, no-wrap
msgid ""
"Browser (`javascript`): Another JavaScript backend which allows you to\n"
"write web applications which run in the browser in Idris.\n"
msgstr "浏览器 (`javascript`)：另一个 JavaScript 后端，允许您编写在 Idris "
"的浏览器中运行的 Web 应用程序。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
#, no-wrap
msgid ""
"RefC (`refc`): A backend compiling Idris to C code, which is then\n"
"further compiled by a C compiler.\n"
msgstr "RefC (`refc`)：后端将 Idris 编译为 C 代码，然后由 C 编译器进一步编译。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:57
#, no-wrap
msgid ""
"I plan to at least cover the JavaScript backends in some more detail\n"
"in another part of this Idris guide, as I use them pretty often myself.\n"
msgstr "我计划至少在本 Idris 指南的另一部分中更详细地介绍 JavaScript 后端，因为我自己也经常使用它们。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:62
#, no-wrap
msgid ""
"There are also several external backends not officially supported by\n"
"the Idris project, amongst which are backends for compiling Idris code\n"
"to Java and Python. You can find a list of external backends on\n"
"the [Idris Wiki](https://github.com/idris-lang/Idris2/wiki/1-%5BLanguage%5D-External-backends).\n"
msgstr "Idris 项目还没有正式支持几个外部后端，其中包括将 Idris 代码编译为 Java 和 Python 的后端。您可以在 [Idris Wiki](https://github.com/idris-lang/Idris2/wiki/1-%5BLanguage%5D-External-backends) 上找到外部后端列表。\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:63
#, no-wrap
msgid "The Idris Primitives"
msgstr "Idris 原语"

#. type: Plain text
#: ../src/Tutorial/Prim.md:69
#, no-wrap
msgid ""
"A *primitive data type* is a type that is built into the Idris compiler\n"
"together with a set of *primitive functions*, which are used to perform\n"
"calculations on the primitives. You will therefore not find a definition\n"
"of a primitive type or function in the source code of the *Prelude*.\n"
msgstr "*原语数据类型* 是与一组 *原语函数* 一起内置到 Idris 编译器中的类型，这些函数用于对原始数据执行计算。因此，您不会在 *Prelude* 的源代码中找到原语类型或函数的定义。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:71
#, no-wrap
msgid "Here is again the list of primitive types in Idris:\n"
msgstr "这是 Idris 中的原语类型列表：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid "Signed, fixed precision integers:\n"
msgstr "有符号、固定精度的整数：\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid "`Int8`: Integer in the range [-128,127]\n"
msgstr "`Int8`：[-128,127] 范围内的整数\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid "`Int16`: Integer in the range [-32768,32767]\n"
msgstr "`Int16`：[-32768,32767] 范围内的整数\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid "`Int32`: Integer in the range [-2147483648,2147483647]\n"
msgstr "`Int32`：[-2147483648,2147483647] 范围内的整数\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid "`Int64`: Integer in the range [-9223372036854775808,9223372036854775807]\n"
msgstr "`Int64`：[-9223372036854775808,9223372036854775807] 范围内的整数\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid "Unsigned, fixed precision integers:\n"
msgstr "无符号整数\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid "`Bits8`: Integer in the range [0,255]\n"
msgstr "`Bits8`：[0,255] 范围内的整数\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid "`Bits16`: Integer in the range [0,65535]\n"
msgstr "`Bits16`：[0,65535] 范围内的整数\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid "`Bits32`: Integer in the range [0,4294967295]\n"
msgstr "`Bits32`：[0,4294967295] 范围内的整数\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid "`Bits64`: Integer in the range [0,18446744073709551615]\n"
msgstr "`Bits64`：[0,18446744073709551615] 范围内的整数\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid "`Integer`: A signed, arbitrary precision integer.\n"
msgstr "`Integer`：带符号的任意精度整数。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid "`Double`: A double precision (64 bit) floating point number.\n"
msgstr "`Double`：双精度（64 位）浮点数。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid "`Char`: A unicode character.\n"
msgstr "`Char`：Unicode 字符。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid "`String`: A sequence of unicode characters.\n"
msgstr "`String`：Unicode 字符序列。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid ""
"`%World`: A symbolic representation of the current world state.\n"
"We learned about this when I showed you how `IO` is implemented.\n"
"Most of the time, you will not handle values of this type in your own\n"
"code.\n"
msgstr ""
"`%World`：当前世界状态的符号表示。\n"
"当我向您展示如何实现 `IO` 时，我们了解了这一点。\n"
"大多数时候，您不会在自己的代码中处理这种类型的值。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid ""
"* `Int`: This one is special. It is a fixed precision, signed integer,\n"
"   but the bit size is somewhat dependent on the backend and\n"
"   (maybe) platform we use.\n"
"   For instance, if you use the default Chez Scheme backend, `Int` is\n"
"   a 64 bit signed integer, while on the JavaScript backends it is a\n"
"   32 bit signed integer for performance reasons. Therefore, `Int` comes\n"
"   with very few guarantees, and you should use one of the well\n"
"   specified integer types listed above whenever possible.\n"
msgstr ""
"* `Int`：这个比较特殊。它是一个固定精度的有符号整数，\n"
"   但位大小在某种程度上取决于后端和\n"
"   （也许）我们使用的平台。\n"
"   例如，如果您使用默认的 Chez Scheme 后端，则 `Int` 是\n"
"   一个 64 位有符号整数，而在 JavaScript 后端它是一个\n"
"   出于性能原因，32 位有符号整数。所以，`Int` 带有很少的保证，\n"
"   你应该尽可能使用上面列出的整数类型的其中一个。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:104
#, no-wrap
msgid ""
"It can be instructive to learn, where in the compiler's source\n"
"code the primitive types and functions are defined. This source\n"
"code can be found in folder `src` of the [Idris project](https://github.com/idris-lang/Idris2)\n"
"and the primitive types are the constant constructors of\n"
"data type `Core.TT.Constant`.\n"
msgstr "学习在编译器源代码中定义原语类型和函数的位置可能具有指导意义。此源代码可以在 [Idris 项目](https://github.com/idris-lang/Idris2) 的文件夹 `src` 中找到，原语类型是数据类型 `Core.TT.Constant` 的常量构造函数。\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:105
#, no-wrap
msgid "Primitive Functions"
msgstr "原语函数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:112
#, no-wrap
msgid ""
"All calculations operating on primitives are based on two\n"
"kinds of primitive functions: The ones built into the compiler\n"
"(see below) and the ones defined by programmers via the\n"
"foreign function interface (FFI), about which I'll talk in\n"
"another chapter.\n"
msgstr "所有对原语进行的计算都基于两种原语函数：编译器内置的（见下文）和程序员通过外部函数接口（FFI）定义的函数，我将在另一章中讨论。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:119
#, no-wrap
msgid ""
"Built-in primitive functions are functions known to the compiler\n"
"the definition of which can not be found in the *Prelude*. They\n"
"define the core functionality available for the primitive\n"
"types. Typically, you do not invoke these directly (although\n"
"it is perfectly fine to do so in most cases) but via functions\n"
"and interfaces exported by the *Prelude* or the *base* library.\n"
msgstr "内置原语函数是编译器已知的函数，其定义在 *Prelude* 中找不到。它们定义了可用于原语类型的核心函数。通常，您不会直接调用它们（尽管在大多数情况下这样做非常好），而是通过 *Prelude* 或 *base* 库导出的函数和接口。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:123
#, no-wrap
msgid ""
"For instance, the primitive function for adding two eight bit\n"
"unsigned integers is `prim__add_Bits8`. You can inspect its\n"
"type and behavior at the REPL:\n"
msgstr "例如，将两个八位无符号整数相加的原语函数是 `prim__add_Bits8`。您可以在 REPL 中检查其类型和行为：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:124
#, no-wrap
msgid ""
"Tutorial.Prim> :t prim__add_Bits8\n"
"prim__add_Bits8 : Bits8 -> Bits8 -> Bits8\n"
"Tutorial.Prim> prim__add_Bits8 12 100\n"
"112\n"
msgstr ""
"Tutorial.Prim> :t prim__add_Bits8\n"
"prim__add_Bits8 : Bits8 -> Bits8 -> Bits8\n"
"Tutorial.Prim> prim__add_Bits8 12 100\n"
"112\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:148
#, no-wrap
msgid ""
"If you look at the source code implementing interface `Num`\n"
"for `Bits8`, you will see that the plus operator just invokes\n"
"`prim__add_Bits8` internally. The same goes for most of the other\n"
"functions in primitive interface implementations.\n"
"For instance, every primitive type with the exception of\n"
"`%World` comes with primitive comparison functions.\n"
"For `Bits8`, these are:\n"
"`prim__eq_Bits8`, `prim__gt_Bits8`, `prim__lt_Bits8`,\n"
"`prim__gte_Bits8`, and `prim__lte_Bits8`.\n"
"Note, that these functions do not return a `Bool` (which\n"
"is *not* a primitive type in Idris), but an `Int`. They are\n"
"therefore not as safe or convenient to use as the corresponding\n"
"operator implementations form interfaces `Eq` and `Comp`.\n"
"On the other hand, they do not go via a conversion to `Bool`\n"
"and might therefore perform slightly better in performance\n"
"critical code (which you can only identify after some\n"
"serious profiling).\n"
msgstr "如果查看 `Bits8` 的实现接口 `Num` 的源代码，您会看到加号运算符只是在内部调用 `prim__add_Bits8`。原语接口实现中的大多数其他函数也是如此。例如，除了 `%World` 之外的每个原语类型都带有原语比较函数。对于 `Bits8`，它们是：`prim__eq_Bits8`、`prim__gt_Bits8`、`prim__lt_Bits8`、`prim__gte_Bits8` 和 `prim__lte_Bits8`。请注意，这些函数不返回 `Bool`（在 Idris 中 *不是* 原语类型），而是 `Int`。因此，它们不像接口 `Eq` 和 `Comp` 中的相应运算符实现那样安全或方便。另一方面，它们不会通过转换为 `Bool` 并且因此在性能关键代码中的性能可能会稍好一些（您只能在经过一些认真的分析后才能识别）。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:152
#, no-wrap
msgid ""
"As with primitive types, the primitive functions are listed as\n"
"constructors in a data type (`Core.TT.PrimFn`) in the compiler\n"
"sources. We will look at most of these in the following sections.\n"
msgstr "与原语类型一样，原语函数在编译器源代码中被列为数据类型 (`Core.TT.PrimFn`) 中的构造函数。我们将在以下部分中介绍其中的大部分内容。\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:153
#, no-wrap
msgid "Consequences of being Primitive"
msgstr "原语的重要性"

#. type: Plain text
#: ../src/Tutorial/Prim.md:163
#, no-wrap
msgid ""
"Primitive functions and types are opaque to the compiler\n"
"in most regards: They have to be defined and implemented by each\n"
"backend individually, therefore, the compiler knows nothing about the inner\n"
"structure of a primitive value nor about the inner workings\n"
"of primitive functions. For instance, in the following recursive\n"
"function, *we* know that the argument in the recursive call\n"
"must be converging towards the base case (unless there is a bug\n"
"in the backend we use), but the compiler does not:\n"
msgstr "在大多数情况下，原语函数和类型对编译器是不透明的：它们必须由每个后端单独定义和实现，因此，编译器对原语值的内部结构和原语函数的内部工作一无所知。例如，在下面的递归函数中，*我们* 知道递归调用中的参数必须收敛到基本情况（除非我们使用的后端存在错误），但编译器不知道：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:164
#, no-wrap
msgid ""
"covering\n"
"replicateBits8' : Bits8 -> a -> List a\n"
"replicateBits8' 0 _ = []\n"
"replicateBits8' n v = v :: replicateBits8' (n - 1) v\n"
msgstr ""
"covering\n"
"replicateBits8' : Bits8 -> a -> List a\n"
"replicateBits8' 0 _ = []\n"
"replicateBits8' n v = v :: replicateBits8' (n - 1) v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:174
#, no-wrap
msgid ""
"In these cases, we either must be content with just a\n"
"*covering* function, or we use `assert_smaller` to\n"
"convince the totality checker (the preferred way):\n"
msgstr "在这些情况下，我们要么只满足于 *covering* 函数，要么使用 `assert_smaller` 来说服整体检查器（首选方式）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:175
#, no-wrap
msgid ""
"replicateBits8 : Bits8 -> a -> List a\n"
"replicateBits8 0 _ = []\n"
"replicateBits8 n v = v :: replicateBits8 (assert_smaller n $ n - 1) v\n"
msgstr ""
"replicateBits8 : Bits8 -> a -> List a\n"
"replicateBits8 0 _ = []\n"
"replicateBits8 n v = v :: replicateBits8 (assert_smaller n $ n - 1) v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:184
#, no-wrap
msgid ""
"I have shown you the risks of using `assert_smaller` before, so we\n"
"must be extra careful in making sure that the new function argument\n"
"is indeed smaller with relation to the base case.\n"
msgstr "我之前已经向您展示了使用 `assert_smaller` 的风险，因此我们必须格外小心，以确保新函数参数相对于基本情况确实更小。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:189
#, no-wrap
msgid ""
"While Idris knows nothing about the internal workings of primitives\n"
"and related functions, most of these functions still reduce during\n"
"evaluation when fed with values known at compile time. For instance,\n"
"we can trivially proof that for `Bits8` the following equation holds:\n"
msgstr "虽然 Idris 对原语和相关函数的内部工作原理一无所知，但当输入编译时已知的值时，这些函数中的大多数在求值期间仍然会减少。例如，我们可以简单地证明对于 `Bits8`，以下等式成立：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:190
#, no-wrap
msgid ""
"zeroBits8 : the Bits8 0 = 255 + 1\n"
"zeroBits8 = Refl\n"
msgstr ""
"zeroBits8 : the Bits8 0 = 255 + 1\n"
"zeroBits8 = Refl\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:200
#, no-wrap
msgid ""
"Having no clue about the internal structure of a primitive\n"
"nor about the implementations of primitive functions,\n"
"Idris can't help us proofing any *general* properties of such functions\n"
"and values. Here is an example to demonstrate this. Assume we'd\n"
"like to wrap a list in a data type indexed by the list's length:\n"
msgstr "由于不了解原语的内部结构或原语函数的实现，Idris 无法帮助我们证明此类函数和值的任何 *泛型* 属性。这是一个例子来证明这一点。假设我们想将一个列表包装在一个由列表长度索引的数据类型中：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:201
#, no-wrap
msgid ""
"data LenList : (n : Nat) -> Type -> Type where\n"
"  MkLenList : (as : List a) -> LenList (length as) a\n"
msgstr ""
"data LenList : (n : Nat) -> Type -> Type where\n"
"  MkLenList : (as : List a) -> LenList (length as) a\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:209
#, no-wrap
msgid ""
"When we concatenate two `LenList`s, the length indices\n"
"should be added. That's how list concatenation affects the\n"
"length of lists. We can safely teach Idris that this is true:\n"
msgstr "当我们连接两个 `LenList` 时，应该累加长度索引。这就是列表连接影响列表长度的方式。我们可以安全地告诉伊德里斯这是真的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:210
#, no-wrap
msgid ""
"0 concatLen : (xs,ys : List a) -> length xs + length ys = length (xs ++ ys)\n"
"concatLen []        ys = Refl\n"
"concatLen (x :: xs) ys = cong S $ concatLen xs ys\n"
msgstr ""
"0 concatLen : (xs,ys : List a) -> length xs + length ys = length (xs ++ ys)\n"
"concatLen []        ys = Refl\n"
"concatLen (x :: xs) ys = cong S $ concatLen xs ys\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:217
#, no-wrap
msgid "With the above lemma, we can implement concatenation of `LenList`:\n"
msgstr "通过上述引理，我们可以实现 `LenList` 的串联：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:218
#, no-wrap
msgid ""
"(++) : LenList m a -> LenList n a -> LenList (m + n) a\n"
"MkLenList xs ++ MkLenList ys =\n"
"  rewrite concatLen xs ys in MkLenList (xs ++ ys)\n"
msgstr ""
"(++) : LenList m a -> LenList n a -> LenList (m + n) a\n"
"MkLenList xs ++ MkLenList ys =\n"
"  rewrite concatLen xs ys in MkLenList (xs ++ ys)\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:231
#, no-wrap
msgid ""
"The same is not possible for strings. There are applications where\n"
"pairing a string with its length would be useful (for instance, if we\n"
"wanted to make sure that strings are getting strictly shorter\n"
"during parsing and will therefore eventually be wholly\n"
"consumed), but Idris cannot help us getting these things right.\n"
"There is no way to implement and thus proof the following\n"
"lemma in a safe way:\n"
msgstr "字符串也是不可能的。在某些应用程序中，将字符串与其长度配对会很有用（例如，如果我们想确保字符串在解析过程中严格缩短，因此最终会被完全消耗掉），但 Idris 无法帮助我们正确处理这些事情。没有办法以安全的方式实现并证明以下引理：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:232
#, no-wrap
msgid "0 concatLenStr : (a,b : String) -> length a + length b = length (a ++ b)\n"
msgstr "0 concatLenStr : (a,b : String) -> length a + length b = length (a ++ b)\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:237
#, no-wrap
msgid "<!-- markdownlint-disable MD026 -->\n"
msgstr "<!-- markdownlint-disable MD026 -->\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:237
#, no-wrap
msgid "Believe Me!"
msgstr "相信我！"

#. type: Plain text
#: ../src/Tutorial/Prim.md:239
#, no-wrap
msgid "<!-- markdownlint-enable MD026 -->\n"
msgstr "<!-- markdownlint-enable MD026 -->\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:245
#, no-wrap
msgid ""
"In order to implement `concatLenStr`, we have to abandon all\n"
"safety and use the ten ton wrecking ball of type coercion:\n"
"`believe_me`. This primitive function allows us to freely\n"
"coerce a value of any type into a value of any other type.\n"
"Needless to say, this is only safe if we *really* know what we are doing:\n"
msgstr "为了实现 `concatLenStr`，我们必须放弃所有安全，使用强制类型的十吨破坏球：`believe_me`。这个原语函数允许我们自由地将任何类型的值强制转换为任何其他类型的值。不用说，只有当我们 *真的* 知道我们在做什么时，这才是安全的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:246
#, no-wrap
msgid "concatLenStr a b = believe_me $ Refl {x = length a + length b}\n"
msgstr "concatLenStr a b = believe_me $ Refl {x = length a + length b}\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:257
#, no-wrap
msgid ""
"The explicit assignment of variable `x` in `{x = length a + length b}`\n"
"is necessary, because otherwise Idris will complain about an *unsolved\n"
"hole*: It can't infer the type of parameter `x` in the `Refl`\n"
"constructor. We could assign any type to `x` here, because we\n"
"are passing the result to `believe_me` anyway, but I consider it\n"
"to be good practice to assign one of the two sides of the equality\n"
"to make our intention clear.\n"
msgstr "在 `x = length a + length b}` 中显式分配变量 `x` 是必要的，否则 Idris 会抱怨 *未解决的孔*：它可以在 `Refl` 构造函数中推断参数 `x` 的类型。我们可以在这里为 `x` 分配任何类型，因为无论如何我们都将结果传递给 `believe_me`，但我认为将等式的两侧之一分配给明确我们的意图。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:262
#, no-wrap
msgid ""
"The higher the complexity of a primitive type, the riskier\n"
"it is to assume even the most basic properties for it to hold.\n"
"For instance, we might act under the delusion that floating\n"
"point addition is associative:\n"
msgstr "原始类型的复杂性越高，假设它拥有最基本的属性的风险就越大。例如，我们可能会误以为浮点加法具有结合性：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:263
#, no-wrap
msgid ""
"0 doubleAddAssoc : (x,y,z : Double) -> x + (y + z) = (x + y) + z\n"
"doubleAddAssoc x y z = believe_me $ Refl {x = x + (y + z)}\n"
msgstr ""
"0 doubleAddAssoc : (x,y,z : Double) -> x + (y + z) = (x + y) + z\n"
"doubleAddAssoc x y z = believe_me $ Refl {x = x + (y + z)}\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:270
#, no-wrap
msgid ""
"Well, guess what: That's a lie. And lies lead us straight\n"
"into the `Void`:\n"
msgstr "好吧，你猜怎么着：那是个谎言。谎言将我们直接带入 `Void`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:271
#, no-wrap
msgid ""
"Tiny : Double\n"
"Tiny = 0.0000000000000001\n"
"\n"
"One : Double\n"
"One = 1.0\n"
"\n"
"wrong : (0 _ : 1.0000000000000002 = 1.0) -> Void\n"
"wrong Refl impossible\n"
"\n"
"boom : Void\n"
"boom = wrong (doubleAddAssoc One Tiny Tiny)\n"
msgstr ""
"Tiny : Double\n"
"Tiny = 0.0000000000000001\n"
"\n"
"One : Double\n"
"One = 1.0\n"
"\n"
"wrong : (0 _ : 1.0000000000000002 = 1.0) -> Void\n"
"wrong Refl impossible\n"
"\n"
"boom : Void\n"
"boom = wrong (doubleAddAssoc One Tiny Tiny)\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:291
#, no-wrap
msgid ""
"Here's what happens in the code above: The call to `doubleAddAssoc`\n"
"returns a proof that `One + (Tiny + Tiny)` is equal to\n"
"`(One + Tiny) + Tiny`. But `One + (Tiny + Tiny)` equals\n"
"`1.0000000000000002`, while `(One + Tiny) + Tiny` equals `1.0`.\n"
"We can therefore pass our (wrong) proof to `wrong`, because it\n"
"is of the correct type, and from this follows a proof of `Void`.\n"
msgstr "下面是上面代码中发生的情况：对 `doubleAddAssoc` 的调用返回一个证明 `One + (Tiny + Tiny)` 等于 `(One + Tiny) + Tiny`。但是 `One + (Tiny + Tiny)` 等于 `1.0000000000000002`，而 `(One + Tiny) + Tiny` 等于 `1.0`。因此，我们可以将我们的（错误的）证明传递给 `wrong`，因为它是正确的类型，并由此得出 `Void` 的证明。\n"

#. type: Title ##
#: ../src/Tutorial/Prim.md:292
#, no-wrap
msgid "Working with Strings"
msgstr "使用字符串"

#. type: Plain text
#: ../src/Tutorial/Prim.md:297
#, no-wrap
msgid ""
"Module `Data.String` in *base* offers a rich set of functions\n"
"for working with strings. All these are based on the following\n"
"primitive operations built into the compiler:\n"
msgstr "*base* 中的模块 `Data.String` 提供了一组丰富的函数来处理字符串。所有这些都基于编译器内置的以下原语操作：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, no-wrap
msgid "`prim__strLength`: Returns the length of a string.\n"
msgstr "`prim__strLength`：返回字符串的长度。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, no-wrap
msgid "`prim__strHead`: Extracts the first character from a string.\n"
msgstr "`prim__strHead`：从字符串中提取第一个字符。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, no-wrap
msgid "`prim__strTail`: Removes the first character from a string.\n"
msgstr "`prim__strTail`：从字符串中删除第一个字符。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, no-wrap
msgid "`prim__strCons`: Prepends a character to a string.\n"
msgstr "`prim__strCons`：在字符串前面添加一个字符。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, no-wrap
msgid "`prim__strAppend`: Appends two strings.\n"
msgstr "`prim__strAppend`：追加两个字符串。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, no-wrap
msgid "`prim__strIndex`: Extracts a character at the given position from a string.\n"
msgstr "`prim__strIndex`：从字符串中提取给定位置的字符。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, no-wrap
msgid "`prim__strSubstr`: Extracts the substring between the given positions.\n"
msgstr "`prim__strSubstr`：提取给定位置之间的子字符串。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:311
#, no-wrap
msgid ""
"Needless to say, not all of these functions are total. Therefore, Idris\n"
"must make sure that invalid calls do not reduce during compile time, as\n"
"otherwise the compiler would crash. If, however we force the evaluation\n"
"of a partial primitive function by compiling and running the corresponding\n"
"program, this program will crash with an error:\n"
msgstr "不用说，并非所有这些功能都是完整的。因此，Idris 必须确保在编译期间不会减少无效调用，否则编译器会崩溃。但是，如果我们通过编译和运行相应的程序来强制对部分原语函数求值，则该程序将崩溃并出现错误：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:312
#, no-wrap
msgid ""
"Tutorial.Prim> prim__strTail \"\"\n"
"prim__strTail \"\"\n"
"Tutorial.Prim> :exec putStrLn (prim__strTail \"\")\n"
"Exception in substring: 1 and 0 are not valid start/end indices for \"\"\n"
msgstr ""
"Tutorial.Prim> prim__strTail \"\"\n"
"prim__strTail \"\"\n"
"Tutorial.Prim> :exec putStrLn (prim__strTail \"\")\n"
"Exception in substring: 1 and 0 are not valid start/end indices for \"\"\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:323
#, no-wrap
msgid ""
"Note, how `prim__strTail \"\"` is not reduced at the REPL and how the\n"
"same expression leads to a runtime exception if we compile and\n"
"execute the program. Valid calls to `prim__strTail` are reduced\n"
"just fine, however:\n"
msgstr "请注意，`prim__strTail \"\"` 在 REPL 中没有减少，以及如果我们编译和执行程序，相同的表达式如何导致运行时异常。对 `prim__strTail` 的有效调用减少得很好，但是：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:324
#, no-wrap
msgid ""
"tailExample : prim__strTail \"foo\" = \"oo\"\n"
"tailExample = Refl\n"
msgstr ""
"tailExample : prim__strTail \"foo\" = \"oo\"\n"
"tailExample = Refl\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:329
#, no-wrap
msgid "Pack and Unpack"
msgstr "打包和解包"

#. type: Plain text
#: ../src/Tutorial/Prim.md:339
#, no-wrap
msgid ""
"Two of the most important functions for working with strings\n"
"are `unpack` and `pack`, which convert a string to a list\n"
"of characters and vice versa. This allows us to conveniently\n"
"implement many string operations by iterating or folding\n"
"over the list of characters instead. This might not always\n"
"be the most efficient thing to do, but unless you plan to\n"
"handle very large amounts of text, they work and perform\n"
"reasonably well.\n"
msgstr "处理字符串的两个最重要的函数是 `unpack` 和 `pack`，它们将字符串转换为字符列表，以及反过来。这允许我们通过迭代或折叠字符列表来方便地实现许多字符串操作。这可能并不总是最有效的做法，但除非您计划处理大量文本，否则它们的工作和性能相当不错。\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:340
#, no-wrap
msgid "String Interpolation"
msgstr "字符串插值"

#. type: Plain text
#: ../src/Tutorial/Prim.md:345
#, no-wrap
msgid ""
"Idris allows us to include arbitrary string expressions in\n"
"a string literal by wrapping them in curly braces, the first\n"
"of which has to be escaped with a backslash. For instance:\n"
msgstr "Idris 允许我们将任意字符串表达式包含在字符串文字中，方法是将它们包裹在花括号中，第一个必须用反斜杠转义。例如：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:346
#, no-wrap
msgid ""
"interpEx1 : Bits64 -> Bits64 -> String\n"
"interpEx1 x y = \"\\{show x} + \\{show y} = \\{show $ x + y}\"\n"
msgstr ""
"interpEx1 : Bits64 -> Bits64 -> String\n"
"interpEx1 x y = \"\\{show x} + \\{show y} = \\{show $ x + y}\"\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:356
#, no-wrap
msgid ""
"This is a very convenient way to assemble complex strings\n"
"from values of different types.\n"
"In addition, there is interface `Interpolation`, which\n"
"allows us to use values in interpolated strings without\n"
"having to convert them to strings first:\n"
msgstr "这是从不同类型的值组装复杂字符串的一种非常方便的方法。此外，还有接口`Interpolation`，它允许我们在插值字符串中使用值，而不必先将它们转换为字符串：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:357
#, no-wrap
msgid ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"Formula : Type\n"
"Formula = List (Element,Nat)\n"
"\n"
"Interpolation Element where\n"
"  interpolate H  = \"H\"\n"
"  interpolate He = \"He\"\n"
"  interpolate C  = \"C\"\n"
"  interpolate N  = \"N\"\n"
"  interpolate O  = \"O\"\n"
"  interpolate F  = \"F\"\n"
"  interpolate Ne = \"Ne\"\n"
"\n"
"Interpolation (Element,Nat) where\n"
"  interpolate (_, 0) = \"\"\n"
"  interpolate (x, 1) = \"\\{x}\"\n"
"  interpolate (x, k) = \"\\{x}\\{show k}\"\n"
"\n"
"Interpolation Formula where\n"
"  interpolate = foldMap interpolate\n"
"\n"
"ethanol : String\n"
"ethanol = \"The formulat of ethanol is: \\{[(C,2),(H,6),(O, the Nat 1)]}\"\n"
msgstr ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"Formula : Type\n"
"Formula = List (Element,Nat)\n"
"\n"
"Interpolation Element where\n"
"  interpolate H  = \"H\"\n"
"  interpolate He = \"He\"\n"
"  interpolate C  = \"C\"\n"
"  interpolate N  = \"N\"\n"
"  interpolate O  = \"O\"\n"
"  interpolate F  = \"F\"\n"
"  interpolate Ne = \"Ne\"\n"
"\n"
"Interpolation (Element,Nat) where\n"
"  interpolate (_, 0) = \"\"\n"
"  interpolate (x, 1) = \"\\{x}\"\n"
"  interpolate (x, k) = \"\\{x}\\{show k}\"\n"
"\n"
"Interpolation Formula where\n"
"  interpolate = foldMap interpolate\n"
"\n"
"ethanol : String\n"
"ethanol = \"The formulat of ethanol is: \\{[(C,2),(H,6),(O, the Nat 1)]}\"\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:384
#, no-wrap
msgid "Raw and Multiline String Literals"
msgstr "原始和多行字符串字面量"

#. type: Plain text
#: ../src/Tutorial/Prim.md:388
#, no-wrap
msgid ""
"In string literals, we have to escape certain characters\n"
"like quotes, backslashes or new line characters. For instance:\n"
msgstr "在字符串文字中，我们必须转义某些字符，如引号、反斜杠或换行符。例如：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:389
#, no-wrap
msgid ""
"escapeExample : String\n"
"escapeExample = \"A quote: \\\". \\nThis is on a new line.\\nA backslash: \\\\\"\n"
msgstr ""
"escapeExample : String\n"
"escapeExample = \"A quote: \\\". \\nThis is on a new line.\\nA backslash: \\\\\"\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:398
#, no-wrap
msgid ""
"Idris allows us to enter raw string literals, where there\n"
"is no need to escape quotes and backslashes, by pre- and\n"
"postfixing the wrapping quote characters with the same number\n"
"of hash characters. For instance:\n"
msgstr "Idris 允许我们输入原始字符串文字，无需转义引号和反斜杠，方法是在引号前后使用相同数量的井号进行包裹。例如：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:399
#, no-wrap
msgid ""
"rawExample : String\n"
"rawExample = #\"A quote: \". A blackslash: \\\"#\n"
"\n"
"rawExample2 : String\n"
"rawExample2 = ##\"A quote: \". A blackslash: \\\"##\n"
msgstr ""
"rawExample : String\n"
"rawExample = #\"A quote: \". A blackslash: \\\"#\n"
"\n"
"rawExample2 : String\n"
"rawExample2 = ##\"A quote: \". A blackslash: \\\"##\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:411
#, no-wrap
msgid ""
"With raw string literals, it is still possible to use string\n"
"interpolation, but the opening curly brace has to be prefixed\n"
"with a backslash and the same number of hashes as are being used\n"
"for opening and closing the string literal:\n"
msgstr "对于原始字符串字面量，仍然可以使用字符串插值，但开始的花括号必须以反斜杠为前缀，并且加上和用于打开关闭字符串字面量的相同数据的井号：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:412
#, no-wrap
msgid ""
"rawInterpolExample : String\n"
"rawInterpolExample = ##\"An interpolated \"string\": \\##{rawExample}\"##\n"
msgstr ""
"rawInterpolExample : String\n"
"rawInterpolExample = ##\"An interpolated \"string\": \\##{rawExample}\"##\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:424
#, no-wrap
msgid ""
"Finally, Idris also allows us to conveniently write multiline\n"
"strings. These can be pre- and postfixed with hashes if we want\n"
"raw multiline string literals, and they also can be combined with\n"
"string interpolation. Multiline literals are opened and closed with\n"
"triple quote characters. Indenting the closing triple quotes\n"
"allows us to indent the whole multiline literal. Whitespace used\n"
"for indentation will not appear in the resulting string. For instance:\n"
msgstr "最后，Idris 还允许我们方便地编写多行字符串。如果我们想要原始的多行字符串字面量，这些可以用井号前缀和后缀，它们也可以与字符串插值结合使用。多行文字用三引号字符打开和关闭。缩进结束的三引号允许我们缩进整个多行文字。用于缩进的空格不会出现在结果字符串中。例如：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:425
#, no-wrap
msgid ""
"multiline1 : String\n"
"multiline1 = \"\"\"\n"
"  And I raise my head and stare\n"
"  Into the eyes of a stranger\n"
"  I've always known that the mirror never lies\n"
"  People always turn away\n"
"  From the eyes of a stranger\n"
"  Afraid to see what hides behind the stare\n"
"  \"\"\"\n"
"\n"
"multiline2 : String\n"
"multiline2 = #\"\"\"\n"
"  An example for a simple expression:\n"
"  \"foo\" ++ \"bar\".\n"
"  This is reduced to \"\\#{\"foo\" ++ \"bar\"}\".\n"
"  \"\"\"#\n"
msgstr ""
"multiline1 : String\n"
"multiline1 = \"\"\"\n"
"  And I raise my head and stare\n"
"  Into the eyes of a stranger\n"
"  I've always known that the mirror never lies\n"
"  People always turn away\n"
"  From the eyes of a stranger\n"
"  Afraid to see what hides behind the stare\n"
"  \"\"\"\n"
"\n"
"multiline2 : String\n"
"multiline2 = #\"\"\"\n"
"  An example for a simple expression:\n"
"  \"foo\" ++ \"bar\".\n"
"  This is reduced to \"\\#{\"foo\" ++ \"bar\"}\".\n"
"  \"\"\"#\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:447
#, no-wrap
msgid ""
"Make sure to look at the example strings at the\n"
"REPL to see the effect of interpolation and raw string\n"
"literals and compare it with the syntax we used.\n"
msgstr "请务必查看 REPL 中的示例字符串，以了解插值和原始字符串文字的效果，并将其与我们使用的语法进行比较。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:454
#, no-wrap
msgid ""
"In these exercises, you are supposed to implement a bunch\n"
"of utility functions for consuming and converting strings.\n"
"I don't give the expected types here, because you are\n"
"supposed to come up with those yourself.\n"
msgstr "在这些练习中，你应该实现一堆用于消费和转换字符串的实用函数。我在这里没有给出预期的类型，因为你应该自己想出那些。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:458
#, no-wrap
msgid ""
"Implement functions similar to `map`, `filter`, and\n"
"`mapMaybe` for strings. The output type of these\n"
"should always be a string.\n"
msgstr "为字符串实现类似于 `map`、`filter` 和 `mapMaybe` "
"的函数。这些的输出类型应该始终是一个字符串。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:461
#, no-wrap
msgid ""
"Implement functions similar to `foldl` and `foldMap`\n"
"for strings.\n"
msgstr "为字符串实现类似于 `foldl` 和 `foldMap` 的函数。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:464
#, no-wrap
msgid ""
"Implement a function similar to `traverse`\n"
"for strings. The output type should be a wrapped string.\n"
msgstr "为字符串实现类似于 `traverse` 的函数。输出类型应该是一个包装的字符串。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:467
#, no-wrap
msgid ""
"Implement the bind operator for strings. The output type\n"
"should again be a string.\n"
msgstr "为字符串实现绑定运算符。输出类型应该再次是字符串。\n"

#. type: Title ##
#: ../src/Tutorial/Prim.md:468
#, no-wrap
msgid "Integers"
msgstr "整数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:475
#, no-wrap
msgid ""
"As listed at the beginning of this chapter, Idris provides different\n"
"fixed-precision signed and unsigned integer types as well as `Integer`,\n"
"an arbitrary precision signed integer type.\n"
"All of them come with the following primitive functions (given\n"
"here for `Bits8` as an example):\n"
msgstr "正如本章开头所列出的，Idris 提供了不同的固定精度有符号和无符号整数类型以及 `Integer`，一种任意精度的有符号整数类型。它们都带有以下原语函数（此处以 `Bits8` 为例）：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, no-wrap
msgid "`prim__add_Bits8`: Integer addition.\n"
msgstr "`prim__add_Bits8`：整数加法。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, no-wrap
msgid "`prim__sub_Bits8`: Integer subtraction.\n"
msgstr "`prim__sub_Bits8`：整数减法。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, no-wrap
msgid "`prim__mul_Bits8`: Integer multiplication.\n"
msgstr "`prim__mul_Bits8`：整数乘法。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, no-wrap
msgid "`prim__div_Bits8`: Integer division.\n"
msgstr "`prim__div_Bits8`：整数除法。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, no-wrap
msgid "`prim__mod_Bits8`: Modulo function.\n"
msgstr "`prim__mod_Bits8`：模函数。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, no-wrap
msgid "`prim__shl_Bits8`: Bitwise left shift.\n"
msgstr "`prim__shl_Bits8`：按位左移。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, no-wrap
msgid "`prim__shr_Bits8`: Bitwise right shift.\n"
msgstr "`prim__shr_Bits8`：按位右移。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, no-wrap
msgid "`prim__and_Bits8`: Bitwise *and*.\n"
msgstr "`prim__and_Bits8`：按位*与*。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, no-wrap
msgid "`prim__or_Bits8`: Bitwise *or*.\n"
msgstr "`prim__or_Bits8`：按位*或*。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, no-wrap
msgid "`prim__xor_Bits8`: Bitwise *xor*.\n"
msgstr "`prim__xor_Bits8`：按位*异或*。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:493
#, no-wrap
msgid ""
"Typically, you use the functions for addition and multiplication\n"
"through the operators from interface `Num`, the function\n"
"for subtraction through interface `Neg`, and the functions\n"
"for division (`div` and `mod`) through interface `Integral`.\n"
"The bitwise operations are available through interfaces\n"
"`Data.Bits.Bits` and `Data.Bits.FiniteBits`.\n"
msgstr "通常，您可以通过接口 `Num` 中的运算符使用加法和乘法函数，通过接口 `Neg` 使用减法函数，以及除法函数 (`div`和 `mod`) 通过接口 `Integral`。位运算可通过接口 `Data.Bits.Bits` 和 `Data.Bits.FiniteBits` 获得。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:497
#, no-wrap
msgid ""
"For all integral types, the following laws are assumed to\n"
"hold for numeric operations (`x`, `y`, and `z` are\n"
"arbitrary value of the same primitive integral type):\n"
msgstr "对于所有整数类型，假设以下定律适用于数值运算（`x`、`y` 和 `z` 是相同原始整数类型的任意值） ：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, no-wrap
msgid "`x + y = y + x`: Addition is commutative.\n"
msgstr "`x + y = y + x`：加法是可交换的。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, no-wrap
msgid "`x + (y + z) = (x + y) + z`: Addition is associative.\n"
msgstr "`x + (y + z) = (x + y) + z`：加法是结合的。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, no-wrap
msgid "`x + 0 = x`: Zero is the neutral element of addition.\n"
msgstr "`x + 0 = x`：零是加法的中性元素。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, no-wrap
msgid "`x - x = x + (-x) = 0`: `-x` is the additive inverse of `x`.\n"
msgstr "`x - x = x + (-x) = 0`：`-x` 是 `x` 的加法逆。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, no-wrap
msgid "`x * y = y * x`: Multiplication is commutative.\n"
msgstr "`x * y = y * x`：乘法是可交换的。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, no-wrap
msgid "`x * (y * z) = (x * y) * z`: Multiplication is associative.\n"
msgstr "`x * (y * z) = (x * y) * z`：乘法是结合的。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, no-wrap
msgid "`x * 1 = x`: One is the neutral element of multiplication.\n"
msgstr "`x * 1 = x`：1 是乘法的中性元素。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, no-wrap
msgid "`x * (y + z) = x * y + x * z`: The distributive law holds.\n"
msgstr "`x * (y + z) = x * y + x * z`：分配律成立。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, no-wrap
msgid "``y * (x `div` y) + (x `mod` y) = x`` (for `y /= 0`).\n"
msgstr "``y * (x `div` y) + (x `mod` y) = x``（对于 `y /= 0`）。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:515
#, no-wrap
msgid ""
"Please note, that the officially supported backends use\n"
"*Euclidian modulus* for calculating `mod`:\n"
"For `y /= 0`, ``x `mod` y`` is always a non-negative value\n"
"strictly smaller than `abs y`, so that the law given above\n"
"does hold. If `x` or `y` are negative numbers, this is different\n"
"to what many other languages do but for good reasons as explained\n"
"in the following [article](https://www.microsoft.com/en-us/research/publication/division-and-modulus-for-computer-scientists/).\n"
msgstr "请注意，官方支持的后端使用 *欧几里得模数* 来计算 `mod`： For `y /= 0`, ``x `mod` y``始终是严格小于 `abs y` 的非负值，因此上面给出的定律确实成立。如果 `x` 或 `y` 是负数，这与许多其他语言所做的不同，但出于以下 [文章](https://www.microsoft.com/en-us/research/publication/division-and-modulus-for-computer-scientists/) 。\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:516
#, no-wrap
msgid "Unsigned Integers"
msgstr "无符号整数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:526
#, no-wrap
msgid ""
"The unsigned fixed precision integer types (`Bits8`, `Bits16`,\n"
"`Bits32`, and `Bits64`) come with implementations of all\n"
"integral interfaces (`Num`, `Neg`, and `Integral`) and\n"
"the two interfaces for bitwise operations (`Bits` and `FiniteBits`).\n"
"All functions with the exception of `div` and `mod` are\n"
"total. Overflows are handled by calculating the remainder\n"
"modulo `2^bitsize`. For instance, for `Bits8`, all operations\n"
"calculate their results modulo 256:\n"
msgstr "无符号固定精度整数类型（`Bits8`、`Bits16`、`Bits32` 和 `Bits64`）带有所有整数接口的实现（`Num`、`Neg` 和 `Integral`）以及用于按位运算的两个接口（`Bits` 和 `FiniteBits`）。除了 `div` 和 `mod` 之外的所有函数都是总计的。通过计算余数模 `2^bitsize` 来处理溢出。例如，对于 `Bits8`，所有操作都以 256 为模计算其结果：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:527
#, no-wrap
msgid ""
"Main> the Bits8 255 + 1\n"
"0\n"
"Main> the Bits8 255 + 255\n"
"254\n"
"Main> the Bits8 128 * 2 + 7\n"
"7\n"
"Main> the Bits8 12 - 13\n"
"255\n"
msgstr ""
"Main> the Bits8 255 + 1\n"
"0\n"
"Main> the Bits8 255 + 255\n"
"254\n"
"Main> the Bits8 128 * 2 + 7\n"
"7\n"
"Main> the Bits8 12 - 13\n"
"255\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:538
#, no-wrap
msgid "Signed Integers"
msgstr "有符号整数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:549
#, no-wrap
msgid ""
"Like the unsigned integer types, the signed fixed precision\n"
"integer types (`Int8`, `Int16`, `Int32`, and `Int64`) come with\n"
"implementations of all integral interfaces and\n"
"the two interfaces for bitwise operations (`Bits` and `FiniteBits`).\n"
"Overflows are handled by calculating the remainder\n"
"modulo `2^bitsize` and adding the lower bound (a negative number)\n"
"if the result is still out of range. For instance, for `Int8`, all operations\n"
"calculate their results modulo 256, subtracting 128 if the\n"
"result is still out of bounds:\n"
msgstr "与无符号整数类型一样，有符号固定精度整数类型（`Int8`、`Int16`、`Int32` 和 `Int64`）具有以下实现所有整数接口和用于按位运算的两个接口（`Bits` 和 `FiniteBits`）。如果结果仍然超出范围，则通过计算余数模 `2^bitsize` 并添加下限（负数）来处理溢出。例如，对于 `Int8`，所有操作都以 256 为模计算结果，如果结果仍然超出范围，则减去 128：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:550
#, no-wrap
msgid ""
"Main> the Int8 2 * 127\n"
"-2\n"
"Main> the Int8 3 * 127\n"
"125\n"
msgstr ""
"Main> the Int8 2 * 127\n"
"-2\n"
"Main> the Int8 3 * 127\n"
"125\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:557
#, no-wrap
msgid "Bitwise Operations"
msgstr "位运算"

#. type: Plain text
#: ../src/Tutorial/Prim.md:568
#, no-wrap
msgid ""
"Module `Data.Bits` exports interfaces for performing bitwise\n"
"operations on integral types. I'm going to show a couple of\n"
"examples on unsigned 8-bit numbers (`Bits8`) to explain the concept\n"
"to readers new to bitwise arithmetics. Note, that this is much easier\n"
"to grasp for unsigned integer types than for the signed versions.\n"
"Those have to include information about the *sign* of numbers in their\n"
"bit pattern, and it is assumed that signed integers in Idris use\n"
"a [two's complement representation](https://en.wikipedia.org/wiki/Two%27s_complement),\n"
"about which I will not go into the details here.\n"
msgstr "模块 `Data.Bits` 导出用于对整数类型执行按位运算的接口。我将展示几个关于无符号 8 位数字 (`Bits8`) 的示例，以向不熟悉按位算术的读者解释这个概念。请注意，对于无符号整数类型，这比有符号版本更容易掌握。那些必须在其位模式中包含有关数字的 *符号* 的信息，并且假设 Idris 中的有符号整数使用 [二进制补码表示](https://en.wikipedia.org/wiki/2%27s_complement) ，这里不再赘述。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:573
#, no-wrap
msgid ""
"An unsigned 8-bit binary number is represented internally as\n"
"a sequence of eight bits (with values 0 or 1), each of which\n"
"corresponds to a power of 2. For instance,\n"
"the number 23 (= 16 + 4 + 2 + 1) is represented as `0001 0111`:\n"
msgstr "无符号 8 位二进制数在内部表示为 8 位序列（值为 0 或 1），每个位对应于 2 的幂。例如，数字 23 (= 16 + 4 + 2 + 1)表示为 `0001 0111`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:574
#, no-wrap
msgid ""
"23 in binary:    0  0  0  1    0  1  1  1\n"
"\n"
"Bit number:      7  6  5  4    3  2  1  0\n"
"Decimal value: 128 64 32 16    8  4  2  1\n"
msgstr ""
"23 in binary:    0  0  0  1    0  1  1  1\n"
"\n"
"Bit number:      7  6  5  4    3  2  1  0\n"
"Decimal value: 128 64 32 16    8  4  2  1\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:583
#, no-wrap
msgid ""
"We can use function `testBit` to check if the bit at the given\n"
"position is set or not:\n"
msgstr "我们可以使用函数 `testBit` 来检查给定位置的位是否已设置：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:584
#, no-wrap
msgid ""
"Tutorial.Prim> testBit (the Bits8 23) 0\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 1\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 3\n"
"False\n"
msgstr ""
"Tutorial.Prim> testBit (the Bits8 23) 0\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 1\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 3\n"
"False\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:595
#, no-wrap
msgid ""
"Likewise, we can use functions `setBit` and `clearBit` to\n"
"set or unset a bit at a certain position:\n"
msgstr "同样，我们可以使用函数 `setBit` 和 `clearBit` 在某个位置设置或取消设置位：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:596
#, no-wrap
msgid ""
"Tutorial.Prim> setBit (the Bits8 23) 3\n"
"31\n"
"Tutorial.Prim> clearBit (the Bits8 23) 2\n"
"19\n"
msgstr ""
"Tutorial.Prim> setBit (the Bits8 23) 3\n"
"31\n"
"Tutorial.Prim> clearBit (the Bits8 23) 2\n"
"19\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:610
#, no-wrap
msgid ""
"There are also operators `(.&.)` (bitwise *and*) and `(.|.)`\n"
"(bitwise *or*) as well as function `xor` (bitwise *exclusive or*)\n"
"for performing boolean operations on integral values.\n"
"For instance `x .&. y` has exactly those bits set, which both `x`\n"
"and `y` have set, while `x .|. y` has all bits set that are either\n"
"set in `x` or `y` (or both), and ``x `xor` y`` has those bits\n"
"set that are set in exactly one of the two values:\n"
msgstr "还有运算符 `(.&.)`（按位 *与*）和 `(.|.)`（按位 *或*）以及用于对整数值执行布尔运算的函数 `xor`（按位 *异或*）。例如 `x .&. y` 正好设置了那些位，`x` 和 `y` 都设置了，而 `x .|. y` 设置了在 `x` 或 `y`（或两者）中设置的所有位，并且 ``x `xor` y`` 设置了那些位设置为以下两个值之一：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:611
#, no-wrap
msgid ""
"23 in binary:          0  0  0  1    0  1  1  1\n"
"11 in binary:          0  0  0  0    1  0  1  1\n"
"\n"
"23 .&. 11 in binary:   0  0  0  0    0  0  1  1\n"
"23 .|. 11 in binary:   0  0  0  1    1  1  1  1\n"
"23 `xor` 11 in binary: 0  0  0  1    1  1  0  0\n"
msgstr ""
"23 in binary:          0  0  0  1    0  1  1  1\n"
"11 in binary:          0  0  0  0    1  0  1  1\n"
"\n"
"23 .&. 11 in binary:   0  0  0  0    0  0  1  1\n"
"23 .|. 11 in binary:   0  0  0  1    1  1  1  1\n"
"23 `xor` 11 in binary: 0  0  0  1    1  1  0  0\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:621
#, no-wrap
msgid "And here are the examples at the REPL:\n"
msgstr "以下是 REPL 上的示例：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:622
#, no-wrap
msgid ""
"Tutorial.Prim> the Bits8 23 .&. 11\n"
"3\n"
"Tutorial.Prim> the Bits8 23 .|. 11\n"
"31\n"
"Tutorial.Prim> the Bits8 23 `xor` 11\n"
"28\n"
msgstr ""
"Tutorial.Prim> the Bits8 23 .&. 11\n"
"3\n"
"Tutorial.Prim> the Bits8 23 .|. 11\n"
"31\n"
"Tutorial.Prim> the Bits8 23 `xor` 11\n"
"28\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:637
#, no-wrap
msgid ""
"Finally, it is possible to shift all bits to the right or left\n"
"by a certain number of steps by using functions `shiftR` and\n"
"`shiftL`, respectively (overflowing bits will just be dropped).\n"
"A left shift can therefore be viewed as a multiplication by a\n"
"power of two, while a right shift can be seen as a division\n"
"by a power of two:\n"
msgstr "最后，可以分别使用函数 `shiftR` 和 `shiftL` 将所有位向右或向左移动一定步数（溢出的位将被丢弃）。因此，左移可以看作是乘以 2 的幂，而右移可以看作是除以 2 的幂：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:638
#, no-wrap
msgid ""
"22 in binary:            0  0  0  1    0  1  1  0\n"
"\n"
"22 `shiftL` 2 in binary: 0  1  0  1    1  0  0  0\n"
"22 `shiftR` 1 in binary: 0  0  0  0    1  0  1  1\n"
msgstr ""
"22 in binary:            0  0  0  1    0  1  1  0\n"
"\n"
"22 `shiftL` 2 in binary: 0  1  0  1    1  0  0  0\n"
"22 `shiftR` 1 in binary: 0  0  0  0    1  0  1  1\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:647
#, no-wrap
msgid ""
"Tutorial.Prim> the Bits8 22 `shiftL` 2\n"
"88\n"
"Tutorial.Prim> the Bits8 22 `shiftR` 1\n"
"11\n"
msgstr ""
"Tutorial.Prim> the Bits8 22 `shiftL` 2\n"
"88\n"
"Tutorial.Prim> the Bits8 22 `shiftR` 1\n"
"11\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:657
#, no-wrap
msgid ""
"Bitwise operations are often used in specialized code or\n"
"certain high-performance applications. As programmers, we\n"
"have to know they exist and how they work.\n"
msgstr "按位运算通常用于专用代码或某些高性能应用程序中。作为程序员，我们必须知道它们的存在以及它们是如何工作的。\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:658
#, no-wrap
msgid "Integer Literals"
msgstr "整数字面量"

#. type: Plain text
#: ../src/Tutorial/Prim.md:666
#, no-wrap
msgid ""
"So far, we always required an implementation of `Num` in order to\n"
"be able to use integer literals for a given type. However,\n"
"it is actually only necessary to implement a function `fromInteger`\n"
"converting an `Integer` to the type in question. As we will\n"
"see in the last section, such a function can even restrict\n"
"the values allowed as valid literals.\n"
msgstr "到目前为止，我们总是需要 `Num` 的实现，以便能够对给定类型使用整数文字。然而，实际上只需要实现一个函数 `fromInteger` 将 `Integer` 转换为相关类型。正如我们将在最后一节中看到的，这样的函数甚至可以限制允许作为有效字面量的值。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:671
#, no-wrap
msgid ""
"For instance, assume we'd like to define a data type for\n"
"representing the charge of a chemical molecule. Such a value\n"
"can be positive or negative and (theoretically) of almost\n"
"arbitrary magnitude:\n"
msgstr "例如，假设我们想定义一个数据类型来表示化学分子的电荷。这样的值可以是正值或负值，并且（理论上）几乎是任意大小：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:672
#, no-wrap
msgid ""
"record Charge where\n"
"  constructor MkCharge\n"
"  value : Integer\n"
msgstr ""
"record Charge where\n"
"  constructor MkCharge\n"
"  value : Integer\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:683
#, no-wrap
msgid ""
"It makes sense to be able to sum up charges, but not to\n"
"multiply them. They should therefore have an implementation\n"
"of `Monoid` but not of `Num`. Still, we'd like to have\n"
"the convenience of integer literals when using constant\n"
"charges at compile time. Here's how to do this:\n"
msgstr "能够对费用求和是有意义的，但不能将它们相乘。因此，它们应该有 `Monoid` 的实现，而不是 `Num` 的实现。尽管如此，我们还是希望在编译时使用常量费用时能够方便地使用整数字面量。以下是如何执行此操作：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:684
#, no-wrap
msgid ""
"fromInteger : Integer -> Charge\n"
"fromInteger = MkCharge\n"
"\n"
"Semigroup Charge where\n"
"  x <+> y = MkCharge $ x.value + y.value\n"
"\n"
"Monoid Charge where\n"
"  neutral = 0\n"
msgstr ""
"fromInteger : Integer -> Charge\n"
"fromInteger = MkCharge\n"
"\n"
"Semigroup Charge where\n"
"  x <+> y = MkCharge $ x.value + y.value\n"
"\n"
"Monoid Charge where\n"
"  neutral = 0\n"

#. type: Title ####
#: ../src/Tutorial/Prim.md:695
#, no-wrap
msgid "Alternative Bases"
msgstr "可供选择的基础"

#. type: Plain text
#: ../src/Tutorial/Prim.md:702
#, no-wrap
msgid ""
"In addition to the well known decimal literals, it is also\n"
"possible to use integer literals in binary, octal, or\n"
"hexadecimal representation. These have to be prefixed\n"
"with a zero following by a `b`, `o`, or `x` for\n"
"binary, octal, and hexadecimal, respectively:\n"
msgstr "除了众所周知的十进制文字外，还可以使用二进制、八进制或十六进制表示的整数文字。对于二进制、八进制和十六进制，它们必须以零为前缀，后跟 `b`、`o` 或 `x`：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:703
#, no-wrap
msgid ""
"Tutorial.Prim> 0b1101\n"
"13\n"
"Tutorial.Prim> 0o773\n"
"507\n"
"Tutorial.Prim> 0xffa2\n"
"65442\n"
msgstr ""
"Tutorial.Prim> 0b1101\n"
"13\n"
"Tutorial.Prim> 0o773\n"
"507\n"
"Tutorial.Prim> 0xffa2\n"
"65442\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:716
#, no-wrap
msgid ""
"Define a wrapper record for integral values and implement\n"
"`Monoid` so that `(<+>)` corresponds to `(.&.)`.\n"
msgstr "定义整数值的包装记录并实现 `Monoid` 以便 `(<+>)` 对应于 `(.&.)`。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:719
#, no-wrap
msgid ""
"   Hint: Have a look at the functions available from interface\n"
"   `Bits` to find a value suitable as the neutral element.\n"
msgstr ""
"   提示：查看 `Bits` 接口中可用的函数\n"
"   找到适合作为中性元素的值。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:722
#, no-wrap
msgid ""
"Define a wrapper record for integral values and implement\n"
"`Monoid` so that `(<+>)` corresponds to `(.|.)`.\n"
msgstr "定义整数值的包装记录并实现 `Monoid` 以便 `(<+>)` 对应于 `(.|.)`。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:725
#, no-wrap
msgid ""
"Use bitwise operations to implement a function, which tests if\n"
"a given value of type `Bits64` is even or not.\n"
msgstr "使用按位运算来实现一个函数，该函数测试 `Bits64` 类型的给定值是否为偶数。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:727
#, no-wrap
msgid "Convert a value of type `Bits64` to a string in binary representation.\n"
msgstr "将 `Bits64` 类型的值转换为二进制表示的字符串。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Prim.md:729
#, no-wrap
msgid "Convert a value of type `Bits64` to a string in hexadecimal representation.\n"
msgstr "将 `Bits64` 类型的值转换为十六进制表示的字符串。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:732
#, no-wrap
msgid ""
"   Hint: Use `shiftR` and `(.&. 15)` to access subsequent packages of\n"
"   four bits.\n"
msgstr "   提示：使用 `shiftR` 和 `(.&. 15)` 访问四位的后续包。\n"

#. type: Title ##
#: ../src/Tutorial/Prim.md:733
#, no-wrap
msgid "Refined Primitives"
msgstr "精炼原语"

#. type: Plain text
#: ../src/Tutorial/Prim.md:741
#, no-wrap
msgid ""
"We often do not want to allow all values of a type in a certain\n"
"context. For instance, `String` as an arbitrary sequence of\n"
"UTF-8 characters (several of which are not even printable), is\n"
"too general most of the time. Therefore, it is usually advisable\n"
"to rule out invalid values early on, by pairing a value with\n"
"an erased proof of validity.\n"
msgstr "我们通常不希望在某个上下文中允许某个类型的所有值。例如，`String` 作为 UTF-8 字符的任意序列（其中有几个甚至无法打印），在大多数情况下都过于笼统。因此，通常建议通过将值与已擦除的有效性证明配对，尽早排除无效值。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:749
#, no-wrap
msgid ""
"We have learned how we can write elegant predicates, with\n"
"which we can proof our functions to be total, and from which we\n"
"can - in the ideal case - derive other, related predicates. However,\n"
"when we define predicates on primitives they are to a certain degree\n"
"doomed to live in isolation, unless we come up with a set of\n"
"primitive axioms (implemented most likely using `believe_me`), with\n"
"which we can manipulate our predicates.\n"
msgstr "我们已经学会了如何编写优雅的谓词，用它我们可以证明我们的函数是完全的，并且我们可以从它——在理想情况下——推导出其他相关的谓词。然而，当我们在原语上定义谓词时，它们在某种程度上注定要孤立存在，除非我们提出一组原语公理（最有可能使用 `believe_me` 实现），我们可以用它来操纵我们的谓词。\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:750
#, no-wrap
msgid "Use Case: ASCII Strings"
msgstr "用例：ASCII 字符串"

#. type: Plain text
#: ../src/Tutorial/Prim.md:756
#, no-wrap
msgid ""
"String encodings is a difficult topic, so in many low level routines\n"
"it makes sense to rule out most characters from the beginning. Assume\n"
"therefore, we'd like to make sure the strings we accept in our\n"
"application only consist of ASCII characters:\n"
msgstr "字符串编码是一个困难的话题，因此在许多低级例程中，从一开始就排除大多数字符是有意义的。因此，假设我们希望确保我们在应用程序中接受的字符串仅包含 ASCII 字符：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:757
#, no-wrap
msgid ""
"isAsciiChar : Char -> Bool\n"
"isAsciiChar c = ord c <= 127\n"
"\n"
"isAsciiString : String -> Bool\n"
"isAsciiString = all isAsciiChar . unpack\n"
msgstr ""
"isAsciiChar : Char -> Bool\n"
"isAsciiChar c = ord c <= 127\n"
"\n"
"isAsciiString : String -> Bool\n"
"isAsciiString = all isAsciiChar . unpack\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:767
#, no-wrap
msgid ""
"We can now *refine* a string value by pairing it with an erased\n"
"proof of validity:\n"
msgstr "我们现在可以 *细化* 一个字符串值，方法是将其与已擦除的有效性证明配对：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:768
#, no-wrap
msgid ""
"record Ascii where\n"
"  constructor MkAscii\n"
"  value : String\n"
"  0 prf : isAsciiString value === True\n"
msgstr ""
"record Ascii where\n"
"  constructor MkAscii\n"
"  value : String\n"
"  0 prf : isAsciiString value === True\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:779
#, no-wrap
msgid ""
"It is now *impossible* to at runtime or compile time create\n"
"a value of type `Ascii` without first validating the wrapped\n"
"string. With this, it is already pretty easy to safely wrap strings at\n"
"compile time in a value of type `Ascii`:\n"
msgstr "现在在运行时或编译时创建 `Ascii` 类型的值，而无需首先验证包装的字符串是 *不可能* 的。有了这个，在编译时将字符串安全地包装成 `Ascii` 类型的值已经很容易了：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:780
#, no-wrap
msgid ""
"hello : Ascii\n"
"hello = MkAscii \"Hello World!\" Refl\n"
msgstr ""
"hello : Ascii\n"
"hello = MkAscii \"Hello World!\" Refl\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:800
#, no-wrap
msgid ""
"And yet, it would be much more convenient to still use string\n"
"literals for this, without having to sacrifice the comfort of\n"
"safety. To do so, we can't use interface `FromString`, as its\n"
"function `fromString` would force us to convert *any* string,\n"
"even an invalid one. However, we actually don't need an implementation of\n"
"`FromString` to support string literals, just like we didn't\n"
"require an implementation of `Num` to support integer literals.\n"
"What we really need is a function named `fromString`. Now, when\n"
"string literals are desugared, they are converted to invocations\n"
"of `fromString` with the given string value as its argument.\n"
"For instance, literal `\"Hello\"` gets desugared to `fromString \"Hello\"`.\n"
"This happens before type checking and filling in of (auto) implicit\n"
"values. It is therefore perfectly fine, to define a custom `fromString`\n"
"function with an erased auto implicit argument as a proof of\n"
"validity:\n"
msgstr "然而，为此仍然使用字符串字面量会更方便，而不必牺牲安全的舒适性。为此，我们不能使用接口 `FromString`，因为它的函数 `fromString` 会强制我们转换 *任意* 字符串，即使是无效字符串。但是，我们实际上不需要实现 `FromString` 来支持字符串文字，就像我们不需要实现 `Num` 来支持整数字面量一样。我们真正需要的是一个名为 `fromString` 的函数。现在，当字符字面量字被脱糖时，它们被转换为以给定字符串值作为参数的 `fromString` 的调用。例如，文字 `\"Hello\"` 被脱糖为 `fromString \"Hello\"`。这发生在类型检查和填充（自动）隐式值之前。因此，使用已擦除的自动隐式参数定义自定义 `fromString` 函数作为有效性证明是非常好的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:801
#, no-wrap
msgid ""
"fromString : (s : String) -> {auto 0 prf : isAsciiString s === True} -> Ascii\n"
"fromString s = MkAscii s prf\n"
msgstr ""
"fromString : (s : String) -> {auto 0 prf : isAsciiString s === True} -> Ascii\n"
"fromString s = MkAscii s prf\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:808
#, no-wrap
msgid ""
"With this, we can us (valid) string literals for coming up with\n"
"values of type `Ascii` directly:\n"
msgstr "有了这个，我们可以使用（有效的）字符串文字直接得出 `Ascii` 类型的值：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:809
#, no-wrap
msgid ""
"hello2 : Ascii\n"
"hello2 = \"Hello World!\"\n"
msgstr ""
"hello2 : Ascii\n"
"hello2 = \"Hello World!\"\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:817
#, no-wrap
msgid ""
"In order to at runtime create values of type `Ascii` from strings\n"
"of an unknown source, we can use a refinement function returning\n"
"some kind of failure type:\n"
msgstr "为了在运行时从未知来源的字符串中创建 `Ascii` 类型的值，我们可以使用返回某种故障类型的细化函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:818
#, no-wrap
msgid ""
"test : (b : Bool) -> Dec (b === True)\n"
"test True  = Yes Refl\n"
"test False = No absurd\n"
"\n"
"ascii : String -> Maybe Ascii\n"
"ascii x = case test (isAsciiString x) of\n"
"  Yes prf   => Just $ MkAscii x prf\n"
"  No contra => Nothing\n"
msgstr ""
"test : (b : Bool) -> Dec (b === True)\n"
"test True  = Yes Refl\n"
"test False = No absurd\n"
"\n"
"ascii : String -> Maybe Ascii\n"
"ascii x = case test (isAsciiString x) of\n"
"  Yes prf   => Just $ MkAscii x prf\n"
"  No contra => Nothing\n"

#. type: Title ####
#: ../src/Tutorial/Prim.md:829
#, no-wrap
msgid "Disadvantages of Boolean Proofs"
msgstr "布尔证明的缺点"

#. type: Plain text
#: ../src/Tutorial/Prim.md:834
#, no-wrap
msgid ""
"For many use cases, what we described above for ASCII strings can\n"
"take us very far. However, one drawback of this approach is that we\n"
"can't safely perform any computations with the proofs at hand.\n"
msgstr "对于许多用例，我们上面描述的 ASCII 字符串可以让我们走得很远。然而，这种方法的一个缺点是我们不能使用手头的证明安全地执行任何计算。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:839
#, no-wrap
msgid ""
"For instance, we know it will be perfectly fine to concatenate\n"
"two ASCII strings, but in order to convince Idris of this, we\n"
"will have to use `believe_me`, because we will not be able to\n"
"proof the following lemma otherwise:\n"
msgstr "例如，我们知道连接两个 ASCII 字符串会非常好，但是为了让 Idris 相信这一点，我们必须使用 `believe_me`，否则我们将无法证明以下引理：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:840
#, no-wrap
msgid ""
"0 allAppend :  (f : Char -> Bool)\n"
"            -> (s1,s2 : String)\n"
"            -> (p1 : all f (unpack s1) === True)\n"
"            -> (p2 : all f (unpack s2) === True)\n"
"            -> all f (unpack (s1 ++ s2)) === True\n"
"allAppend f s1 s2 p1 p2 = believe_me $ Refl {x = True}\n"
"\n"
"namespace Ascii\n"
"  export\n"
"  (++) : Ascii -> Ascii -> Ascii\n"
"  MkAscii s1 p1 ++ MkAscii s2 p2 =\n"
"    MkAscii (s1 ++ s2) (allAppend isAsciiChar s1 s2 p1 p2)\n"
msgstr ""
"0 allAppend :  (f : Char -> Bool)\n"
"            -> (s1,s2 : String)\n"
"            -> (p1 : all f (unpack s1) === True)\n"
"            -> (p2 : all f (unpack s2) === True)\n"
"            -> all f (unpack (s1 ++ s2)) === True\n"
"allAppend f s1 s2 p1 p2 = believe_me $ Refl {x = True}\n"
"\n"
"namespace Ascii\n"
"  export\n"
"  (++) : Ascii -> Ascii -> Ascii\n"
"  MkAscii s1 p1 ++ MkAscii s2 p2 =\n"
"    MkAscii (s1 ++ s2) (allAppend isAsciiChar s1 s2 p1 p2)\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:861
#, no-wrap
msgid ""
"The same goes for all operations extracting a substring from\n"
"a given string: We will have to implement according rules using\n"
"`believe_me`. Finding a reasonable set of axioms to conveniently\n"
"deal with refined primitives can therefore be challenging at times,\n"
"and whether such axioms are even required very much depends\n"
"on the use case at hand.\n"
msgstr "从给定字符串中提取子字符串的所有操作也是如此：我们必须使用 `believe_me` 来实现相应的规则。因此，找到一组合理的公理来方便地处理精炼的原语有时可能具有挑战性，而且是否需要这样的公理在很大程度上取决于手头的用例。\n"

#. type: Title ###
#: ../src/Tutorial/Prim.md:862
#, no-wrap
msgid "Use Case: Sanitized HTML"
msgstr "用例：净化的 HTML"

#. type: Plain text
#: ../src/Tutorial/Prim.md:869
#, no-wrap
msgid ""
"Assume you write a simple web application for scientific\n"
"discourse between registered users. To keep things simple, we\n"
"only consider unformatted text input here. Users can write arbitrary\n"
"text in a text field and upon hitting Enter, the message is\n"
"displayed to all other registered users.\n"
msgstr "假设您为注册用户之间的科学讨论编写了一个简单的 Web 应用程序。为了简单起见，我们在这里只考虑未格式化的文本输入。用户可以在文本字段中写入任意文本，然后按 Enter 键，该消息将显示给所有其他注册用户。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:871
#, no-wrap
msgid "Assume now a user decides to enter the following text:\n"
msgstr "假设现在用户决定输入以下文本：\n"

#. type: Fenced code block (html)
#: ../src/Tutorial/Prim.md:872
#, no-wrap
msgid "<script>alert(\"Hello World!\")</script>\n"
msgstr "<script>alert(\"Hello World!\")</script>\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:884
#, no-wrap
msgid ""
"Well, it could have been (much) worse. Still, unless we take measures\n"
"to prevent this from happening, this might embed a JavaScript\n"
"program in our web page we never intended to have there!\n"
"What I described here, is a well known security vulnerability called\n"
"[cross-site scripting](https://en.wikipedia.org/wiki/Cross-site_scripting).\n"
"It allows users of web pages to enter malicious JavaScript code in\n"
"text fields, which will then be included in the page's HTML structure\n"
"and executed when it is being displayed to other users.\n"
msgstr "好吧，它本来可以（非常）更糟。尽管如此，除非我们采取措施防止这种情况发生，否则这可能会在我们的网页中嵌入我们从未打算拥有的 JavaScript 程序！我在这里描述的是一个众所周知的安全漏洞，称为 [cross-site scripting](https://en.wikipedia.org/wiki/Cross-site_scripting)。它允许网页用户在文本字段中输入恶意 JavaScript 代码，然后这些代码将包含在页面的 HTML 结构中，并在向其他用户显示时执行。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:891
#, no-wrap
msgid ""
"We want to make sure, that this cannot happen on our own web page.\n"
"In order to protect us from this attack, we could for instance disallow\n"
"certain characters like `'<'` or `'>'` completely (although this might not\n"
"be enough!), but if our chat service is targeted at programmers,\n"
"this will be overly restrictive. An alternative\n"
"is to escape certain characters before rendering them on the page.\n"
msgstr "我们想确保这不会发生在我们自己的网页上。为了保护我们免受这种攻击，我们可以例如完全禁止某些字符，例如 `'<'` 或 `'>'`（尽管这可能还不够！），但是如果我们的聊天服务是针对程序员的，这将是过度限制。另一种方法是在将某些字符呈现在页面上之前对其进行转义。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:892
#, no-wrap
msgid ""
"escape : String -> String\n"
"escape = concat . map esc . unpack\n"
"  where esc : Char -> String\n"
"        esc '<'  = \"&lt;\"\n"
"        esc '>'  = \"&gt;\"\n"
"        esc '\"'  = \"&quot;\"\n"
"        esc '&'  = \"&amp;\"\n"
"        esc '\\'' = \"&apos;\"\n"
"        esc c    = singleton c\n"
msgstr ""
"escape : String -> String\n"
"escape = concat . map esc . unpack\n"
"  where esc : Char -> String\n"
"        esc '<'  = \"&lt;\"\n"
"        esc '>'  = \"&gt;\"\n"
"        esc '\"'  = \"&quot;\"\n"
"        esc '&'  = \"&amp;\"\n"
"        esc '\\'' = \"&apos;\"\n"
"        esc c    = singleton c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:910
#, no-wrap
msgid ""
"What we now want to do is to store a string together with\n"
"a proof that is was properly escaped. This is another form\n"
"of existential quantification: \"Here is a string, and there\n"
"once existed another string, which we passed to `escape`\n"
"and arrived at the string we have now\". Here's how to encode\n"
"this:\n"
msgstr "我们现在要做的是将字符串与正确转义的证明一起存储。这是存在量化的另一种形式：“这是一个字符串，曾经存在另一个字符串，我们将其传递给 `escape` 并到达我们现在拥有的字符串”。以下是如何对此进行编码：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:911
#, no-wrap
msgid ""
"record Escaped where\n"
"  constructor MkEscaped\n"
"  value    : String\n"
"  0 origin : String\n"
"  0 prf    : escape origin === value\n"
msgstr ""
"record Escaped where\n"
"  constructor MkEscaped\n"
"  value    : String\n"
"  0 origin : String\n"
"  0 prf    : escape origin === value\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:925
#, no-wrap
msgid ""
"Whenever we now embed a string of unknown origin in our web page,\n"
"we can request a value of type `Escaped` and have the very\n"
"strong guarantee that we are no longer vulnerable to cross-site\n"
"scripting attacks. Even better, it is also possible to safely\n"
"embed string literals known at compile time without the need\n"
"to escape them first:\n"
msgstr "每当我们现在在我们的网页中嵌入一个未知来源的字符串时，我们都可以请求一个类型为 `Escaped` 的值，并且非常有力地保证我们不再容易受到跨站点脚本攻击。更好的是，还可以安全地嵌入编译时已知的字符串文字，而无需先转义它们：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:926
#, no-wrap
msgid ""
"namespace Escaped\n"
"  export\n"
"  fromString : (s : String) -> {auto 0 prf : escape s === s} -> Escaped\n"
"  fromString s = MkEscaped s s prf\n"
"\n"
"escaped : Escaped\n"
"escaped = \"Hello World!\"\n"
msgstr ""
"namespace Escaped\n"
"  export\n"
"  fromString : (s : String) -> {auto 0 prf : escape s === s} -> Escaped\n"
"  fromString s = MkEscaped s s prf\n"
"\n"
"escaped : Escaped\n"
"escaped = \"Hello World!\"\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:941
#, no-wrap
msgid ""
"In this massive set of exercises, you are going to build\n"
"a small library for working with predicates on primitives.\n"
"We want to keep the following goals in mind:\n"
msgstr "在这组庞大的练习中，您将构建一个小型库，用于处理原语上的谓词。我们要牢记以下目标：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
#, no-wrap
msgid ""
"We want to use the usual operations of propositional logic to\n"
"combine predicates: Negation, conjuction (logical *and*),\n"
"and disjunction (logical *or*).\n"
msgstr "我们想使用命题逻辑的常用运算来组合谓词：否定、合取（逻辑*与*）和析取（逻辑*或"
"*）。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
#, no-wrap
msgid ""
"All predicates should be erased at runtime. If we proof\n"
"something about a primitive number, we want to make sure\n"
"not to carry around a huge proof of validity.\n"
msgstr "所有谓词都应在运行时擦除。如果我们证明一些关于原语数字的东西，我们要确保不携"
"带大量的有效性证明。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
#, no-wrap
msgid ""
"Calculations on predicates should make no appearance\n"
"at runtime (with the exception of `decide`; see below).\n"
msgstr "谓词的计算不应在运行时出现（`decide` 除外；见下文）。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
#, no-wrap
msgid ""
"Recursive calculations on predicates should be tail recursive if\n"
"they are used in implementations of `decide`. This might be tough\n"
"to achieve. If you can't find a tail recursive\n"
"solution for a given problem, use what feels most natural\n"
"instead.\n"
msgstr ""
"如果谓词用于 `decide` 的实现，则谓词的递归计算应该是尾递归的。这可能很难实现"
"。如果您找不到给定问题的尾递归解决方案，请改用感觉最自然的方法。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:980
#, no-wrap
msgid ""
"A note on efficiency: In order to be able to run\n"
"computations on our predicates, we try to convert primitive\n"
"values to algebraic data types as often and as soon as possible:\n"
"Unsigned integers will be converted to `Nat` using `cast`,\n"
"and strings will be converted to `List Char` using `unpack`.\n"
"This allows us to work with proofs on `Nat` and `List` most\n"
"of the time, and such proofs can be implemented without\n"
"resorting to `believe_me` or other cheats. However, the one\n"
"advantage of primitive types over algebraic data types is\n"
"that they often perform much better. This is especially\n"
"critical when comparing integral types with `Nat`: Operations\n"
"on natural numbers often run with `O(n)` time complexity,\n"
"where `n` is the size of one of the natural numbers involved,\n"
"while with `Bits64`, for instance, many operations run in fast constant\n"
"time (`O(1)`). Luckily, the Idris compiler optimizes many\n"
"functions on natural number to use the corresponding `Integer`\n"
"operations at runtime. This has the advantage that we can\n"
"still use proper induction to proof stuff about natural\n"
"numbers at compile time, while getting the benefit of fast\n"
"integer operations at runtime. However, operations on `Nat` do\n"
"run with `O(n)` time complexity and *compile time*. Proofs\n"
"working on large natural number will therefore drastically\n"
"slow down the compiler. A way out of this is discussed at\n"
"the end of this section of exercises.\n"
msgstr "关于效率的说明：为了能够在我们的谓词上运行计算，我们尝试尽快将原语值转换为代数数据类型：无符号整数将转换为 `Nat` 使用 `cast`，字符串将使用 `unpack` 转换为 `List Char`。这使我们大部分时间都可以在 `Nat` 和 `List` 上使用证明，并且可以在不借助 `believe_me` 或其他作弊手段的情况下实现此类证明。然而，原语类型相对于代数数据类型的一个优势是它们通常执行得更好。在将整数类型与 `Nat` 进行比较时，这一点尤其重要：对自然数的运算通常以 `O(n)` 时间复杂度运行，其中 `n` 是所涉及的自然数其中之一的大小，而对于 `Bits64`，例如，许多操作在常数时间内（`O(1)`）快速运行。幸运的是，Idris 编译器优化了许多自然数函数，以便在运行时使用相应的 `Integer` 操作。这样做的好处是我们仍然可以在编译时使用适当的归纳来证明关于自然数的东西，同时在运行时获得快速整数运算的好处。但是，`Nat` 上的操作确实以 `O(n)` 时间复杂度在 *编译期* 运行。因此，在大自然数上工作的证明将大大减慢编译器的速度。在本节练习的末尾讨论了解决此问题的方法。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:983
#, no-wrap
msgid ""
"Enough talk, let's begin!\n"
"To start with, you are given the following utilities:\n"
msgstr "废话不多说，开始吧！首先，您将获得以下实用程序：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:984
#, no-wrap
msgid ""
"-- Like `Dec` but with erased proofs. Constructors `Yes0`\n"
"-- and `No0` will be converted to constants `0` and `1` by\n"
"-- the compiler!\n"
"data Dec0 : (prop : Type) -> Type where\n"
"  Yes0 : (0 prf : prop) -> Dec0 prop\n"
"  No0  : (0 contra : prop -> Void) -> Dec0 prop\n"
"\n"
"-- For interfaces with more than one parameter (`a` and `p`\n"
"-- in this example) sometimes one parameter can be determined\n"
"-- by knowing the other. For instance, if we know what `p` is,\n"
"-- we will most certainly also know what `a` is. We therefore\n"
"-- specify that proof search on `Decidable` should only be\n"
"-- based on `p` by listing `p` after a vertical bar: `| p`.\n"
"-- This is like specifing the search parameter(s) of\n"
"-- a data type with `[search p]` as was shown in the chapter\n"
"-- about predicates.\n"
"-- Specifying a single search parameter as shown here can\n"
"-- drastically help with type inference.\n"
"interface Decidable (0 a : Type) (0 p : a -> Type) | p where\n"
"  decide : (v : a) -> Dec0 (p v)\n"
"\n"
"-- We often have to pass `p` explicitly in order to help Idris with\n"
"-- type inference. In such cases, it is more convenient to use\n"
"-- `decideOn pred` instead of `decide {p = pred}`.\n"
"decideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> Dec0 (p v)\n"
"decideOn _ = decide\n"
"\n"
"-- Some primitive predicates can only be reasonably implemented\n"
"-- using boolean functions. This utility helps with decidability\n"
"-- on such proofs.\n"
"test0 : (b : Bool) -> Dec0 (b === True)\n"
"test0 True  = Yes0 Refl\n"
"test0 False = No0 absurd\n"
msgstr ""
"-- Like `Dec` but with erased proofs. Constructors `Yes0`\n"
"-- and `No0` will be converted to constants `0` and `1` by\n"
"-- the compiler!\n"
"data Dec0 : (prop : Type) -> Type where\n"
"  Yes0 : (0 prf : prop) -> Dec0 prop\n"
"  No0  : (0 contra : prop -> Void) -> Dec0 prop\n"
"\n"
"-- For interfaces with more than one parameter (`a` and `p`\n"
"-- in this example) sometimes one parameter can be determined\n"
"-- by knowing the other. For instance, if we know what `p` is,\n"
"-- we will most certainly also know what `a` is. We therefore\n"
"-- specify that proof search on `Decidable` should only be\n"
"-- based on `p` by listing `p` after a vertical bar: `| p`.\n"
"-- This is like specifing the search parameter(s) of\n"
"-- a data type with `[search p]` as was shown in the chapter\n"
"-- about predicates.\n"
"-- Specifying a single search parameter as shown here can\n"
"-- drastically help with type inference.\n"
"interface Decidable (0 a : Type) (0 p : a -> Type) | p where\n"
"  decide : (v : a) -> Dec0 (p v)\n"
"\n"
"-- We often have to pass `p` explicitly in order to help Idris with\n"
"-- type inference. In such cases, it is more convenient to use\n"
"-- `decideOn pred` instead of `decide {p = pred}`.\n"
"decideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> Dec0 (p v)\n"
"decideOn _ = decide\n"
"\n"
"-- Some primitive predicates can only be reasonably implemented\n"
"-- using boolean functions. This utility helps with decidability\n"
"-- on such proofs.\n"
"test0 : (b : Bool) -> Dec0 (b === True)\n"
"test0 True  = Yes0 Refl\n"
"test0 False = No0 absurd\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1025
#, no-wrap
msgid ""
"We also want to run decidable computations at compile time. This\n"
"is often much more efficient than running a direct proof search on\n"
"an inductive type. We therefore come up with a predicate witnessing\n"
"that a `Dec0` value is actually a `Yes0` together with two\n"
"utility functions:\n"
msgstr "我们还希望在编译时运行可判定的计算。这通常比在归纳类型上运行直接证明搜索更有效。因此，我们提出了一个谓词，证明 `Dec0` 值实际上是 `Yes0` 以及两个实用函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1026
#, no-wrap
msgid ""
"data IsYes0 : (d : Dec0 prop) -> Type where\n"
"  ItIsYes0 : IsYes0 (Yes0 prf)\n"
"\n"
"0 fromYes0 : (d : Dec0 prop) -> (0 prf : IsYes0 d) => prop\n"
"fromYes0 (Yes0 x) = x\n"
"fromYes0 (No0 contra) impossible\n"
"\n"
"0 safeDecideOn :  (0 p : a -> Type)\n"
"               -> Decidable a p\n"
"               => (v : a)\n"
"               -> (0 prf : IsYes0 (decideOn p v))\n"
"               => p v\n"
"safeDecideOn p v = fromYes0 $ decideOn p v\n"
msgstr ""
"data IsYes0 : (d : Dec0 prop) -> Type where\n"
"  ItIsYes0 : IsYes0 (Yes0 prf)\n"
"\n"
"0 fromYes0 : (d : Dec0 prop) -> (0 prf : IsYes0 d) => prop\n"
"fromYes0 (Yes0 x) = x\n"
"fromYes0 (No0 contra) impossible\n"
"\n"
"0 safeDecideOn :  (0 p : a -> Type)\n"
"               -> Decidable a p\n"
"               => (v : a)\n"
"               -> (0 prf : IsYes0 (decideOn p v))\n"
"               => p v\n"
"safeDecideOn p v = fromYes0 $ decideOn p v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1045
#, no-wrap
msgid ""
"Finally, as we are planning to refine mostly primitives, we will\n"
"at times require some sledge hammer to convince Idris that\n"
"we know what we are doing:\n"
msgstr "最后，由于我们计划主要改进原语，我们有时需要一些大锤来说服 Idris 我们知道我们在做什么：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1046
#, no-wrap
msgid ""
"-- only use this if you are sure that `decideOn p v`\n"
"-- will return a `Yes0`!\n"
"0 unsafeDecideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> p v\n"
"unsafeDecideOn p v = case decideOn p v of\n"
"  Yes0 prf => prf\n"
"  No0  _   =>\n"
"    assert_total $ idris_crash \"Unexpected refinement failure in `unsafeRefineOn`\"\n"
msgstr ""
"-- only use this if you are sure that `decideOn p v`\n"
"-- will return a `Yes0`!\n"
"0 unsafeDecideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> p v\n"
"unsafeDecideOn p v = case decideOn p v of\n"
"  Yes0 prf => prf\n"
"  No0  _   =>\n"
"    assert_total $ idris_crash \"Unexpected refinement failure in `unsafeRefineOn`\"\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:1058
#, no-wrap
msgid ""
"We start with equality proofs. Implement `Decidable` for\n"
"`Equal v`.\n"
msgstr "我们从等式证明开始。为 `Equal v` 实现 `Decidable`。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1061
#, no-wrap
msgid ""
"   Hint: Use `DecEq` from module `Decidable.Equality` as a constraint\n"
"         and make sure that `v` is available at runtime.\n"
msgstr ""
"   提示：使用模块 `Decidable.Equality` 中的 `DecEq` 作为约束\n"
"         并确保 `v` 在运行时可用。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:1063
#, no-wrap
msgid "We want to be able to negate a predicate:\n"
msgstr "我们希望能够否定一个谓词：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1064
#, no-wrap
msgid ""
"   data Neg : (p : a -> Type) -> a -> Type where\n"
"     IsNot : {0 p : a -> Type} -> (contra : p v -> Void) -> Neg p v\n"
msgstr ""
"   data Neg : (p : a -> Type) -> a -> Type where\n"
"     IsNot : {0 p : a -> Type} -> (contra : p v -> Void) -> Neg p v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1070
#, no-wrap
msgid "   Implement `Decidable` for `Neg p` using a suitable constraint.\n"
msgstr "   使用合适的约束为 `Neg p` 实现 `Decidable`。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:1072
#, no-wrap
msgid "We want to describe the conjunction of two predicates:\n"
msgstr "我们要描述两个谓词的合取：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1073
#, no-wrap
msgid ""
"   data (&&) : (p,q : a -> Type) -> a -> Type where\n"
"     Both : {0 p,q : a -> Type} -> (prf1 : p v) -> (prf2 : q v) -> (&&) p q v\n"
msgstr ""
"   data (&&) : (p,q : a -> Type) -> a -> Type where\n"
"     Both : {0 p,q : a -> Type} -> (prf1 : p v) -> (prf2 : q v) -> (&&) p q v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1079
#, no-wrap
msgid "   Implement `Decidable` for `(p && q)` using suitable constraints.\n"
msgstr "   使用合适的约束为 `(p && q)` 实现 `Decidable`。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:1083
#, no-wrap
msgid ""
"Come up with a data type called `(||)` for the\n"
"disjunction (logical *or*) of two predicates and implement\n"
"`Decidable` using suitable constraints.\n"
msgstr "提出一个名为 `(||)` 的数据类型，用于两个谓词的析取（逻辑*或*），"
"并使用合适的约束实现 `Decidable`。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Prim.md:1086
#, no-wrap
msgid ""
"Proof [De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws)\n"
"by implementing the following propositions:\n"
msgstr "通过实施以下命题证明 [德摩根定律](https://en.wikipedia.org/wiki/De_Morgan"
"%27s_laws)：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1087
#, no-wrap
msgid ""
"   negOr : Neg (p || q) v -> (Neg p && Neg q) v\n"
"\n"
"   andNeg : (Neg p && Neg q) v -> Neg (p || q) v\n"
"\n"
"   orNeg : (Neg p || Neg q) v -> Neg (p && q) v\n"
msgstr ""
"   negOr : Neg (p || q) v -> (Neg p && Neg q) v\n"
"\n"
"   andNeg : (Neg p && Neg q) v -> Neg (p || q) v\n"
"\n"
"   orNeg : (Neg p || Neg q) v -> Neg (p && q) v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1100
#, no-wrap
msgid ""
"   The last of De Morgan's implications is harder to type and proof\n"
"   as we need a way to come up with values of type `p v` and `q v`\n"
"   and show that not both can exist. Here is a way to encode this\n"
"   (annotated with quantity 0 as we will need to access an erased\n"
"   contraposition):\n"
msgstr ""
"   德摩根的最后一个含义更难输入和证明\n"
"   因为我们需要一种方法来得出 `p v` 和 `q v` 类型的值\n"
"   并表明并非两者都可以存在。这是一种对此进行编码的方法\n"
"   （用定量 0 注释，因为我们需要访问已擦除的\n"
"   对偶）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1101
#, no-wrap
msgid ""
"   0 negAnd :  Decidable a p\n"
"            => Decidable a q\n"
"            => Neg (p && q) v\n"
"            -> (Neg p || Neg q) v\n"
msgstr ""
"   0 negAnd :  Decidable a p\n"
"            => Decidable a q\n"
"            => Neg (p && q) v\n"
"            -> (Neg p || Neg q) v\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1111
#, no-wrap
msgid ""
"   When you implement `negAnd`, remember that you can freely access\n"
"   erased (implicit) arguments, because `negAnd` itself can only be\n"
"   used in an erased context.\n"
msgstr ""
"   当你实现`negAnd`时，记住你可以自由访问\n"
"   擦除（隐式）参数，因为 `negAnd` 本身只能是\n"
"   在已删除的上下文中使用。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1117
#, no-wrap
msgid ""
"So far, we implemented the tools to algebraically describe\n"
"and combine several predicate. It is now time to come up\n"
"with some examples. As a first use case, we will focus on\n"
"limiting the valid range of natural numbers. For this,\n"
"we use the following data type:\n"
msgstr "到目前为止，我们实现了代数描述和组合几个谓词的工具。现在是提出一些例子的时候了。作为第一个用例，我们将专注于限制自然数的有效范围。为此，我们使用以下数据类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1118
#, no-wrap
msgid ""
"-- Proof that m <= n\n"
"data (<=) : (m,n : Nat) -> Type where\n"
"  ZLTE : 0 <= n\n"
"  SLTE : m <= n -> S m <= S n\n"
msgstr ""
"-- Proof that m <= n\n"
"data (<=) : (m,n : Nat) -> Type where\n"
"  ZLTE : 0 <= n\n"
"  SLTE : m <= n -> S m <= S n\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1128
#, no-wrap
msgid ""
"This is similar to `Data.Nat.LTE` but I find operator\n"
"notation often to be clearer.\n"
"We also can define and use the following aliases:\n"
msgstr "这类似于 `Data.Nat.LTE` 但我发现运算符符号通常更清晰。我们还可以定义和使用以下别名：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:1129
#, no-wrap
msgid ""
"(>=) : (m,n : Nat) -> Type\n"
"m >= n = n <= m\n"
"\n"
"(<) : (m,n : Nat) -> Type\n"
"m < n = S m <= n\n"
"\n"
"(>) : (m,n : Nat) -> Type\n"
"m > n = n < m\n"
"\n"
"LessThan : (m,n : Nat) -> Type\n"
"LessThan m = (< m)\n"
"\n"
"To : (m,n : Nat) -> Type\n"
"To m = (<= m)\n"
"\n"
"GreaterThan : (m,n : Nat) -> Type\n"
"GreaterThan m = (> m)\n"
"\n"
"From : (m,n : Nat) -> Type\n"
"From m = (>= m)\n"
"\n"
"FromTo : (lower,upper : Nat) -> Nat -> Type\n"
"FromTo l u = From l && To u\n"
"\n"
"Between : (lower,upper : Nat) -> Nat -> Type\n"
"Between l u = GreaterThan l && LessThan u\n"
msgstr ""
"(>=) : (m,n : Nat) -> Type\n"
"m >= n = n <= m\n"
"\n"
"(<) : (m,n : Nat) -> Type\n"
"m < n = S m <= n\n"
"\n"
"(>) : (m,n : Nat) -> Type\n"
"m > n = n < m\n"
"\n"
"LessThan : (m,n : Nat) -> Type\n"
"LessThan m = (< m)\n"
"\n"
"To : (m,n : Nat) -> Type\n"
"To m = (<= m)\n"
"\n"
"GreaterThan : (m,n : Nat) -> Type\n"
"GreaterThan m = (> m)\n"
"\n"
"From : (m,n : Nat) -> Type\n"
"From m = (>= m)\n"
"\n"
"FromTo : (lower,upper : Nat) -> Nat -> Type\n"
"FromTo l u = From l && To u\n"
"\n"
"Between : (lower,upper : Nat) -> Nat -> Type\n"
"Between l u = GreaterThan l && LessThan u\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Prim.md:1171
#, no-wrap
msgid ""
"Coming up with a value of type `m <= n` by pattern\n"
"matching on `m` and `n` is highly inefficient for\n"
"large values of `m`, as it will require `m` iterations\n"
"to do so. However, while in an erased context, we don't\n"
"need to hold a value of type `m <= n`. We only need to\n"
"show, that such a value follows from a more efficient\n"
"computation. Such a computation is `compare` for natural\n"
"numbers: Although this is implemented in the *Prelude* with\n"
"a pattern match on its arguments, it is optimized\n"
"by the compiler to a comparison of integers which runs\n"
"in constant time even for very large numbers.\n"
"Since `Prelude.(<=)` for natural numbers is implemented in terms of\n"
"`compare`, it runs just as efficiently.\n"
msgstr ""
"通过在 `m` 和 `n` 上进行模式匹配来得出 `m <= n` 类型的值对于较大的 `m` "
"值非常低效，因为这样做需要 `m` 次迭代。但是，在擦除上下文中，我们不需要保存 `"
"m <= n` 类型的值。我们只需要证明，这样的值来自更有效的计算。对于自然数，"
"这样的计算是 `compare`：尽管这是在 *Prelude* 中实现的，其参数的模式匹配，但编"
"译器将其优化为运行在即使对于非常大的数字也是恒定的时间。由于自然数的 "
"`Prelude.(<=)` 是根据 `compare` 实现的，因此它的运行效率同样高。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1175
#, no-wrap
msgid ""
"   We therefore need to proof the following two lemmas (make\n"
"   sure to not confuse `Prelude.(<=)` with `Prim.(<=)` in\n"
"   these declarations):\n"
msgstr ""
"   因此，我们需要证明以下两个引理（使\n"
"   确保不要将 `Prelude.(<=)` 与 `Prim.(<=)` 混淆\n"
"   这些声明）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1176
#, no-wrap
msgid ""
"   0 fromLTE : (n1,n2 : Nat) -> (n1 <= n2) === True -> n1 <= n2\n"
"\n"
"   0 toLTE : (n1,n2 : Nat) -> n1 <= n2 -> (n1 <= n2) === True\n"
msgstr ""
"   0 fromLTE : (n1,n2 : Nat) -> (n1 <= n2) === True -> n1 <= n2\n"
"\n"
"   0 toLTE : (n1,n2 : Nat) -> n1 <= n2 -> (n1 <= n2) === True\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1185
#, no-wrap
msgid ""
"   They come with a quantity of 0, because they are just as inefficient\n"
"   as the other computations we discussed above. We therefore want\n"
"   to make absolutely sure that they will never be used at runtime!\n"
msgstr ""
"   它们的定量为 0，因为它们同样低效\n"
"   正如我们上面讨论的其他计算。因此我们想要\n"
"   绝对确保它们永远不会在运行时使用！\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1190
#, no-wrap
msgid ""
"   Now, implement `Decidable Nat (<= n)`, making use of `test0`,\n"
"   `fromLTE`, and `toLTE`.\n"
"   Likewise, implement `Decidable Nat (m <=)`, because we require\n"
"   both kinds of predicates.\n"
msgstr ""
"   现在，利用 `test0` 实现 `Decidable Nat (<= n)`，\n"
"   `从LTE` 和 `到LTE`。\n"
"   同样，实现 `Decidable Nat (m <=)`，因为我们需要\n"
"   两种谓词。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1193
#, no-wrap
msgid ""
"   Note: You should by know figure out yourself that `n` must be\n"
"   available at runtime and how to make sure that this is the case.\n"
msgstr ""
"   注意：您应该自己知道 `n` 必须是\n"
"   在运行时可用以及如何确保是这种情况。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Prim.md:1198
#, no-wrap
msgid ""
"Proof that `(<=)` is reflexive and transitive by declaring and\n"
"implementing corresponding propositions. As we might require\n"
"the proof of transitivity to chain several values of type `(<=)`,\n"
"it makes sense to also define a short operator alias for this.\n"
msgstr ""
"通过声明和实现相应的命题证明 `(<=)` 是自反和传递的。"
"由于我们可能需要传递性证明来链接多个类型为 `(<=)` "
"的值，因此也可以为此定义一个简短的运算符别名。\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Prim.md:1200
#, no-wrap
msgid "Proof that from `n > 0` follows `IsSucc n` and vise versa.\n"
msgstr "证明从 `n > 0` 遵循 `IsSucc n`，反之亦然。\n"

#. type: Bullet: '9. '
#: ../src/Tutorial/Prim.md:1207
#, no-wrap
msgid ""
"Declare and implement safe division and modulo functions\n"
"for `Bits64`, by requesting an erased proof that\n"
"the denominator is strictly positive when cast to a natural\n"
"number. In case of the modulo function, return a refined\n"
"value carrying an erased proof that the result is strictly\n"
"smaller than the modulus:\n"
msgstr ""
"声明并实现 `Bits64` 的安全除法和模函数，方法是请求删除证明，证明分母在转换为"
"自然数时严格为正。在模函数的情况下，返回一个精确的值，带有一个删除的证明，证"
"明结果严格小于模数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1208
#, no-wrap
msgid ""
"   safeMod :  (x,y : Bits64)\n"
"           -> (0 prf : cast y > 0)\n"
"           => Subset Bits64 (\\v => cast v < cast y)\n"
msgstr ""
"   safeMod :  (x,y : Bits64)\n"
"           -> (0 prf : cast y > 0)\n"
"           => Subset Bits64 (\\v => cast v < cast y)\n"

#. type: Bullet: '10. '
#: ../src/Tutorial/Prim.md:1218
#, no-wrap
msgid ""
"We will use the predicates and utilities we defined so\n"
"far to convert a value of type `Bits64` to a string\n"
"of digits in base `b` with `2 <= b && b <= 16`.\n"
"To do so, implement the following skeleton definitions:\n"
msgstr ""
"我们将使用到目前为止定义的谓词和实用程序将 `Bits64` 类型的值转换为基数 `b` "
"中的数字字符串，其中 `2 <= b && b <= 16`。为此，请实现以下骨架定义：\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1223
#, no-wrap
msgid ""
"    ```idris\n"
"    -- this will require some help from `assert_total`\n"
"    -- and `idris_crash`.\n"
"    digit : (v : Bits64) -> (0 prf : cast v < 16) => Char\n"
msgstr ""
"    ```idris\n"
"    -- this will require some help from `assert_total`\n"
"    -- and `idris_crash`.\n"
"    digit : (v : Bits64) -> (0 prf : cast v < 16) => Char\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1228
#, no-wrap
msgid ""
"    record Base where\n"
"      constructor MkBase\n"
"      value : Bits64\n"
"      0 prf : FromTo 2 16 (cast value)\n"
msgstr ""
"    record Base where\n"
"      constructor MkBase\n"
"      value : Bits64\n"
"      0 prf : FromTo 2 16 (cast value)\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1230
#, no-wrap
msgid "    base : Bits64 -> Maybe Base\n"
msgstr "    base : Bits64 -> Maybe Base\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1235
#, no-wrap
msgid ""
"    namespace Base\n"
"      public export\n"
"      fromInteger : (v : Integer) -> {auto 0 _ : IsJust (base $ cast v)} -> Base\n"
"    ```\n"
msgstr ""
"    namespace Base\n"
"      public export\n"
"      fromInteger : (v : Integer) -> {auto 0 _ : IsJust (base $ cast v)} -> Base\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1241
#, no-wrap
msgid ""
"    Finally, implement `digits`, using `safeDiv` and `safeMod`\n"
"    in your implementation. This might be challenging, as you will\n"
"    have to manually transform some proofs to satisfy the type\n"
"    checker. You might also require `assert_smaller` in the\n"
"    recursive step.\n"
msgstr ""
"    最后，使用 `safeDiv` 和 `safeMod` 实现 `digits`\n"
"    在您的实现中。这可能具有挑战性，因为您将\n"
"    必须手动转换一些证明以满足类型\n"
"    检查器。您可能还需要 `assert_smaller` 在\n"
"    递归步骤。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1245
#, no-wrap
msgid ""
"    ```idris\n"
"    digits : Bits64 -> Base -> String\n"
"    ```\n"
msgstr ""
"    ```idris\n"
"    digits : Bits64 -> Base -> String\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1255
#, no-wrap
msgid ""
"We will now turn our focus on strings. Two of the most\n"
"obvious ways in which we can restrict the strings we\n"
"accept are by limiting the set of characters and\n"
"limiting their lengths. More advanced refinements might\n"
"require strings to match a certain pattern or regular\n"
"expression. In such cases, we might either go for a\n"
"boolean check or use a custom data type representing the\n"
"different parts of the pattern, but we will not cover\n"
"these topics here.\n"
msgstr "我们现在将注意力转向字符串。我们可以限制我们接受的字符串的两种最明显的方法是限制字符集和限制它们的长度。更高级的改进可能需要字符串匹配某个模式或正则表达式。在这种情况下，我们可能会进行布尔检查或使用自定义数据类型来表示模式的不同部分，但我们不会在这里讨论这些主题。\n"

#. type: Bullet: '11. '
#: ../src/Tutorial/Prim.md:1258
#, no-wrap
msgid ""
"Implement the following aliases for useful predicates on\n"
"characters.\n"
msgstr "为字符上的有用谓词实现以下别名。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1262
#, no-wrap
msgid ""
"    Hint: Use `cast` to convert characters to natural numbers,\n"
"    use `(<=)` and `InRange` to specify regions of characters,\n"
"    and use `(||)` to combine regions of characters.\n"
msgstr ""
"    提示：使用 `cast` 将字符转换为自然数，\n"
"    使用 `(<=)` 和 `InRange` 指定字符区域，\n"
"    并使用 `(||)` 组合字符区域。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1266
#, no-wrap
msgid ""
"    ```idris\n"
"    -- Characters <= 127\n"
"    IsAscii : Char -> Type\n"
msgstr ""
"    ```idris\n"
"    -- Characters <= 127\n"
"    IsAscii : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1269
#, no-wrap
msgid ""
"    -- Characters <= 255\n"
"    IsLatin : Char -> Type\n"
msgstr ""
"    -- Characters <= 255\n"
"    IsLatin : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1272
#, no-wrap
msgid ""
"    -- Characters in the interval ['A','Z']\n"
"    IsUpper : Char -> Type\n"
msgstr ""
"    -- Characters in the interval ['A','Z']\n"
"    IsUpper : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1275
#, no-wrap
msgid ""
"    -- Characters in the interval ['a','z']\n"
"    IsLower : Char -> Type\n"
msgstr ""
"    -- Characters in the interval ['a','z']\n"
"    IsLower : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1278
#, no-wrap
msgid ""
"    -- Lower or upper case characters\n"
"    IsAlpha : Char -> Type\n"
msgstr ""
"    -- Lower or upper case characters\n"
"    IsAlpha : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1281
#, no-wrap
msgid ""
"    -- Characters in the range ['0','9']\n"
"    IsDigit : Char -> Type\n"
msgstr ""
"    -- Characters in the range ['0','9']\n"
"    IsDigit : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1284
#, no-wrap
msgid ""
"    -- Digits or characters from the alphabet\n"
"    IsAlphaNum : Char -> Type\n"
msgstr ""
"    -- Digits or characters from the alphabet\n"
"    IsAlphaNum : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1287
#, no-wrap
msgid ""
"    -- Characters in the ranges [0,31] or [127,159]\n"
"    IsControl : Char -> Type\n"
msgstr ""
"    -- Characters in the ranges [0,31] or [127,159]\n"
"    IsControl : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1290
#, no-wrap
msgid ""
"    -- An ASCII character that is not a control character\n"
"    IsPlainAscii : Char -> Type\n"
msgstr ""
"    -- An ASCII character that is not a control character\n"
"    IsPlainAscii : Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1294
#, no-wrap
msgid ""
"    -- A latin character that is not a control character\n"
"    IsPlainLatin : Char -> Type\n"
"    ```\n"
msgstr ""
"    -- A latin character that is not a control character\n"
"    IsPlainLatin : Char -> Type\n"
"    ```\n"

#. type: Bullet: '12. '
#: ../src/Tutorial/Prim.md:1301
#, no-wrap
msgid ""
"The advantage of this more modular approach to predicates\n"
"on primitives is that we can safely run calculations on\n"
"our predicates and get the strong guarantees from the existing\n"
"proofs on inductive types like `Nat` and `List`. Here are\n"
"some examples of such calculations and conversions, all of which\n"
"can be implemented without cheating:\n"
msgstr ""
"这种更模块化的原语谓词方法的优势在于，我们可以安全地对谓词运行计算，并从现有"
"的关于归纳类型（如 `Nat` 和 `List`）的证明中获得强有力的保证。以下是此类计算"
"和转换的一些示例，所有这些都可以在不作弊的情况下实现：\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1304
#, no-wrap
msgid ""
"    ```idris\n"
"    0 plainToAscii : IsPlainAscii c -> IsAscii c\n"
msgstr ""
"    ```idris\n"
"    0 plainToAscii : IsPlainAscii c -> IsAscii c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1306
#, no-wrap
msgid "    0 digitToAlphaNum : IsDigit c -> IsAlphaNum c\n"
msgstr "    0 digitToAlphaNum : IsDigit c -> IsAlphaNum c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1308
#, no-wrap
msgid "    0 alphaToAlphaNum : IsAlpha c -> IsAlphaNum c\n"
msgstr "    0 alphaToAlphaNum : IsAlpha c -> IsAlphaNum c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1310
#, no-wrap
msgid "    0 lowerToAlpha : IsLower c -> IsAlpha c\n"
msgstr "    0 lowerToAlpha : IsLower c -> IsAlpha c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1312
#, no-wrap
msgid "    0 upperToAlpha : IsUpper c -> IsAlpha c\n"
msgstr "    0 upperToAlpha : IsUpper c -> IsAlpha c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1314
#, no-wrap
msgid "    0 lowerToAlphaNum : IsLower c -> IsAlphaNum c\n"
msgstr "    0 lowerToAlphaNum : IsLower c -> IsAlphaNum c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1317
#, no-wrap
msgid ""
"    0 upperToAlphaNum : IsUpper c -> IsAlphaNum c\n"
"    ```\n"
msgstr ""
"    0 upperToAlphaNum : IsUpper c -> IsAlphaNum c\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1324
#, no-wrap
msgid ""
"    The following (`asciiToLatin`) is trickier. Remember that\n"
"    `(<=)` is transitive. However, in your invocation of the proof\n"
"    of transitivity, you will not be able to apply direct proof search using\n"
"    `%search` because the search depth is too small. You could\n"
"    increase the search depth, but it is much more efficient\n"
"    to use `safeDecideOn` instead.\n"
msgstr ""
"    以下 (`asciiToLatin`) 比较棘手。请记住\n"
"    `(<=)` 是传递的。但是，在您调用证明时\n"
"    传递性，您将无法使用直接证明搜索\n"
"    `%search` 因为搜索深度太小。你可以\n"
"    增加搜索深度，但\n"
"    改为使用 `safeDecideOn` 效率更高。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1327
#, no-wrap
msgid ""
"    ```idris\n"
"    0 asciiToLatin : IsAscii c -> IsLatin c\n"
msgstr ""
"    ```idris\n"
"    0 asciiToLatin : IsAscii c -> IsLatin c\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1330
#, no-wrap
msgid ""
"    0 plainAsciiToPlainLatin : IsPlainAscii c -> IsPlainLatin c\n"
"    ```\n"
msgstr ""
"    0 plainAsciiToPlainLatin : IsPlainAscii c -> IsPlainLatin c\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1334
#, no-wrap
msgid ""
"Before we turn our full attention to predicates on strings,\n"
"we have to cover lists first, because we will often treat\n"
"strings as lists of characters.\n"
msgstr "在我们将全部注意力转向字符串谓词之前，我们必须先介绍列表，因为我们经常将字符串视为字符列表。\n"

#. type: Bullet: '13. '
#: ../src/Tutorial/Prim.md:1336
#, no-wrap
msgid "Implement `Decidable` for `Head`:\n"
msgstr "为 `Head` 实现 `Decidable`：\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1341
#, no-wrap
msgid ""
"    ```idris\n"
"    data Head : (p : a -> Type) -> List a -> Type where\n"
"      AtHead : {0 p : a -> Type} -> (0 prf : p v) -> Head p (v :: vs)\n"
"    ```\n"
msgstr ""
"    ```idris\n"
"    data Head : (p : a -> Type) -> List a -> Type where\n"
"      AtHead : {0 p : a -> Type} -> (0 prf : p v) -> Head p (v :: vs)\n"
"    ```\n"

#. type: Bullet: '14. '
#: ../src/Tutorial/Prim.md:1343
#, no-wrap
msgid "Implement `Decidable` for `Length`:\n"
msgstr "为 `Length` 实现 `Decidable`：\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1350
#, no-wrap
msgid ""
"    ```idris\n"
"    data Length : (p : Nat -> Type) -> List a -> Type where\n"
"      HasLength :  {0 p : Nat -> Type}\n"
"                -> (0 prf : p (List.length vs))\n"
"                -> Length p vs\n"
"    ```\n"
msgstr ""
"    ```idris\n"
"    data Length : (p : Nat -> Type) -> List a -> Type where\n"
"      HasLength :  {0 p : Nat -> Type}\n"
"                -> (0 prf : p (List.length vs))\n"
"                -> Length p vs\n"
"    ```\n"

#. type: Bullet: '15. '
#: ../src/Tutorial/Prim.md:1354
#, no-wrap
msgid ""
"The following predicate is a proof that all values in a list\n"
"of values fulfill the given predicate. We will use this to limit\n"
"the valid set of characters in a string.\n"
msgstr "以下谓词证明值列表中的所有值都满足给定谓词。我们将使用它来限制字符串中的有效"
"字符集。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1363
#, no-wrap
msgid ""
"    ```idris\n"
"    data All : (p : a -> Type) -> (as : List a) -> Type where\n"
"      Nil  : All p []\n"
"      (::) :  {0 p : a -> Type}\n"
"           -> (0 h : p v)\n"
"           -> (0 t : All p vs)\n"
"           -> All p (v :: vs)\n"
"    ```\n"
msgstr ""
"    ```idris\n"
"    data All : (p : a -> Type) -> (as : List a) -> Type where\n"
"      Nil  : All p []\n"
"      (::) :  {0 p : a -> Type}\n"
"           -> (0 h : p v)\n"
"           -> (0 t : All p vs)\n"
"           -> All p (v :: vs)\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1365
#, no-wrap
msgid "    Implement `Decidable` for `All`.\n"
msgstr "    为 `All` 实现 `Decidable`。\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1373
#, no-wrap
msgid ""
"    For a real challenge, try to make your implementation of\n"
"    `decide` tail recursive. This will be important for real world\n"
"    applications on the JavaScript backends, where we might want to\n"
"    refine strings of thousands of characters without overflowing the\n"
"    stack at runtime. In order to come up with a tail recursive implementation,\n"
"    you will need an additional data type `AllSnoc` witnessing that a predicate\n"
"    holds for all elements in a `SnocList`.\n"
msgstr ""
"    对于真正的挑战，请尝试使您的\n"
"    `decide`  实现尾递归。这对JavaScript 后端上的现实世界应用程序很重要，我们可能想要精炼数千个字符的字符串的地方\n"
"    而不会在运行时堆栈溢出。为了提出尾递归实现，\n"
"    您将需要一个额外的数据类型 `AllSnoc` 来见证谓词\n"
"    适用于 `SnocList` 中的所有元素。\n"

#. type: Bullet: '16. '
#: ../src/Tutorial/Prim.md:1379
#, no-wrap
msgid ""
"It's time to come to an end here. An identifier in Idris is a sequence\n"
"of alphanumeric characters, possibly separated by underscore characters\n"
"(`_`). In addition, all identifiers must start with a letter.\n"
"Given this specification, implement predicate `IdentChar`, from\n"
"which we can define a new wrapper type for identifiers:\n"
msgstr ""
"是时候在这里结束了。 Idris 中的标识符是一系列字母数字字符，可能由下划线字符 "
"(`_`) 分隔。此外，所有标识符都必须以字母开头。给定这个规范，实现谓词 "
"`IdentChar`，我们可以从中为标识符定义一个新的包装器类型：\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1382
#, no-wrap
msgid ""
"    ```idris\n"
"    0 IdentChars : List Char -> Type\n"
msgstr ""
"    ```idris\n"
"    0 IdentChars : List Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1388
#, no-wrap
msgid ""
"    record Identifier where\n"
"      constructor MkIdentifier\n"
"      value : String\n"
"      0 prf : IdentChars (unpack value)\n"
"    ```\n"
msgstr ""
"    record Identifier where\n"
"      constructor MkIdentifier\n"
"      value : String\n"
"      0 prf : IdentChars (unpack value)\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1391
#, no-wrap
msgid ""
"    Implement a factory method `identifier` for converting strings\n"
"    of unknown source at runtime:\n"
msgstr "    实现一个工厂方法 `identifier` 来转换运行时未知来源的字符串 ：\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1395
#, no-wrap
msgid ""
"    ```idris\n"
"    identifier : String -> Maybe Identifier\n"
"    ```\n"
msgstr ""
"    ```idris\n"
"    identifier : String -> Maybe Identifier\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1398
#, no-wrap
msgid ""
"    In addition, implement `fromString` for `Identifier` and verify,\n"
"    that the following is a valid identifier:\n"
msgstr ""
"    此外，为 `Identifier` 实现 `fromString` 并验证，\n"
"    以下是有效的标识符：\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1403
#, no-wrap
msgid ""
"    ```idris\n"
"    testIdent : Identifier\n"
"    testIdent = \"fooBar_123\"\n"
"    ```\n"
msgstr ""
"    ```idris\n"
"    testIdent : Identifier\n"
"    testIdent = \"fooBar_123\"\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1409
#, no-wrap
msgid ""
"Final remarks: Proofing stuff about the primitives can be challenging,\n"
"both when deciding on what axioms to use and when trying to make\n"
"things perform well at runtime and compile time. I'm experimenting\n"
"with a library, which deals with these issues. It is not yet finished,\n"
"but you can have a look at it [here](https://github.com/stefan-hoeck/idris2-prim).\n"
msgstr "最后的评论：在决定使用什么公理以及试图使事情在运行时和编译时表现良好时，证明关于原语的东西可能具有挑战性。我正在尝试一个处理这些问题的库。它尚未完成，但您可以在 [这里](https://github.com/stefan-hoeck/idris2-prim) 看看它。\n"

#. type: Title #
#: ../src/Tutorial/Traverse.md:1
#, no-wrap
msgid "Effectful Traversals"
msgstr "遍历副作用"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:11
#, no-wrap
msgid ""
"In this chapter, we are going to bring our treatment\n"
"of the higher-kinded interfaces in the *Prelude* to an\n"
"end. In order to do so, we will continue developing the\n"
"CSV reader we started implementing in chapter\n"
"[Functor and Friends](Functor.md). I moved some of\n"
"the data types and interfaces from that chapter to\n"
"their own modules, so we can import them here without\n"
"the need to start from scratch.\n"
msgstr ""
"在本章中，我们将带来 *Prelude* 中更高种类的接口。为此，我们将继续开发\n"
"我们在 [函子和朋友](Functor.md) 章节中开始实现的 CSV 阅读器。我移动了一些\n"
"该章的数据类型和接口到他们自己的模块，所以我们可以在这里导入它们而无需从头开始。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:16
#, no-wrap
msgid ""
"Note that unlike in our original CSV reader, we will use\n"
"`Validated` instead of `Either` for handling exceptions,\n"
"since this will allow us to accumulate all errors\n"
"when reading a CSV file.\n"
msgstr ""
"请注意，与我们原来的 CSV 阅读器不同，我们将使用 `Validated` 而不是 `Either` 处理异常，\n"
"因为这将使我们能够累积读取 CSV 文件时的所有错误。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:17
#, no-wrap
msgid ""
"module Tutorial.Traverse\n"
"\n"
"import Data.HList\n"
"import Data.IORef\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Validated\n"
"import Data.Vect\n"
"import Text.CSV\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Traverse\n"
"\n"
"import Data.HList\n"
"import Data.IORef\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Validated\n"
"import Data.Vect\n"
"import Text.CSV\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Traverse.md:31
#, no-wrap
msgid "Reading CSV Tables"
msgstr "读取 CSV 表"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:37
#, no-wrap
msgid ""
"We stopped developing our CSV reader with function\n"
"`hdecode`, which allows us to read a single line\n"
"in a CSV file and decode it to a heterogeneous list.\n"
"As a reminder, here is how to use `hdecode` at the REPL:\n"
msgstr ""
"我们停止开发具有 `hdecode` 函数—的 CSV 阅读器，它允许我们在 CSV 文件中读取单行并将其解码为异构列表。\n"
"提醒一下，这里是如何在 REPL 中使用 `hdecode` ：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:38
#, no-wrap
msgid ""
"Tutorial.Traverse> hdecode [Bool,String,Bits8] 1 \"f,foo,12\"\n"
"Valid [False, \"foo\", 12]\n"
msgstr ""
"Tutorial.Traverse> hdecode [Bool,String,Bits8] 1 \"f,foo,12\"\n"
"Valid [False, \"foo\", 12]\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:51
#, no-wrap
msgid ""
"The next step will be to parse a whole CSV table, represented\n"
"as a list of strings, where each string corresponds to one\n"
"of the table's rows.\n"
"We will go about this stepwise as there are several aspects\n"
"about doing this properly. What we are looking for - eventually -\n"
"is a function of the following type (we are going to\n"
"implement several versions of this function, hence the\n"
"numbering):\n"
msgstr ""
"下一步将解析整个 CSV 表作为字符串列表，其中每个字符串对应一个\n"
"表的一行。\n"
"我们将逐步进行，因为有几个方面可以正确地做到这一点。我们正在寻找的——最终—— 是以下类型的函数（我们将实现这个函数的几个版本，因此我们给它了编号）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:52
#, no-wrap
msgid ""
"hreadTable1 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
msgstr ""
"hreadTable1 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:61
#, no-wrap
msgid ""
"In our first implementation, we are not going to care\n"
"about line numbers:\n"
msgstr ""
"在我们的第一个实现中，我们不会关心\n"
"关于行号的事情：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:62
#, no-wrap
msgid ""
"hreadTable1 _  []        = pure []\n"
"hreadTable1 ts (s :: ss) = [| hdecode ts 0 s :: hreadTable1 ts ss |]\n"
msgstr ""
"hreadTable1 _  []        = pure []\n"
"hreadTable1 ts (s :: ss) = [| hdecode ts 0 s :: hreadTable1 ts ss |]\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:72
#, no-wrap
msgid ""
"Note, how we can just use applicative syntax in the implementation\n"
"of `hreadTable1`. To make this clearer, I used `pure []` on the first\n"
"line instead of the more specific `Valid []`. In fact, if we used\n"
"`Either` or `Maybe` instead of `Validated` for error handling,\n"
"the implementation of `hreadTable1` would look exactly the same.\n"
msgstr ""
"注意，我们如何在 `hreadTable1` 的实现中使用应用函子语法。为了更清楚，我优先使用 `pure []` 而不是更具体的 `Valid []`。事实上，如果我们使用\n"
"`Either` 或 `Maybe` 而不是 `Validated` 用于错误处理，\n"
"`hreadTable1` 的实现看起来完全一样。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:81
#, no-wrap
msgid ""
"The question is: Can we extract a pattern to abstract over\n"
"from this observation? What we do in `hreadTable1` is running\n"
"an effectful computation of type `String -> Validated CSVError (HList ts)`\n"
"over a list of strings, so that the result is a list of `HList ts`\n"
"wrapped in a `Validated CSVError`. The first step of abstraction\n"
"should be to use type parameters for the input and output:\n"
"Run a computation of type `a -> Validated CSVError b` over a\n"
"list `List a`:\n"
msgstr ""
"问题是：我们从这个观察中可以提取一个模式来抽象吗？我们在 `hreadTable1` 中运行字符串列表上的副作用计算，类型为 `String -> Validated CSVError (HList ts)`，因此结果是 `HList ts` 的列表\n"
"且包裹在 `Validated CSVError` 中。抽象的第一步\n"
"应该是对输入和输出使用类型参数：\n"
"在列表 `List a` 上运行 `a -> Validated CSVError b` 类型的计算：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:82
#, no-wrap
msgid ""
"traverseValidatedList :  (a -> Validated CSVError b)\n"
"                      -> List a\n"
"                      -> Validated CSVError (List b)\n"
"traverseValidatedList _ []        = pure []\n"
"traverseValidatedList f (x :: xs) = [| f x :: traverseValidatedList f xs |]\n"
"\n"
"hreadTable2 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable2 ts = traverseValidatedList (hdecode ts 0)\n"
msgstr ""
"traverseValidatedList :  (a -> Validated CSVError b)\n"
"                      -> List a\n"
"                      -> Validated CSVError (List b)\n"
"traverseValidatedList _ []        = pure []\n"
"traverseValidatedList f (x :: xs) = [| f x :: traverseValidatedList f xs |]\n"
"\n"
"hreadTable2 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable2 ts = traverseValidatedList (hdecode ts 0)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:104
#, no-wrap
msgid ""
"But our observation was, that the implementation of `hreadTable1`\n"
"would be exactly the same if we used `Either CSVError` or `Maybe`\n"
"as our effect types instead of `Validated CSVError`.\n"
"So, the next step should be to abstract over the *effect type*.\n"
"We note, that we used applicative syntax (idiom brackets and\n"
"`pure`) in our implementation, so we will need to write\n"
"a function with an `Applicative` constraint\n"
"on the effect type:\n"
msgstr ""
"但我们的观察是，如果我们使用 `Either CSVError` 或 `Maybe` 代替 `Validated CSVError`作为我们的副作用类型，`hreadTable1` 的实现将完全相同。\n"
"所以，下一步应该是对*副作用类型*进行抽象。\n"
"我们注意到，我们使用了应用函子语法（习语括号和\n"
"`pure`) 在我们的实现中，所以我们需要编写\n"
"关于副作用类型具有 `Applicative` 约束的函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:105
#, no-wrap
msgid ""
"traverseList :  Applicative f => (a -> f b) -> List a -> f (List b)\n"
"traverseList _ []        = pure []\n"
"traverseList f (x :: xs) = [| f x :: traverseList f xs |]\n"
"\n"
"hreadTable3 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable3 ts = traverseList (hdecode ts 0)\n"
msgstr ""
"traverseList :  Applicative f => (a -> f b) -> List a -> f (List b)\n"
"traverseList _ []        = pure []\n"
"traverseList f (x :: xs) = [| f x :: traverseList f xs |]\n"
"\n"
"hreadTable3 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable3 ts = traverseList (hdecode ts 0)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:120
#, no-wrap
msgid ""
"Note, how the implementation of `traverseList` is exactly the same\n"
"as the one of `traverseValidatedList`, but the types are more general\n"
"and therefore, `traverseList` is much more powerful.\n"
msgstr ""
"注意，`traverseList`的实现和 `traverseValidatedList` 完全一样的，但类型更通用\n"
"因此，`traverseList` 更强大。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:123
#, no-wrap
msgid ""
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"f,12\",\"t,0\"]\n"
"Valid [[False, 12], [True, 0]]\n"
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"f,12\",\"t,1000\"]\n"
"Invalid (FieldError 0 2 \"1000\")\n"
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"1,12\",\"t,1000\"]\n"
"Invalid (Append (FieldError 0 1 \"1\") (FieldError 0 2 \"1000\"))\n"
msgstr ""
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"f,12\",\"t,0\"]\n"
"Valid [[False, 12], [True, 0]]\n"
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"f,12\",\"t,1000\"]\n"
"Invalid (FieldError 0 2 \"1000\")\n"
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"1,12\",\"t,1000\"]\n"
"Invalid (Append (FieldError 0 1 \"1\") (FieldError 0 2 \"1000\"))\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:139
#, no-wrap
msgid ""
"This works very well already, but note how our error messages do\n"
"not yet print the correct line numbers. That's not surprising,\n"
"as we are using a dummy constant in our call to `hdecode`.\n"
"We will look at how we can come up with the line numbers on the\n"
"fly when we talk about stateful computations later in this chapter.\n"
"For now, we could just manually annotate the lines with their\n"
"numbers and pass a list of pairs to `hreadTable`:\n"
msgstr ""
"这已经很好用了，但请注意我们的错误消息是如何做的，\n"
"尚未打印正确的行号。这并不奇怪，\n"
"因为我们在调用 `hdecode` 时使用了一个虚拟常量。\n"
"我们将研究如何得出行号\n"
"当我们在本章后面讨论有状态计算时会飞起来。\n"
"现在，我们可以手动注释这些行号并将一对列表传递给 `hreadTable`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:140
#, no-wrap
msgid ""
"hreadTable4 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List (Nat, String)\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable4 ts = traverseList (uncurry $ hdecode ts)\n"
msgstr ""
"hreadTable4 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List (Nat, String)\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable4 ts = traverseList (uncurry $ hdecode ts)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:154
#, no-wrap
msgid ""
"If this is the first time you came across function `uncurry`,\n"
"make sure you have a look at its type and try to figure out why it is\n"
"used here. There are several utility functions like this\n"
"in the *Prelude*, such as `curry`, `uncurry`, `flip`, or even\n"
"`id`, all of which can be very useful when working with higher-order\n"
"functions.\n"
msgstr ""
"如果这是你第一次遇到函数 `uncurry`，\n"
"确保您查看了它的类型并尝试找出它在这里被使用的原因。在 *Prelude* 中有几个这样的实用函数，如`curry`、`uncurry`、`flip`，还有 `id`，所有这些在处理高阶函数时都非常有用。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:157
#, no-wrap
msgid ""
"While not perfect, this version at least allows us to verify at the REPL\n"
"that the line numbers are passed to the error messages correctly:\n"
msgstr "虽然不完美，但这个版本至少允许我们在 REPL 进行验证行号正确传递的错误消息：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:158
#, no-wrap
msgid ""
"Tutorial.Traverse> hreadTable4 [Bool,Bits8] [(1,\"t,1000\"),(2,\"1,100\")]\n"
"Invalid (Append (FieldError 1 2 \"1000\") (FieldError 2 1 \"1\"))\n"
msgstr ""
"Tutorial.Traverse> hreadTable4 [Bool,Bits8] [(1,\"t,1000\"),(2,\"1,100\")]\n"
"Invalid (Append (FieldError 1 2 \"1000\") (FieldError 2 1 \"1\"))\n"

#. type: Title ###
#: ../src/Tutorial/Traverse.md:163
#, no-wrap
msgid "Interface Traversable"
msgstr "Traversable 接口"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:172
#, no-wrap
msgid ""
"Now, here is an interesting observation: We can implement a function\n"
"like `traverseList` for other container types as well. You might think that's\n"
"obvious, given that we can convert container types to lists via\n"
"function `toList` from interface `Foldable`. However, while going\n"
"via `List` might be feasible in some occasions, it is undesirable in\n"
"general, as we loose typing information. For instance, here\n"
"is such a function for `Vect`:\n"
msgstr ""
"现在，这里有一个有趣的现象：我们可以实现一个函数，\n"
"像其他容器类型的 `traverseList` 那样。你可能认为那是很简单的，鉴于我们可以通过以下方式将容器类型转换为列表\n"
"来自接口 `Foldable` 的函数 `toList`。然而，通过 `List` 来处理在某些情况下可能是可行的，一般来说，我们会丢失了类型信息。例如，这里 `Vect` 的函数是这样的：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:173
#, no-wrap
msgid ""
"traverseVect' : Applicative f => (a -> f b) -> Vect n a -> f (List b)\n"
"traverseVect' fun = traverseList fun . toList\n"
msgstr ""
"traverseVect' : Applicative f => (a -> f b) -> Vect n a -> f (List b)\n"
"traverseVect' fun = traverseList fun . toList\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:182
#, no-wrap
msgid ""
"Note how we lost all information about the structure of the\n"
"original container type. What we are looking for is a function\n"
"like `traverseVect'`, which keeps this type level information:\n"
"The result should be a vector of the same length as the input.\n"
msgstr "注意我们是如何丢失了所有关于原始容器类型结构的信息的。我们要找的是像`traverseVect'` 的一个函数，它保留了这个类型级别的信息：结果应该是与输入长度相同的向量。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:183
#, no-wrap
msgid ""
"traverseVect : Applicative f => (a -> f b) -> Vect n a -> f (Vect n b)\n"
"traverseVect _   []        = pure []\n"
"traverseVect fun (x :: xs) = [| fun x :: traverseVect fun xs |]\n"
msgstr ""
"traverseVect : Applicative f => (a -> f b) -> Vect n a -> f (Vect n b)\n"
"traverseVect _   []        = pure []\n"
"traverseVect fun (x :: xs) = [| fun x :: traverseVect fun xs |]\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:193
#, no-wrap
msgid ""
"That's much better! And as I wrote above, we can easily get the same\n"
"for other container types like `List1`, `SnocList`, `Maybe`, and so on.\n"
"As usual, some derived functions will follow immediately from `traverseXY`.\n"
"For instance:\n"
msgstr ""
"那好多了！正如我上面写的，我们可以很容易地得到相同的对于其他容器类型，如 `List1`、`SnocList`、`Maybe` 等。\n"
"像往常一样，一些派生函数将紧跟在 `traverseXY` 之后。例如：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:194
#, no-wrap
msgid ""
"sequenceList : Applicative f => List (f a) -> f (List a)\n"
"sequenceList = traverseList id\n"
msgstr ""
"sequenceList : Applicative f => List (f a) -> f (List a)\n"
"sequenceList = traverseList id\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:202
#, no-wrap
msgid ""
"All of this calls for a new interface, which is called\n"
"`Traversable` and is exported from the *Prelude*. Here is\n"
"its definition (with primes for disambiguation):\n"
msgstr ""
"所有这些都需要一个新的接口，它被称为\n"
"`Traversable` 并从 *Prelude* 导出。这是\n"
"它的定义（用单引号来消除歧义）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:203
#, no-wrap
msgid ""
"interface Functor t => Foldable t => Traversable' t where\n"
"  traverse' : Applicative f => (a -> f b) -> t a -> f (t b)\n"
msgstr ""
"interface Functor t => Foldable t => Traversable' t where\n"
"  traverse' : Applicative f => (a -> f b) -> t a -> f (t b)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:214
#, no-wrap
msgid ""
"Function `traverse` is one of the most abstract and versatile\n"
"functions available from the *Prelude*. Just how powerful\n"
"it is will only become clear once you start using it\n"
"over and over again in your code. However, it will be the\n"
"goal of the remainder of this chapter to show you several\n"
"diverse and interesting use cases.\n"
msgstr ""
"函数 `traverse` 是*Prelude* 提供的函数中最抽象和通用的函数之一。到底有多强大\n"
"只有在你的代码中一遍又一遍开始使用它才会变得清晰。然而，这将是本章剩余部分的目标，会向您展示几个多样而有趣的用例。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:229
#, no-wrap
msgid ""
"For now, we will quickly focus on the degree of abstraction.\n"
"Function `traverse` is parameterized over no less than\n"
"four parameters: The container type `t` (`List`, `Vect n`,\n"
"`Maybe`, to just name a few), the effect type (`Validated e`,\n"
"`IO`, `Maybe`, and so on), the input element type `a`, and\n"
"the output element type `b`. Considering that the libraries\n"
"bundled with the Idris project export more than 30 data types\n"
"with an implementation of `Applicative` and more than ten\n"
"traversable container types, there are literally hundreds\n"
"of combinations for traversing a container with an effectful\n"
"computation. This number gets even larger once we realize\n"
"that traversable containers - like applicative functors -\n"
"are closed under composition (see the exercises and\n"
"the final section in this chapter).\n"
msgstr ""
"现在，我们将快速关注抽象程度。\n"
"函数 `traverse` 参数化不小于四个参数：容器类型 `t` (`List`, `Vect n`,\n"
"`Maybe`，仅举几例），副作用类型（`Validated e`，\n"
"`IO`、`Maybe` 等），输入元素类型 `a` 和输出元素类型 `b`。考虑到库\n"
"与 Idris 基础库导出 30 多种数据类型\n"
"具有 `Applicative` 的实现和十多个\n"
"可遍历的容器类型，实际上有数百个\n"
"副作用遍历容器的组合计算。一旦我们意识到可遍历的容器——比如应用函子——\n"
"可以在组合下闭合，这个数字会变得更大\n"
"（见练习和\n"
"本章的最后一节）。\n"

#. type: Title ###
#: ../src/Tutorial/Traverse.md:230
#, no-wrap
msgid "Traversable Laws"
msgstr "Traversable 定律"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:233
#, no-wrap
msgid "There are two laws function `traverse` must obey:\n"
msgstr "函数 `traverse` 必须遵守两个定律：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:241
#, no-wrap
msgid ""
"`traverse (Id . f) = Id . map f`: Traversing over\n"
"the `Identity` monad is just functor `map`.\n"
msgstr "`traverse (Id . f) = Id . map f`: 遍历 `Identity` 单子等同于使用 `map`.\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:241
#, no-wrap
msgid ""
"`traverse (MkComp . map f . g) = MkComp . map (traverse f) . traverse g`:\n"
"Traversing with a composition of effects\n"
"must be the same when being done in a single traversal\n"
"(left hand side) or a sequence of two traversals (right\n"
"hand side).\n"
msgstr ""
"`traverse (MkComp . map f . g) = MkComp . map (traverse f) . traverse g`：在"
"单个遍历（左侧）或两个遍历序列（右侧）中完成时，具有副作用组合的遍历必须相同"
"。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:246
#, no-wrap
msgid ""
"Since `map id = id` (functor's identity law), we can derive\n"
"from the first law that `traverse Id = Id`. This means, that\n"
"`traverse` must not change the size or shape of the container\n"
"type, nor is it allowed to change the order of elements.\n"
msgstr ""
"由于`map id = id`（函子恒等律），我们可以从第一定律推导出\n"
"`traverse Id = Id`。这意味着\n"
"`traverse`不得改变容器的大小或形状\n"
"类型，也不允许改变元素的顺序。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:253
#, no-wrap
msgid ""
"It is interesting that `Traversable` has a `Functor`\n"
"constraint. Proof that every `Traversable` is\n"
"automatically a `Functor` by implementing `map`\n"
"in terms of `traverse`.\n"
msgstr ""
"有趣的是 `Traversable` 有一个 `Functor` 约束。通过根据 `traverse` 实现 "
"`map`，证明每个 `Traversable` 自动成为 `Functor`。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:255
#, no-wrap
msgid "   Hint: Remember `Control.Monad.Identity`.\n"
msgstr "   提示：记住 `Control.Monad.Identity`。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:259
#, no-wrap
msgid ""
"Likewise, proof that every `Traversable` is\n"
"a `Foldable` by implementing `foldMap` in\n"
"terms of `Traverse`.\n"
msgstr "同样，通过根据 `Traverse` 实现 `foldMap` 来证明每个 `Traversable` 都是 "
"`Foldable`。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:261
#, no-wrap
msgid "   Hint: Remember `Control.Applicative.Const`.\n"
msgstr "   提示：记住 `Control.Applicative.Const`。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Traverse.md:264
#, no-wrap
msgid ""
"To gain some routine, implement `Traversable'` for\n"
"`List1`, `Either e`, and `Maybe`.\n"
msgstr "开始一些例行程序，请为 `List1`、`Ei` 和 `Maybe` 实现 `Traversable'`。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Traverse.md:266
#, no-wrap
msgid "Implement `Traversable` for `List01 ne`:\n"
msgstr "为 `List01 ne` 实现 `Traversable`：\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Traverse.md:275
#, no-wrap
msgid ""
"Implement `Traversable` for rose trees. Try to satisfy\n"
"the totality checker without cheating.\n"
msgstr "为玫瑰树实现 `Traversable`。尝试在不作弊的情况下满足完全性检查器。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:276
#, no-wrap
msgid ""
"   record Tree a where\n"
"     constructor Node\n"
"     value  : a\n"
"     forest : List (Tree a)\n"
msgstr ""
"   record Tree a where\n"
"     constructor Node\n"
"     value  : a\n"
"     forest : List (Tree a)\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Traverse.md:284
#, no-wrap
msgid "Implement `Traversable` for `Crud i`:\n"
msgstr "为 `Crud i` 实现 `Traversable`：\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Traverse.md:294
#, no-wrap
msgid "Implement `Traversable` for `Response e i`:\n"
msgstr "为 `Response e i` 实现 `Traversable`：\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Traverse.md:307
#, no-wrap
msgid ""
"Like `Functor`, `Applicative` and `Foldable`, `Traversable` is closed under\n"
"composition. Proof this by implementing `Traversable` for `Comp`\n"
"and `Product`:\n"
msgstr ""
"与 `Functor`、`Applicative` 和 `Foldable` 一样，`Traversable` "
"在组合下是封闭的。通过为 `Comp` 和 `Product` 实现 `Traversable` "
"来证明这一点：\n"

#. type: Title ##
#: ../src/Tutorial/Traverse.md:319
#, no-wrap
msgid "Programming with State"
msgstr "用状态编程"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:324
#, no-wrap
msgid ""
"Let's go back to our CSV reader. In order to get reasonable\n"
"error messages, we'd like to tag each line with its\n"
"index:\n"
msgstr ""
"让我们回到我们的 CSV 阅读器。为了合理\n"
"错误消息，我们想用索引来标记每一行：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:325
#, no-wrap
msgid "zipWithIndex : List a -> List (Nat, a)\n"
msgstr "zipWithIndex : List a -> List (Nat, a)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:331
#, no-wrap
msgid ""
"It is, of course, very easy to come up with an ad hoc\n"
"implementation for this:\n"
msgstr "当然，很容易想出一个临时的实现：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:332
#, no-wrap
msgid ""
"zipWithIndex = go 1\n"
"  where go : Nat -> List a -> List (Nat,a)\n"
"        go _ []        = []\n"
"        go n (x :: xs) = (n,x) :: go (S n) xs\n"
msgstr ""
"zipWithIndex = go 1\n"
"  where go : Nat -> List a -> List (Nat,a)\n"
"        go _ []        = []\n"
"        go n (x :: xs) = (n,x) :: go (S n) xs\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:344
#, no-wrap
msgid ""
"While this is perfectly fine, we should still note that\n"
"we might want to do the same thing with the elements of\n"
"trees, vectors, non-empty lists and so on.\n"
"And again, we are interested in whether there is some\n"
"form of abstraction we can use to describe such computations.\n"
msgstr ""
"虽然这很好，但我们仍然应该注意到\n"
"我们可能想对树、向量、非空列表等的元素做同样的事情。\n"
"再一次，我们感兴趣的是是否有一些\n"
"我们可以使用抽象形式来描述此类计算。\n"

#. type: Title ###
#: ../src/Tutorial/Traverse.md:345
#, no-wrap
msgid "Mutable References in Idris"
msgstr "Idris 中的可变引用"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:352
#, no-wrap
msgid ""
"Let us for a moment think about how we'd do such a thing\n"
"in an imperative language. There, we'd probably define\n"
"a local (mutable) variable to keep track of the current\n"
"index, which would then be increased while iterating over the list\n"
"in a `for`- or `while`-loop.\n"
msgstr ""
"让我们考虑一下我们会如何做这样的事情\n"
"在命令式语言中。在那里，我们可能会定义\n"
"一个局部（可变）变量，用于跟踪当前\n"
"索引，然后在遍历列表时增加\n"
"在 `for`- 或 `while`-循环中。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:363
#, no-wrap
msgid ""
"In Idris, there is no such thing as mutable state.\n"
"Or is there? Remember, how we used a mutable reference\n"
"to simulate a data base connection in an earlier\n"
"exercise. There, we actually used some truly mutable\n"
"state. However, since accessing or modifying a mutable\n"
"variable is not a referential transparent operation,\n"
"such actions have to be performed within `IO`.\n"
"Other than that, nothing keeps us from using mutable\n"
"variables in our code. The necessary functionality is\n"
"available from module `Data.IORef` from the *base* library.\n"
msgstr ""
"在 Idris 中，没有可变状态之类的东西。\n"
"或者有吗？请记住，我们如何在早期模拟数据库连接练习中使用可变引用。在那里，我们实际上使用了一些真正可变的\n"
"状态。但是，由于访问或修改一个可变\n"
"变量不是引用透明操作，\n"
"此类操作必须在 `IO` 内执行。\n"
"除此之外，没有什么能阻止我们在我们代码中使用可变变量。必要的函数可从 *base* 库中的模块 `Data.IORef` 获得。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:367
#, no-wrap
msgid ""
"As a quick exercise, try to implement a function, which -\n"
"given an `IORef Nat` - pairs a value with the current\n"
"index and increases the index afterwards.\n"
msgstr ""
"作为一个快速练习，尝试实现一个函数，它 - 给定 `IORef Nat` - 将值与当前值配对\n"
"索引并在之后增加索引。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:369
#, no-wrap
msgid "Here's how I would do this:\n"
msgstr "下面看我将如何做到这一点：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:370
#, no-wrap
msgid ""
"pairWithIndexIO : IORef Nat -> a -> IO (Nat,a)\n"
"pairWithIndexIO ref va = do\n"
"  ix <- readIORef ref\n"
"  writeIORef ref (S ix)\n"
"  pure (ix,va)\n"
msgstr ""
"pairWithIndexIO : IORef Nat -> a -> IO (Nat,a)\n"
"pairWithIndexIO ref va = do\n"
"  ix <- readIORef ref\n"
"  writeIORef ref (S ix)\n"
"  pure (ix,va)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:387
#, no-wrap
msgid ""
"Note, that every time we *run* `pairWithIndexIO ref`, the\n"
"natural number stored in `ref` is incremented by one.\n"
"Also, look at the type of `pairWithIndexIO ref`: `a -> IO (Nat,a)`.\n"
"We want to apply this effectful computation to each element\n"
"in a list, which should lead to a new list wrapped in `IO`,\n"
"since all of this describes a single computation with side\n"
"effects. But this is *exactly* what function `traverse` does: Our\n"
"input type is `a`, our output type is `(Nat,a)`, our\n"
"container type is `List`, and the effect type is `IO`!\n"
msgstr ""
"注意，每次我们 *运行* `pairWithIndexIO ref`，\n"
"`ref` 中存储的自然数加一。\n"
"另外，查看 `pairWithIndexIO ref` 的类型：`a -> IO (Nat,a)`。\n"
"我们希望将这种副作用的计算应用于在一个列表中每个元素，这应该会导致一个包含在 `IO` 中的新列表，\n"
"因为所有这些都描述了一个单一的计算\n"
"副作用。但这 *正是* `traverse` 的作用：我们的\n"
"输入类型是 `a`，我们的输出类型是 `(Nat,a)`，我们的\n"
"容器类型为`List`，副作用类型为`IO`！\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:388
#, no-wrap
msgid ""
"zipListWithIndexIO : IORef Nat -> List a -> IO (List (Nat,a))\n"
"zipListWithIndexIO ref = traverse (pairWithIndexIO ref)\n"
msgstr ""
"zipListWithIndexIO : IORef Nat -> List a -> IO (List (Nat,a))\n"
"zipListWithIndexIO ref = traverse (pairWithIndexIO ref)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:397
#, no-wrap
msgid ""
"Now *this* is really powerful: We could apply the same function\n"
"to *any* traversable data structure. It therefore makes\n"
"absolutely no sense to specialize `zipListWithIndexIO` to\n"
"lists only:\n"
msgstr ""
"现在 *这个* 真的很强大：我们可以应用相同的函数\n"
"到 *任意* 可遍历的数据结构。因此它使\n"
"将 `zipListWithIndexIO` 专门用于\n"
"仅列出：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:398
#, no-wrap
msgid ""
"zipWithIndexIO : Traversable t => IORef Nat -> t a -> IO (t (Nat,a))\n"
"zipWithIndexIO ref = traverse (pairWithIndexIO ref)\n"
msgstr ""
"zipWithIndexIO : Traversable t => IORef Nat -> t a -> IO (t (Nat,a))\n"
"zipWithIndexIO ref = traverse (pairWithIndexIO ref)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:405
#, no-wrap
msgid ""
"To please our intellectual minds even more, here is the\n"
"same function in point-free style:\n"
msgstr ""
"为了更取悦我们的智力，这里是\n"
"无参风格的相同函数：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:406
#, no-wrap
msgid ""
"zipWithIndexIO' : Traversable t => IORef Nat -> t a -> IO (t (Nat,a))\n"
"zipWithIndexIO' = traverse . pairWithIndexIO\n"
msgstr ""
"zipWithIndexIO' : Traversable t => IORef Nat -> t a -> IO (t (Nat,a))\n"
"zipWithIndexIO' = traverse . pairWithIndexIO\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:413
#, no-wrap
msgid ""
"All that's left to do now is to initialize a new mutable variable\n"
"before passing it to `zipWithIndexIO`:\n"
msgstr "现在剩下要做的就是在将其传递给 `zipWithIndexIO` 之前初始化一个新的可变变量：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:414
#, no-wrap
msgid ""
"zipFromZeroIO : Traversable t => t a -> IO (t (Nat,a))\n"
"zipFromZeroIO ta = newIORef 0 >>= (`zipWithIndexIO` ta)\n"
msgstr ""
"zipFromZeroIO : Traversable t => t a -> IO (t (Nat,a))\n"
"zipFromZeroIO ta = newIORef 0 >>= (`zipWithIndexIO` ta)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:420
#, no-wrap
msgid "Quickly, let's give this a go at the REPL:\n"
msgstr "很快，让我们在 REPL 上试一试：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:421
#, no-wrap
msgid ""
"> :exec zipFromZeroIO {t = List} [\"hello\", \"world\"] >>= printLn\n"
"[(0, \"hello\"), (1, \"world\")]\n"
"> :exec zipFromZeroIO (Just 12) >>= printLn\n"
"Just (0, 12)\n"
"> :exec zipFromZeroIO {t = Vect 2} [\"hello\", \"world\"] >>= printLn\n"
"[(0, \"hello\"), (1, \"world\")]\n"
msgstr ""
"> :exec zipFromZeroIO {t = List} [\"hello\", \"world\"] >>= printLn\n"
"[(0, \"hello\"), (1, \"world\")]\n"
"> :exec zipFromZeroIO (Just 12) >>= printLn\n"
"Just (0, 12)\n"
"> :exec zipFromZeroIO {t = Vect 2} [\"hello\", \"world\"] >>= printLn\n"
"[(0, \"hello\"), (1, \"world\")]\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:432
#, no-wrap
msgid ""
"Thus, we solved the problem of tagging each element with its\n"
"index once and for all for all traversable container types.\n"
msgstr "因此，对于所有可遍历的容器类型，我们解决了用索引一次性标记每个元素的问题。\n"

#. type: Title ###
#: ../src/Tutorial/Traverse.md:433
#, no-wrap
msgid "The State Monad"
msgstr "状态单子"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:441
#, no-wrap
msgid ""
"Alas, while the solution presented above is elegant and\n"
"performs very well, it still carries its `IO` stain, which\n"
"is fine if we are already in `IO` land, but unacceptable\n"
"otherwise. We do not want to make our otherwise pure functions\n"
"much harder to test and reason about just for a simple\n"
"case of stateful element tagging.\n"
msgstr ""
"唉，虽然上面提出的解决方案很优雅，表现也非常好，但它仍然带有 `IO` 污渍，\n"
"如果我们已经在 `IO` 土地上就还好，否则这是不可接受的。我们不想让我们原本纯粹的函数只是为了一个简单有状态元素标记的情况就让测试和推理变得困难。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:450
#, no-wrap
msgid ""
"Luckily, there is an alternative to using a mutable reference,\n"
"which allows us to keep our computations pure and\n"
"untainted. However, it is not easy to come upon this\n"
"alternative on one's own, and it can be hard to figure out\n"
"what's going on here, so I'll try to introduce this slowly.\n"
"We first need to ask ourselves what the essence of a\n"
"\"stateful\" but otherwise pure computation is. There\n"
"are two essential ingredients:\n"
msgstr ""
"幸运的是，有一个使用可变引用的替代方法，\n"
"这使我们能够保持我们的计算纯粹和\n"
"不受污染。然而，自己的替代方案要做到这一点并不容易，而且很难弄清楚这是怎么回事，所以我会尝试慢慢介绍。\n"
"我们首先需要问自己 “有状态” 的本质是什么，否则什么是纯计算。那是两个基本成分：\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:458
#, no-wrap
msgid ""
"Access to the *current* state. In case of a pure\n"
"function, this means that the function should take\n"
"the current state as one of its arguments.\n"
msgstr "访问*当前*状态。对于纯函数，这意味着该函数应将当前状态作为其参数之一。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:458
#, no-wrap
msgid ""
"Ability to communicate the updated state to later\n"
"stateful computations. In case of a pure function\n"
"this means, that the function will return a pair\n"
"of values: The computation's result plus the updated state.\n"
msgstr "能够将更新的状态传达给以后的有状态计算。在纯函数的情况下，这意味着该函数将返"
"回一对值：计算的结果加上更新的状态。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:462
#, no-wrap
msgid ""
"These two prerequisites lead to the following generic\n"
"type for a pure, stateful computation operating on state\n"
"type `st` and producing values of type `a`:\n"
msgstr ""
"这两个先决条件导致以泛型，\n"
"用于在状态上运行的纯的有状态计算的类型，输入 `st` 并生成 `a` 类型的值 ：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:463
#, no-wrap
msgid ""
"Stateful : (st : Type) -> (a : Type) -> Type\n"
"Stateful st a = st -> (st, a)\n"
msgstr ""
"Stateful : (st : Type) -> (a : Type) -> Type\n"
"Stateful st a = st -> (st, a)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:470
#, no-wrap
msgid ""
"Our use case is pairing elements with indices, which\n"
"can be implemented as a pure, stateful computation like so:\n"
msgstr ""
"我们的用例是将元素与索引配对，\n"
"可以实现为纯粹的、有状态的计算，如下所示：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:471
#, no-wrap
msgid ""
"pairWithIndex' : a -> Stateful Nat (Nat,a)\n"
"pairWithIndex' v index = (S index, (index,v))\n"
msgstr ""
"pairWithIndex' : a -> Stateful Nat (Nat,a)\n"
"pairWithIndex' v index = (S index, (index,v))\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:479
#, no-wrap
msgid ""
"Note, how we at the same time increment the index, returning\n"
"the incremented value as the new state, while pairing\n"
"the first argument with the original index.\n"
msgstr ""
"注意，我们如何同时增加索引，返回\n"
"增加的值作为新状态，同时配对第一个参数与原始索引。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:488
#, no-wrap
msgid ""
"Now, here is an important thing to note: While `Stateful` is\n"
"a useful type alias, Idris in general does *not* resolve\n"
"interface implementations for function types. If we want to\n"
"write a small library of utility functions around such a type,\n"
"it is therefore best to wrap it in a single-constructor data type and\n"
"use this as our building block for writing more complex\n"
"computations. We therefore introduce record `State` as\n"
"a wrapper for pure, stateful computations:\n"
msgstr ""
"现在，需要注意一件重要的事情：虽然 `Stateful` 是一个有用的类型别名，Idris 通常 *不会* 解析函数类型的接口实现。如果我们想围绕这种类型编写一个小型实用函数库，\n"
"因此，最好将其包装在单构造函数数据类型中，并且\n"
"使用它作为我们编写更复杂计算的构建块。因此，我们将记录 `State` 引入为\n"
"纯粹的有状态计算的包装器：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:489
#, no-wrap
msgid ""
"record State st a where\n"
"  constructor ST\n"
"  runST : st -> (st,a)\n"
msgstr ""
"record State st a where\n"
"  constructor ST\n"
"  runST : st -> (st,a)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:496
#, no-wrap
msgid "We can now implement `pairWithIndex` in terms of `State` like so:\n"
msgstr "我们现在可以用 `State` 来实现 `pairWithIndex` ，如下所示：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:497
#, no-wrap
msgid ""
"pairWithIndex : a -> State Nat (Nat,a)\n"
"pairWithIndex v = ST $ \\index => (S index, (index, v))\n"
msgstr ""
"pairWithIndex : a -> State Nat (Nat,a)\n"
"pairWithIndex v = ST $ \\index => (S index, (index, v))\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:505
#, no-wrap
msgid ""
"In addition, we can define some more utility functions. Here's\n"
"one for getting the current state without modifying it\n"
"(this corresponds to `readIORef`):\n"
msgstr "此外，我们还可以定义更多的工具函数。这里是一个用于获取当前状态而不修改它的函数（这对应于 `readIORef`）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:506
#, no-wrap
msgid ""
"get : State st st\n"
"get = ST $ \\s => (s,s)\n"
msgstr ""
"get : State st st\n"
"get = ST $ \\s => (s,s)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:513
#, no-wrap
msgid ""
"Here are two others, for overwriting the current state. These\n"
"corresponds to `writeIORef` and `modifyIORef`:\n"
msgstr ""
"这是另外两个，用于覆盖当前状态。这些\n"
"对应 `writeIORef` 和 `modifyIORef`：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:514
#, no-wrap
msgid ""
"put : st -> State st ()\n"
"put v = ST $ \\_ => (v,())\n"
"\n"
"modify : (st -> st) -> State st ()\n"
"modify f = ST $ \\v => (f v,())\n"
msgstr ""
"put : st -> State st ()\n"
"put v = ST $ \\_ => (v,())\n"
"\n"
"modify : (st -> st) -> State st ()\n"
"modify f = ST $ \\v => (f v,())\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:524
#, no-wrap
msgid ""
"Finally, we can define three functions in addition to `runST`\n"
"for running stateful computations\n"
msgstr "最后，我们可以定义除用于运行有状态计算 `runST` 之外的三个函数\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:525
#, no-wrap
msgid ""
"runState : st -> State st a -> (st, a)\n"
"runState = flip runST\n"
"\n"
"evalState : st -> State st a -> a\n"
"evalState s = snd . runState s\n"
"\n"
"execState : st -> State st a -> st\n"
"execState s = fst . runState s\n"
msgstr ""
"runState : st -> State st a -> (st, a)\n"
"runState = flip runST\n"
"\n"
"evalState : st -> State st a -> a\n"
"evalState s = snd . runState s\n"
"\n"
"execState : st -> State st a -> st\n"
"execState s = fst . runState s\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:542
#, no-wrap
msgid ""
"All of these are useful on their own, but the real power of\n"
"`State s` comes from the observation that it is a monad.\n"
"Before you go on, please spend some time and try implementing\n"
"`Functor`, `Applicative`, and `Monad` for `State s` yourself.\n"
"Even if you don't succeed, you will have an easier time\n"
"understanding how the implementations below work.\n"
msgstr ""
"所有这些都是单独有用的，但真正的力量\n"
"`State s` 来自观察它是一个单子。\n"
"在继续之前，请花一些时间尝试自己实现 `Functor`、`Applicative` 和 `Monad` 用于 `State s`。\n"
"即使你没有成功，你也会过得更轻松了解下面的实现是如何工作的。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:543
#, no-wrap
msgid ""
"Functor (State st) where\n"
"  map f (ST run) = ST $ \\s => let (s2,va) = run s in (s2, f va)\n"
"\n"
"Applicative (State st) where\n"
"  pure v = ST $ \\s => (s,v)\n"
"\n"
"  ST fun <*> ST val = ST $ \\s =>\n"
"    let (s2, f)  = fun s\n"
"        (s3, va) = val s2\n"
"     in (s3, f va)\n"
"\n"
"Monad (State st) where\n"
"  ST val >>= f = ST $ \\s =>\n"
"    let (s2, va) = val s\n"
"     in runST (f va) s2\n"
msgstr ""
"Functor (State st) where\n"
"  map f (ST run) = ST $ \\s => let (s2,va) = run s in (s2, f va)\n"
"\n"
"Applicative (State st) where\n"
"  pure v = ST $ \\s => (s,v)\n"
"\n"
"  ST fun <*> ST val = ST $ \\s =>\n"
"    let (s2, f)  = fun s\n"
"        (s3, va) = val s2\n"
"     in (s3, f va)\n"
"\n"
"Monad (State st) where\n"
"  ST val >>= f = ST $ \\s =>\n"
"    let (s2, va) = val s\n"
"     in runST (f va) s2\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:573
#, no-wrap
msgid ""
"This may take some time to digest, so we come back to it in a\n"
"slightly advanced exercise. The most important thing to note is,\n"
"that we use every state value only ever once. We *must* make sure\n"
"that the updated state is passed to later computations, otherwise\n"
"the information about state updates is being lost. This can\n"
"best be seen in the implementation of `Applicative`: The initial\n"
"state, `s`, is used in the computation of the function value,\n"
"which will also return an updated state, `s2`, which is then\n"
"used in the computation of the function argument. This will\n"
"again return an updated state, `s3`, which is passed on to\n"
"later stateful computations together with the result of\n"
"applying `f` to `va`.\n"
msgstr ""
"这可能需要一些时间来消化，所以我们稍后稍微高级的练习时会回顾它。最需要注意的是，\n"
"我们每个状态值只使用一次。我们*必须*确保将更新后的状态传递给以后的计算，否则有关状态更新的信息就会丢失。这个可以最好在 `Applicative` 的实现中看到：初始状态 `s` 用于计算函数值，这也将返回一个更新的状态，`s2` 用于计算函数参数。这将再次返回一个更新的状态，`s3`，它连同将 `f` 应用于 `va` 的结果被传递给以后的有状态计算。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:583
#, no-wrap
msgid ""
"This sections consists of two extended exercise, the aim\n"
"of which is to increase your understanding of the state monad.\n"
"In the first exercise, we will look at random value generation,\n"
"a classical application of stateful computations.\n"
"In the second exercise, we will look at an indexed version of\n"
"a state monad, which allows us to not only change the\n"
"state's value but also its *type* during computations.\n"
msgstr ""
"本节包括两个扩展练习，目的是\n"
"其中是为了增加你对状态单子的理解。\n"
"在第一个练习中，我们将研究随机值生成，\n"
"有状态计算的经典应用。\n"
"在第二个练习中，我们将看基于状态单子的一个索引版本，它允许我们在计算过程中不仅改变状态的值以及它的 *类型*。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:590
#, no-wrap
msgid ""
"Below is the implementation of a simple pseudo-random number\n"
"generator. We call this a *pseudo-random* number generator,\n"
"because the numbers look pretty random but are generated\n"
"predictably. If we initialize a series of such computations\n"
"with a truly random seed, most users of our library will not\n"
"be able to predict the outcome of our computations.\n"
msgstr ""
"下面是一个简单的伪随机数生成器的实现。我们称其为*伪随机*数字生成器，因为这些"
"数字看起来非常随机，但生成是可预测的。如果我们用真正的随机种子初始化一系列这"
"样的计算，我们库的大多数用户将无法预测我们的计算结果。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:591
#, no-wrap
msgid ""
"   rnd : Bits64 -> Bits64\n"
"   rnd seed = fromInteger\n"
"            $ (437799614237992725 * cast seed) `mod` 2305843009213693951\n"
msgstr ""
"   rnd : Bits64 -> Bits64\n"
"   rnd seed = fromInteger\n"
"            $ (437799614237992725 * cast seed) `mod` 2305843009213693951\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:604
#, no-wrap
msgid ""
"   The idea here is that the next pseudo-random number gets\n"
"   calculated from the previous one. But once we think about\n"
"   how we can use these numbers as seeds for computing\n"
"   random values of other types, we realize that these are\n"
"   just stateful computations. We can therefore write\n"
"   down an alias for random value generators as stateful\n"
"   computations:\n"
msgstr "   这里的意思是，下一个伪随机数是从上一个伪随机数计算出来的。但一旦我们考虑如何使用这些数字作为种子来计算其他类型的随机值，我们就会意识到这些只是有状态的计算。因此，我们可以将随机值生成器的别名写为有状态计算：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:605
#, no-wrap
msgid ""
"   Gen : Type -> Type\n"
"   Gen = State Bits64\n"
msgstr ""
"   Gen : Type -> Type\n"
"   Gen = State Bits64\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:617
#, no-wrap
msgid ""
"   Before we begin, please note that `rnd` is not a very strong\n"
"   pseudo-random number generator. It will not generate values in\n"
"   the full 64bit range, nor is it safe to use in cryptographic\n"
"   applications. It is sufficient for our purposes in this chapter,\n"
"   however. Note also, that we could replace `rnd` with a stronger\n"
"   generator without any changes to the functions you will implement\n"
"   as part of this exercise.\n"
msgstr ""
"   在开始之前，请注意 `rnd` 不是很强的\n"
"   伪随机数发生器。它不会在完整的 64 位区间生成值，在密码应用程序中使用也不安全 。然而对我们本章的目的来说足够了，\n"
"   。另请注意，我们可以将 `rnd` 替换为更强的\n"
"   生成器，无需对您将作为本练习的一部分实现的函数进行任何更改\n"
"   。\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/Traverse.md:622
#, no-wrap
msgid ""
"Implement `bits64` in terms of `rnd`. This should return\n"
"the current state, updating it afterwards by invoking\n"
"function `rnd`. Make sure the state is properly updated,\n"
"otherwise this won't behave as expected.\n"
msgstr ""
"根据 `rnd` 实现 `bits64`。这应该返回当前状态，然后通过调用函数 `rnd` "
"对其进行更新。确保状态已正确更新，否则将无法按预期运行。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:626
#, no-wrap
msgid ""
"      ```idris\n"
"      bits64 : Gen Bits64\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      bits64 : Gen Bits64\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:631
#, no-wrap
msgid ""
"      This will be our *only* primitive generator, from which\n"
"      we will derived all the others. Therefore,\n"
"      before you continue, quickly test your implementation of\n"
"      `bits64` at the REPL:\n"
msgstr ""
"      这将是我们的 *仅限* 原语的生成器，从中\n"
"      我们将推导出所有其他的。所以，\n"
"      在你继续之前， 在 REPL 中快速测试你的 `bits64` 实现：\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:636
#, no-wrap
msgid ""
"      ```repl\n"
"      Solutions.Traverse> runState 100 bits64\n"
"      (2274787257952781382, 100)\n"
"      ```\n"
msgstr ""
"      ```repl\n"
"      Solutions.Traverse> runState 100 bits64\n"
"      (2274787257952781382, 100)\n"
"      ```\n"

#. type: Bullet: '   2. '
#: ../src/Tutorial/Traverse.md:642
#, no-wrap
msgid ""
"Implement `range64` for generating random values in\n"
"the range `[0,upper]`. Hint: Use `bits64` and `mod`\n"
"in your implementation but make sure to deal with\n"
"the fact that `mod x upper` produces values in the\n"
"range `[0,upper)`.\n"
msgstr ""
"实现 `range64` 以在 `[0,upper]` 范围内生成随机值。提示：在你的实现中使用 "
"`bits64` 和 `mod` 但确保处理 `mod x upper` 在 `[0,upper)` 区间生成。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:646
#, no-wrap
msgid ""
"      ```idris\n"
"      range64 : (upper : Bits64) -> Gen Bits64\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      range64 : (upper : Bits64) -> Gen Bits64\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:649
#, no-wrap
msgid ""
"      Likewise, implement `interval64` for generating values\n"
"      in the range `[min a b, max a b]`:\n"
msgstr "      同样的, 实现 `interval64` 来生成区间为 `[min a b, max a b]` 的值:\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:653
#, no-wrap
msgid ""
"      ```idris\n"
"      interval64 : (a,b : Bits64) -> Gen Bits64\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      interval64 : (a,b : Bits64) -> Gen Bits64\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:655
#, no-wrap
msgid "      Finally, implement `interval` for arbitrary integral types.\n"
msgstr "      最后，为任意整数类型实现 `interval`。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:659
#, no-wrap
msgid ""
"      ```idris\n"
"      interval : Num n => Cast n Bits64 => (a,b : n) -> Gen n\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      interval : Num n => Cast n Bits64 => (a,b : n) -> Gen n\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:663
#, no-wrap
msgid ""
"      Note, that `interval` will not generate all possible values in\n"
"      the given interval but only such values with a `Bits64`\n"
"      representation in the the range `[0,2305843009213693950]`.\n"
msgstr ""
"      请注意， `interval` 不会生成给定的间隔所有可能的值\n"
"      ，只会生成`[0,2305843009213693950]` 范围内 `Bits64` 的值。\n"

#. type: Bullet: '   3. '
#: ../src/Tutorial/Traverse.md:665
#, no-wrap
msgid "Implement a generator for random boolean values.\n"
msgstr "实现随机布尔值的生成器。\n"

#. type: Bullet: '   4. '
#: ../src/Tutorial/Traverse.md:670
#, no-wrap
msgid ""
"Implement a generator for `Fin n`. You'll have to think\n"
"carefully about getting this one to typecheck and be\n"
"accepted by the totality checker without cheating.\n"
"Note: Have a look at function `Data.Fin.natToFin`.\n"
msgstr ""
"为 `Fin n` 实现一个生成器。您必须仔细考虑如何让这个进行类型检查并在不作弊的情"
"况下被整体检查器接受。注意：查看函数 `Data.Fin.natToFin`。\n"

#. type: Bullet: '   5. '
#: ../src/Tutorial/Traverse.md:674
#, no-wrap
msgid ""
"Implement a generator for selecting a random element\n"
"from a vector of values. Use the generator from\n"
"exercise 4 in your implementation.\n"
msgstr "实现一个生成器，用于从值向量中选择一个随机元素。在您的实现中使用练习 4 "
"中的生成器。\n"

#. type: Bullet: '   6. '
#: ../src/Tutorial/Traverse.md:678
#, no-wrap
msgid ""
"Implement `vect` and `list`. In case of `list`, the\n"
"first argument should be used to randomly determine the length\n"
"of the list.\n"
msgstr "实现 `vect` 和 `list`。在 `list` "
"的情况下，第一个参数应该用于随机确定列表的长度。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:681
#, no-wrap
msgid ""
"      ```idris\n"
"      vect : {n : _} -> Gen a -> Gen (Vect n a)\n"
msgstr ""
"      ```idris\n"
"      vect : {n : _} -> Gen a -> Gen (Vect n a)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:684
#, no-wrap
msgid ""
"      list : Gen Nat -> Gen a -> Gen (List a)\n"
"      ```\n"
msgstr ""
"      list : Gen Nat -> Gen a -> Gen (List a)\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:687
#, no-wrap
msgid ""
"      Use `vect` to implement utility function `testGen` for\n"
"      testing your generators at the REPL:\n"
msgstr ""
"      使用`vect`实现工具函数`testGen` ，\n"
"      并在 REPL 测试你的生成器：\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:691
#, no-wrap
msgid ""
"      ```idris\n"
"      testGen : Bits64 -> Gen a -> Vect 10 a\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      testGen : Bits64 -> Gen a -> Vect 10 a\n"
"      ```\n"

#. type: Bullet: '   7. '
#: ../src/Tutorial/Traverse.md:693
#, no-wrap
msgid "Implement `choice`.\n"
msgstr "实现 `choice`.\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:697
#, no-wrap
msgid ""
"      ```idris\n"
"      choice : {n : _} -> Vect (S n) (Gen a) -> Gen a\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      choice : {n : _} -> Vect (S n) (Gen a) -> Gen a\n"
"      ```\n"

#. type: Bullet: '   8. '
#: ../src/Tutorial/Traverse.md:699
#, no-wrap
msgid "Implement `either`.\n"
msgstr "实现 `either`.\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:703
#, no-wrap
msgid ""
"      ```idris\n"
"      either : Gen a -> Gen b -> Gen (Either a b)\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      either : Gen a -> Gen b -> Gen (Either a b)\n"
"      ```\n"

#. type: Bullet: '   9. '
#: ../src/Tutorial/Traverse.md:708
#, no-wrap
msgid ""
"Implement a generator for printable ASCII characters.\n"
"These are characters with ASCII codes in the interval\n"
"`[32,126]`. Hint: Function `chr` from the *Prelude*\n"
"will be useful here.\n"
msgstr ""
"为可打印的 ASCII 字符实现生成器。这些是 ASCII 码在区间 `[32,126]` "
"中的字符。提示：*Prelude* 中的函数 `chr` 在这里很有用。\n"

#. type: Bullet: '   10. '
#: ../src/Tutorial/Traverse.md:711
#, no-wrap
msgid ""
"Implement a generator for strings. Hint: Function `pack`\n"
"from the *Prelude* might be useful for this.\n"
msgstr "实现一个字符串生成器。提示：*Prelude* 中的函数 `pack` 可能对此有用。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:715
#, no-wrap
msgid ""
"       ```idris\n"
"       string : Gen Nat -> Gen Char -> Gen String\n"
"       ```\n"
msgstr ""
"       ```idris\n"
"       string : Gen Nat -> Gen Char -> Gen String\n"
"       ```\n"

#. type: Bullet: '   11. '
#: ../src/Tutorial/Traverse.md:722
#, no-wrap
msgid ""
"We shouldn't forget about our ability to encode interesting\n"
"things in the types in Idris, so, for a challenge and without\n"
"further ado, implement `hlist` (note the distinction between\n"
"`HListF` and `HList`). If you are rather new to dependent types,\n"
"this might take a moment to digest, so don't forget to\n"
"use holes.\n"
msgstr ""
"我们不应该忘记我们在 Idris "
"的类型中编码有趣事物的能力，因此，为了挑战，事不宜迟，实现 `hlist`（注意 "
"`HListF` 和 `HList`）。如果您对依赖类型比较陌生，这可能需要一点时间来消化，所"
"以不要忘记使用孔。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:727
#, no-wrap
msgid ""
"       ```idris\n"
"       data HListF : (f : Type -> Type) -> (ts : List Type) -> Type where\n"
"         Nil  : HListF f []\n"
"         (::) : (x : f t) -> (xs : HLift f ts) -> HListF f (t :: ts)\n"
msgstr ""
"       ```idris\n"
"       data HListF : (f : Type -> Type) -> (ts : List Type) -> Type where\n"
"         Nil  : HListF f []\n"
"         (::) : (x : f t) -> (xs : HLift f ts) -> HListF f (t :: ts)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:730
#, no-wrap
msgid ""
"       hlist : HListF Gen ts -> Gen (HList ts)\n"
"       ```\n"
msgstr ""
"       hlist : HListF Gen ts -> Gen (HList ts)\n"
"       ```\n"

#. type: Bullet: '   12. '
#: ../src/Tutorial/Traverse.md:732
#, no-wrap
msgid "Generalize `hlist` to work with any applicative functor, not just `Gen`.\n"
msgstr "泛化 `hlist` 以与任何应用函子一起工作，而不仅仅是 `Gen`.\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:736
#, no-wrap
msgid ""
"   If you arrived here, please realize how we can now generate pseudo-random\n"
"   values for most primitives, as well as regular sum- and product types.\n"
"   Here is an example REPL session:\n"
msgstr ""
"   如果你到了这里，请意识到我们现在如何生成大多数原语的伪随机值，以及常规的 sum- 和 product 类型。\n"
"   这是一个示例 REPL 会话：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:737
#, no-wrap
msgid ""
"   > testGen 100 $ hlist [bool, printableAscii, interval 0 127]\n"
"   [[True, ';', 5],\n"
"    [True, '^', 39],\n"
"    [False, 'o', 106],\n"
"    [True, 'k', 127],\n"
"    [False, ' ', 11],\n"
"    [False, '~', 76],\n"
"    [True, 'M', 11],\n"
"    [False, 'P', 107],\n"
"    [True, '5', 67],\n"
"    [False, '8', 9]]\n"
msgstr ""
"   > testGen 100 $ hlist [bool, printableAscii, interval 0 127]\n"
"   [[True, ';', 5],\n"
"    [True, '^', 39],\n"
"    [False, 'o', 106],\n"
"    [True, 'k', 127],\n"
"    [False, ' ', 11],\n"
"    [False, '~', 76],\n"
"    [True, 'M', 11],\n"
"    [False, 'P', 107],\n"
"    [True, '5', 67],\n"
"    [False, '8', 9]]\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:764
#, no-wrap
msgid ""
"   Final remarks: Pseudo-random value generators play an important role\n"
"   in property based testing libraries like [QuickCheck](https://hackage.haskell.org/package/QuickCheck)\n"
"   or [Hedgehog](https://github.com/stefan-hoeck/idris2-hedgehog).\n"
"   The idea of property based testing is to test predefined *properties* of\n"
"   pure functions against a large number of randomly generated arguments,\n"
"   to get strong guarantees about these properties to hold for *all*\n"
"   possible arguments. One example would be a test for verifying\n"
"   that the result of reversing a list twice equals the original list.\n"
"   While it is possible to proof many of the simpler properties in Idris\n"
"   directly without the need for tests, this is no longer possible\n"
"   as soon as functions are involved, which don't reduce during unification\n"
"   such as foreign function calls or functions not publicly exported from\n"
"   other modules.\n"
msgstr ""
"   最后的评论：伪随机值生成器在基于属性的测试库中起着重要作用，如 [QuickCheck](https://hackage.haskell.org/package/QuickCheck)\n"
"   或 [Hedgehog](https://github.com/stefan-hoeck/idris2-hedgehog)。\n"
"   基于属性的测试的思想是针对大量随机生成的参数的纯函数测试预定义的*属性*，\n"
"   为 *所有* 可能的参数获得有关这些属性的有力保证。一个例子是验证\n"
"   将列表反转两次的结果等于原始列表的测试。\n"
"   虽然不需要测试可以直接证明 Idris 中的许多更简单的属性，一旦涉及函数这不再可能，因为在统一期间不会减少，\n"
"   例如外部函数调用或其他模块未公开导出的函数。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:770
#, no-wrap
msgid ""
"While `State s a` gives us a convenient way to talk about\n"
"stateful computations, it only allows us to mutate the\n"
"state's *value* but not its *type*. For instance, the following\n"
"function cannot be encapsulated in `State` because the type\n"
"of the state changes:\n"
msgstr ""
"虽然 `State s a` 为我们提供了一种讨论有状态计算的便捷方式，但它只允许我们改变"
"状态的*值*而不是它的*类型*。例如，下面的函数不能封装在 `State` "
"中，因为状态的类型发生了变化：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:771
#, no-wrap
msgid ""
"   uncons : Vect (S n) a -> (Vect n a, a)\n"
"   uncons (x :: xs) = (xs, x)\n"
msgstr ""
"   uncons : Vect (S n) a -> (Vect n a, a)\n"
"   uncons (x :: xs) = (xs, x)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:784
#, no-wrap
msgid ""
"   Your task is to come up with a new state type allowing for\n"
"   such changes (sometimes referred to as an *indexed* state data type).\n"
"   The goal of this exercise is to also sharpen your skills in\n"
"   expressing things at the type level including derived function\n"
"   types and interfaces. Therefore, I will give only little\n"
"   guidance on how to go about this. If you get stuck, feel free to\n"
"   peek at the solutions but make sure to only look at the types\n"
"   at first.\n"
msgstr ""
"   你的任务是提出一个新的状态类型，允许\n"
"   此类更改（有时称为 *索引* 状态数据类型）。\n"
"   这个练习的目的也是为了提高你的技能\n"
"   在类型级别表达事物，包括派生函数\n"
"   类型和接口。因此，我只会付出一点点\n"
"   指导如何去做。如果您遇到困难，请随时\n"
"   查看解决方案，但确保只查看类型\n"
"   首先。\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/Traverse.md:790
#, no-wrap
msgid ""
"Come up with a parameterized data type for encapsulating\n"
"stateful computations where the input and output state type can\n"
"differ. It must be possible to wrap `uncons` in a value of\n"
"this type.\n"
msgstr "提出一种参数化数据类型，用于封装输入和输出状态类型可能不同的有状态计算。"
"必须可以将 `uncons` 包装在这种类型的值中。\n"

#. type: Bullet: '   2. '
#: ../src/Tutorial/Traverse.md:792
#, no-wrap
msgid "Implement `Functor` for your indexed state type.\n"
msgstr "为您的索引状态类型实现 `Functor`。\n"

#. type: Bullet: '   3. '
#: ../src/Tutorial/Traverse.md:797
#, no-wrap
msgid ""
"It is not possible to implement `Applicative` for this\n"
"*indexed* state type (but see also exercise 2.vii).\n"
"Still, implement the necessary functions\n"
"to use it with idom brackets.\n"
msgstr ""
"对于这种*索引*状态类型，无法实现 `Applicative`（但另请参见练习 2."
"vii）。尽管如此，实现必要的函数以将其与习语括号一起使用。\n"

#. type: Bullet: '   4. '
#: ../src/Tutorial/Traverse.md:801
#, no-wrap
msgid ""
"It is not possible to implement `Monad` for this\n"
"indexed state type. Still, implement the necessary functions\n"
"to use it in do blocks.\n"
msgstr "无法为此索引状态类型实现 `Monad`。不过，实现必要的功能以在 do 块中使用它。\n"

#. type: Bullet: '   5. '
#: ../src/Tutorial/Traverse.md:805
#, no-wrap
msgid ""
"Generalize the functions from exercises 3 and 4 with two new\n"
"interfaces `IxApplicative` and `IxMonad` and provide implementations\n"
"of these for your indexed state data type.\n"
msgstr ""
"使用两个新接口 `IxApplicative` 和 `IxMonad` 概括练习 3 和 4 "
"中的函数，并为您的索引状态数据类型提供这些实现。\n"

#. type: Bullet: '   6. '
#: ../src/Tutorial/Traverse.md:809
#, no-wrap
msgid ""
"Implement functions `get`, `put`, `modify`, `runState`,\n"
"`evalState`, and `execState` for the indexed state data type. Make\n"
"sure to adjust the type parameters where necessary.\n"
msgstr ""
"实现函数 `get`、`put`、`modify`、`runState`、`evalState` 和 "
"`execState`对于索引状态数据类型。确保在必要时调整类型参数。\n"

#. type: Bullet: '   7. '
#: ../src/Tutorial/Traverse.md:812
#, no-wrap
msgid ""
"Show that your indexed state type is strictly more powerful than\n"
"`State` by implementing `Applicative` and `Monad` for it.\n"
msgstr "通过为它实现 `Applicative` 和 `Monad` 来证明你的索引状态类型比 `State` "
"更强大。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:816
#, no-wrap
msgid ""
"      Hint: Keep the input and output state identical. Note also,\n"
"      that you might need to implement `join` manually if Idris\n"
"      has trouble inferring the types correctly.\n"
msgstr ""
"      提示：保持输入和输出状态相同。另请注意，\n"
"      如果 Idris 无法正确推断类型，您可能需要手动实施 `join`。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:821
#, no-wrap
msgid ""
"   Indexed state types can be useful when we want to make sure that\n"
"   stateful computations are combined in the correct sequence, or\n"
"   that scarce resources get cleaned up properly. We might get back\n"
"   to such use cases in later examples.\n"
msgstr ""
"   当我们想要确保\n"
"   有状态的计算以正确的顺序组合，或者\n"
"   稀缺资源得到妥善清理。我们可能会在后面的示例中使用此类用例。\n"

#. type: Title ##
#: ../src/Tutorial/Traverse.md:822
#, no-wrap
msgid "The Power of Composition"
msgstr "组合的力量"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:830
#, no-wrap
msgid ""
"After our excursion into the realms of stateful computations, we\n"
"will go back and combine mutable state with error accumulation\n"
"to tag and read CSV lines in a single traversal. We already\n"
"defined `pairWithIndex` for tagging lines with their indices.\n"
"We also have `uncurry $ hdecode ts` for decoding single tagged lines.\n"
"We can now combine the two effects in a single computation:\n"
msgstr ""
"在进入有状态计算领域之后，我们\n"
"将返回并将可变状态与错误累积结合起来\n"
"在一次遍历中标记和读取 CSV 行。我们已经\n"
"定义 `pairWithIndex` 用于标记行及其索引。\n"
"我们还有 `uncurry $ hdecode ts` 用于解码单个标记行。\n"
"我们现在可以在一次计算中结合这两种效果：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:831
#, no-wrap
msgid ""
"tagAndDecode :  (0 ts : List Type)\n"
"             -> CSVLine (HList ts)\n"
"             => String\n"
"             -> State Nat (Validated CSVError (HList ts))\n"
"tagAndDecode ts s = uncurry (hdecode ts) <$> pairWithIndex s\n"
msgstr ""
"tagAndDecode :  (0 ts : List Type)\n"
"             -> CSVLine (HList ts)\n"
"             => String\n"
"             -> State Nat (Validated CSVError (HList ts))\n"
"tagAndDecode ts s = uncurry (hdecode ts) <$> pairWithIndex s\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:851
#, no-wrap
msgid ""
"Now, as we learned before, applicative functors are closed under\n"
"composition, and the result of `tagAndDecode` is a nesting\n"
"of two applicatives: `State Nat` and `Validated CSVError`.\n"
"The *Prelude* exports a corresponding named interface implementation\n"
"(`Prelude.Applicative.Compose`), which we can use for traversing\n"
"a list of strings with `tagAndDecode`.\n"
"Remember, that we have to provide named implementations explicitly.\n"
"Since `traverse` has the applicative functor as its\n"
"second constraint, we also need to provide the first\n"
"constraint (`Traversable`) explicitly. But this\n"
"is going to be the unnamed default implementation! To get our hands on such\n"
"a value, we can use the `%search` pragma:\n"
msgstr ""
"现在，正如我们之前所了解的，应用函子是封闭的\n"
"组合，`tagAndDecode` 的结果是嵌套\n"
"两个应用程序：`State Nat` 和 `Validated CSVError`。\n"
"*Prelude* 导出相应的命名接口实现\n"
"(`Prelude.Applicative.Compose`)，我们可以用来遍历\n"
"带有 `tagAndDecode` 的字符串列表。\n"
"请记住，我们必须明确提供命名实现。\n"
"由于 `traverse` 有应用函子作为它的\n"
"第二个约束，我们还需要提供第一个\n"
"显式约束 (`Traversable`)。但是这个\n"
"将是未命名的默认实现！为了得到这样的一个值，我们可以使用 `%search` pragma：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:852
#, no-wrap
msgid ""
"readTable :  (0 ts : List Type)\n"
"          -> CSVLine (HList ts)\n"
"          => List String\n"
"          -> Validated CSVError (List $ HList ts)\n"
"readTable ts = evalState 1 . traverse @{%search} @{Compose} (tagAndDecode ts)\n"
msgstr ""
"readTable :  (0 ts : List Type)\n"
"          -> CSVLine (HList ts)\n"
"          => List String\n"
"          -> Validated CSVError (List $ HList ts)\n"
"readTable ts = evalState 1 . traverse @{%search} @{Compose} (tagAndDecode ts)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:866
#, no-wrap
msgid ""
"This tells Idris to use the default implementation for the\n"
"`Traversable` constraint, and `Prelude.Applicatie.Compose` for the\n"
"`Applicative` constraint.\n"
"While this syntax is not very nice, it doesn't come up too often, and\n"
"if it does, we can improve things by providing custom functions\n"
"for better readability:\n"
msgstr ""
"这告诉 Idris 使用默认实现\n"
"`Traversable` 约束和 `Applicative` 约束的 `Prelude.Applicatie.Compose` 。\n"
"虽然这种语法不是很好，但它不会经常出现，并且\n"
"如果是这样，我们可以通过提供自定义函数来改进\n"
"为了更好的可读性：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:867
#, no-wrap
msgid ""
"traverseComp : Traversable t\n"
"             => Applicative f\n"
"             => Applicative g\n"
"             => (a -> f (g b))\n"
"             -> t a\n"
"             -> f (g (t b))\n"
"traverseComp = traverse @{%search} @{Compose}\n"
"\n"
"readTable' :  (0 ts : List Type)\n"
"           -> CSVLine (HList ts)\n"
"           => List String\n"
"           -> Validated CSVError (List $ HList ts)\n"
"readTable' ts = evalState 1 . traverseComp (tagAndDecode ts)\n"
msgstr ""
"traverseComp : Traversable t\n"
"             => Applicative f\n"
"             => Applicative g\n"
"             => (a -> f (g b))\n"
"             -> t a\n"
"             -> f (g (t b))\n"
"traverseComp = traverse @{%search} @{Compose}\n"
"\n"
"readTable' :  (0 ts : List Type)\n"
"           -> CSVLine (HList ts)\n"
"           => List String\n"
"           -> Validated CSVError (List $ HList ts)\n"
"readTable' ts = evalState 1 . traverseComp (tagAndDecode ts)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:885
#, no-wrap
msgid ""
"Note, how this allows us to combine two computational effects\n"
"(mutable state and error accumulation) in a single list traversal.\n"
msgstr ""
"请注意，这如何让我们结合两种计算效果\n"
"（可变状态和错误累积）在单个列表遍历中。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:898
#, no-wrap
msgid ""
"But I am not yet done demonstrating the power of composition. As you showed\n"
"in one of the exercises, `Traversable` is also closed under composition,\n"
"so a nesting of traversables is again a traversable. Consider the following\n"
"use case: When reading a CSV file, we'd like to allow lines to be\n"
"annotated with additional information. Such annotations could be\n"
"mere comments but also some formatting instructions or other\n"
"custom data tags might be feasible.\n"
"Annotations are supposed to be separated from the rest of the\n"
"content by a single hash character (`#`).\n"
"We want to keep track of these optional annotations\n"
"so we come up with a custom data type encapsulating\n"
"this distinction:\n"
msgstr ""
"但我还没有完成展示组合的力量。正如你在其中一个练习中所展示的，`Traversable` 在组合下也是闭合的，\n"
"所以可遍历的嵌套又是可遍历的。考虑以下用例：读取 CSV 文件时，我们希望允许行附有附加信息的注释。这样的注释可以仅仅是评论，还有一些格式说明或其他\n"
"可选的自定义数据标签。\n"
"注释应该与其他注释分开\n"
"单个哈希字符 (`#`) 的内容。\n"
"我们希望跟踪这些可选注释\n"
"所以我们想出了一个自定义数据类型封装\n"
"这种区别：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:899
#, no-wrap
msgid ""
"data Line : Type -> Type where\n"
"  Annotated : String -> a -> Line a\n"
"  Clean     : a -> Line a\n"
msgstr ""
"data Line : Type -> Type where\n"
"  Annotated : String -> a -> Line a\n"
"  Clean     : a -> Line a\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:908
#, no-wrap
msgid ""
"This is just another container type and we can\n"
"easily implement `Traversable` for `Line` (do this yourself as\n"
"a quick exercise):\n"
msgstr ""
"这只是另一种容器类型，我们可以\n"
"为 `Line` 轻松实现 `Traversable` （自己做\n"
"快速练习）：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:909
#, no-wrap
msgid ""
"Functor Line where\n"
"  map f (Annotated s x) = Annotated s $ f x\n"
"  map f (Clean x)       = Clean $ f x\n"
"\n"
"Foldable Line where\n"
"  foldr f acc (Annotated _ x) = f x acc\n"
"  foldr f acc (Clean x)       = f x acc\n"
"\n"
"Traversable Line where\n"
"  traverse f (Annotated s x) = Annotated s <$> f x\n"
"  traverse f (Clean x)       = Clean <$> f x\n"
msgstr ""
"Functor Line where\n"
"  map f (Annotated s x) = Annotated s $ f x\n"
"  map f (Clean x)       = Clean $ f x\n"
"\n"
"Foldable Line where\n"
"  foldr f acc (Annotated _ x) = f x acc\n"
"  foldr f acc (Clean x)       = f x acc\n"
"\n"
"Traversable Line where\n"
"  traverse f (Annotated s x) = Annotated s <$> f x\n"
"  traverse f (Clean x)       = Clean <$> f x\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:928
#, no-wrap
msgid ""
"Below is a function for parsing a line and putting it in its\n"
"correct category. For simplicity, we just split the line on hashes:\n"
"If the result consists of exactly two strings, we treat the second\n"
"part as an annotation, otherwise we treat the whole line as untagged\n"
"CSV content.\n"
msgstr ""
"下面是一个用于解析一行并将其放入其中的函数\n"
"正确的类别。为简单起见，我们只是将行拆分为散列：\n"
"如果结果正好由两个字符串组成，我们处理第二个\n"
"部分作为注释，否则我们将整行视为未标记\n"
"CSV 内容。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:929
#, no-wrap
msgid ""
"readLine : String -> Line String\n"
"readLine s = case split ('#' ==) s of\n"
"  h ::: [t] => Annotated t h\n"
"  _         => Clean s\n"
msgstr ""
"readLine : String -> Line String\n"
"readLine s = case split ('#' ==) s of\n"
"  h ::: [t] => Annotated t h\n"
"  _         => Clean s\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:938
#, no-wrap
msgid ""
"We are now going to implement a function for reading whole\n"
"CSV tables, keeping track of line annotations:\n"
msgstr ""
"我们现在要实现一个读取整个函数的函数\n"
"CSV 表，跟踪行注释：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:939
#, no-wrap
msgid ""
"readCSV :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => String\n"
"        -> Validated CSVError (List $ Line $ HList ts)\n"
"readCSV ts = evalState 1\n"
"           . traverse @{Compose} @{Compose} (tagAndDecode ts)\n"
"           . map readLine\n"
"           . lines\n"
msgstr ""
"readCSV :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => String\n"
"        -> Validated CSVError (List $ Line $ HList ts)\n"
"readCSV ts = evalState 1\n"
"           . traverse @{Compose} @{Compose} (tagAndDecode ts)\n"
"           . map readLine\n"
"           . lines\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:966
#, no-wrap
msgid ""
"Let's digest this monstrosity. This is written in point-free\n"
"style, so we have to read it from end to beginning. First, we\n"
"split the whole string at line breaks, getting a list of strings\n"
"(function `Data.String.lines`). Next, we analyze each line,\n"
"keeping track of optional annotations (`map readLine`).\n"
"This gives us a value of type `List (Line String)`. Since\n"
"this is a nesting of traversables, we invoke `traverse`\n"
"with a named instance from the *Prelude*: `Prelude.Traversable.Compose`.\n"
"Idris can disambiguate this based on the types, so we can\n"
"drop the namespace prefix. But the effectful computation\n"
"we run over the list of lines results in a composition\n"
"of applicative functors, so we also need the named implementation\n"
"for compositions of applicatives in the second\n"
"constraint (again without need of an explicit\n"
"prefix, which would be `Prelude.Applicative` here).\n"
"Finally, we evaluate the stateful computation with `evalState 1`.\n"
msgstr ""
"让我们消化这个怪物。这是用无点的\n"
"风格写的，所以我们必须从头到尾阅读它。首先，我们\n"
"在换行符处拆分整个字符串，得到一个字符串列表\n"
"（函数 `Data.String.lines`）。接下来，我们分析每一行，\n"
"跟踪可选注释（`map readLine`）。\n"
"这给了我们一个 `List (Line String)` 类型的值。这是可遍历的嵌套，我们调用 `traverse`\n"
"使用来自 *Prelude* 的命名实例：`Prelude.Traversable.Compose`。\n"
"Idris 可以根据类型消除歧义，因此我们可以\n"
"删除命名空间前缀。但我们在行列表上有效的计算会产生一个应用函子的组合，所以对于第二个中的应用程序组合\n"
"约束我们还需要命名的实现（同样不需要明确的前缀，此处为 `Prelude.Applicative`）。\n"
"最后，我们使用 `evalState 1` 评估有状态计算。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:974
#, no-wrap
msgid ""
"Honestly, I wrote all of this without verifying if it works,\n"
"so let's give it a go at the REPL. I'll provide two\n"
"example strings for this, a valid one without errors, and\n"
"an invalid one. I use *multiline string literals* here, about which\n"
"I'll talk in more detail in a later chapter. For the moment,\n"
"note that these allow us to conveniently enter string literals\n"
"with line breaks:\n"
msgstr ""
"老实说，我写了所有这些都没有验证它是否有效，\n"
"所以让我们在 REPL 上试一试吧。我会提供两个\n"
"示例字符串，一个没有错误的有效字符串，以及\n"
"一个无效的。我在这里使用 *多行字符串文字* ，关于\n"
"我将在后面的章节中更详细地讨论。暂时，\n"
"请注意，这些允许我们方便地输入字符串文字\n"
"带换行符：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:975
#, no-wrap
msgid ""
"validInput : String\n"
"validInput = \"\"\"\n"
"  f,12,-13.01#this is a comment\n"
"  t,100,0.0017\n"
"  t,1,100.8#color: red\n"
"  f,255,0.0\n"
"  f,24,1.12e17\n"
"  \"\"\"\n"
"\n"
"invalidInput : String\n"
"invalidInput = \"\"\"\n"
"  o,12,-13.01#another comment\n"
"  t,100,0.0017\n"
"  t,1,abc\n"
"  f,256,0.0\n"
"  f,24,1.12e17\n"
"  \"\"\"\n"
msgstr ""
"validInput : String\n"
"validInput = \"\"\"\n"
"  f,12,-13.01#this is a comment\n"
"  t,100,0.0017\n"
"  t,1,100.8#color: red\n"
"  f,255,0.0\n"
"  f,24,1.12e17\n"
"  \"\"\"\n"
"\n"
"invalidInput : String\n"
"invalidInput = \"\"\"\n"
"  o,12,-13.01#another comment\n"
"  t,100,0.0017\n"
"  t,1,abc\n"
"  f,256,0.0\n"
"  f,24,1.12e17\n"
"  \"\"\"\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:996
#, no-wrap
msgid "And here's how it goes at the REPL:\n"
msgstr "以下是 REPL 的情况：\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid ""
"Tutorial.Traverse> readCSV [Bool,Bits8,Double] validInput\n"
"Valid [Annotated \"this is a comment\" [False, 12, -13.01],\n"
"       Clean [True, 100, 0.0017],\n"
"       Annotated \"color: red\" [True, 1, 100.8],\n"
"       Clean [False, 255, 0.0],\n"
"       Clean [False, 24, 1.12e17]]\n"
"\n"
"Tutorial.Traverse> readCSV [Bool,Bits8,Double] invalidInput\n"
"Invalid (Append (FieldError 1 1 \"o\")\n"
"  (Append (FieldError 3 3 \"abc\") (FieldError 4 2 \"256\")))\n"
msgstr ""
"Tutorial.Traverse> readCSV [Bool,Bits8,Double] validInput\n"
"Valid [Annotated \"this is a comment\" [False, 12, -13.01],\n"
"       Clean [True, 100, 0.0017],\n"
"       Annotated \"color: red\" [True, 1, 100.8],\n"
"       Clean [False, 255, 0.0],\n"
"       Clean [False, 24, 1.12e17]]\n"
"\n"
"Tutorial.Traverse> readCSV [Bool,Bits8,Double] invalidInput\n"
"Invalid (Append (FieldError 1 1 \"o\")\n"
"  (Append (FieldError 3 3 \"abc\") (FieldError 4 2 \"256\")))\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1015
#, no-wrap
msgid ""
"It is pretty amazing how we wrote dozens of lines of\n"
"code, always being guided by the type- and totality\n"
"checkers, arriving eventually at a function for parsing\n"
"properly typed CSV tables with automatic line numbering and\n"
"error accumulation, all of which just worked on first try.\n"
msgstr ""
"我们写了几十行代码，这真是太神奇了，始终遵循类型和完全性检查器，最终到达解析函数\n"
"正确键入带有自动行编号的 CSV 表和\n"
"错误累积，所有这些都在第一次尝试时起作用。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1025
#, no-wrap
msgid ""
"The *Prelude* provides three additional interfaces for\n"
"container types parameterized over *two* type parameters\n"
"such as `Either` or `Pair`: `Bifunctor`, `Bifoldable`,\n"
"and `Bitraversable`. In the following exercises we get\n"
"some hands-one experience working with these. You are\n"
"supposed to look up what functions they provide\n"
"and how to implement and use them yourself.\n"
msgstr ""
"*Prelude* 提供三个附加接口\n"
"通过 *两个* 类型参数参数化的容器类型\n"
"比如`Either`或者`Pair`：`Bifunctor`，`Bifoldable`，\n"
"和 `Bitraversable`。在下面的练习中，我们得到\n"
"一些与这些一起工作的亲身体验。你是\n"
"应该查找它们提供的功能\n"
"以及如何自己实施和使用它们。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:1029
#, no-wrap
msgid ""
"Assume we'd like to not only interpret CSV content\n"
"but also the optional comment tags in our CSV files.\n"
"For this, we could use a data type such as `Tagged`:\n"
msgstr "假设我们不仅要解释 CSV 内容，还要解释 CSV 文件中的可选注释标签。为此，"
"我们可以使用诸如 `Tagged` 之类的数据类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1030
#, no-wrap
msgid ""
"   data Tagged : (tag, value : Type) -> Type where\n"
"     Tag  : tag -> value -> Tagged tag value\n"
"     Pure : value -> Tagged tag value\n"
msgstr ""
"   data Tagged : (tag, value : Type) -> Type where\n"
"     Tag  : tag -> value -> Tagged tag value\n"
"     Pure : value -> Tagged tag value\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1039
#, no-wrap
msgid ""
"   Implement interfaces `Functor`, `Foldable`, and `Traversable`\n"
"   but also `Bifunctor`, `Bifoldable`, and `Bitraversable`\n"
"   for `Tagged`.\n"
msgstr ""
"   为 `Tagged` 实现接口 `Functor`、`Foldable` 和 `Traversable`\n"
"   还有 `Bifunctor`、`Bifoldable` 和 `Bitraversable`。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:1045
#, no-wrap
msgid ""
"Show that the composition of a bifunctor with two functors\n"
"such as `Either (List a) (Maybe b)` is again a bifunctor\n"
"by defining a dedicated wrapper type for such compositions\n"
"and writing a corresponding implementation of `Bifunctor`.\n"
"Likewise for `Bifoldable`/`Foldable` and `Bitraversable`/`Traversable`.\n"
msgstr ""
"通过为此类组合定义专用包装器类型并编写 `Bifunctor` "
"的相应实现，证明具有两个函子（例如 `Either (List a) (Maybe "
"b)`）的二元函子的组合再次成为二元函子`。同样适用于 `Bifoldable`/`Foldable` "
"和 `Bitraversable`/`Traversable`。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Traverse.md:1051
#, no-wrap
msgid ""
"Show that the composition of a functor with a bifunctor\n"
"such as `List (Either a b)` is again a bifunctor\n"
"by defining a dedicated wrapper type for such compositions\n"
"and writing a corresponding implementation of `Bifunctor`.\n"
"Likewise for `Bifoldable`/`Foldable` and `Bitraversable`/`Traversable`.\n"
msgstr ""
"通过为此类组合定义专用包装器类型并编写 `Bifunctor` "
"的相应实现，证明具有二元函子（如 `List (Either a "
"b)`）的函子的组合再次是二元函子。同样适用于 `Bifoldable`/`Foldable` 和 "
"`Bitraversable`/`Traversable`。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Traverse.md:1055
#, no-wrap
msgid ""
"We are now going to adjust `readCSV` in such a way that it\n"
"decodes comment tags and CSV content in a single traversal.\n"
"We need a new error type to include invalid tags for this:\n"
msgstr "我们现在将调整 `readCSV` 使其在一次遍历中解码评论标签和 CSV "
"内容。我们需要一个新的错误类型来包含无效的标签：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1056
#, no-wrap
msgid ""
"   data TagError : Type where\n"
"     CE         : CSVError -> TagError\n"
"     InvalidTag : (line : Nat) -> (tag : String) -> TagError\n"
"     Append     : TagError -> TagError -> TagError\n"
"\n"
"   Semigroup TagError where (<+>) = Append\n"
msgstr ""
"   data TagError : Type where\n"
"     CE         : CSVError -> TagError\n"
"     InvalidTag : (line : Nat) -> (tag : String) -> TagError\n"
"     Append     : TagError -> TagError -> TagError\n"
"\n"
"   Semigroup TagError where (<+>) = Append\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1066
#, no-wrap
msgid "   For testing, we also define a simple data type for color tags:\n"
msgstr "   为了测试，我们还为颜色标签定义了一个简单的数据类型：\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1067
#, no-wrap
msgid "   data Color = Red | Green | Blue\n"
msgstr "   data Color = Red | Green | Blue\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1076
#, no-wrap
msgid ""
"   You should now implement the following functions, but\n"
"   please note that while `readColor` will need to\n"
"   access the current line number in case of an error,\n"
"   it must *not* increase it, as otherwise line numbers\n"
"   will be wrong in the invocation of `tagAndDecodeTE`.\n"
msgstr ""
"   您现在应该实现以下功能，但是\n"
"   请注意，虽然 `readColor` 需要\n"
"   出现错误时访问当前行号，\n"
"   它必须 *不* 增加它，否则行号\n"
"   调用 `tagAndDecodeTE` 会出错。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1077
#, no-wrap
msgid ""
"   readColor : String -> State Nat (Validated TagError Color)\n"
"\n"
"   readTaggedLine : String -> Tagged String String\n"
"\n"
"   tagAndDecodeTE :  (0 ts : List Type)\n"
"                  -> CSVLine (HList ts)\n"
"                  => String\n"
"                  -> State Nat (Validated TagError (HList ts))\n"
msgstr ""
"   readColor : String -> State Nat (Validated TagError Color)\n"
"\n"
"   readTaggedLine : String -> Tagged String String\n"
"\n"
"   tagAndDecodeTE :  (0 ts : List Type)\n"
"                  -> CSVLine (HList ts)\n"
"                  => String\n"
"                  -> State Nat (Validated TagError (HList ts))\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1094
#, no-wrap
msgid ""
"   Finally, implement `readTagged` by using the wrapper type\n"
"   from exercise 3 as well as `readColor` and `tagAndDecodeTE`\n"
"   in a call to `bitraverse`.\n"
"   The implementation will look very similar to `readCSV` but\n"
"   with some additional wrapping and unwrapping at the right\n"
"   places.\n"
msgstr ""
"   最后，使用 wrapper 类型实现 `readTagged`\n"
"   来自练习 3 以及 `readColor` 和 `tagAndDecodeTE`\n"
"   在对 `bitraverse` 的调用中。\n"
"   该实现看起来与 `readCSV` 非常相似，但是\n"
"   在右侧有一些额外的包装和展开。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1095
#, no-wrap
msgid ""
"   readTagged :  (0 ts : List Type)\n"
"              -> CSVLine (HList ts)\n"
"              => String\n"
"              -> Validated TagError (List $ Tagged Color $ HList ts)\n"
msgstr ""
"   readTagged :  (0 ts : List Type)\n"
"              -> CSVLine (HList ts)\n"
"              => String\n"
"              -> Validated TagError (List $ Tagged Color $ HList ts)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1103
#, no-wrap
msgid "   Test your implementation with some example strings at the REPL.\n"
msgstr "   使用 REPL 中的一些示例字符串测试您的实现。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1108
#, no-wrap
msgid ""
"You can find more examples for functor/bifunctor compositions\n"
"in Haskell's [bifunctors](https://hackage.haskell.org/package/bifunctors)\n"
"package.\n"
msgstr ""
"您可以找到更多关于函子/二元函子组合的示例\n"
"在 Haskell 的 [bifunctors](https://hackage.haskell.org/package/bifunctors)\n"
"包装。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1117
#, no-wrap
msgid ""
"Interface `Traversable` and its main function `traverse` are incredibly\n"
"powerful forms of abstraction - even more so, because both `Applicative`\n"
"and `Traversable` are closed under composition. If you are interested\n"
"in additional use cases, the publication, which\n"
"introduced `Traversable` to Haskell, is a highly recommended read:\n"
"[The Essence of the Iterator Pattern](https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf)\n"
msgstr ""
"接口`Traversable`及其主函数`traverse`令人难以置信\n"
"强大的抽象形式 - 更是如此，因为 `Applicative`\n"
"和 `Traversable` 在组合下是闭合的。如果你感兴趣\n"
"在其他用例中，该出版物，其中\n"
"向 Haskell 介绍了 `Traversable`，强烈推荐阅读：\n"
"[迭代器模式的本质](https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf)\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1124
#, no-wrap
msgid ""
"The *base* library provides an extended version of the\n"
"state monad in module `Control.Monad.State`. We will look\n"
"at this in more detail when we talk about monad transformers.\n"
"Please note also, that `IO` itself is implemented as a\n"
"[simple state monad](IO.md#how-io-is-implemented)\n"
"over an abstract, primitive state type: `%World`.\n"
msgstr ""
"*base* 库提供了\n"
"模块 `Control.Monad.State` 中的状态单子。我们会看\n"
"当我们谈论 monad 转换器时，会更详细地介绍这一点。\n"
"另请注意，`IO` 本身被实现为\n"
"[简单状态单子](IO.md#how-io-is-implemented)\n"
"在抽象的原始状态类型上：`%World`。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1126
#, no-wrap
msgid "Here's a short summary of what we learned in this chapter:\n"
msgstr "以下是我们在本章中学到的内容的简短摘要：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
#, no-wrap
msgid ""
"Function `traverse` is used to run effectful computations\n"
"over container types without affecting their size or shape.\n"
msgstr "函数 `traverse` 用于对容器类型运行有效的计算，而不影响它们的大小或形状。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
#, no-wrap
msgid ""
"We can use `IORef` as mutable references in stateful\n"
"computations running in `IO`.\n"
msgstr "我们可以使用 `IORef` 作为在 `IO` 中运行的有状态计算中的可变引用。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
#, no-wrap
msgid ""
"For referentially transparent computations with \"mutable\"\n"
"state, the `State` monad is extremely useful.\n"
msgstr "对于具有“可变”状态的引用透明计算，`State` 单子非常有用。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
#, no-wrap
msgid ""
"Applicative functors are closed under composition,\n"
"so we can run several effectful computations in a single\n"
"traversal.\n"
msgstr "应用函子在组合下是封闭的，因此我们可以在一次遍历中运行多个有效的计算。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
#, no-wrap
msgid ""
"Traversables are also closed under composition, so we can\n"
"use `traverse` to operate on a nesting of containers.\n"
msgstr "Traversables 在组合下也是封闭的，所以我们可以使用 `traverse` "
"对容器的嵌套进行操作。\n"

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1146
#, no-wrap
msgid ""
"For now, this concludes our introduction of the *Prelude*'s\n"
"higher-kinded interfaces, which started with the introduction of\n"
"`Functor`, `Applicative`, and `Monad`, before moving on to `Foldable`,\n"
"and - last but definitely not least - `Traversable`.\n"
"There's one still missing - `Alternative` - but this will\n"
"have to wait a bit longer, because we need to first make\n"
"our brains smoke with some more type-level wizardry.\n"
msgstr ""
"至此，我们对 *Prelude* 的介绍到此结束\n"
"更高级的接口，从引入\n"
"`Functor`、`Applicative` 和 `Monad`，在继续 `Foldable` 之前，\n"
"和 - 最后但同样重要的是 - `Traversable`。\n"
"仍然缺少一个 - `Alternative` - 但这会\n"
"必须等待更长的时间，因为我们需要先使\n"
"我们的大脑会冒出更多类型级别的魔法。\n"

#. type: Title #
#: ../src/Appendices/Neovim.md:1
#, no-wrap
msgid "Interactive Editing in Neovim"
msgstr "Neovim 中的交互式编辑"

#. type: Plain text
#: ../src/Appendices/Neovim.md:10
#, no-wrap
msgid ""
"Idris provides extensive capabilities to interactively\n"
"analyze the types of values and expressions in our programs\n"
"and fill out skeleton implementations and sometimes even whole\n"
"programs for us based on the types provided. These interactive\n"
"editing features are available via plugins in different editors.\n"
"Since I am a Neovim user, I explain the Idris related parts of\n"
"my own setup in detail here.\n"
msgstr ""
"Idris 提供了广泛的交互功能\n"
"来分析我们程序中的值和表达式的类型\n"
"并填写骨架实现，有时甚至根据提供的类型为我们提供完整的的程序。这些交互\n"
"编辑功能可通过不同编辑器中的插件获得。\n"
"由于我是 Neovim 用户，我会详细解释一下我自己的设置中 Idris 的相关部分。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:20
#, no-wrap
msgid ""
"The main component required to get all these features to run\n"
"in Neovim is an executable provided by the\n"
"[idris2-lsp](https://github.com/idris-community/idris2-lsp) project.\n"
"This executable makes use of the Idris compiler API (application\n"
"programming interface) internally and can check the syntax and\n"
"types of the source code we are working on. It communicates with\n"
"Neovim via the language server protocol (LSP). This communication\n"
"is setup through the [idris2-nvim](https://github.com/ShinKage/idris2-nvim)\n"
"plugin.\n"
msgstr ""
"Neovim 中运行所有这些功能所需的主要组件是由 [idris2-lsp](https://github.com/idris-community/idris2-lsp) 项目提供的可执行文件。\n"
"此可执行文件内部使用 Idris 编译器 API（应用程序编程接口），可以检查语法和\n"
"我们正在处理的源代码的类型。它与\n"
"Neovim 通过语言服务器协议 (LSP)。这种沟通由 [idris2-nvim](https://github.com/ShinKage/idris2-nvim) \n"
"插件来完成 。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:31
#, no-wrap
msgid ""
"As we will see in this tutorial, the `idris2-lsp` executable not only\n"
"supports syntax and type checking, but comes also with additional\n"
"interactive editing features. Finally, the Idris compiler API supports\n"
"semantic highlighting of Idris source code: Identifiers and keywords\n"
"are highlighted not only based on the language's syntax (that would\n"
"be *syntax highlighting*, a feature expected from all modern\n"
"programming environments and editors), but also based on their\n"
"*semantics*. For instance, a local variable in a function implementation\n"
"gets highlighted differently than the name of a top level function,\n"
"although syntactically these are both just identifiers.\n"
msgstr ""
"正如我们将在本教程中看到的，`idris2-lsp` 可执行文件不仅\n"
"支持语法和类型检查，但还附带额外的\n"
"交互式编辑功能。最后，Idris 编译器 API 支持\n"
"Idris 源代码的语义高亮：标识符和关键字\n"
"突出显示不仅基于语言的语法（这将\n"
"成为 *语法高亮*，所有现代编程环境和编辑器都预期会有的功能），也基于它们的\n"
"*语义*。例如，函数实现中的局部变量\n"
"以不同于顶级函数名称的方式突出显示，\n"
"尽管从语法上讲，它们都只是标识符。\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:32
#, no-wrap
msgid ""
"module Appendices.Neovim\n"
"\n"
"import Data.Vect\n"
"\n"
"%default total\n"
msgstr ""
"module Appendices.Neovim\n"
"\n"
"import Data.Vect\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:40
#, no-wrap
msgid "Setup"
msgstr "设置"

#. type: Plain text
#: ../src/Appendices/Neovim.md:44
#, no-wrap
msgid ""
"In order to make full use of interactive Idris editing in\n"
"Neovim, at least the following tools need to be installed:\n"
msgstr ""
"为了充分利用交互式 Idris 编辑\n"
"Neovim，至少需要安装以下工具：\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid "A recent version of Neovim (version 0.5 or later).\n"
msgstr "Neovim 的最新版本（0.5 版或更高版本）。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid "A recent version of the Idris compiler (at least version 0.5.1).\n"
msgstr "Idris 编译器的最新版本（至少版本 0.5.1）。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid "The Idris compiler API.\n"
msgstr "Idris 编译器 API。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid "The [idris2-lsp](https://github.com/idris-community/idris2-lsp) package.\n"
msgstr "[idris2-lsp](https://github.com/idris-community/idris2-lsp) 包。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid "The following Neovim plugins:\n"
msgstr "以下 Neovim 插件：\n"

#. type: Bullet: '  * '
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid "[idris2-nvim](https://github.com/ShinKage/idris2-nvim)\n"
msgstr "[idris2-nvim](https://github.com/ShinKage/idris2-nvim)\n"

#. type: Bullet: '  * '
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid "[nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)\n"
msgstr "[nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:57
#, no-wrap
msgid ""
"The `idris2-lsp` project gives detailed instructions about how\n"
"to install Idris 2 together with its standard libraries and compiler\n"
"API. Make sure to follow these instructions so that your compiler\n"
"and `idris2-lsp` executable are in sync.\n"
msgstr ""
"`idris2-lsp` 项目提供了有关如何使用的详细说明\n"
"安装 Idris 2 及其标准库和编译器\n"
"API。确保遵循这些说明，以便您的编译器和 `idris2-lsp` 可执行文件是同步的。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:67
#, no-wrap
msgid ""
"If you are new to Neovim, you might want to use the `init.vim`\n"
"file provided in the `resources` folder. In that case, the\n"
"necessary Neovim plugins are already included, but you need to install\n"
"[vim-plug](https://github.com/junegunn/vim-plug), a plugin manager.\n"
"Afterwards, copy all or parts of `resources/init.vim` to your own `init.vim`\n"
"file. (Use `:help init.vim` from within Neovim in order to find\n"
"out where to look for this file.). After setting up your `init.vim`\n"
"file, restart Neovim and run `:PlugUpdate` to install the\n"
"necessary plugins.\n"
msgstr ""
"如果你是 Neovim 的新手，你可能想要使用 `resource` 文件夹中提供的 `init.vim` 文件。在这种情况下，\n"
"已经包含了必要的 Neovim 插件，但您需要安装\n"
"[vim-plug](https://github.com/junegunn/vim-plug)，一个插件管理器。\n"
"之后，将 `resources/init.vim` 的全部或部分复制到你自己的 `init.vim`\n"
"文件。 （在 Neovim 中使用 `:help init.vim` 来查找\n"
"在哪里可以找到这个文件。）。设置好 `init.vim` 文件后，重启 Neovim 并运行 `:PlugUpdate` 安装\n"
"必要的插件。\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:68
#, no-wrap
msgid "A Typical Workflow"
msgstr "常见的工作流程"

#. type: Plain text
#: ../src/Appendices/Neovim.md:77
#, no-wrap
msgid ""
"In order to checkout the interactive editing features\n"
"available to us, we will reimplement some small utilities\n"
"from the *Prelude*. To follow along, you should have\n"
"already worked through the [Introduction](../Tutorial/Intro.md),\n"
"[Functions Part 1](../Tutorial/Functions1.md), and at least\n"
"parts of [Algebraic Data Types](../Tutorial/DataTypes.md), otherwise\n"
"it will be hard to understand what's going on here.\n"
msgstr ""
"为了检查可供我们使用的交互式编辑功能\n"
"，我们将重新实现一些来自 *Prelude* 的小型实用程序。跟随我到这一步，你应该已经完成了[介绍](../Tutorial/Intro.md)，\n"
"[函数第 1 部分](../Tutorial/Functions1.md)，并且至少\n"
"[代数数据类型](../Tutorial/DataTypes.md) 的一部分，否则很难理解这里发生了什么。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:83
#, no-wrap
msgid ""
"Before we begin, note that the commands and actions shown in this\n"
"tutorial might not work correctly after you edited a source file\n"
"but did not write your changes to disk. Therefore, the first thing\n"
"you should try if the things described here do not work, is to\n"
"quickly save the current file (`:w`).\n"
msgstr ""
"在开始之前，请注意这里显示的命令和操作在编辑源文件后教程可能无法正常工作\n"
"引用没有将您的更改写入磁盘。因此，第一件事是\n"
"如果这里描述的东西不起作用，你应该尝试，快速保存当前文件（`:w`）。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:85
#, no-wrap
msgid "Let's start with negation of a boolean value:\n"
msgstr "让我们从布尔值的否定开始：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:86
#, no-wrap
msgid "negate1 : Bool -> Bool\n"
msgstr "negate1 : Bool -> Bool\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:102
#, no-wrap
msgid ""
"Typically, when writing Idris code we follow the mantra\n"
"\"types first\". Although you might already have an idea about\n"
"how to implement a certain piece of functionality, you still\n"
"need to provide an accurate type before you can start writing\n"
"your implementation. This means, when programming in Idris, we have\n"
"to mentally keep track of the implementation of an algorithm\n"
"and the types involved at the same time, both of which can\n"
"become arbitrarily complex. Or do we? Remember that Idris knows\n"
"at least as much about the variables and their types available\n"
"in the current context of a function implementation as we do,\n"
"so we probably should ask it for guidance instead of trying\n"
"to do everything on our own.\n"
msgstr "通常，在编写 Idris 代码时，我们遵循“类型优先”准则。虽然您可能已经知道如何实现某一功能，但在开始编写实现之前，仍然需要提供准确的类型。这意味着，在 Idris 中编程时，我们需要在脑海中跟踪算法的实现以及同时涉及的类型，两者都有可能会变得异常复杂。我们还可以吗？请记住，请记住，Idris 至少和我们一样了解当前函数实现上下文中可用的变量及其类型，因此我们可能应该向Idris寻求指导，而不是尝试自己做所有事情。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:112
#, no-wrap
msgid ""
"So, in order to proceed, we ask Idris for a skeleton function\n"
"body: In normal editor mode, move your cursor on the line where\n"
"`negate1` is declared and enter `<LocalLeader>a` in quick\n"
"succession. `<LocalLeader>` is a special key that can be specified\n"
"in the `init.vim` file. If you\n"
"use the `init.vim` from the `resources` folder, it is set to\n"
"the comma character (`,`), in which case the above command\n"
"consists of a comma quickly followed by the lowercase letter \"a\".\n"
"See also `:help leader` and `:help localleader` in Neovim\n"
msgstr ""
"所以，为了继续，我们向 Idris 请求一个骨架函数体：在普通编辑器模式下，将光标移动到 `negate1` 声明并快速输入 `<LocalLeader>a`。 `<LocalLeader>` 是可以在 `init.vim` 文件中指定的特殊键。如果你使用 `resources` 文件夹中的 `init.vim`，它被设置为\n"
"逗号字符 (`,`)，在这种情况下，上面的命令由一个逗号后跟小写字母“a”组成。\n"
"另见 Neovim 中的 `:help leader` 和 `:help localleader`\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:115
#, no-wrap
msgid ""
"Idris will generate a skeleton implementation similar to the\n"
"following:\n"
msgstr "Idris 将生成一个类似于下面的代码：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:116
#, no-wrap
msgid ""
"negate2 : Bool -> Bool\n"
"negate2 x = ?negate2_rhs\n"
msgstr ""
"negate2 : Bool -> Bool\n"
"negate2 x = ?negate2_rhs\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:139
#, no-wrap
msgid ""
"Note, that on the left hand side a new variable with name\n"
"`x` was introduced, while on the right hand side Idris\n"
"added a *metavariable* (also called a *hole*). This is an\n"
"identifier prefixed with a question mark. It signals to Idris,\n"
"that we will implement this part of the function at a later time.\n"
"The great thing about holes is, that we can *hover* over them\n"
"and inspect their types and the types of values in the\n"
"surrounding context. You can do so by placing the cursor\n"
"on the identifier of a hole and entering `K` (the uppercase letter) in\n"
"normal mode. This will open a popup displaying the type of\n"
"the variable under the cursor plus the types and quantities of the variables\n"
"in the surrounding context. You can also have this information\n"
"displayed in a separate window: Enter `<LocalLeader>so` to\n"
"open this window and repeat the hovering. The information will\n"
"appear in the new window and as an additional benefit, it will\n"
"be semantically highlighted. Enter `<LocalLeader>sc` to close\n"
"this window again. Go ahead and checkout the type and\n"
"context of `?negate2_rhs`.\n"
msgstr ""
"请注意，在左边有一个名称为 `x` 的新变量被引入，而在右边 Idris 添加了一个*元变量*（也称为*孔*）。这是个\n"
"以问号为前缀的标识符。它向 Idris 发出信号，\n"
"我们将在稍后实现函数的这一部分。\n"
"孔的好处在于，我们可以*悬停*来检查它们的类型和上下文中所有值的类型。在正常模式下，您可以通过放置光标在孔的标识符上然后输入 `K`（大写字母）来做到。这将打开一个弹窗，显示光标下的变量类型和上下文中变量的类型和定量。你也可以让这些信息在单独的窗口中显示：输入 `<LocalLeader>so` 以打开此窗口并重复悬停。该信息将\n"
"出现在新窗口中，作为额外的好处，它将在语义上突出显示。输入`<LocalLeader>sc`关闭这个窗口。继续检查`?negate2_rhs` 的类型和上下文。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:148
#, no-wrap
msgid ""
"Most functions in Idris are implemented by pattern matching\n"
"on one or more of the arguments. Idris,\n"
"knowing the data constructors of all non-primitive data types,\n"
"can write such pattern matches for us (a process also called\n"
"*case splitting*). To give this a try, move the cursor onto the `x`\n"
"in the skeleton implementation of `negate2`, and enter\n"
"`<LocalLeader>c` in normal mode. The result will look as\n"
"follows:\n"
msgstr ""
"Idris 中的大部分函数都是通过模式匹配一个或多个参数实现的。\n"
"Idris 了解所有非原语数据类型的数据构造函数，\n"
"可以为我们编写这样的模式匹配（这个过程也称为*案例拆分*）。要尝试一下，请将光标移动到在`negate2`的骨架实现中的 `x` 上，在常规模式下输入 `<LocalLeader>c` 。结果将如下所示\n"
"如下：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:149
#, no-wrap
msgid ""
"negate3 : Bool -> Bool\n"
"negate3 False = ?negate3_rhs_0\n"
"negate3 True = ?negate3_rhs_1\n"
msgstr ""
"negate3 : Bool -> Bool\n"
"negate3 False = ?negate3_rhs_0\n"
"negate3 True = ?negate3_rhs_1\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:158
#, no-wrap
msgid ""
"As you can see, Idris inserted a hole for each of the cases on the\n"
"right hand side. We can again inspect their types or\n"
"replace them with a proper implementation directly.\n"
msgstr "如您所见，Idris 为每个情况的右侧插入了一个孔。我们可以再次检查它们的类型或直接用适当的实现替换它们。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:164
#, no-wrap
msgid ""
"This concludes the introduction of the (in my opinion) core\n"
"features of interactive editing: Hovering on metavariables,\n"
"adding skeleton function implementations, and case splitting\n"
"(which also works in case blocks and for nested pattern\n"
"matches). You should start using these all the time *now*!\n"
msgstr ""
"（在我看来）对于交互式编辑的核心特点的介绍到此结束：悬停在元变量上，\n"
"添加骨架函数实现和案例拆分\n"
"（这也适用于案例块和嵌套模式匹配）。你应该开始使用这些 *now*！\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:165
#, no-wrap
msgid "Expression Search"
msgstr "表达式搜索"

#. type: Plain text
#: ../src/Appendices/Neovim.md:173
#, no-wrap
msgid ""
"Sometimes, Idris knows enough about the types involved to\n"
"come up with a function implementation on its own. For instance,\n"
"let us implement function `either` from the *Prelude*.\n"
"After giving its type, creating a skeleton implementation,\n"
"and case splitting on the `Either` argument, we arrive at\n"
"something similar to the following:\n"
msgstr ""
"有时，Idris 对所涉及的类型有足够的了解但能自己想出一个函数的实现。例如，让我们实现 *Prelude* 中 `either` 函数。\n"
"在给出它的类型之后，创建一个骨架实现，\n"
"然后 `Either` 的参数上进行案例分割，我们得出类似于以下内容：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:174
#, no-wrap
msgid ""
"either2 : (a -> c) -> (b -> c) -> Either a b -> c\n"
"either2 f g (Left x) = ?either2_rhs_0\n"
"either2 f g (Right x) = ?either2_rhs_1\n"
msgstr ""
"either2 : (a -> c) -> (b -> c) -> Either a b -> c\n"
"either2 f g (Left x) = ?either2_rhs_0\n"
"either2 f g (Right x) = ?either2_rhs_1\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:186
#, no-wrap
msgid ""
"Idris can come up with expressions for the two metavariables\n"
"on its own, because the types are specific enough. Move\n"
"the cursor onto one of the metavariables and enter\n"
"`<LocalLeader>o` in normal mode. You will be given\n"
"a selection of possible expressions (only one in this case),\n"
"of which you can choose a fitting one (or abort with `q`).\n"
msgstr ""
"Idris 可以仅凭自己就可以提取出两个元变量的表达式，因为类型足够具体。\n"
"将光标移到其中一个元变量上并在常规模式下输入 `<LocalLeader>o`。你会得到一组可能的表达式（在这种情况下只有一个），\n"
"您可以从中选择一个合适的（或使用 `q` 中止）。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:190
#, no-wrap
msgid ""
"Here is another example: A reimplementation of function `maybe`.\n"
"If you run an expression search on `?maybe2_rhs1`, you will\n"
"get a larger list of choices.\n"
msgstr ""
"这是另一个例子：函数 `maybe` 的重新实现。\n"
"如果您在 `?maybe2_rhs1` 上运行表达式搜索，您将\n"
"获得更大的选择列表。\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:191
#, no-wrap
msgid ""
"maybe2 : b -> (a -> b) -> Maybe a -> b\n"
"maybe2 x f Nothing = x\n"
"maybe2 x f (Just y) = ?maybe2_rhs_1\n"
msgstr ""
"maybe2 : b -> (a -> b) -> Maybe a -> b\n"
"maybe2 x f Nothing = x\n"
"maybe2 x f (Just y) = ?maybe2_rhs_1\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:208
#, no-wrap
msgid ""
"Idris is also sometimes capable of coming up with complete function\n"
"implementations based on a function's type. For this to work well\n"
"in practice, the number of possible implementations satisfying\n"
"the type checker must be pretty small. As an example, here is\n"
"function `zipWith` for vectors. You might not have heard\n"
"about vectors yet: They will be introduced in the chapter about\n"
"[dependent types](../Tutorial/Dependent.md). You can still give\n"
"this a go to check out its effect. Just move the cursor on the\n"
"line declaring `zipWithV`, enter `<LocalLeader>gd` and select the first option.\n"
"This will automatically generate the whole function body including\n"
"case splits and implementations.\n"
msgstr ""
"Idris 有时也能够基于函数类型提出完整的函数实现。为了让它在实践中运作良好，\n"
"满足类型检查器的可能实现的数量必须非常小。\n"
"例如，这里是用于向量的函数 `zipWith`。你可能没听说过向量：它们将在[依赖类型](../Tutorial/Dependent.md)的章节中介绍。\n"
"你仍然可以去检查一下它的效果。只需将光标移到声明 `zipWithV` 的行，输入 `<LocalLeader>gd` 并选择第一个选项。\n"
"这将自动生成整个函数体，包括案例拆分和实现。\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:209
#, no-wrap
msgid "zipWithV : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
msgstr "zipWithV : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:218
#, no-wrap
msgid ""
"Expression search only works well if the types are specific\n"
"enough. If you feel like that might be the case, go ahead\n"
"and give it a go, either by running `<LocalLeader>o` on\n"
"a metavariable, or by trying `<LocalLeader>gd` on a\n"
"function declaration.\n"
msgstr ""
"表达式搜索仅在类型足够特定时才有效。如果您觉得可能是这种情况，请继续\n"
"试一试，方法是在元变量上运行 `<LocalLeader>o`，或在函数声明处尝试 `<LocalLeader>gd`。\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:219
#, no-wrap
msgid "More Code Actions"
msgstr "更多代码操作"

#. type: Plain text
#: ../src/Appendices/Neovim.md:223
#, no-wrap
msgid ""
"There are other shortcuts available for generating part of your code,\n"
"two of which I'll explain here.\n"
msgstr ""
"还有其他快捷方式可用于生成部分代码，\n"
"其中两个我将在这里解释。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:231
#, no-wrap
msgid ""
"First, it is possible to add a new case block by entering\n"
"`<LocalLeader>mc` in normal mode when on a metavariable.\n"
"For instance, here is part of an implementation of `filterList`,\n"
"which appears in an exercise in the chapter about\n"
"algebraic data types. I arrived at this by letting Idris\n"
"generate a skeleton implementation followed by a case split\n"
"and an expression search on the first metavariable:\n"
msgstr ""
"首先，处于正常模式是可以通过在元变量上按下 `<LocalLeader>mc` 添加一个新的案例块。\n"
"例如，这里是 `filterList` 实现的一部分，\n"
"它出现在代数数据类型一章中。让 Idris 先生成骨架实现，然后是进行一次案例拆分\n"
"以及对第一个元变量的表达式搜索：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:232
#, no-wrap
msgid ""
"filterList : (a -> Bool) -> List a -> List a\n"
"filterList f [] = []\n"
"filterList f (x :: xs) = ?filterList_rhs_1\n"
msgstr ""
"filterList : (a -> Bool) -> List a -> List a\n"
"filterList f [] = []\n"
"filterList f (x :: xs) = ?filterList_rhs_1\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:247
#, no-wrap
msgid ""
"We will next have to pattern match on the result of applying\n"
"`x` to `f`. Idris can introduce a new case block for us,\n"
"if we move the cursor onto metavariable `?filterList_rhs_1`\n"
"and enter `<LocalLeader>mc` in normal mode. We can then\n"
"continue with our implementation by first giving the\n"
"expression to use in the case block (`f x`) followed by a\n"
"case split on the new variable in the case block.\n"
"This will lead us to an implementation similar to the following\n"
"(I had to fix the indentation, though):\n"
msgstr ""
"接下来我们必须对应用 `x` 到 `f` 的结果进行模式匹配。\n"
"Idris 可以为我们介绍一个新的案例块，\n"
"如果我们将光标移动到元变量 `?filterList_rhs_1`\n"
"并在正常模式下输入 `<LocalLeader>mc`。那么我们可以\n"
"继续我们的实现，首先给出\n"
"在 case 块中使用的表达式 (`f x`) 后跟一个\n"
"对 case 块中的新变量进行 case 拆分。\n"
"这将导致我们实现类似于以下的实现\n"
"（不过，我必须修复缩进）：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:248
#, no-wrap
msgid ""
"filterList2 : (a -> Bool) -> List a -> List a\n"
"filterList2 f [] = []\n"
"filterList2 f (x :: xs) = case f x of\n"
"  False => ?filterList2_rhs_2\n"
"  True => ?filterList2_rhs_3\n"
msgstr ""
"filterList2 : (a -> Bool) -> List a -> List a\n"
"filterList2 f [] = []\n"
"filterList2 f (x :: xs) = case f x of\n"
"  False => ?filterList2_rhs_2\n"
"  True => ?filterList2_rhs_3\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:266
#, no-wrap
msgid ""
"Sometimes, we want to extract a utility function from\n"
"an implementation we are working on. For instance, this is often\n"
"useful or even necessary when we write proofs about our code\n"
"(see chapters [Propositional Equality](../Tutorial/Eq.md)\n"
"and [Predicates](../Tutorial/Predicates.md), for instance).\n"
"In order to do so, we can move the cursor on a metavariable,\n"
"and enter `<LocalLeader>ml`. Give this a try with\n"
"`?whatNow` in the following example (this will work better\n"
"in a regular Idris source file instead of the literate\n"
"file I use for this tutorial):\n"
msgstr ""
"有时，我们想从正在工作的实现中提取一个工具函数。例如，\n"
"当我们编写代码证明时通常是有用甚至是必要的\n"
"（参见章节 [命题等式](../Tutorial/Eq.md)\n"
"和 [谓词](../Tutorial/Predicates.md)）。\n"
"为此，我们可以将光标移动到元变量上，\n"
"并输入 `<LocalLeader>ml`。试试这个\n"
"`?whatNow` 在下面的例子中（这在常规的 Idris 源文件中会更好，\n"
"而不是我用于本教程的文学编程文件）：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:267
#, no-wrap
msgid ""
"traverseEither : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither f [] = Right []\n"
"traverseEither f (x :: xs) = ?whatNow x xs f (f x) (traverseEither f xs)\n"
msgstr ""
"traverseEither : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither f [] = Right []\n"
"traverseEither f (x :: xs) = ?whatNow x xs f (f x) (traverseEither f xs)\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:279
#, no-wrap
msgid ""
"Idris will create a new function declaration with the\n"
"type and name of `?whatNow`, which takes as arguments\n"
"all variables currently in scope. It also replaces the hole in\n"
"`traverseEither` with a call to this new function. Typically,\n"
"you will have to manually remove unneeded arguments\n"
"afterwards. This led me to the following version:\n"
msgstr ""
"Idris 将创建一个新的带有类型的函数声明，其名称为 `?whatNow`，\n"
"可以把当前作用域内的所有变量作为参数。它也取代了 `traverseEither` 中的孔来调用这个新函数。通常，\n"
"您将不得不手动删除不需要的参数。这导致我得到以下版本：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:280
#, no-wrap
msgid ""
"whatNow2 : Either e b -> Either e (List b) -> Either e (List b)\n"
"\n"
"traverseEither2 : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither2 f [] = Right []\n"
"traverseEither2 f (x :: xs) = whatNow2 (f x) (traverseEither f xs)\n"
msgstr ""
"whatNow2 : Either e b -> Either e (List b) -> Either e (List b)\n"
"\n"
"traverseEither2 : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither2 f [] = Right []\n"
"traverseEither2 f (x :: xs) = whatNow2 (f x) (traverseEither f xs)\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:288
#, no-wrap
msgid "Getting Information"
msgstr "获取资讯"

#. type: Plain text
#: ../src/Appendices/Neovim.md:294
#, no-wrap
msgid ""
"The `idris2-lsp` executable and through it, the `idris2-nvim` plugin,\n"
"not only supports the code actions described above. Here is a\n"
"non-comprehensive list of other capabilities. I suggest you try\n"
"out each of them from within this source file.\n"
msgstr ""
"`idris2-nvim` 通过`idris2-lsp` 可执行文件并通过它不仅支持上述代码操作。\n"
"这里有一个其他功能的非全面列表。\n"
"我建议你从这个源文件中取出它们中的每一个去试试。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, no-wrap
msgid ""
"Typing `K` when on an identifier or operator in normal mode shows its type\n"
"and namespace (if any). In case of a metavariable, variables\n"
"in the current context are displayed as well together with their\n"
"types and quantities (quantities will be explained in\n"
"[Functions Part 2](../Tutorial/Functions2.md)).\n"
"If you don't like popups, enter `<LocalLeader>so` to open a new window where\n"
"this information is displayed and semantically highlighted instead.\n"
msgstr ""
"在正常模式下的标识符或运算符上键入 `K` 会显示其类型和命名空间（如果有）。在元"
"变量的情况下，当前上下文中的变量也会连同它们的类型和定量一起显示（定量将在 ["
"Functions Part 2](../Tutorial/Functions2.md) 中解释）。如果您不喜欢弹出窗口，"
"请输入 `<LocalLeader>so` "
"以打开一个新窗口，该窗口将显示此信息并在语义上突出显示。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, no-wrap
msgid ""
"Typing `gd` on a function, operator, data constructor or type\n"
"constructor in normal mode jumps to the item's definition.\n"
"For external modules, this works only if the\n"
"module in question has been installed together with its source code\n"
"(by using the `idris2 --install-with-src` command).\n"
msgstr ""
"在正常模式下在函数、运算符、数据构造函数或类型构造函数上输入 `gd` "
"会跳转到项目的定义。对于外部模块，仅当相关模块与其源代码一起安装时才有效（"
"通过使用 `idris2 --install-with-src` 命令）。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, no-wrap
msgid ""
"Typing `<LocalLeader>mm` opens a popup window listing all metavariables\n"
"in the current module. You can place the cursor on an entry and\n"
"jump to its location by pressing `<Enter>`.\n"
msgstr ""
"输入 `<LocalLeader>mm` "
"打开一个弹出窗口，列出当前模块中的所有元变量。您可以将光标放在一个条目上，"
"然后按 `<Enter>` 跳转到它的位置。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, no-wrap
msgid ""
"Typing `<LocalLeader>mn` (or `<LocalLeader>mp`) jumps to the next\n"
"(or previous) metavariable in the current module.\n"
msgstr "输入 `<LocalLeader>mn`（或 "
"`<LocalLeader>mp`）跳转到当前模块中的下一个（或上一个）元变量。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, no-wrap
msgid ""
"Typing `<LocalLeader>br` opens a popup where you can enter a\n"
"namespace. Idris will then show all functions (plus their types)\n"
"exported from that namespace in a popup window, and you can\n"
"jump to a function's definition by pressing enter on one of the\n"
"entries. Note: The module in question must be imported in the\n"
"current source file.\n"
msgstr ""
"键入 `<LocalLeader>br` 会打开一个弹出窗口，您可以在其中输入名称空间。然后 "
"Idris 将在弹出窗口中显示从该命名空间导出的所有函数（以及它们的类型），"
"您可以通过在其中一个条目上按 enter "
"来跳转到函数的定义。注意：有问题的模块必须在当前源文件中导入。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, no-wrap
msgid ""
"Typing `<LocalLeader>x` opens a popup where you can enter\n"
"a REPL command or Idris expression, and the plugin will reply\n"
"with a response from the REPL. Whenever REPL examples are shown\n"
"in the main part of this guide, you can try them from within\n"
"Neovim with this shortcut if you like.\n"
msgstr ""
"输入 `<LocalLeader>x` 会打开一个弹出窗口，您可以在其中输入 REPL 命令或 Idris "
"表达式，插件将回复来自 REPL 的响应。每当本指南的主要部分显示 REPL "
"示例时，如果您愿意，可以使用此快捷方式在 Neovim 中尝试它们。\n"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, no-wrap
msgid ""
"Typing `<LocalLeader><LocalLeader>e` will display the error message\n"
"from the current line in a popup window. This can be highly useful,\n"
"if error messages are too long to fit on a single line. Likewise,\n"
"`<LocalLeader><LocalLeader>el` will list all error messages from the current\n"
"buffer in a new window. You can then select an error message and\n"
"jump to its origin by pressing `<Enter>`.\n"
msgstr ""
"键入 `<LocalLeader><LocalLeader>e` 将在弹出窗口中显示当前行的错误消息。如果错"
"误消息太长而无法放在一行中，这将非常有用。同样， "
"`<LocalLeader><LocalLeader>el` "
"将在新窗口中列出当前缓冲区中的所有错误消息。然后，您可以通过按 `<Enter>` "
"选择错误消息并跳转到其原点。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:332
#, no-wrap
msgid ""
"Other use cases and examples are described on the GitHub page\n"
"of the `idris2-nvim` plugin and can be included as described there.\n"
msgstr "`idris2-nvim` 插件其他用例和示例在 GitHub 页面上进行了描述，这些描述也包含在内。\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:333
#, no-wrap
msgid "The `%name` Pragma"
msgstr "`%name` 编译指示"

#. type: Plain text
#: ../src/Appendices/Neovim.md:345
#, no-wrap
msgid ""
"When you ask Idris for a skeleton implementation with `<LocalLeader>a`\n"
"or a case split with `<LocalLeader>c`,\n"
"it has to decide on what names to use for the new variables it introduces.\n"
"If these variables already have predefined names (from the function's\n"
"signature, record fields, or named data constructor arguments),\n"
"those names will be used, but\n"
"otherwise Idris will as a default use names `x`, `y`, and `z`, followed\n"
"by other letters. You can change this default behavior by\n"
"specifying a list of names to use for such occasions for any\n"
"data type.\n"
msgstr ""
"当您向 Idris 询问使用 `<LocalLeader>a` 的框架实现\n"
"或用 `<LocalLeader>c` 案例拆分时，\n"
"它必须决定为它引入的新变量使用什么名称。\n"
"如果这些变量已经有预定义的名称（来自函数的\n"
"签名、记录字段或命名数据构造函数参数），\n"
"这些名称将被使用，否则 Idris 将默认使用名称 `x`、`y` 和 `z`，然后\n"
"或其他字母。您可以更改此默认行为，\n"
"只要指定用于此类数据类型场合的名称列表。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:347
#, no-wrap
msgid "For instance:\n"
msgstr "例如：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:348
#, no-wrap
msgid ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"%name Element e,f\n"
msgstr ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"%name Element e,f\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:358
#, no-wrap
msgid ""
"Idris will then use these names (followed by these names postfixed\n"
"with increasing integers), when it has to come up with variable names of this\n"
"type on its own. For instance, here is a test function and the\n"
"result of adding a skeleton definition to it:\n"
msgstr ""
"然后 Idris 将使用这些名称（这些名称后跟自增数字的后缀），\n"
"当它必须想出这个类型的自己变量名时。\n"
"例如，这是一个测试函数和向其添加骨架定义的结果：\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:359
#, no-wrap
msgid ""
"test : Element -> Element -> Element -> Element -> Element -> Element\n"
"test e f e1 f1 e2 = ?test_rhs\n"
msgstr ""
"test : Element -> Element -> Element -> Element -> Element -> Element\n"
"test e f e1 f1 e2 = ?test_rhs\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:372
#, no-wrap
msgid ""
"Neovim, together with the `idris2-lsp` executable and the\n"
"`idris2-nvim` editor plugin, provides extensive utilities for\n"
"interactive editing when programming in Idris. Similar functionality\n"
"is available for some other editors, so feel free to ask what's\n"
"available for your editor of choice, for instance on the\n"
"[Idris 2 Discord channel](https://discord.gg/UX68fDs2jc).\n"
msgstr ""
"Neovim，连同 `idris2-lsp` 可执行文件和 `idris2-nvim` 编辑器插件，\n"
"为在 Idris 中编程时的交互式编辑。\n"
"其他一些编辑也可以使用类似的功能，\n"
"所以请随时询问可供您选择使用的编辑器有什么，\n"
"例如在 [Idris 2 Discord 频道](https://discord.gg/UX68fDs2jc) 上。\n"

#, no-wrap
#~ msgid "idris"
#~ msgstr "idris"

#, no-wrap
#~ msgid "repl"
#~ msgstr "repl"

#, no-wrap
#~ msgid "sh"
#~ msgstr "sh"

#, fuzzy
#~| msgid "`(+)`: Addition\n"
#~ msgid "`(+)`: Addition"
#~ msgstr "`(+)`：加法\n"

#, fuzzy
#~| msgid "`(*)`: Multiplication\n"
#~ msgid "`(*)`: Multiplication"
#~ msgstr "`(*)`：乘法\n"

#, fuzzy
#~| msgid "`(-)`: Subtraction\n"
#~ msgid "`(-)`: Subtraction"
#~ msgstr "`(-)`：减法\n"

#, fuzzy
#~| msgid "`(/)`: Division\n"
#~ msgid "`(/)`: Division"
#~ msgstr "`(/)`：除法\n"

#, no-wrap
#~ msgid ""
#~ "* `Num`\n"
#~ "  * `(+)` : Addition\n"
#~ "  * `(*)` : Multiplication\n"
#~ "  * `fromInteger` : Overloaded integer literals\n"
#~ msgstr ""
#~ "* `Num`\n"
#~ "  * `(+)` : Addition\n"
#~ "  * `(*)` : Multiplication\n"
#~ "  * `fromInteger` : Overloaded integer literals\n"

#, no-wrap
#~ msgid ""
#~ "* `Neg`\n"
#~ "  * `negate` : Negation\n"
#~ "  * `(-)` : Subtraction\n"
#~ msgstr ""
#~ "* `Neg`\n"
#~ "  * `negate` : Negation\n"
#~ "  * `(-)` : Subtraction\n"

#, no-wrap
#~ msgid ""
#~ "* `Integral`\n"
#~ "  * `div` : Integer division\n"
#~ "  * `mod` : Modulo operation\n"
#~ msgstr ""
#~ "* `Integral`\n"
#~ "  * `div` : Integer division\n"
#~ "  * `mod` : Modulo operation\n"

#, no-wrap
#~ msgid ""
#~ "* Signed, fixed precision integers:\n"
#~ "  * `Int8`: Integer in the range [-128,127]\n"
#~ "  * `Int16`: Integer in the range [-32768,32767]\n"
#~ "  * `Int32`: Integer in the range [-2147483648,2147483647]\n"
#~ "  * `Int64`: Integer in the range [-9223372036854775808,9223372036854775807]\n"
#~ "* Unsigned, fixed precision integers:\n"
#~ "  * `Bits8`: Integer in the range [0,255]\n"
#~ "  * `Bits16`: Integer in the range [0,65535]\n"
#~ "  * `Bits32`: Integer in the range [0,4294967295]\n"
#~ "  * `Bits64`: Integer in the range [0,18446744073709551615]\n"
#~ "* `Integer`: A signed, arbitrary precision integer.\n"
#~ "* `Double`: A double precision (64 bit) floating point number.\n"
#~ "* `Char`: A unicode character.\n"
#~ "* `String`: A sequence of unicode characters.\n"
#~ "* `%World`: A symbolic representation of the current world state.\n"
#~ "  We learned about this when I showed you how `IO` is implemented.\n"
#~ "  Most of the time, you will not handle values of this type in your own\n"
#~ "  code.\n"
#~ "* `Int`: This one is special. It is a fixed precision, signed integer,\n"
#~ "   but the bit size is somewhat dependent on the backend and\n"
#~ "   (maybe) platform we use.\n"
#~ "   For instance, if you use the default Chez Scheme backend, `Int` is\n"
#~ "   a 64 bit signed integer, while on the JavaScript backends it is a\n"
#~ "   32 bit signed integer for performance reasons. Therefore, `Int` comes\n"
#~ "   with very few guarantees, and you should use one of the well\n"
#~ "   specified integer types listed above whenever possible.\n"
#~ msgstr ""
#~ "* 有符号、固定精度整数：\n"
#~ "  * `Int8`：[-128,127] 范围内的整数\n"
#~ "  * `Int16`：[-32768,32767] 范围内的整数\n"
#~ "  * `Int32`：[-2147483648,2147483647] 范围内的整数\n"
#~ "  *`Int64`：范围内的整数 [-9223372036854775808,9223372036854775807]\n"
#~ "* 无符号、固定精度整数：\n"
#~ "  * `Bits8`：[0,255] 范围内的整数\n"
#~ "  * `Bits16`：[0,65535] 范围内的整数\n"
#~ "  * `Bits32`：[0,4294967295] 范围内的整数\n"
#~ "  * `Bits64`：[0,18446744073709551615] 范围内的整数\n"
#~ "* `Integer`：有符号的任意精度整数。\n"
#~ "* `Double`：双精度（64 位）浮点数。\n"
#~ "* `Char`：一个 unicode 字符。\n"
#~ "* `String`：Unicode 字符序列。\n"
#~ "* `%World`：当前世界状态的符号表示。\n"
#~ "  当我向您展示如何实现 IO 时，我们了解了这一点。\n"
#~ "  大多数时候，您不会自己处理这种类型的值的代码。\n"
#~ "* `Int`：这个比较特殊。它是一个固定精度的有符号整数，\n"
#~ "   但位大小在某种程度上取决于后端和\n"
#~ "   （也许）我们使用的平台。\n"
#~ "   例如，如果您使用默认 Chez Scheme 后端，则 `Int` 是\n"
#~ "   一个 64 位有符号整数，而在 JavaScript 后端出于性能原因它是一个32 位有符号整数。因此，`Int` 没有太多的保证，你应该尽可能指定使用上面列出的整数类型其中一个。\n"

#, no-wrap
#~ msgid "html"
#~ msgstr "html"

#, no-wrap
#~ msgid ""
#~ "* The following Neovim plugins:\n"
#~ "  * [idris2-nvim](https://github.com/ShinKage/idris2-nvim)\n"
#~ "  * [nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)\n"
#~ msgstr ""
#~ "* 以下 Neovim 插件：\n"
#~ "  * [idris2-nvim](https://github.com/ShinKage/idris2-nvim)\n"
#~ "  * [nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)\n"

#~ msgid ""
#~ "Tutorial.DataTypes> greet dr \"Hck\"\n"
#~ "\"Hello, Dr. Hck!\"\n"
#~ "Tutorial.DataTypes> greet Mrs \"Smith\"\n"
#~ "\"Hello, Mrs. Smith!\"\n"
#~ msgstr ""
#~ "Tutorial.DataTypes> greet dr \"Hck\"\n"
#~ "\"Hello, Dr. Hck!\"\n"
#~ "Tutorial.DataTypes> greet Mrs \"Smith\"\n"
#~ "\"Hello, Mrs. Smith!\"\n"

#~ msgid ""
#~ "Adjust `readRNA` and `readDNA` in such a way that the *sense* of a "
#~ "sequence is read from the input string.  Sense strands are encoded like "
#~ "so: \"5-CGGTAG-3\". Antisense strands are encoded like so: \"3-CGGTAG-5\"."
#~ msgstr ""
#~ "调整 `readRNA` 和 `readDNA` 使得从输入字符串中读取序列的 *sense*。 Sense "
#~ "链编码如下：“5-CGGTAG-3”。反义链编码如下：“3-CGGTAG-5”。"

#~ msgid ""
#~ "0 Employee : Type\n"
#~ "Employee = Row EmployeeSchema\n"
#~ "\n"
#~ "hock : Employee\n"
#~ "hock = [ \"Stefan\", \"Hck\", \"hock@foo.com\", 46, 5443.2, False ]\n"
#~ msgstr ""
#~ "0 Employee : Type\n"
#~ "Employee = Row EmployeeSchema\n"
#~ "\n"
#~ "hock : Employee\n"
#~ "hock = [ \"Stefan\", \"Hck\", \"hock@foo.com\", 46, 5443.2, False ]\n"
