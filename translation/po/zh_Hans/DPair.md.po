# Chinese translations for idris package
# Copyright (C) 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the idris package.
# Automatically generated, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: idris 2-tutorial\n"
"POT-Creation-Date: 2022-08-03 13:28+0800\n"
"PO-Revision-Date: 2022-08-25 15:08+0000\n"
"Last-Translator: admin <467195537@qq.com>\n"
"Language-Team: Chinese (Simplified) <https://weblate.grass.work:30443/"
"projects/idris2-tutorial/dpair/zh_Hans/>\n"
"Language: zh_Hans\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.13.1\n"

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:16 ../src/Tutorial/DataTypes.md:25
#: ../src/Tutorial/DataTypes.md:60 ../src/Tutorial/DataTypes.md:112
#: ../src/Tutorial/DataTypes.md:130 ../src/Tutorial/DataTypes.md:152
#: ../src/Tutorial/DataTypes.md:163 ../src/Tutorial/DataTypes.md:184
#: ../src/Tutorial/DataTypes.md:215 ../src/Tutorial/DataTypes.md:253
#: ../src/Tutorial/DataTypes.md:283 ../src/Tutorial/DataTypes.md:327
#: ../src/Tutorial/DataTypes.md:348 ../src/Tutorial/DataTypes.md:359
#: ../src/Tutorial/DataTypes.md:378 ../src/Tutorial/DataTypes.md:408
#: ../src/Tutorial/DataTypes.md:415 ../src/Tutorial/DataTypes.md:441
#: ../src/Tutorial/DataTypes.md:449 ../src/Tutorial/DataTypes.md:482
#: ../src/Tutorial/DataTypes.md:505 ../src/Tutorial/DataTypes.md:518
#: ../src/Tutorial/DataTypes.md:546 ../src/Tutorial/DataTypes.md:559
#: ../src/Tutorial/DataTypes.md:587 ../src/Tutorial/DataTypes.md:598
#: ../src/Tutorial/DataTypes.md:617 ../src/Tutorial/DataTypes.md:628
#: ../src/Tutorial/DataTypes.md:638 ../src/Tutorial/DataTypes.md:654
#: ../src/Tutorial/DataTypes.md:667 ../src/Tutorial/DataTypes.md:681
#: ../src/Tutorial/DataTypes.md:693 ../src/Tutorial/DataTypes.md:701
#: ../src/Tutorial/DataTypes.md:716 ../src/Tutorial/DataTypes.md:729
#: ../src/Tutorial/DataTypes.md:804 ../src/Tutorial/DataTypes.md:828
#: ../src/Tutorial/DataTypes.md:861 ../src/Tutorial/DataTypes.md:897
#: ../src/Tutorial/DataTypes.md:908 ../src/Tutorial/DataTypes.md:942
#: ../src/Tutorial/DataTypes.md:957 ../src/Tutorial/DataTypes.md:967
#: ../src/Tutorial/DataTypes.md:992 ../src/Tutorial/DataTypes.md:1069
#: ../src/Tutorial/DataTypes.md:1081 ../src/Tutorial/DataTypes.md:1105
#: ../src/Tutorial/DataTypes.md:1143 ../src/Tutorial/DataTypes.md:1178
#: ../src/Tutorial/DataTypes.md:1208 ../src/Tutorial/DataTypes.md:1246
#: ../src/Tutorial/DataTypes.md:1269 ../src/Tutorial/DataTypes.md:1291
#: ../src/Tutorial/Dependent.md:10 ../src/Tutorial/Dependent.md:18
#: ../src/Tutorial/Dependent.md:42 ../src/Tutorial/Dependent.md:62
#: ../src/Tutorial/Dependent.md:70 ../src/Tutorial/Dependent.md:81
#: ../src/Tutorial/Dependent.md:111 ../src/Tutorial/Dependent.md:125
#: ../src/Tutorial/Dependent.md:136 ../src/Tutorial/Dependent.md:155
#: ../src/Tutorial/Dependent.md:174 ../src/Tutorial/Dependent.md:182
#: ../src/Tutorial/Dependent.md:227 ../src/Tutorial/Dependent.md:266
#: ../src/Tutorial/Dependent.md:278 ../src/Tutorial/Dependent.md:296
#: ../src/Tutorial/Dependent.md:388 ../src/Tutorial/Dependent.md:396
#: ../src/Tutorial/Dependent.md:404 ../src/Tutorial/Dependent.md:421
#: ../src/Tutorial/Dependent.md:429 ../src/Tutorial/Dependent.md:448
#: ../src/Tutorial/Dependent.md:465 ../src/Tutorial/Dependent.md:507
#: ../src/Tutorial/Dependent.md:517 ../src/Tutorial/Dependent.md:531
#: ../src/Tutorial/Dependent.md:564 ../src/Tutorial/Dependent.md:579
#: ../src/Tutorial/Dependent.md:600 ../src/Tutorial/Dependent.md:607
#: ../src/Tutorial/Dependent.md:617 ../src/Tutorial/Dependent.md:690
#: ../src/Tutorial/Dependent.md:705 ../src/Tutorial/Dependent.md:727
#: ../src/Tutorial/Dependent.md:748 ../src/Tutorial/Dependent.md:789
#: ../src/Tutorial/Dependent.md:797 ../src/Tutorial/Dependent.md:806
#: ../src/Tutorial/Dependent.md:820 ../src/Tutorial/Dependent.md:836
#: ../src/Tutorial/Dependent.md:846 ../src/Tutorial/DPair.md:19
#: ../src/Tutorial/DPair.md:47 ../src/Tutorial/DPair.md:76
#: ../src/Tutorial/DPair.md:93 ../src/Tutorial/DPair.md:116
#: ../src/Tutorial/DPair.md:132 ../src/Tutorial/DPair.md:148
#: ../src/Tutorial/DPair.md:165 ../src/Tutorial/DPair.md:174
#: ../src/Tutorial/DPair.md:203 ../src/Tutorial/DPair.md:216
#: ../src/Tutorial/DPair.md:226 ../src/Tutorial/DPair.md:243
#: ../src/Tutorial/DPair.md:255 ../src/Tutorial/DPair.md:266
#: ../src/Tutorial/DPair.md:285 ../src/Tutorial/DPair.md:298
#: ../src/Tutorial/DPair.md:307 ../src/Tutorial/DPair.md:315
#: ../src/Tutorial/DPair.md:327 ../src/Tutorial/DPair.md:339
#: ../src/Tutorial/DPair.md:373 ../src/Tutorial/DPair.md:405
#: ../src/Tutorial/DPair.md:416 ../src/Tutorial/DPair.md:428
#: ../src/Tutorial/DPair.md:459 ../src/Tutorial/DPair.md:481
#: ../src/Tutorial/DPair.md:498 ../src/Tutorial/DPair.md:513
#: ../src/Tutorial/DPair.md:532 ../src/Tutorial/DPair.md:545
#: ../src/Tutorial/DPair.md:555 ../src/Tutorial/DPair.md:584
#: ../src/Tutorial/DPair.md:631 ../src/Tutorial/DPair.md:781
#: ../src/Tutorial/DPair.md:792 ../src/Tutorial/DPair.md:808
#: ../src/Tutorial/DPair.md:824 ../src/Tutorial/DPair.md:840
#: ../src/Tutorial/DPair.md:911 ../src/Tutorial/DPair.md:930
#: ../src/Tutorial/DPair.md:991 ../src/Tutorial/DPair.md:1019
#: ../src/Tutorial/DPair.md:1053 ../src/Tutorial/DPair.md:1068
#: ../src/Tutorial/DPair.md:1088 ../src/Tutorial/Eq.md:10
#: ../src/Tutorial/Eq.md:27 ../src/Tutorial/Eq.md:56 ../src/Tutorial/Eq.md:115
#: ../src/Tutorial/Eq.md:129 ../src/Tutorial/Eq.md:135
#: ../src/Tutorial/Eq.md:144 ../src/Tutorial/Eq.md:173
#: ../src/Tutorial/Eq.md:181 ../src/Tutorial/Eq.md:204
#: ../src/Tutorial/Eq.md:222 ../src/Tutorial/Eq.md:254
#: ../src/Tutorial/Eq.md:316 ../src/Tutorial/Eq.md:337
#: ../src/Tutorial/Eq.md:347 ../src/Tutorial/Eq.md:358
#: ../src/Tutorial/Eq.md:374 ../src/Tutorial/Eq.md:388
#: ../src/Tutorial/Eq.md:423 ../src/Tutorial/Eq.md:454
#: ../src/Tutorial/Eq.md:495 ../src/Tutorial/Eq.md:531
#: ../src/Tutorial/Eq.md:544 ../src/Tutorial/Eq.md:577
#: ../src/Tutorial/Eq.md:587 ../src/Tutorial/Eq.md:618
#: ../src/Tutorial/Eq.md:634 ../src/Tutorial/Eq.md:643
#: ../src/Tutorial/Eq.md:652 ../src/Tutorial/Eq.md:668
#: ../src/Tutorial/Eq.md:711 ../src/Tutorial/Eq.md:753
#: ../src/Tutorial/Eq.md:798 ../src/Tutorial/Eq.md:810
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Eq.md:889
#: ../src/Tutorial/Eq.md:900 ../src/Tutorial/Eq.md:924
#: ../src/Tutorial/Eq.md:941 ../src/Tutorial/Eq.md:961
#: ../src/Tutorial/Eq.md:1002 ../src/Tutorial/Eq.md:1033
#: ../src/Tutorial/Eq.md:1074 ../src/Tutorial/Folds.md:23
#: ../src/Tutorial/Folds.md:51 ../src/Tutorial/Folds.md:64
#: ../src/Tutorial/Folds.md:74 ../src/Tutorial/Folds.md:89
#: ../src/Tutorial/Folds.md:104 ../src/Tutorial/Folds.md:118
#: ../src/Tutorial/Folds.md:134 ../src/Tutorial/Folds.md:188
#: ../src/Tutorial/Folds.md:205 ../src/Tutorial/Folds.md:216
#: ../src/Tutorial/Folds.md:230 ../src/Tutorial/Folds.md:254
#: ../src/Tutorial/Folds.md:282 ../src/Tutorial/Folds.md:303
#: ../src/Tutorial/Folds.md:320 ../src/Tutorial/Folds.md:384
#: ../src/Tutorial/Folds.md:393 ../src/Tutorial/Folds.md:400
#: ../src/Tutorial/Folds.md:406 ../src/Tutorial/Folds.md:429
#: ../src/Tutorial/Folds.md:438 ../src/Tutorial/Folds.md:446
#: ../src/Tutorial/Folds.md:452 ../src/Tutorial/Folds.md:458
#: ../src/Tutorial/Folds.md:465 ../src/Tutorial/Folds.md:495
#: ../src/Tutorial/Folds.md:521 ../src/Tutorial/Folds.md:544
#: ../src/Tutorial/Folds.md:609 ../src/Tutorial/Folds.md:621
#: ../src/Tutorial/Folds.md:638 ../src/Tutorial/Folds.md:656
#: ../src/Tutorial/Folds.md:720 ../src/Tutorial/Folds.md:737
#: ../src/Tutorial/Folds.md:766 ../src/Tutorial/Folds.md:847
#: ../src/Tutorial/Folds.md:869 ../src/Tutorial/Folds.md:892
#: ../src/Tutorial/Folds.md:935 ../src/Tutorial/Folds.md:951
#: ../src/Tutorial/Folds.md:996 ../src/Tutorial/Folds.md:1006
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/Folds.md:1040
#: ../src/Tutorial/Functions1.md:17 ../src/Tutorial/Functions1.md:29
#: ../src/Tutorial/Functions1.md:80 ../src/Tutorial/Functions1.md:96
#: ../src/Tutorial/Functions1.md:109 ../src/Tutorial/Functions1.md:127
#: ../src/Tutorial/Functions1.md:158 ../src/Tutorial/Functions1.md:178
#: ../src/Tutorial/Functions1.md:221 ../src/Tutorial/Functions1.md:246
#: ../src/Tutorial/Functions1.md:292 ../src/Tutorial/Functions1.md:349
#: ../src/Tutorial/Functions1.md:391 ../src/Tutorial/Functions1.md:472
#: ../src/Tutorial/Functions1.md:505 ../src/Tutorial/Functions2.md:16
#: ../src/Tutorial/Functions2.md:94 ../src/Tutorial/Functions2.md:164
#: ../src/Tutorial/Functions2.md:203 ../src/Tutorial/Functions2.md:220
#: ../src/Tutorial/Functions2.md:249 ../src/Tutorial/Functions2.md:277
#: ../src/Tutorial/Functions2.md:319 ../src/Tutorial/Functions2.md:372
#: ../src/Tutorial/Functions2.md:391 ../src/Tutorial/Functions2.md:408
#: ../src/Tutorial/Functions2.md:426 ../src/Tutorial/Functions2.md:440
#: ../src/Tutorial/Functions2.md:447 ../src/Tutorial/Functions2.md:455
#: ../src/Tutorial/Functions2.md:472 ../src/Tutorial/Functions2.md:510
#: ../src/Tutorial/Functions2.md:624 ../src/Tutorial/Functions2.md:634
#: ../src/Tutorial/Functions2.md:646 ../src/Tutorial/Functions2.md:659
#: ../src/Tutorial/Functions2.md:670 ../src/Tutorial/Functions2.md:707
#: ../src/Tutorial/Functions2.md:780 ../src/Tutorial/Functions2.md:869
#: ../src/Tutorial/Functions2.md:880 ../src/Tutorial/Functor.md:18
#: ../src/Tutorial/Functor.md:54 ../src/Tutorial/Functor.md:63
#: ../src/Tutorial/Functor.md:73 ../src/Tutorial/Functor.md:84
#: ../src/Tutorial/Functor.md:95 ../src/Tutorial/Functor.md:111
#: ../src/Tutorial/Functor.md:126 ../src/Tutorial/Functor.md:139
#: ../src/Tutorial/Functor.md:167 ../src/Tutorial/Functor.md:236
#: ../src/Tutorial/Functor.md:260 ../src/Tutorial/Functor.md:270
#: ../src/Tutorial/Functor.md:285 ../src/Tutorial/Functor.md:298
#: ../src/Tutorial/Functor.md:314 ../src/Tutorial/Functor.md:340
#: ../src/Tutorial/Functor.md:351 ../src/Tutorial/Functor.md:392
#: ../src/Tutorial/Functor.md:408 ../src/Tutorial/Functor.md:417
#: ../src/Tutorial/Functor.md:429 ../src/Tutorial/Functor.md:442
#: ../src/Tutorial/Functor.md:456 ../src/Tutorial/Functor.md:479
#: ../src/Tutorial/Functor.md:494 ../src/Tutorial/Functor.md:512
#: ../src/Tutorial/Functor.md:531 ../src/Tutorial/Functor.md:551
#: ../src/Tutorial/Functor.md:576 ../src/Tutorial/Functor.md:622
#: ../src/Tutorial/Functor.md:651 ../src/Tutorial/Functor.md:660
#: ../src/Tutorial/Functor.md:676 ../src/Tutorial/Functor.md:693
#: ../src/Tutorial/Functor.md:704 ../src/Tutorial/Functor.md:750
#: ../src/Tutorial/Functor.md:761 ../src/Tutorial/Functor.md:773
#: ../src/Tutorial/Functor.md:784 ../src/Tutorial/Functor.md:828
#: ../src/Tutorial/Functor.md:842 ../src/Tutorial/Functor.md:860
#: ../src/Tutorial/Functor.md:872 ../src/Tutorial/Functor.md:888
#: ../src/Tutorial/Functor.md:926 ../src/Tutorial/Functor.md:945
#: ../src/Tutorial/Functor.md:971 ../src/Tutorial/Functor.md:1082
#: ../src/Tutorial/Functor.md:1122 ../src/Tutorial/Functor.md:1135
#: ../src/Tutorial/Functor.md:1199 ../src/Tutorial/Functor.md:1257
#: ../src/Tutorial/Functor.md:1268 ../src/Tutorial/Functor.md:1278
#: ../src/Tutorial/Functor.md:1285 ../src/Tutorial/Interfaces.md:10
#: ../src/Tutorial/Interfaces.md:43 ../src/Tutorial/Interfaces.md:62
#: ../src/Tutorial/Interfaces.md:71 ../src/Tutorial/Interfaces.md:100
#: ../src/Tutorial/Interfaces.md:117 ../src/Tutorial/Interfaces.md:159
#: ../src/Tutorial/Interfaces.md:234 ../src/Tutorial/Interfaces.md:255
#: ../src/Tutorial/Interfaces.md:274 ../src/Tutorial/Interfaces.md:296
#: ../src/Tutorial/Interfaces.md:321 ../src/Tutorial/Interfaces.md:333
#: ../src/Tutorial/Interfaces.md:341 ../src/Tutorial/Interfaces.md:362
#: ../src/Tutorial/Interfaces.md:456 ../src/Tutorial/Interfaces.md:466
#: ../src/Tutorial/Interfaces.md:475 ../src/Tutorial/Interfaces.md:498
#: ../src/Tutorial/Interfaces.md:534 ../src/Tutorial/Interfaces.md:552
#: ../src/Tutorial/Interfaces.md:561 ../src/Tutorial/Interfaces.md:650
#: ../src/Tutorial/Interfaces.md:661 ../src/Tutorial/Interfaces.md:677
#: ../src/Tutorial/Interfaces.md:695 ../src/Tutorial/Interfaces.md:716
#: ../src/Tutorial/Interfaces.md:727 ../src/Tutorial/Intro.md:20
#: ../src/Tutorial/Intro.md:191 ../src/Tutorial/Intro.md:252
#: ../src/Tutorial/Intro.md:287 ../src/Tutorial/Intro.md:312
#: ../src/Tutorial/IO.md:8 ../src/Tutorial/IO.md:25 ../src/Tutorial/IO.md:84
#: ../src/Tutorial/IO.md:121 ../src/Tutorial/IO.md:217
#: ../src/Tutorial/IO.md:232 ../src/Tutorial/IO.md:240
#: ../src/Tutorial/IO.md:255 ../src/Tutorial/IO.md:299
#: ../src/Tutorial/IO.md:334 ../src/Tutorial/IO.md:342
#: ../src/Tutorial/IO.md:352 ../src/Tutorial/IO.md:374
#: ../src/Tutorial/IO.md:405 ../src/Tutorial/IO.md:417
#: ../src/Tutorial/IO.md:472 ../src/Tutorial/IO.md:493
#: ../src/Tutorial/IO.md:506 ../src/Tutorial/IO.md:517
#: ../src/Tutorial/IO.md:528 ../src/Tutorial/IO.md:563
#: ../src/Tutorial/IO.md:581 ../src/Tutorial/IO.md:650
#: ../src/Tutorial/IO.md:689 ../src/Tutorial/IO.md:696
#: ../src/Tutorial/IO.md:705 ../src/Tutorial/IO.md:713
#: ../src/Tutorial/IO.md:734 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/IO.md:875 ../src/Tutorial/IO.md:920
#: ../src/Tutorial/IO.md:960 ../src/Tutorial/IO.md:984
#: ../src/Tutorial/IO.md:997 ../src/Tutorial/Predicates.md:13
#: ../src/Tutorial/Predicates.md:108 ../src/Tutorial/Predicates.md:118
#: ../src/Tutorial/Predicates.md:139 ../src/Tutorial/Predicates.md:153
#: ../src/Tutorial/Predicates.md:165 ../src/Tutorial/Predicates.md:191
#: ../src/Tutorial/Predicates.md:203 ../src/Tutorial/Predicates.md:212
#: ../src/Tutorial/Predicates.md:224 ../src/Tutorial/Predicates.md:235
#: ../src/Tutorial/Predicates.md:252 ../src/Tutorial/Predicates.md:259
#: ../src/Tutorial/Predicates.md:277 ../src/Tutorial/Predicates.md:288
#: ../src/Tutorial/Predicates.md:352 ../src/Tutorial/Predicates.md:359
#: ../src/Tutorial/Predicates.md:368 ../src/Tutorial/Predicates.md:387
#: ../src/Tutorial/Predicates.md:406 ../src/Tutorial/Predicates.md:416
#: ../src/Tutorial/Predicates.md:447 ../src/Tutorial/Predicates.md:475
#: ../src/Tutorial/Predicates.md:493 ../src/Tutorial/Predicates.md:532
#: ../src/Tutorial/Predicates.md:550 ../src/Tutorial/Predicates.md:568
#: ../src/Tutorial/Predicates.md:603 ../src/Tutorial/Predicates.md:620
#: ../src/Tutorial/Predicates.md:639 ../src/Tutorial/Predicates.md:658
#: ../src/Tutorial/Predicates.md:719 ../src/Tutorial/Predicates.md:747
#: ../src/Tutorial/Predicates.md:768 ../src/Tutorial/Predicates.md:784
#: ../src/Tutorial/Predicates.md:798 ../src/Tutorial/Predicates.md:812
#: ../src/Tutorial/Predicates.md:821 ../src/Tutorial/Predicates.md:835
#: ../src/Tutorial/Predicates.md:850 ../src/Tutorial/Predicates.md:862
#: ../src/Tutorial/Predicates.md:872 ../src/Tutorial/Predicates.md:951
#: ../src/Tutorial/Predicates.md:963 ../src/Tutorial/Predicates.md:983
#: ../src/Tutorial/Predicates.md:999 ../src/Tutorial/Predicates.md:1024
#: ../src/Tutorial/Predicates.md:1035 ../src/Tutorial/Predicates.md:1044
#: ../src/Tutorial/Predicates.md:1066 ../src/Tutorial/Predicates.md:1080
#: ../src/Tutorial/Predicates.md:1094 ../src/Tutorial/Predicates.md:1105
#: ../src/Tutorial/Predicates.md:1113 ../src/Tutorial/Predicates.md:1121
#: ../src/Tutorial/Predicates.md:1134 ../src/Tutorial/Predicates.md:1163
#: ../src/Tutorial/Predicates.md:1199 ../src/Tutorial/Predicates.md:1236
#: ../src/Tutorial/Predicates.md:1287 ../src/Tutorial/Prim.md:8
#: ../src/Tutorial/Prim.md:164 ../src/Tutorial/Prim.md:175
#: ../src/Tutorial/Prim.md:190 ../src/Tutorial/Prim.md:201
#: ../src/Tutorial/Prim.md:210 ../src/Tutorial/Prim.md:218
#: ../src/Tutorial/Prim.md:232 ../src/Tutorial/Prim.md:246
#: ../src/Tutorial/Prim.md:263 ../src/Tutorial/Prim.md:271
#: ../src/Tutorial/Prim.md:324 ../src/Tutorial/Prim.md:346
#: ../src/Tutorial/Prim.md:357 ../src/Tutorial/Prim.md:389
#: ../src/Tutorial/Prim.md:399 ../src/Tutorial/Prim.md:412
#: ../src/Tutorial/Prim.md:425 ../src/Tutorial/Prim.md:672
#: ../src/Tutorial/Prim.md:684 ../src/Tutorial/Prim.md:757
#: ../src/Tutorial/Prim.md:768 ../src/Tutorial/Prim.md:780
#: ../src/Tutorial/Prim.md:801 ../src/Tutorial/Prim.md:809
#: ../src/Tutorial/Prim.md:818 ../src/Tutorial/Prim.md:840
#: ../src/Tutorial/Prim.md:892 ../src/Tutorial/Prim.md:911
#: ../src/Tutorial/Prim.md:926 ../src/Tutorial/Prim.md:984
#: ../src/Tutorial/Prim.md:1026 ../src/Tutorial/Prim.md:1046
#: ../src/Tutorial/Prim.md:1064 ../src/Tutorial/Prim.md:1073
#: ../src/Tutorial/Prim.md:1087 ../src/Tutorial/Prim.md:1101
#: ../src/Tutorial/Prim.md:1118 ../src/Tutorial/Prim.md:1176
#: ../src/Tutorial/Prim.md:1208 ../src/Tutorial/Traverse.md:17
#: ../src/Tutorial/Traverse.md:52 ../src/Tutorial/Traverse.md:62
#: ../src/Tutorial/Traverse.md:82 ../src/Tutorial/Traverse.md:105
#: ../src/Tutorial/Traverse.md:140 ../src/Tutorial/Traverse.md:173
#: ../src/Tutorial/Traverse.md:183 ../src/Tutorial/Traverse.md:194
#: ../src/Tutorial/Traverse.md:203 ../src/Tutorial/Traverse.md:267
#: ../src/Tutorial/Traverse.md:276 ../src/Tutorial/Traverse.md:285
#: ../src/Tutorial/Traverse.md:295 ../src/Tutorial/Traverse.md:308
#: ../src/Tutorial/Traverse.md:325 ../src/Tutorial/Traverse.md:332
#: ../src/Tutorial/Traverse.md:370 ../src/Tutorial/Traverse.md:388
#: ../src/Tutorial/Traverse.md:398 ../src/Tutorial/Traverse.md:406
#: ../src/Tutorial/Traverse.md:414 ../src/Tutorial/Traverse.md:463
#: ../src/Tutorial/Traverse.md:471 ../src/Tutorial/Traverse.md:489
#: ../src/Tutorial/Traverse.md:497 ../src/Tutorial/Traverse.md:506
#: ../src/Tutorial/Traverse.md:514 ../src/Tutorial/Traverse.md:525
#: ../src/Tutorial/Traverse.md:543 ../src/Tutorial/Traverse.md:591
#: ../src/Tutorial/Traverse.md:605 ../src/Tutorial/Traverse.md:771
#: ../src/Tutorial/Traverse.md:831 ../src/Tutorial/Traverse.md:852
#: ../src/Tutorial/Traverse.md:867 ../src/Tutorial/Traverse.md:899
#: ../src/Tutorial/Traverse.md:909 ../src/Tutorial/Traverse.md:929
#: ../src/Tutorial/Traverse.md:939 ../src/Tutorial/Traverse.md:975
#: ../src/Tutorial/Traverse.md:1030 ../src/Tutorial/Traverse.md:1056
#: ../src/Tutorial/Traverse.md:1067 ../src/Tutorial/Traverse.md:1077
#: ../src/Tutorial/Traverse.md:1095
#, no-wrap
msgid "idris"
msgstr "idris"

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:39 ../src/Tutorial/DataTypes.md:234
#: ../src/Tutorial/DataTypes.md:241 ../src/Tutorial/DataTypes.md:310
#: ../src/Tutorial/DataTypes.md:337 ../src/Tutorial/DataTypes.md:390
#: ../src/Tutorial/DataTypes.md:427 ../src/Tutorial/DataTypes.md:494
#: ../src/Tutorial/DataTypes.md:646 ../src/Tutorial/DataTypes.md:840
#: ../src/Tutorial/DataTypes.md:1009 ../src/Tutorial/DataTypes.md:1016
#: ../src/Tutorial/DataTypes.md:1024 ../src/Tutorial/DataTypes.md:1031
#: ../src/Tutorial/DataTypes.md:1038 ../src/Tutorial/DataTypes.md:1045
#: ../src/Tutorial/Dependent.md:197 ../src/Tutorial/Dependent.md:204
#: ../src/Tutorial/Dependent.md:239 ../src/Tutorial/Dependent.md:245
#: ../src/Tutorial/Dependent.md:309 ../src/Tutorial/Dependent.md:346
#: ../src/Tutorial/Dependent.md:364 ../src/Tutorial/Dependent.md:631
#: ../src/Tutorial/Dependent.md:866 ../src/Tutorial/DPair.md:66
#: ../src/Tutorial/DPair.md:234 ../src/Tutorial/DPair.md:713
#: ../src/Tutorial/Eq.md:74 ../src/Tutorial/Eq.md:93 ../src/Tutorial/Eq.md:153
#: ../src/Tutorial/Eq.md:397 ../src/Tutorial/Eq.md:404
#: ../src/Tutorial/Eq.md:436 ../src/Tutorial/Eq.md:505
#: ../src/Tutorial/Eq.md:518 ../src/Tutorial/Eq.md:679
#: ../src/Tutorial/Eq.md:778 ../src/Tutorial/Eq.md:984
#: ../src/Tutorial/Eq.md:1014 ../src/Tutorial/Folds.md:198
#: ../src/Tutorial/Folds.md:787 ../src/Tutorial/Folds.md:798
#: ../src/Tutorial/Folds.md:822 ../src/Tutorial/Folds.md:839
#: ../src/Tutorial/Folds.md:880 ../src/Tutorial/Folds.md:904
#: ../src/Tutorial/Functions1.md:37 ../src/Tutorial/Functions1.md:143
#: ../src/Tutorial/Functions1.md:165 ../src/Tutorial/Functions1.md:204
#: ../src/Tutorial/Functions1.md:228 ../src/Tutorial/Functions1.md:253
#: ../src/Tutorial/Functions1.md:261 ../src/Tutorial/Functions1.md:312
#: ../src/Tutorial/Functions1.md:333 ../src/Tutorial/Functions1.md:358
#: ../src/Tutorial/Functions1.md:366 ../src/Tutorial/Functions1.md:378
#: ../src/Tutorial/Functions1.md:488 ../src/Tutorial/Functions1.md:519
#: ../src/Tutorial/Functions1.md:568 ../src/Tutorial/Functions2.md:42
#: ../src/Tutorial/Functions2.md:63 ../src/Tutorial/Functions2.md:74
#: ../src/Tutorial/Functions2.md:114 ../src/Tutorial/Functions2.md:528
#: ../src/Tutorial/Functions2.md:541 ../src/Tutorial/Functions2.md:553
#: ../src/Tutorial/Functions2.md:560 ../src/Tutorial/Functions2.md:567
#: ../src/Tutorial/Functions2.md:719 ../src/Tutorial/Functions2.md:726
#: ../src/Tutorial/Functions2.md:735 ../src/Tutorial/Functions2.md:755
#: ../src/Tutorial/Functions2.md:763 ../src/Tutorial/Functions2.md:787
#: ../src/Tutorial/Functions2.md:811 ../src/Tutorial/Functions2.md:819
#: ../src/Tutorial/Functions2.md:835 ../src/Tutorial/Functions2.md:848
#: ../src/Tutorial/Functions2.md:899 ../src/Tutorial/Functor.md:187
#: ../src/Tutorial/Functor.md:201 ../src/Tutorial/Functor.md:216
#: ../src/Tutorial/Functor.md:610 ../src/Tutorial/Functor.md:801
#: ../src/Tutorial/Functor.md:903 ../src/Tutorial/Functor.md:1001
#: ../src/Tutorial/Functor.md:1100 ../src/Tutorial/Functor.md:1167
#: ../src/Tutorial/Functor.md:1219 ../src/Tutorial/Interfaces.md:36
#: ../src/Tutorial/Interfaces.md:140 ../src/Tutorial/Interfaces.md:505
#: ../src/Tutorial/Intro.md:122 ../src/Tutorial/Intro.md:134
#: ../src/Tutorial/Intro.md:148 ../src/Tutorial/Intro.md:158
#: ../src/Tutorial/Intro.md:167 ../src/Tutorial/Intro.md:227
#: ../src/Tutorial/Intro.md:270 ../src/Tutorial/Intro.md:279
#: ../src/Tutorial/Intro.md:300 ../src/Tutorial/Intro.md:326
#: ../src/Tutorial/Intro.md:337 ../src/Tutorial/Intro.md:349
#: ../src/Tutorial/IO.md:33 ../src/Tutorial/IO.md:94 ../src/Tutorial/IO.md:433
#: ../src/Tutorial/IO.md:442 ../src/Tutorial/IO.md:539
#: ../src/Tutorial/IO.md:621 ../src/Tutorial/IO.md:634
#: ../src/Tutorial/IO.md:1020 ../src/Tutorial/IO.md:1040
#: ../src/Tutorial/IO.md:1050 ../src/Tutorial/IO.md:1060
#: ../src/Tutorial/Predicates.md:428 ../src/Tutorial/Predicates.md:462
#: ../src/Tutorial/Predicates.md:926 ../src/Tutorial/Predicates.md:1337
#: ../src/Tutorial/Prim.md:124 ../src/Tutorial/Prim.md:312
#: ../src/Tutorial/Prim.md:527 ../src/Tutorial/Prim.md:550
#: ../src/Tutorial/Prim.md:574 ../src/Tutorial/Prim.md:584
#: ../src/Tutorial/Prim.md:596 ../src/Tutorial/Prim.md:611
#: ../src/Tutorial/Prim.md:622 ../src/Tutorial/Prim.md:638
#: ../src/Tutorial/Prim.md:647 ../src/Tutorial/Prim.md:703
#: ../src/Tutorial/Prim.md:1129 ../src/Tutorial/Traverse.md:38
#: ../src/Tutorial/Traverse.md:123 ../src/Tutorial/Traverse.md:158
#: ../src/Tutorial/Traverse.md:421 ../src/Tutorial/Traverse.md:737
#: ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid "repl"
msgstr "repl"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr "练习第 1 部分"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:622
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:962
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:712
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr "练习第 2 部分"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:842
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1232
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:936
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr "练习第 3 部分"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:871
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1395
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#, no-wrap
msgid "Conclusion"
msgstr "结论"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:909
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1098
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Predicates.md:1369 ../src/Tutorial/Prim.md:1411
#: ../src/Tutorial/Traverse.md:1148
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2\n"
"-->\n"

#. type: Title #
#: ../src/Tutorial/DPair.md:1
#, no-wrap
msgid "Sigma Types"
msgstr "Sigma 类型"

#. type: Plain text
#: ../src/Tutorial/DPair.md:18
#, no-wrap
msgid ""
"So far in our examples of dependently typed programming,\n"
"type indices such as the length of vectors were known at\n"
"compile time or could be calculated from values known at\n"
"compile time. In real applications, however, such information is\n"
"often not available until runtime, where values depend on\n"
"the decisions made by users or the state of the surrounding world.\n"
"For instance, if we store a file's content as a vector of lines\n"
"of text, the length of this vector is in general unknown until\n"
"the file has been loaded into memory.\n"
"As a consequence, the types of values we work with depend on\n"
"other values only known at runtime, and we can often only figure out\n"
"these types by pattern matching on the values they depend on.\n"
"To express these dependencies, we need so called\n"
"[*sigma types*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A3_type):\n"
"Dependent pairs and their generalization, dependent records.\n"
msgstr "到目前为止，在我们的依赖类型编程示例中，类型索引（例如向量的长度）在编译时是已知的，或者可以从编译时已知的值中计算出来。然而，在实际应用中，此类信息通常在运行时才可用，其中值取决于用户做出的决定或周围世界的状态。例如，如果我们将文件的内容存储为文本行向量，则该向量的长度通常在文件加载到内存之前是未知的。因此，我们使用的值的类型依赖于仅在运行时才知道的其他值，并且我们通常只能通过对它们所依赖的值进行模式匹配来找出这些类型。为了表达这些依赖关系，我们需要所谓的 [*sigma types*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A3_type)：依赖对及其泛化，依赖记录。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:19
#, no-wrap
msgid ""
"module Tutorial.DPair\n"
"\n"
"import Control.Monad.State\n"
"\n"
"import Data.DPair\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.List\n"
"import Data.List1\n"
"import Data.Singleton\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import Text.CSV\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.DPair\n"
"\n"
"import Control.Monad.State\n"
"\n"
"import Data.DPair\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.List\n"
"import Data.List1\n"
"import Data.Singleton\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import Text.CSV\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/DPair.md:38
#, no-wrap
msgid "Dependent Pairs"
msgstr "依赖对"

#. type: Plain text
#: ../src/Tutorial/DPair.md:46
#, no-wrap
msgid ""
"We've already seen several examples of how useful the length\n"
"index of a vector is to describe more precisely in the types what\n"
"a function can and can't do. For instance, `map` or `traverse`\n"
"operating on a vector will return a vector of exactly\n"
"the same length. The types guarantee that this is true, therefore\n"
"the following function is perfectly safe and provably total:\n"
msgstr "我们已经看到了几个例子，说明向量的长度索引在更精确地描述函数可以做什么和不能做什么的类型中是多么有用。例如，对向量进行操作的 `map` 或 `traverse` 将返回长度完全相同的向量。这些类型保证这是真的，因此以下函数是完全安全的并且可以证明是完全的：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:47
#, no-wrap
msgid ""
"parseAndDrop : Vect (3 + n) String -> Maybe (Vect n Nat)\n"
"parseAndDrop = map (drop 3) . traverse parsePositive\n"
msgstr ""
"parseAndDrop : Vect (3 + n) String -> Maybe (Vect n Nat)\n"
"parseAndDrop = map (drop 3) . traverse parsePositive\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:60
#, no-wrap
msgid ""
"Since the argument of `traverse parsePositive`\n"
"is of type `Vect (3 + n) String`, its result will be of\n"
"type `Maybe (Vect (3 + n) Nat)`. It is therefore\n"
"safe to use this in a call to `drop 3`. Note, how all of this\n"
"is known at compile time: We encoded the prerequisite\n"
"that the first argument is a vector of at least three elements\n"
"in the length index and could derive the length\n"
"of the result from this.\n"
msgstr "由于 `traverse parsePositive` 的参数是 `Vect (3 + n) String` 类型，其结果将是 `Maybe (Vect (3 + n) Nat)` 类型]。因此在调用 `drop 3` 时使用它是安全的。请注意，所有这些在编译时是如何知道的：我们编码的先决条件是第一个参数是长度索引中至少三个元素的向量，并且可以从中得出结果的长度。\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:61
#, no-wrap
msgid "Vectors of Unknown Length"
msgstr "未知长度的向量"

#. type: Plain text
#: ../src/Tutorial/DPair.md:65
#, no-wrap
msgid ""
"However, this is not always possible. Consider the following function,\n"
"defined on `List` and exported by `Data.List`:\n"
msgstr "然而，这并不总是可能的。考虑以下函数，在 `List` 上定义并由 `Data.List` 导出：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:66
#, no-wrap
msgid ""
"Tutorial.Relations> :t takeWhile\n"
"Data.List.takeWhile : (a -> Bool) -> List a -> List a\n"
msgstr ""
"Tutorial.Relations> :t takeWhile\n"
"Data.List.takeWhile : (a -> Bool) -> List a -> List a\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:75
#, no-wrap
msgid ""
"This will take the longest prefix of the list argument, for which\n"
"the given predicate returns `True`. In this case, it depends on\n"
"the list elements and the predicate, how long this prefix will be.\n"
"Can we write such a function for vectors? Let's give it a try:\n"
msgstr "这将采用列表参数的最长前缀，给定谓词为此返回 `True`。在这种情况下，它取决于列表元素和谓词，这个前缀有多长。我们可以为向量编写这样的函数吗？试一试吧：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:76
#, no-wrap
msgid "takeWhile' : (a -> Bool) -> Vect n a -> Vect m a\n"
msgstr "takeWhile' : (a -> Bool) -> Vect n a -> Vect m a\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:92
#, no-wrap
msgid ""
"Go ahead, and try to implement this. Don't try too long, as you will not\n"
"be able to do so in a provably total way. The question is: What is the\n"
"problem here?\n"
"In order to understand this, we have to realize what the type of `takeWhile'`\n"
"promises: \"For all predicates operating on values on type `a`, and for\n"
"all vectors holding values of this type, and for all lengths `m`, I\n"
"give you a vector of length `m` holding values of type `a`\".\n"
"All three arguments are said to be\n"
"[*universally quantified*](https://en.wikipedia.org/wiki/Universal_quantification):\n"
"The caller of our function is free to choose the predicate,\n"
"the input vector, the type of values the vector holds,\n"
"and *the length of the output vector*. Don't believe me? See here:\n"
msgstr "继续，并尝试实现这一点。不要尝试太久，因为您将无法以可证明的整体方式这样做。问题是：这里有什么问题？为了理解这一点，我们必须了解 `takeWhile'` 的类型所承诺的内容：“对于所有对 `a` 类型的值进行操作的谓词，以及所有包含此类型值的向量，对于所有长度 `m`，我给你一个长度为 `m` 的向量，其中包含 `a`\" 类型的值。所有三个参数都被称为 [*universally quantified*](https://en.wikipedia.org/wiki/Universal_quantification)：我们函数的调用者可以自由选择谓词、输入向量、向量持有的值的类型，以及 *输出向量的长度*。不相信我？看这里：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:93
#, no-wrap
msgid ""
"-- This looks like trouble: We got a non-empty vector of `Void`...\n"
"voids : Vect 7 Void\n"
"voids = takeWhile' (const True) []\n"
"\n"
"-- ...from which immediately follows a proof of `Void`\n"
"proofOfVoid : Void\n"
"proofOfVoid = head voids\n"
msgstr ""
"-- This looks like trouble: We got a non-empty vector of `Void`...\n"
"voids : Vect 7 Void\n"
"voids = takeWhile' (const True) []\n"
"\n"
"-- ...from which immediately follows a proof of `Void`\n"
"proofOfVoid : Void\n"
"proofOfVoid = head voids\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:108
#, no-wrap
msgid ""
"See how I could freely decide on the value of `m` when invoking `takeWhile'`?\n"
"Although I passed `takeWhile'` an empty vector (the only existing vector\n"
"holding values of type `Void`), the function's type promises me\n"
"to return a possibly non-empty vector holding values of the same\n"
"type, from which I freely extracted the first one.\n"
msgstr "看看我在调用 `takeWhile'` 时如何自由决定 `m` 的值？尽管我将 `takeWhile'` 传递给了一个空向量（唯一的现有向量包含 `Void` 类型的值），但该函数的类型保证我返回一个可能非空的向量，该向量包含相同类型的值，我从中自由地提取了第一个。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:115
#, no-wrap
msgid ""
"Luckily, Idris doesn't allow this: We won't be able to\n"
"implement `takeWhile'` without cheating (for instance, by\n"
"turning totality checking off and looping forever).\n"
"So, the question remains, how to express the result of `takeWhile'`\n"
"in a type. The answer to this is: \"Use a *dependent pair*\", a vector\n"
"paired with a value corresponding to its length.\n"
msgstr "幸运的是，Idris 不允许这样做：我们将无法在不作弊的情况下实现 `takeWhile'`（例如，通过关闭完全性检查并永远循环）。所以，问题仍然存在，如何在一个类型中表达 `takeWhile'` 的结果。对此的答案是：“使用 *依赖对*”，一个向量与与其长度对应的值配对。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:116
#, no-wrap
msgid ""
"record AnyVect a where\n"
"  constructor MkAnyVect\n"
"  length : Nat\n"
"  vect   : Vect length a\n"
msgstr ""
"record AnyVect a where\n"
"  constructor MkAnyVect\n"
"  length : Nat\n"
"  vect   : Vect length a\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:131
#, no-wrap
msgid ""
"This corresponds to [*existential quantification*](https://en.wikipedia.org/wiki/Existential_quantification)\n"
"in predicate logic: There is a natural number, which corresponds to\n"
"the length of the vector I have here. Note, how from the outside\n"
"of `AnyVect a`, the length of the wrapped vector is no longer\n"
"visible at the type level but we can still inspect it and learn\n"
"something about it at runtime, since it is wrapped up together\n"
"with the actual vector. We can implement `takeWhile` in such\n"
"a way that it returns a value of type `AnyVect a`:\n"
msgstr "这对应于谓词逻辑中的[*存在量化*](https://en.wikipedia.org/wiki/Existential_quantification)：有一个自然数，对应于我这里的向量的长度。请注意，从 `AnyVect a` 的外部，包装矢量的长度在类型级别不再可见，但我们仍然可以检查它并在运行时了解它，因为它被包装在一起与实际向量。我们可以实现 `takeWhile`，使其返回 `AnyVect a` 类型的值：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:132
#, no-wrap
msgid ""
"takeWhile : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile f []        = MkAnyVect 0 []\n"
"takeWhile f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect n ys = takeWhile f xs in MkAnyVect (S n) (x :: ys)\n"
msgstr ""
"takeWhile : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile f []        = MkAnyVect 0 []\n"
"takeWhile f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect n ys = takeWhile f xs in MkAnyVect (S n) (x :: ys)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:147
#, no-wrap
msgid ""
"This works in a provably total way, because callers of this function\n"
"can no longer choose the length of the resulting vector themselves. Our\n"
"function, `takeWhile`, decides on this length and returns it together\n"
"with the vector, and the type checker verifies that we\n"
"make no mistakes when pairing the two values. In fact,\n"
"the length can be inferred automatically by Idris, so we can replace\n"
"it with underscores, if we so desire:\n"
msgstr "这可以证明是完全可行的，因为这个函数的调用者不能再自己选择结果向量的长度。我们的函数 `takeWhile` 决定这个长度并将它与向量一起返回，类型检查器验证我们在配对两个值时没有错误。事实上，长度可以由 Idris 自动推断，所以如果我们愿意，我们可以用下划线替换它：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:148
#, no-wrap
msgid ""
"takeWhile2 : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile2 f []        = MkAnyVect _ []\n"
"takeWhile2 f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect _ ys = takeWhile2 f xs in MkAnyVect _ (x :: ys)\n"
msgstr ""
"takeWhile2 : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile2 f []        = MkAnyVect _ []\n"
"takeWhile2 f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect _ ys = takeWhile2 f xs in MkAnyVect _ (x :: ys)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:161
#, no-wrap
msgid ""
"To summarize: Parameters in generic function types are\n"
"universally quantified, and their values can be decided on at the\n"
"call site of such functions. Dependent record types allow us\n"
"to describe existentially quantified values. Callers cannot choose\n"
"such values freely: They are returned as part of a function's result.\n"
msgstr "总结：泛型函数类型中的参数是通用量化的，它们的值可以在此类函数的调用处确定。依赖记录类型允许我们描述存在量化的值。调用者不能自由选择这些值：它们作为函数结果的一部分返回。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:164
#, no-wrap
msgid ""
"Note, that Idris allows us to be explicit about universal quantification.\n"
"The type of `takeWhile'` can also be written like so:\n"
msgstr "请注意，Idris 允许我们明确地进行全称量化。 `takeWhile'` 的类型也可以这样写：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:165
#, no-wrap
msgid "takeWhile'' : forall a, n, m . (a -> Bool) -> Vect n a -> Vect m a\n"
msgstr "takeWhile'' : forall a, n, m . (a -> Bool) -> Vect n a -> Vect m a\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:173
#, no-wrap
msgid ""
"Universally quantified arguments are desugared to implicit\n"
"erased arguments by Idris. The above is a less verbose version\n"
"of the following function type, the likes of which we have seen\n"
"before:\n"
msgstr "普遍量化的参数被 Idris 脱糖为隐式的已擦除参数。上面是以下函数类型的一个不那么冗长的版本，我们之前已经看到过类似的函数类型：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:174
#, no-wrap
msgid ""
"takeWhile''' :  {0 a : _}\n"
"             -> {0 n : _}\n"
"             -> {0 m : _}\n"
"             -> (a -> Bool)\n"
"             -> Vect n a\n"
"             -> Vect m a\n"
msgstr ""
"takeWhile''' :  {0 a : _}\n"
"             -> {0 n : _}\n"
"             -> {0 m : _}\n"
"             -> (a -> Bool)\n"
"             -> Vect n a\n"
"             -> Vect m a\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:189
#, no-wrap
msgid ""
"In Idris, we are free to choose whether we want to be explicit\n"
"about universal quantification. Sometimes it can help understanding\n"
"what's going on at the type level. Other languages - for instance\n"
"[PureScript](https://www.purescript.org/) - are more strict about\n"
"this: There, explicit annotations on universally quantified parameters\n"
"are [mandatory](https://github.com/purescript/documentation/blob/master/language/Differences-from-Haskell.md#explicit-forall).\n"
msgstr "在 Idris 中，我们可以自由选择是否要明确全称量化。有时它可以帮助理解在类型级别上发生了什么。其他语言 - 例如 [PureScript](https://www.purescript.org/) - 对此更为严格：在那里，对普遍量化参数的显式注释是 [强制性](https://github.com/purescript/documentation/blob/master/language/Differences-from-Haskell.md#explicit-forall)的。\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:190
#, no-wrap
msgid "The Essence of Dependent Pairs"
msgstr "依赖对的本质"

#. type: Plain text
#: ../src/Tutorial/DPair.md:202
#, no-wrap
msgid ""
"It can take some time and experience to understand what's going on here. At\n"
"least in my case, it took many sessions programming in Idris, before I figured\n"
"out what dependent pairs are about: They pair a *value* of some type with\n"
"a second value of a type calculated from the first value.\n"
"For instance, a natural number `n` (the value)\n"
"paired with a vector of length `n` (the second value, the type\n"
"of which *depends* on the first value).\n"
"This is such a fundamental concept of programming with dependent types, that\n"
"a general dependent pair type is provided by the *Prelude*. Here is its\n"
"implementation (primed for disambiguation):\n"
msgstr "了解这里发生的事情可能需要一些时间和经验。至少在我的情况下，在 Idris 中进行了许多会话编程，然后我才弄清楚依赖对的含义：它们将某种类型的 *value* 与从第一个值计算的类型的第二个值配对。例如，自然数 `n`（值）与长度为 `n` 的向量对（第二个值，其类型 *取决于* 第一个值）。这是使用依赖类型进行编程的基本概念，*Prelude* 提供了一个通用的依赖对类型。这是它的实现（准备消除歧义）：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:203
#, no-wrap
msgid ""
"record DPair' (a : Type) (p : a -> Type) where\n"
"  constructor MkDPair'\n"
"  fst : a\n"
"  snd : p fst\n"
msgstr ""
"record DPair' (a : Type) (p : a -> Type) where\n"
"  constructor MkDPair'\n"
"  fst : a\n"
"  snd : p fst\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:215
#, no-wrap
msgid ""
"It is essential to understand what's going on here. There are two\n"
"parameters: A type `a`, and a function `p`, calculating a *type*\n"
"from a *value* of type `a`. Such a value (`fst`) is then used\n"
"to calculate the *type* of the second value (`snd`).\n"
"For instance, here is `AnyVect a` represented as a `DPair`:\n"
msgstr "必须了解这里发生了什么。有两个参数：类型 `a` 和函数 `p`，从类型 `a` 的 *值* 计算出一个 *类型* 。这个值 (`fst`) 被用来计算第二个值 (`snd`) 的 *类型*。例如，这里是 `AnyVect a` 使用 `DPair` 的表示：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:216
#, no-wrap
msgid ""
"AnyVect' : (a : Type) -> Type\n"
"AnyVect' a = DPair Nat (\\n => Vect n a)\n"
msgstr ""
"AnyVect' : (a : Type) -> Type\n"
"AnyVect' a = DPair Nat (\\n => Vect n a)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:225
#, no-wrap
msgid ""
"Note, how `\\n => Vect n a` is a function from `Nat` to `Type`.\n"
"Idris provides special syntax for describing dependent pairs, as\n"
"they are important building blocks for programming in languages\n"
"with first class types:\n"
msgstr "请注意，`\\n => Vect n a` 如何是从 `Nat` 到 `Type` 的函数。 Idris 提供了用于描述依赖对的特殊语法，因为它们是使用一流类型的语言进行编程的重要构建块：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:226
#, no-wrap
msgid ""
"AnyVect'' : (a : Type) -> Type\n"
"AnyVect'' a = (n : Nat ** Vect n a)\n"
msgstr ""
"AnyVect'' : (a : Type) -> Type\n"
"AnyVect'' a = (n : Nat ** Vect n a)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:233
#, no-wrap
msgid ""
"We can inspect at the REPL, that the right hand side of `AnyVect''`\n"
"get's desugared to the right hand side of `AnyVect'`:\n"
msgstr "我们可以在 REPL 中检查，`AnyVect''` 的右侧被脱糖到 `AnyVect'` 的右侧：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:234
#, no-wrap
msgid ""
"Tutorial.Relations> (n : Nat ** Vect n Int)\n"
"DPair Nat (\\n => Vect n Int)\n"
msgstr ""
"Tutorial.Relations> (n : Nat ** Vect n Int)\n"
"DPair Nat (\\n => Vect n Int)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:242
#, no-wrap
msgid ""
"Idris can infer, that `n` must be of type `Nat`, so we can drop\n"
"this information. (We still need to put the whole expression in\n"
"parentheses.)\n"
msgstr "Idris 可以推断，`n` 必须是 `Nat` 类型，因此我们可以删除此信息。 （我们仍然需要将整个表达式放在括号中。）\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:243
#, no-wrap
msgid ""
"AnyVect3 : (a : Type) -> Type\n"
"AnyVect3 a = (n ** Vect n a)\n"
msgstr ""
"AnyVect3 : (a : Type) -> Type\n"
"AnyVect3 a = (n ** Vect n a)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:254
#, no-wrap
msgid ""
"This allows us to pair a natural number `n` with a vector of\n"
"length `n`, which is exactly what we did with `AnyVect`. We can\n"
"therefore rewrite `takeWhile` to return a `DPair` instead of\n"
"our custom type `AnyVect`. Note, that like with regular pairs,\n"
"we can use the same syntax `(x ** y)` for creating and\n"
"pattern matching on dependent pairs:\n"
msgstr "这允许我们将自然数 `n` 与长度为 `n` 的向量配对，这正是我们对 `AnyVect` 所做的。因此，我们可以重写 `takeWhile` 以返回 `DPair` 而不是我们的自定义类型 `AnyVect`。请注意，与常规对一样，我们可以使用相同的语法 `(x ** y)` 在依赖对上创建和模式匹配：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:255
#, no-wrap
msgid ""
"takeWhile3 : (a -> Bool) -> Vect m a -> (n ** Vect n a)\n"
"takeWhile3 f []        = (_ ** [])\n"
"takeWhile3 f (x :: xs) = case f x of\n"
"  False => (_ ** [])\n"
"  True  => let (_  ** ys) = takeWhile3 f xs in (_ ** x :: ys)\n"
msgstr ""
"takeWhile3 : (a -> Bool) -> Vect m a -> (n ** Vect n a)\n"
"takeWhile3 f []        = (_ ** [])\n"
"takeWhile3 f (x :: xs) = case f x of\n"
"  False => (_ ** [])\n"
"  True  => let (_  ** ys) = takeWhile3 f xs in (_ ** x :: ys)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:265
#, no-wrap
msgid ""
"Just like with regular pairs, we can use the dependent pair\n"
"syntax to define dependent triples and larger tuples:\n"
msgstr "就像常规对一样，我们可以使用依赖对语法来定义依赖三元组和更大的元组：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:266
#, no-wrap
msgid ""
"AnyMatrix : (a : Type) -> Type\n"
"AnyMatrix a = (m ** n ** Vect m (Vect n a))\n"
msgstr ""
"AnyMatrix : (a : Type) -> Type\n"
"AnyMatrix a = (m ** n ** Vect m (Vect n a))\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:271
#, no-wrap
msgid "Erased Existentials"
msgstr "已删除的存在"

#. type: Plain text
#: ../src/Tutorial/DPair.md:281
#, no-wrap
msgid ""
"Sometimes, it is possible to determine the value of an\n"
"index by pattern matching on a value of the indexed type.\n"
"For instance, by pattern matching on a vector, we can learn\n"
"about its length index. In these cases, it is not strictly\n"
"necessary to carry around the index at runtime,\n"
"and we can write a special version of a dependent pair\n"
"where the first argument has quantity zero. Module `Data.DPair`\n"
"from *base* exports data type `Exists` for this use case.\n"
msgstr "有时，可以通过对索引类型的值进行模式匹配来确定索引的值。例如，通过对向量进行模式匹配，我们可以了解它的长度索引。在这些情况下，不一定要在运行时携带索引，我们可以编写一个特殊版本的依赖对，其中第一个参数的数量为零。 *base* 中的模块 `Data.DPair` 为此用例导出数据类型 `Exists`。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:284
#, no-wrap
msgid ""
"As an example, here is a version of `takeWhile` returning\n"
"a value of type `Exists`:\n"
msgstr "例如，下面是 `takeWhile` 的一个版本，返回一个 `Exists` 类型的值：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:285
#, no-wrap
msgid ""
"takeWhileExists : (a -> Bool) -> Vect m a -> Exists (\\n => Vect n a)\n"
"takeWhileExists f []        = Evidence _ []\n"
"takeWhileExists f (x :: xs) = case f x of\n"
"  True  => let Evidence _ ys = takeWhileExists f xs\n"
"            in Evidence _ (x :: ys)\n"
"  False => takeWhileExists f xs\n"
msgstr ""
"takeWhileExists : (a -> Bool) -> Vect m a -> Exists (\\n => Vect n a)\n"
"takeWhileExists f []        = Evidence _ []\n"
"takeWhileExists f (x :: xs) = case f x of\n"
"  True  => let Evidence _ ys = takeWhileExists f xs\n"
"            in Evidence _ (x :: ys)\n"
"  False => takeWhileExists f xs\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:297
#, no-wrap
msgid ""
"In order to restore an erased value, data type `Singleton`\n"
"from *base* module `Data.Singleton` can be useful: It is\n"
"parameterized by the *value* it stores:\n"
msgstr "为了恢复已擦除的值，来自 *base* 模块 `Data.Singleton` 的数据类型 `Singleton` 可能很有用：它由参数化 *值* 来存储：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:298
#, no-wrap
msgid ""
"true : Singleton True\n"
"true = Val True\n"
msgstr ""
"true : Singleton True\n"
"true = Val True\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:306
#, no-wrap
msgid ""
"This is called a *singleton* type: A type corresponding to\n"
"exactly one value. It is a type error to return any other\n"
"value for constant `true`, and Idris knows this:\n"
msgstr "这称为 *singleton* 类型：与一个值对应的类型。返回常量 `true` 的任何其他值都是类型错误，Idris 知道这一点：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:307
#, no-wrap
msgid ""
"true' : Singleton True\n"
"true' = Val _\n"
msgstr ""
"true' : Singleton True\n"
"true' = Val _\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:314
#, no-wrap
msgid ""
"We can use this to conjure the (erased!) length of a vector\n"
"out of thin air:\n"
msgstr "我们可以使用它凭空变出一个向量的（擦除的！）长度：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:315
#, no-wrap
msgid ""
"vectLength : Vect n a -> Singleton n\n"
"vectLength []        = Val 0\n"
"vectLength (x :: xs) = let Val k = vectLength xs in Val (S k)\n"
msgstr ""
"vectLength : Vect n a -> Singleton n\n"
"vectLength []        = Val 0\n"
"vectLength (x :: xs) = let Val k = vectLength xs in Val (S k)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:326
#, no-wrap
msgid ""
"This function comes with much stronger guarantees\n"
"than `Data.Vect.length`: The latter claims to just return\n"
"*any* natural number, while `vectLength` *must* return\n"
"exactly `n` in order to type check. As a demonstration,\n"
"here is a well-typed bogus implementation of `length`:\n"
msgstr "此函数提供比 `Data.Vect.length` 更强的保证：后者声称只返回 *任意* 自然数，而 `vectLength` *必须*准确返回 `n` 以便进行类型检查。作为演示，这里是 `length` 的良类型的虚假实现：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:327
#, no-wrap
msgid ""
"bogusLength : Vect n a -> Nat\n"
"bogusLength = const 0\n"
msgstr ""
"bogusLength : Vect n a -> Nat\n"
"bogusLength = const 0\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:334
#, no-wrap
msgid ""
"This would not be accepted as a valid implementation of\n"
"`vectLength`, as you may quickly verify yourself.\n"
msgstr "这不会被接受为 `vectLength` 的有效实现，因为您可以快速验证自己。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:338
#, no-wrap
msgid ""
"With the help of `vectLength` (but not with `Data.Vect.length`)\n"
"we can convert an erased existential to a proper dependent\n"
"pair:\n"
msgstr "在 `vectLength` 的帮助下（但不是 `Data.Vect.length`），我们可以将已擦除的存在转换为正确的依赖对：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:339
#, no-wrap
msgid ""
"toDPair : Exists (\\n => Vect n a) -> (m ** Vect m a)\n"
"toDPair (Evidence _ as) = let Val m = vectLength as in (m ** as)\n"
msgstr ""
"toDPair : Exists (\\n => Vect n a) -> (m ** Vect m a)\n"
"toDPair (Evidence _ as) = let Val m = vectLength as in (m ** as)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:347
#, no-wrap
msgid ""
"Again, as a quick exercise, try implementing `toDPair` in terms\n"
"of `length`, and note how Idris will fail to unify the\n"
"result of `length` with the actual length of the vector.\n"
msgstr "同样，作为一个快速练习，尝试根据 `length` 实现 `toDPair`，并注意 Idris 无法将 `length` 的结果与实际长度向量统一。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:352
msgid ""
"Declare and implement a function for filtering a vector similar to `Data."
"List.filter`."
msgstr "声明并实现一个过滤向量的函数，类似于 `Data.List.filter`。"

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:356
msgid ""
"Declare and implement a function for mapping a partial function over the "
"values of a vector similar to `Data.List.mapMaybe`."
msgstr ""
"声明并实现一个函数，用于将偏函数映射到类似于 `Data.List.mapMaybe` 的向量的值"
"上。"

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:360
msgid ""
"Declare and implement a function similar to `Data.List.dropWhile` for "
"vectors. Use `Data.DPair.Exists` as your return type."
msgstr ""
"为向量声明并实现类似于 `Data.List.dropWhile` 的函数。使用 `Data.DPair."
"Exists` 作为您的返回类型。"

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:363
msgid ""
"Repeat exercise 3 but return a proper dependent pair. Use the function from "
"exercise 3 in your implementation."
msgstr "重复练习 3，但返回正确的依赖对。在您的实现中使用练习 3 中的函数。"

#. type: Title ##
#: ../src/Tutorial/DPair.md:364
#, no-wrap
msgid "Use Case: Nucleic Acids"
msgstr "用例：核酸"

#. type: Plain text
#: ../src/Tutorial/DPair.md:372
#, no-wrap
msgid ""
"We'd like to come up with a small, simplified library for running computations\n"
"on nucleic acids: RNA and DNA. These are built from five types of\n"
"nucleobases, three of which are used in both types of nucleic\n"
"acids and two bases specific for each type of acid. We'd like\n"
"to make sure that only valid bases are in strands of nucleic acids.\n"
"Here's a possible encoding:\n"
msgstr "我们想提出一个小型、简化的库，用于运行核酸计算：RNA 和 DNA。它们由五种类型的核碱基构成，其中三种用于两种类型的核酸中，两种碱基对每种类型的酸具有特异性。我们想确保只有有效的碱基存在于核酸链中。这是一种可能的编码：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:373
#, no-wrap
msgid ""
"data BaseType = DNABase | RNABase\n"
"\n"
"data Nucleobase : BaseType -> Type where\n"
"  Adenine  : Nucleobase b\n"
"  Cytosine : Nucleobase b\n"
"  Guanine  : Nucleobase b\n"
"  Thymine  : Nucleobase DNABase\n"
"  Uracile  : Nucleobase RNABase\n"
"\n"
"NucleicAcid : BaseType -> Type\n"
"NucleicAcid = List . Nucleobase\n"
"\n"
"RNA : Type\n"
"RNA = NucleicAcid RNABase\n"
"\n"
"DNA : Type\n"
"DNA = NucleicAcid DNABase\n"
"\n"
"encodeBase : Nucleobase b -> Char\n"
"encodeBase Adenine  = 'A'\n"
"encodeBase Cytosine = 'C'\n"
"encodeBase Guanine  = 'G'\n"
"encodeBase Thymine  = 'T'\n"
"encodeBase Uracile  = 'U'\n"
"\n"
"encode : NucleicAcid b -> String\n"
"encode = pack . map encodeBase\n"
msgstr ""
"data BaseType = DNABase | RNABase\n"
"\n"
"data Nucleobase : BaseType -> Type where\n"
"  Adenine  : Nucleobase b\n"
"  Cytosine : Nucleobase b\n"
"  Guanine  : Nucleobase b\n"
"  Thymine  : Nucleobase DNABase\n"
"  Uracile  : Nucleobase RNABase\n"
"\n"
"NucleicAcid : BaseType -> Type\n"
"NucleicAcid = List . Nucleobase\n"
"\n"
"RNA : Type\n"
"RNA = NucleicAcid RNABase\n"
"\n"
"DNA : Type\n"
"DNA = NucleicAcid DNABase\n"
"\n"
"encodeBase : Nucleobase b -> Char\n"
"encodeBase Adenine  = 'A'\n"
"encodeBase Cytosine = 'C'\n"
"encodeBase Guanine  = 'G'\n"
"encodeBase Thymine  = 'T'\n"
"encodeBase Uracile  = 'U'\n"
"\n"
"encode : NucleicAcid b -> String\n"
"encode = pack . map encodeBase\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:404
#, no-wrap
msgid "It is a type error to use `Uracile` in a strand of DNA:\n"
msgstr "在 DNA 链中使用 `Uracile` 是一个类型错误：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:405
#, no-wrap
msgid ""
"failing \"Mismatch between: RNABase and DNABase.\"\n"
"  errDNA : DNA\n"
"  errDNA = [Uracile, Adenine]\n"
msgstr ""
"failing \"Mismatch between: RNABase and DNABase.\"\n"
"  errDNA : DNA\n"
"  errDNA = [Uracile, Adenine]\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:415
#, no-wrap
msgid ""
"Note, how we used a variable for nucleobases `Adenine`, `Cytosine`, and\n"
"`Guanine`: These are again universally quantified,\n"
"and client code is free to choose a value here. This allows us\n"
"to use these bases in strands of DNA *and* RNA:\n"
msgstr "请注意，我们如何为核碱基 `Adenine`、`Cytosine` 和 `Guanine` 使用变量：这些又是普遍量化的，客户代码可以在这里自由选择一个值.这使我们能够在 DNA *和* RNA 链中使用这些碱基：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:416
#, no-wrap
msgid ""
"dna1 : DNA\n"
"dna1 = [Adenine, Cytosine, Guanine]\n"
"\n"
"rna1 : RNA\n"
"rna1 = [Adenine, Cytosine, Guanine]\n"
msgstr ""
"dna1 : DNA\n"
"dna1 = [Adenine, Cytosine, Guanine]\n"
"\n"
"rna1 : RNA\n"
"rna1 = [Adenine, Cytosine, Guanine]\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:427
#, no-wrap
msgid ""
"With `Thymine` and `Uracile`, we are more restrictive: `Thymine` is only\n"
"allowed in DNA, while `Uracile` is restricted to be used in RNA strands.\n"
"Let's write parsers for strands of DNA and RNA:\n"
msgstr "对于 `Thymine` 和 `Uracile`，我们的限制性更强：`Thymine` 仅允许用于 DNA，而 `Uracile` 仅限用于 RNA。让我们为 DNA 和 RNA 链编写解析器：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:428
#, no-wrap
msgid ""
"readAnyBase : Char -> Maybe (Nucleobase b)\n"
"readAnyBase 'A' = Just Adenine\n"
"readAnyBase 'C' = Just Cytosine\n"
"readAnyBase 'G' = Just Guanine\n"
"readAnyBase _   = Nothing\n"
"\n"
"readRNABase : Char -> Maybe (Nucleobase RNABase)\n"
"readRNABase 'U' = Just Uracile\n"
"readRNABase c   = readAnyBase c\n"
"\n"
"readDNABase : Char -> Maybe (Nucleobase DNABase)\n"
"readDNABase 'T' = Just Thymine\n"
"readDNABase c   = readAnyBase c\n"
"\n"
"readRNA : String -> Maybe RNA\n"
"readRNA = traverse readRNABase . unpack\n"
"\n"
"readDNA : String -> Maybe DNA\n"
"readDNA = traverse readDNABase . unpack\n"
msgstr ""
"readAnyBase : Char -> Maybe (Nucleobase b)\n"
"readAnyBase 'A' = Just Adenine\n"
"readAnyBase 'C' = Just Cytosine\n"
"readAnyBase 'G' = Just Guanine\n"
"readAnyBase _   = Nothing\n"
"\n"
"readRNABase : Char -> Maybe (Nucleobase RNABase)\n"
"readRNABase 'U' = Just Uracile\n"
"readRNABase c   = readAnyBase c\n"
"\n"
"readDNABase : Char -> Maybe (Nucleobase DNABase)\n"
"readDNABase 'T' = Just Thymine\n"
"readDNABase c   = readAnyBase c\n"
"\n"
"readRNA : String -> Maybe RNA\n"
"readRNA = traverse readRNABase . unpack\n"
"\n"
"readDNA : String -> Maybe DNA\n"
"readDNA = traverse readDNABase . unpack\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:454
#, no-wrap
msgid ""
"Again, in case of the bases appearing in both kinds of strands,\n"
"users of the universally quantified `readAnyBase`\n"
"are free to choose what base type they want, but they will\n"
"never get a `Thymine` or `Uracile` value.\n"
msgstr "同样，如果碱基出现在两种链中，通用量化的 `readAnyBase` 的用户可以自由选择他们想要的碱基类型，但他们永远不会得到 `Thymine` 或`Uracile`值。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:458
#, no-wrap
msgid ""
"We can now implement some simple calculations on sequences of\n"
"nucleobases. For instance, we can come up with the complementary\n"
"strand:\n"
msgstr "我们现在可以对核碱基序列进行一些简单的计算。例如，我们可以提出互补链：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:459
#, no-wrap
msgid ""
"complementRNA' : RNA -> RNA\n"
"complementRNA' = map calc\n"
"  where calc : Nucleobase RNABase -> Nucleobase RNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Uracile\n"
"        calc Uracile  = Adenine\n"
"\n"
"complementDNA' : DNA -> DNA\n"
"complementDNA' = map calc\n"
"  where calc : Nucleobase DNABase -> Nucleobase DNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Thymine\n"
"        calc Thymine  = Adenine\n"
msgstr ""
"complementRNA' : RNA -> RNA\n"
"complementRNA' = map calc\n"
"  where calc : Nucleobase RNABase -> Nucleobase RNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Uracile\n"
"        calc Uracile  = Adenine\n"
"\n"
"complementDNA' : DNA -> DNA\n"
"complementDNA' = map calc\n"
"  where calc : Nucleobase DNABase -> Nucleobase DNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Thymine\n"
"        calc Thymine  = Adenine\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:480
#, no-wrap
msgid ""
"Ugh, code repetition! Not too bad here, but imagine there were\n"
"dozens of bases with only few specialized ones. Surely, we can\n"
"do better? Unfortunately, the following won't work:\n"
msgstr "呃，代码重复！这里还不错，但想象一下有几十个基础的，只有几个特殊的。那么，我们可以做得更好吗？不幸的是，以下方法不起作用：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:481
#, no-wrap
msgid ""
"complementBase' : Nucleobase b -> Nucleobase b\n"
"complementBase' Adenine  = ?what_now\n"
"complementBase' Cytosine = Guanine\n"
"complementBase' Guanine  = Cytosine\n"
"complementBase' Thymine  = Adenine\n"
"complementBase' Uracile  = Adenine\n"
msgstr ""
"complementBase' : Nucleobase b -> Nucleobase b\n"
"complementBase' Adenine  = ?what_now\n"
"complementBase' Cytosine = Guanine\n"
"complementBase' Guanine  = Cytosine\n"
"complementBase' Thymine  = Adenine\n"
"complementBase' Uracile  = Adenine\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:497
#, no-wrap
msgid ""
"All goes well with the exception of the `Adenine` case. Remember:\n"
"Parameter `b` is universally quantified, and the *callers* of\n"
"our function can decide what `b` is supposed to\n"
"be. We therefore can't just return `Thymine`: Idris will respond\n"
"with a type error since callers might want a `Nucleobase RNABase` instead.\n"
"One way to go about this is to take an additional unerased argument\n"
"(explicit or implicit) representing the base type:\n"
msgstr "除了 `Adenine` 情况外，一切都很顺利。请记住：参数 `b` 是通用量化的，我们函数的 *callers* 可以决定 `b` 应该是什么。因此，我们不能只返回 `Thymine`：Idris 将响应类型错误，因为调用者可能需要 `Nucleobase RNABase` 代替。解决此问题的一种方法是采用表示基本类型的附加未擦除参数（显式或隐式）：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:498
#, no-wrap
msgid ""
"complementBase : (b : BaseType) -> Nucleobase b -> Nucleobase b\n"
"complementBase DNABase Adenine  = Thymine\n"
"complementBase RNABase Adenine  = Uracile\n"
"complementBase _       Cytosine = Guanine\n"
"complementBase _       Guanine  = Cytosine\n"
"complementBase _       Thymine  = Adenine\n"
"complementBase _       Uracile  = Adenine\n"
msgstr ""
"complementBase : (b : BaseType) -> Nucleobase b -> Nucleobase b\n"
"complementBase DNABase Adenine  = Thymine\n"
"complementBase RNABase Adenine  = Uracile\n"
"complementBase _       Cytosine = Guanine\n"
"complementBase _       Guanine  = Cytosine\n"
"complementBase _       Thymine  = Adenine\n"
"complementBase _       Uracile  = Adenine\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:512
#, no-wrap
msgid ""
"This is again an example of a dependent *function* type (also called a\n"
"[*pi type*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A0_type)):\n"
"The input and output types both *depend* on the *value* of the first argument.\n"
"We can now use this to calculate the complement of any nucleic acid:\n"
msgstr "这又是一个依赖 *函数* 类型（也称为 [*pi 类型*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A0_type)）的示例 : 输入和输出类型都 *取决于* 第一个参数的 *值*。我们现在可以使用它来计算任何核酸的互补链：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:513
#, no-wrap
msgid ""
"complement : (b : BaseType) -> NucleicAcid b -> NucleicAcid b\n"
"complement b = map (complementBase b)\n"
msgstr ""
"complement : (b : BaseType) -> NucleicAcid b -> NucleicAcid b\n"
"complement b = map (complementBase b)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:528
#, no-wrap
msgid ""
"Now, here is an interesting use case: We'd like to read a sequence\n"
"of nucleobases from user input, accepting two strings: The first\n"
"telling us, whether the user plans to enter a DNA or RNA sequence,\n"
"the second being the sequence itself. What should be the type of\n"
"such a function? Well, we're describing computations with side effects,\n"
"so something involving `IO` seems about right. User input almost\n"
"always needs to be validated or translated, so something might go wrong\n"
"and we need an error type for this case. Finally, our users can\n"
"decide whether they want to enter a strand of RNA or DNA, so this\n"
"distinction should be encoded as well.\n"
msgstr "现在，这是一个有趣的用例：我们想从用户输入中读取一个核碱基序列，接受两个字符串：第一个告诉我们，用户打算输入 DNA 还是 RNA 序列，第二个是序列本身.这种函数的类型应该是什么？好吧，我们正在描述具有副作用的计算，因此涉及 `IO` 的东西似乎是正确的。用户输入几乎总是需要验证或翻译，因此可能会出现问题，我们需要针对这种情况的错误类型。最后，我们的用户可以决定是否要输入一条 RNA 或 DNA，因此也应该对这种区别进行编码。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:531
#, no-wrap
msgid ""
"Of course, it is always possible to write a custom sum type for\n"
"such a use case:\n"
msgstr "当然，总是可以为这样的用例编写自定义和类型：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:532
#, no-wrap
msgid ""
"data Result : Type where\n"
"  UnknownBaseType : String -> Result\n"
"  InvalidSequence : String -> Result\n"
"  GotDNA          : DNA -> Result\n"
"  GotRNA          : RNA -> Result\n"
msgstr ""
"data Result : Type where\n"
"  UnknownBaseType : String -> Result\n"
"  InvalidSequence : String -> Result\n"
"  GotDNA          : DNA -> Result\n"
"  GotRNA          : RNA -> Result\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:544
#, no-wrap
msgid ""
"This has all possible outcomes encoded in a single data type.\n"
"However, it is lacking in terms of flexibility. If we want to handle\n"
"errors early on and just extract a strand of RNA or DNA, we need\n"
"yet another data type:\n"
msgstr "这具有以单一数据类型编码的所有可能结果。但是，它缺乏灵活性。如果我们想及早处理错误并只提取一条 RNA 或 DNA，我们需要另一种数据类型：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:545
#, no-wrap
msgid "data RNAOrDNA = ItsRNA RNA | ItsDNA DNA\n"
msgstr "data RNAOrDNA = ItsRNA RNA | ItsDNA DNA\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:552
#, no-wrap
msgid ""
"This might be the way to go, but for results with many options, this\n"
"can get cumbersome quickly. Also: Why come up with a custom data type when\n"
"we already have the tools to deal with this at our hands?\n"
msgstr "这可能是要走的路，但对于有很多选项的结果，这很快就会变得很麻烦。另外：当我们已经拥有处理这个问题的工具时，为什么还要提出自定义数据类型？\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:554
#, no-wrap
msgid "Here is how we can encode this with a dependent pair:\n"
msgstr "以下是我们如何使用依赖对对其进行编码：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:555
#, no-wrap
msgid ""
"namespace InputError\n"
"  public export\n"
"  data InputError : Type where\n"
"    UnknownBaseType : String -> InputError\n"
"    InvalidSequence : String -> InputError\n"
"\n"
"readAcid : (b : BaseType) -> String -> Either InputError (NucleicAcid b)\n"
"readAcid b str =\n"
"  let err = InvalidSequence str\n"
"   in case b of\n"
"        DNABase => maybeToEither err $ readDNA str\n"
"        RNABase => maybeToEither err $ readRNA str\n"
"\n"
"getNucleicAcid : IO (Either InputError (b ** NucleicAcid b))\n"
"getNucleicAcid = do\n"
"  baseString <- getLine\n"
"  case baseString of\n"
"    \"DNA\" => map (MkDPair _) . readAcid DNABase <$> getLine\n"
"    \"RNA\" => map (MkDPair _) . readAcid RNABase <$> getLine\n"
"    _     => pure $ Left (UnknownBaseType baseString)\n"
msgstr ""
"namespace InputError\n"
"  public export\n"
"  data InputError : Type where\n"
"    UnknownBaseType : String -> InputError\n"
"    InvalidSequence : String -> InputError\n"
"\n"
"readAcid : (b : BaseType) -> String -> Either InputError (NucleicAcid b)\n"
"readAcid b str =\n"
"  let err = InvalidSequence str\n"
"   in case b of\n"
"        DNABase => maybeToEither err $ readDNA str\n"
"        RNABase => maybeToEither err $ readRNA str\n"
"\n"
"getNucleicAcid : IO (Either InputError (b ** NucleicAcid b))\n"
"getNucleicAcid = do\n"
"  baseString <- getLine\n"
"  case baseString of\n"
"    \"DNA\" => map (MkDPair _) . readAcid DNABase <$> getLine\n"
"    \"RNA\" => map (MkDPair _) . readAcid RNABase <$> getLine\n"
"    _     => pure $ Left (UnknownBaseType baseString)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:583
#, no-wrap
msgid ""
"Note, how we paired the type of nucleobases with the nucleic acid\n"
"sequence. Assume now we implement a function for transcribing\n"
"a strand of DNA to RNA, and we'd like to convert a sequence of\n"
"nucleobases from user input to the corresponding RNA sequence.\n"
"Here's how to do this:\n"
msgstr "请注意，我们如何将核碱基类型与核酸序列配对。假设现在我们实现了一个将 DNA 链转录为 RNA 的函数，并且我们希望将用户输入的核碱基序列转换为相应的 RNA 序列。以下是如何执行此操作：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:584
#, no-wrap
msgid ""
"transcribeBase : Nucleobase DNABase -> Nucleobase RNABase\n"
"transcribeBase Adenine  = Uracile\n"
"transcribeBase Cytosine = Guanine\n"
"transcribeBase Guanine  = Cytosine\n"
"transcribeBase Thymine  = Adenine\n"
"\n"
"transcribe : DNA -> RNA\n"
"transcribe = map transcribeBase\n"
"\n"
"printRNA : RNA -> IO ()\n"
"printRNA = putStrLn . encode\n"
"\n"
"transcribeProg : IO ()\n"
"transcribeProg = do\n"
"  Right (b ** seq) <- getNucleicAcid\n"
"    | Left (InvalidSequence str) => putStrLn $ \"Invalid sequence: \" ++ str\n"
"    | Left (UnknownBaseType str) => putStrLn $ \"Unknown base type: \" ++ str\n"
"  case b of\n"
"    DNABase => printRNA $ transcribe seq\n"
"    RNABase => printRNA seq\n"
msgstr ""
"transcribeBase : Nucleobase DNABase -> Nucleobase RNABase\n"
"transcribeBase Adenine  = Uracile\n"
"transcribeBase Cytosine = Guanine\n"
"transcribeBase Guanine  = Cytosine\n"
"transcribeBase Thymine  = Adenine\n"
"\n"
"transcribe : DNA -> RNA\n"
"transcribe = map transcribeBase\n"
"\n"
"printRNA : RNA -> IO ()\n"
"printRNA = putStrLn . encode\n"
"\n"
"transcribeProg : IO ()\n"
"transcribeProg = do\n"
"  Right (b ** seq) <- getNucleicAcid\n"
"    | Left (InvalidSequence str) => putStrLn $ \"Invalid sequence: \" ++ str\n"
"    | Left (UnknownBaseType str) => putStrLn $ \"Unknown base type: \" ++ str\n"
"  case b of\n"
"    DNABase => printRNA $ transcribe seq\n"
"    RNABase => printRNA seq\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:611
#, no-wrap
msgid ""
"By pattern matching on the first value of the dependent pair we could\n"
"determine, whether the second value is an RNA or DNA sequence.\n"
"In the first case, we had to transcribe the\n"
"sequence first, in the second case, we could invoke `printRNA` directly.\n"
msgstr "通过对依赖对的第一个值的模式匹配，我们可以确定第二个值是 RNA 还是 DNA 序列。在第一种情况下，我们必须先转录序列，在第二种情况下，我们可以直接调用 `printRNA`。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:620
#, no-wrap
msgid ""
"In a more interesting scenario, we would *translate* the RNA sequence\n"
"to the corresponding protein sequence. Still, this example shows\n"
"how to deal with a simplified real world scenario: Data may be\n"
"encoded differently and coming from different sources. By using precise\n"
"types, we are forced to first convert values to the correct\n"
"format. Failing to do so leads to a compile time exception instead of\n"
"an error at runtime or - even worse - the program silently running\n"
"a bogus computation.\n"
msgstr "在一个更有趣的场景中，我们将 RNA 序列 *翻译* 成相应的蛋白质序列。尽管如此，这个例子展示了如何处理一个简化的现实世界场景：数据可能以不同的方式编码并且来自不同的来源。通过使用精确类型，我们被迫首先将值转换为正确的格式。不这样做会导致编译时异常，而不是运行时错误，或者 - 更糟糕的是 - 程序静默运行虚假计算。\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:621
#, no-wrap
msgid "Dependent Records vs Sum Types"
msgstr "依赖记录与和类型"

#. type: Plain text
#: ../src/Tutorial/DPair.md:630
#, no-wrap
msgid ""
"Dependent records as shown for `AnyVect a` are a generalization\n"
"of dependent pairs: We can have an arbitrary number of fields\n"
"and use the values stored therein to calculate the types of\n"
"other values. For very simple cases like the example with nucleobases,\n"
"it doesn't matter too much, whether we use a `DPair`, a custom\n"
"dependent record, or even a sum type. In fact, the three encodings\n"
"are equally expressive:\n"
msgstr "`AnyVect a` 所示的依赖记录是依赖对的概括：我们可以有任意数量的字段并使用其中存储的值来计算其他值的类型。对于非常简单的情况，例如带有核碱基的示例，无论我们使用 `DPair`、自定义相关记录还是和类型都没有太大关系。事实上，这三种编码同样具有表现力：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:631
#, no-wrap
msgid ""
"Acid1 : Type\n"
"Acid1 = (b ** NucleicAcid b)\n"
"\n"
"record Acid2 where\n"
"  constructor MkAcid2\n"
"  baseType : BaseType\n"
"  sequence : NucleicAcid baseType\n"
"\n"
"data Acid3 : Type where\n"
"  SomeRNA : RNA -> Acid3\n"
"  SomeDNA : DNA -> Acid3\n"
msgstr ""
"Acid1 : Type\n"
"Acid1 = (b ** NucleicAcid b)\n"
"\n"
"record Acid2 where\n"
"  constructor MkAcid2\n"
"  baseType : BaseType\n"
"  sequence : NucleicAcid baseType\n"
"\n"
"data Acid3 : Type where\n"
"  SomeRNA : RNA -> Acid3\n"
"  SomeDNA : DNA -> Acid3\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:652
#, no-wrap
msgid ""
"It is trivial to write lossless conversions between these\n"
"encodings, and with each encoding we can decide with a simple\n"
"pattern match, whether we currently have a sequence of\n"
"RNA or DNA. However, dependent types can depend on more than\n"
"one value, as we will see in the exercises. In such cases,\n"
"sum types and dependent pairs quickly become unwieldy, and\n"
"you should go for an encoding as a dependent record.\n"
msgstr "在这些编码之间编写无损转换是微不足道的，并且对于每种编码，我们可以通过简单的模式匹配来决定我们当前是否具有 RNA 或 DNA 序列。然而，依赖类型可以依赖多个值，正如我们将在练习中看到的那样。在这种情况下，和类型和依赖对很快就会变得笨拙，您应该将编码作为依赖记录。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:661
#, no-wrap
msgid ""
"Sharpen your skills in using dependent pairs and dependent\n"
"records! In exercises 2 to 7 you have to decide yourself,\n"
"when a function should return a dependent pair or record,\n"
"when a function requires additional arguments, on which you\n"
"can pattern match, and what other utility functions might be\n"
"necessary.\n"
msgstr "提高您使用依赖对和依赖记录的技能！在练习 2 到 7 中，你必须自己决定什么时候函数应该返回一个依赖对或记录，什么时候函数需要额外的参数，你可以在这些参数上进行模式匹配，以及可能需要哪些其他实用函数。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:666
msgid ""
"Proof that the three encodings for nucleobases are *isomorphic* (meaning: of "
"the same structure) by writing lossless conversion functions from `Acid1` to "
"`Acid2` and back. Likewise for `Acid1` and `Acid3`."
msgstr ""
"通过编写从 `Acid1` 到 `Acid2` 并返回的无损转换函数，证明核碱基的三种编码是 *"
"同构的*（意思是：结构相同）。同样适用于 `Acid1` 和 `Acid3`。"

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:673
msgid ""
"Sequences of nucleobases can be encoded in one of two directions: [*Sense* "
"and *antisense*](https://en.wikipedia.org/wiki/Sense_(molecular_biology)).  "
"Declare a new data type to describe the sense of a sequence of nucleobases, "
"and add this as an additional parameter to type `Nucleobase` and types `DNA` "
"and `RNA`."
msgstr ""
"核碱基序列可以在以下两个方向之一编码：[*Sense* 和 *antisense*](https://en."
"wikipedia.org/wiki/Sense_(molecular_biology))。声明一个新的数据类型来描述核碱"
"基序列的意义，并将其作为附加参数添加到类型 `Nucleobase` 和类型 `DNA` 和 "
"`RNA`。"

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:677
msgid ""
"Refine the types of `complement` and `transcribe`, so that they reflect the "
"changing of *sense*. In case of `transcribe`, a strand of antisense DNA is "
"converted to a strand of sense RNA."
msgstr ""
"细化`complement`和`transcribe`的类型，使其反映*sense*的变化。在 `transcribe` "
"的情况下，反义 DNA 链被转化为 sense RNA 链。"

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:680
msgid ""
"Define a dependent record storing the base type and sense together with a "
"sequence of nucleobases."
msgstr "定义一个依赖记录，将碱基类型和 sense 与一系列核碱基一起存储。"

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:685
#, fuzzy
#| msgid ""
#| "Adjust `readRNA` and `readDNA` in such a way that the *sense* of a "
#| "sequence is read from the input string.  Sense strands are encoded like "
#| "so: \"5-CGGTAG-3\". Antisense strands are encoded like so: \"3-CGGTAG-5\"."
msgid ""
"Adjust `readRNA` and `readDNA` in such a way that the *sense* of a sequence "
"is read from the input string.  Sense strands are encoded like so: \"5-"
"CGGTAG-3\". Antisense strands are encoded like so: \"3-CGGTAG-5\"."
msgstr ""
"调整 `readRNA` 和 `readDNA` 使得从输入字符串中读取序列的 *sense*。 Sense 链编"
"码如下：“5-CGGTAG-3”。反义链编码如下：“3-CGGTAG-5”。"

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:688
msgid "Adjust `encode` in such a way that it includes the sense in its output."
msgstr "调整 `encode` 使其在输出中包含 sense。"

#. type: Bullet: '7. '
#: ../src/Tutorial/DPair.md:693
msgid ""
"Enhance `getNucleicAcid` and `transcribeProg` in such a way that the sense "
"and base type are stored together with the sequence, and that "
"`transcribeProg` always prints the *sense* RNA strand (after transcription, "
"if necessary)."
msgstr ""
"增强 `getNucleicAcid` 和 `transcribeProg` 以使 sense 和碱基类型与序列一起存"
"储，并且 `transcribeProg` 始终打印 *sense* RNA 链（转录后，如有必要）。"

#. type: Bullet: '8. '
#: ../src/Tutorial/DPair.md:695
msgid "Enjoy the fruits of your labour and test your program at the REPL."
msgstr "享受您的劳动成果并在 REPL 测试您的程序。"

#. type: Plain text
#: ../src/Tutorial/DPair.md:703
#, no-wrap
msgid ""
"Note: Instead of using a dependent record, we could again\n"
"have used a sum type of four constructors to encode the different\n"
"types of sequences. However, the number of constructors\n"
"required corresponds to the *product* of the number of values\n"
"of each type level index. Therefore, this number can grow quickly\n"
"and sum type encodings can lead to lengthy blocks of pattern matches\n"
"in these cases.\n"
msgstr "注意：我们可以再次使用四个构造函数的和类型来编码不同类型的序列，而不是使用依赖记录。但是，所需的构造函数数量对应于每个类型级别索引的值数量的 *积*。因此，这个数字会快速增长，并且在这些情况下，和类型编码会导致模式匹配的块很长。\n"

#. type: Title ##
#: ../src/Tutorial/DPair.md:704
#, no-wrap
msgid "Use Case: CSV Files with a Schema"
msgstr "用例：带有模式的 CSV 文件"

#. type: Plain text
#: ../src/Tutorial/DPair.md:712
#, no-wrap
msgid ""
"In this section, we are going to look at an extended example\n"
"based on our previous work on CSV parsers. We'd like to\n"
"write a small command-line program, where users can specify a\n"
"schema for the CSV tables they'd like to parse and load into\n"
"memory. Before we begin, here is a REPL session running\n"
"the final program, which you will complete in the exercises:\n"
msgstr "在本节中，我们将看一个基于我们之前在 CSV 解析器上的工作的扩展示例。我们想编写一个小型命令行程序，用户可以在其中为他们想要解析并加载到内存中的 CSV 表指定模式。在我们开始之前，这是一个运行最终程序的 REPL 会话，您将在练习中完成它：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:713
#, no-wrap
msgid ""
"Solutions.DPair> :exec main\n"
"Enter a command: load resources/example\n"
"Table loaded. Schema: str,str,fin2023,str?,boolean?\n"
"Enter a command: get 3\n"
"Row 3:\n"
"\n"
"str   | str    | fin2023 | str? | boolean?\n"
"------------------------------------------\n"
"Floor | Jansen | 1981    |      | t\n"
"\n"
"Enter a command: add Mikael,Stanne,1974,,\n"
"Row prepended:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: delete 1\n"
"Deleted row: 1.\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str | str     | fin2023 | str? | boolean?\n"
"-----------------------------------------\n"
"Rob | Halford | 1951    |      |\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"
msgstr ""
"Solutions.DPair> :exec main\n"
"Enter a command: load resources/example\n"
"Table loaded. Schema: str,str,fin2023,str?,boolean?\n"
"Enter a command: get 3\n"
"Row 3:\n"
"\n"
"str   | str    | fin2023 | str? | boolean?\n"
"------------------------------------------\n"
"Floor | Jansen | 1981    |      | t\n"
"\n"
"Enter a command: add Mikael,Stanne,1974,,\n"
"Row prepended:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: delete 1\n"
"Deleted row: 1.\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str | str     | fin2023 | str? | boolean?\n"
"-----------------------------------------\n"
"Rob | Halford | 1951    |      |\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:754
#, no-wrap
msgid ""
"This example was inspired by a similar program used as an example\n"
"in the [Type-Driven Development with Idris](https://www.manning.com/books/type-driven-development-with-idris)\n"
"book.\n"
msgstr "这个例子的灵感来自于 [Type-Driven Development with Idris](https://www.manning.com/books/type-driven-development-with-idris) 一书中用作示例的类似程序。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:756
#, no-wrap
msgid "We'd like to focus on several things here:\n"
msgstr "我们想在这里重点关注几件事：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
msgid ""
"Purity: With the exception of the main program loop, all functions used in "
"the implementation should be pure, which in this context means \"not running "
"in any monad with side effects such as `IO`\"."
msgstr ""
"纯度：除了主程序循环之外，实现中使用的所有函数都应该是纯函数，在这种情况下，"
"这意味着“不在任何具有副作用的 monad 中运行，例如 `IO`”。"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
msgid ""
"Fail early: With the exception of the command parser, all functions updating "
"the table and handling queries should be typed and implemented in such a way "
"that they cannot fail."
msgstr ""
"尽早失败：除了命令解析器之外，所有更新表和处理查询的函数都应该以不会失败的方"
"式输入和实现。"

#. type: Plain text
#: ../src/Tutorial/DPair.md:766
#, no-wrap
msgid ""
"We are often well advised to adhere to these two guidelines, as they can\n"
"make the majority of our functions easier to implement and test.\n"
msgstr "我们经常被建议遵守这两个准则，因为它们可以使我们的大多数函数更容易实现和测试。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:772
#, no-wrap
msgid ""
"Since we allow users of our library to specify a schema (order and\n"
"types of columns) for the table they work with, this information is\n"
"not known until runtime. The same goes for the current size of the\n"
"table. We will therefore store both values as fields in a\n"
"dependent record.\n"
msgstr "由于我们允许我们库的用户为他们使用的表指定模式（列的顺序和类型），因此直到运行时才知道此信息。表的当前大小也是如此。因此，我们会将这两个值作为字段存储在依赖记录中。\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:773
#, no-wrap
msgid "Encoding the Schema"
msgstr "为模式编码"

#. type: Plain text
#: ../src/Tutorial/DPair.md:780
#, no-wrap
msgid ""
"We need to inspect the table schema at runtime. Although theoretically\n"
"possible, it is not advisable to operate on Idris types directly here.\n"
"We'd rather use a closed custom data type describing the types of\n"
"columns we understand. In a first try, we only support some Idris\n"
"primitives:\n"
msgstr "我们需要在运行时检查表模式。尽管理论上可行，但不建议在此处直接对 Idris 类型进行操作。我们宁愿使用封闭的自定义数据类型来描述我们理解的列类型。在第一次尝试中，我们只支持一些 Idris 原语：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:781
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
msgstr ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:791
#, no-wrap
msgid ""
"Next, we need a way to convert a `Schema` to a list of Idris\n"
"types, which we will then use as the index of a heterogeneous\n"
"list representing the rows in our table:\n"
msgstr "接下来，我们需要一种将 `Schema` 转换为 Idris 类型列表的方法，然后将其用作表示表中行的异构列表的索引：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:792
#, no-wrap
msgid ""
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
msgstr ""
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:807
#, no-wrap
msgid ""
"We can now describe a table as a dependent record storing\n"
"the table's content as a vector of rows. In order to safely\n"
"index rows of the table and parse new rows to be added, the\n"
"current schema and size of the table must be known at runtime:\n"
msgstr "我们现在可以将表描述为将表内容存储为行向量的依赖记录。为了安全地索引表的行并解析要添加的新行，必须在运行时知道表的当前模式和大小：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:808
#, no-wrap
msgid ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
msgstr ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:823
#, no-wrap
msgid ""
"Finally, we define an indexed data type describing commands\n"
"operating on the current table. Using the current table as\n"
"the command's index allows us to make sure that indices for\n"
"accessing and deleting rows are within bounds and that\n"
"new rows agree with the current schema. This is necessary\n"
"to uphold our second design principle: All functions\n"
"operating on tables must do so without the possibility of failure.\n"
msgstr "最后，我们定义了一个索引数据类型来描述对当前表进行操作的命令。使用当前表作为命令的索引允许我们确保访问和删除行的索引在界限内，并且新行与当前模式一致。这对于维护我们的第二个设计原则是必要的：所有在表上操作的函数都必须这样做，并且没有失败的可能性。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:824
#, no-wrap
msgid ""
"data Command : (t : Table) -> Type where\n"
"  PrintSchema : Command t\n"
"  PrintSize   : Command t\n"
"  New         : (newSchema : Schema) -> Command t\n"
"  Prepend     : Row (schema t) -> Command t\n"
"  Get         : Fin (size t) -> Command t\n"
"  Delete      : Fin (size t) -> Command t\n"
"  Quit        : Command t\n"
msgstr ""
"data Command : (t : Table) -> Type where\n"
"  PrintSchema : Command t\n"
"  PrintSize   : Command t\n"
"  New         : (newSchema : Schema) -> Command t\n"
"  Prepend     : Row (schema t) -> Command t\n"
"  Get         : Fin (size t) -> Command t\n"
"  Delete      : Fin (size t) -> Command t\n"
"  Quit        : Command t\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:839
#, no-wrap
msgid ""
"We can now implement the main application logic: How user\n"
"entered commands affect the application's current state. As promised,\n"
"this comes without the risk of failure, so we don't have to\n"
"wrap the return type in an `Either`:\n"
msgstr "我们现在可以实现主要的应用程序逻辑：用户输入的命令如何影响应用程序的当前状态。正如所承诺的那样，这没有失败的风险，因此我们不必将返回类型包装在 `Either` 中：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:840
#, no-wrap
msgid ""
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"
msgstr ""
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:857
#, no-wrap
msgid ""
"Please understand, that the constructors of `Command t` are typed\n"
"in such a way that indices are always within bounds (constructors\n"
"`Get` and `Delete`), and new rows adhere to the table's\n"
"current schema (constructor `Prepend`).\n"
msgstr "请理解，`Command t` 的构造函数的类型使得索引始终在范围内（构造函数 `Get` 和 `Delete`），并且新行遵循到表的当前模式（构造函数 `Prepend`）。`\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:866
#, no-wrap
msgid ""
"One thing you might not have seen so far is the call to `absurd`\n"
"on the last line. This is a derived function of the\n"
"`Uninhabited` interface, which is used to describe types such\n"
"as `Void` or - in the case above - `Fin 0`, of which there can\n"
"be no value. Function `absurd` is then just another manifestation\n"
"of the principle of explosion. If this doesn't make too much sense\n"
"yet, don't worry. We will look at `Void` and its uses in the\n"
"next chapter.\n"
msgstr "到目前为止你可能没有看到的一件事是最后一行对 `absurd` 的调用。这是 `Uninhabited` 接口的派生函数，用于描述诸如 `Void` 或 - 在上述情况下 - `Fin 0` 等类型，其中有可以没有价值。函数`absurd` 则只是爆炸原理的另一种表现。如果这还没有太大意义，请不要担心。我们将在下一章中介绍 `Void` 及其用法。\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:867
#, no-wrap
msgid "Parsing Commands"
msgstr "解析命令"

#. type: Plain text
#: ../src/Tutorial/DPair.md:879
#, no-wrap
msgid ""
"User input validation is an important topic when writing\n"
"applications. If it happens early, you can keep larger parts\n"
"of your application pure (which - in this context - means:\n"
"\"without the possibility of failure\") and provably total.\n"
"If done properly, this step encodes and handles most if not all\n"
"ways in which things can go wrong in your program, allowing\n"
"you to come up with clear error messages telling users exactly what caused\n"
"an issue. As you surely have experienced yourself, there are few\n"
"things more frustrating than a non-trivial computer program terminating\n"
"with an unhelpful \"There was an error\" message.\n"
msgstr "用户输入验证是编写应用程序时的一个重要主题。如果它发生得早，您可以保持应用程序的大部分纯净（在这种情况下，这意味着：“没有失败的可能性”）并且可以证明是完全的。如果操作正确，此步骤将编码和处理程序中可能出现问题的大部分（可能不是全部）方式，从而使您能够提出明确的错误消息，告诉用户究竟是什么导致了问题。正如您自己所经历的那样，没有什么比一个有意义的计算机程序以无用的“发生错误”消息终止更令人沮丧的了。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:892
#, no-wrap
msgid ""
"So, in order to treat this important topic with all due respect,\n"
"we are first going to implement a custom error type. This is\n"
"not *strictly* necessary for small programs, but once your software\n"
"gets more complex, it can be tremendously helpful for keeping track\n"
"of what can go wrong where. In order to figure out what can possibly\n"
"go wrong, we first need to decide on how the commands should be entered.\n"
"Here, we use a single keyword for each command, together with an\n"
"optional number of arguments separated from the keyword by a single\n"
"space character. For instance: `\"new i64,boolean,str,str\"`,\n"
"for initializing an empty table with a new schema. With this settled,\n"
"here is a list of things that can go wrong, and the messages we'd\n"
"like to print:\n"
msgstr "因此，为了以应有的尊重对待这个重要的话题，我们首先要实现一个自定义错误类型。这对于小程序来说 *严格* 不是所必需的，但是一旦您的软件变得更加复杂，它对于跟踪可能出错的地方非常有帮助。为了找出可能出错的地方，我们首先需要决定如何输入命令。在这里，我们为每个命令使用一个关键字，以及由单个空格字符与关键字分隔的可选数量的参数。例如：`\"new i64,boolean,str,str\"`，用于使用新模式初始化空表。解决了这个问题，这里列出了可能出错的地方，以及我们想要打印的消息：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"A bogus command is entered. We repeat the input with a message that we don't "
"know the command plus a list of commands we know about."
msgstr ""
"输入了虚假命令。我们使用我们不知道命令的消息以及我们知道的命令列表重复输入。"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An invalid schema was entered. In this case, we list the position of the "
"first unknown type, the string we found there, and a list of types we know "
"about."
msgstr ""
"输入了无效的模式。在这种情况下，我们列出了第一个未知类型的位置、我们在那里找"
"到的字符串以及我们知道的类型列表。"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An invalid CSV encoding of a row was entered. We list the erroneous "
"position, the string encountered there, plus the expected type. In case of a "
"too small or too large number of fields, we also print a corresponding error "
"message."
msgstr ""
"输入的行的 CSV 编码无效。我们列出了错误的位置、在那里遇到的字符串以及预期的类"
"型。如果字段数量过少或过多，我们也会打印相应的错误消息。"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An index was out of bounds. This can happen, when users try to access or "
"delete specific rows. We print the current number of rows plus the value "
"entered."
msgstr ""
"索引超出范围。当用户尝试访问或删除特定行时，可能会发生这种情况。我们打印当前"
"行数加上输入的值。"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"A value not representing a natural number was entered as an index.  We print "
"an according error message."
msgstr "输入了不代表自然数的值作为索引。我们打印相应的错误消息。"

#. type: Plain text
#: ../src/Tutorial/DPair.md:910
#, no-wrap
msgid ""
"That's a lot of stuff to keep track off, so let's encode this in\n"
"a sum type:\n"
msgstr "有很多东西需要跟踪，所以让我们将其编码为和类型：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:911
#, no-wrap
msgid ""
"data Error : Type where\n"
"  UnknownCommand : String -> Error\n"
"  UnknownType    : (pos : Nat) -> String -> Error\n"
"  InvalidField   : (pos : Nat) -> ColType -> String -> Error\n"
"  ExpectedEOI    : (pos : Nat) -> String -> Error\n"
"  UnexpectedEOI  : (pos : Nat) -> String -> Error\n"
"  OutOfBounds    : (size : Nat) -> (index : Nat) -> Error\n"
"  NoNat          : String -> Error\n"
msgstr ""
"data Error : Type where\n"
"  UnknownCommand : String -> Error\n"
"  UnknownType    : (pos : Nat) -> String -> Error\n"
"  InvalidField   : (pos : Nat) -> ColType -> String -> Error\n"
"  ExpectedEOI    : (pos : Nat) -> String -> Error\n"
"  UnexpectedEOI  : (pos : Nat) -> String -> Error\n"
"  OutOfBounds    : (size : Nat) -> (index : Nat) -> Error\n"
"  NoNat          : String -> Error\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:929
#, no-wrap
msgid ""
"In order to conveniently construct our error messages, it is best\n"
"to use Idris' string interpolation facilities: We can enclose\n"
"arbitrary string expressions in a string literal by enclosing\n"
"them in curly braces, the first of which must be escaped with\n"
"a backslash. Like so: `\"foo \\{myExpr a b c}\"`.\n"
"We can pair this with multiline string literals to get\n"
"nicely formatted error messages.\n"
msgstr "为了方便地构造我们的错误消息，最好使用 Idris 的字符串插值工具：我们可以通过将任意字符串表达式括在花括号中，将它们括在字符串文字中，第一个必须用反斜杠转义。像这样：`\"foo \\{myExpr a b c}\"`。我们可以将它与多行字符串文字配对以获得格式良好的错误消息。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:930
#, no-wrap
msgid ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map showColType\n"
"\n"
"allTypes : String\n"
"allTypes = concat\n"
"         . List.intersperse \", \"\n"
"         . map showColType\n"
"         $ [I64,Str,Boolean,Float]\n"
"\n"
"showError : Error -> String\n"
"showError (UnknownCommand x) = \"\"\"\n"
"  Unknown command: \\{x}.\n"
"  Known commands are: clear, schema, size, new, add, get, delete, quit.\n"
"  \"\"\"\n"
"\n"
"showError (UnknownType pos x) = \"\"\"\n"
"  Unknown type at position \\{show pos}: \\{x}.\n"
"  Known types are: \\{allTypes}.\n"
"  \"\"\"\n"
"\n"
"showError (InvalidField pos tpe x) = \"\"\"\n"
"  Invalid value at position \\{show pos}.\n"
"  Expected type: \\{showColType tpe}.\n"
"  Value found: \\{x}.\n"
"  \"\"\"\n"
"\n"
"showError (ExpectedEOI k x) = \"\"\"\n"
"  Expected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (UnexpectedEOI k x) = \"\"\"\n"
"  Unxpected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (OutOfBounds size index) = \"\"\"\n"
"  Index out of bounds.\n"
"  Size of table: \\{show size}\n"
"  Index: \\{show index}\n"
"  Note: Indices start at 1.\n"
"  \"\"\"\n"
"\n"
"showError (NoNat x) = \"Not a natural number: \\{x}\"\n"
msgstr ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map showColType\n"
"\n"
"allTypes : String\n"
"allTypes = concat\n"
"         . List.intersperse \", \"\n"
"         . map showColType\n"
"         $ [I64,Str,Boolean,Float]\n"
"\n"
"showError : Error -> String\n"
"showError (UnknownCommand x) = \"\"\"\n"
"  Unknown command: \\{x}.\n"
"  Known commands are: clear, schema, size, new, add, get, delete, quit.\n"
"  \"\"\"\n"
"\n"
"showError (UnknownType pos x) = \"\"\"\n"
"  Unknown type at position \\{show pos}: \\{x}.\n"
"  Known types are: \\{allTypes}.\n"
"  \"\"\"\n"
"\n"
"showError (InvalidField pos tpe x) = \"\"\"\n"
"  Invalid value at position \\{show pos}.\n"
"  Expected type: \\{showColType tpe}.\n"
"  Value found: \\{x}.\n"
"  \"\"\"\n"
"\n"
"showError (ExpectedEOI k x) = \"\"\"\n"
"  Expected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (UnexpectedEOI k x) = \"\"\"\n"
"  Unxpected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (OutOfBounds size index) = \"\"\"\n"
"  Index out of bounds.\n"
"  Size of table: \\{show size}\n"
"  Index: \\{show index}\n"
"  Note: Indices start at 1.\n"
"  \"\"\"\n"
"\n"
"showError (NoNat x) = \"Not a natural number: \\{x}\"\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:990
#, no-wrap
msgid ""
"We can now write parsers for the different commands. We need facilities\n"
"to parse vector indices, schemata, and CSV rows.\n"
"Since we are using a CSV format for encoding\n"
"and decoding rows, it makes sense to also encode the schema\n"
"as a comma-separated list of values:\n"
msgstr "我们现在可以为不同的命令编写解析器。我们需要工具来解析向量索引、模式和 CSV 行。由于我们使用 CSV 格式对行进行编码和解码，因此也可以将模式编码为逗号分隔的值列表：\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:991
#, no-wrap
msgid ""
"zipWithIndex : Traversable t => t a -> t (Nat, a)\n"
"zipWithIndex = evalState 1 . traverse pairWithIndex\n"
"  where pairWithIndex : a -> State Nat (Nat,a)\n"
"        pairWithIndex v = (,v) <$> get <* modify S\n"
"\n"
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"readColType : Nat -> String -> Either Error ColType\n"
"readColType _ \"i64\"      = Right I64\n"
"readColType _ \"str\"      = Right Str\n"
"readColType _ \"boolean\"  = Right Boolean\n"
"readColType _ \"float\"    = Right Float\n"
"readColType n s          = Left $ UnknownType n s\n"
"\n"
"readSchema : String -> Either Error Schema\n"
"readSchema = traverse (uncurry readColType) . zipWithIndex . fromCSV\n"
msgstr ""
"zipWithIndex : Traversable t => t a -> t (Nat, a)\n"
"zipWithIndex = evalState 1 . traverse pairWithIndex\n"
"  where pairWithIndex : a -> State Nat (Nat,a)\n"
"        pairWithIndex v = (,v) <$> get <* modify S\n"
"\n"
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"readColType : Nat -> String -> Either Error ColType\n"
"readColType _ \"i64\"      = Right I64\n"
"readColType _ \"str\"      = Right Str\n"
"readColType _ \"boolean\"  = Right Boolean\n"
"readColType _ \"float\"    = Right Float\n"
"readColType n s          = Left $ UnknownType n s\n"
"\n"
"readSchema : String -> Either Error Schema\n"
"readSchema = traverse (uncurry readColType) . zipWithIndex . fromCSV\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1018
#, no-wrap
msgid ""
"We also need to decode CSV content based on the current schema.\n"
"Note, how we can do so in a type safe manner by pattern matching\n"
"on the schema, which will not be known until runtime. Unfortunately,\n"
"we need to reimplement CSV-parsing, because we want to add the\n"
"expected type to the error messages (a thing that would be\n"
"much harder to do with interface `CSVLine`\n"
"and error type `CSVError`).\n"
msgstr "我们还需要根据当前模式解码 CSV 内容。请注意，我们如何通过模式上的模式匹配以类型安全的方式做到这一点，直到运行时才知道。不幸的是，我们需要重新实现 CSV 解析，因为我们想将预期的类型添加到错误消息中（使用接口 `CSVLine` 和错误类型 `CSVError`）。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1019
#, no-wrap
msgid ""
"decodeField : Nat -> (c : ColType) -> String -> Either Error (IdrisType c)\n"
"decodeField k c s =\n"
"  let err = InvalidField k c s\n"
"   in case c of\n"
"        I64     => maybeToEither err $ read s\n"
"        Str     => maybeToEither err $ read s\n"
"        Boolean => maybeToEither err $ read s\n"
"        Float   => maybeToEither err $ read s\n"
"\n"
"decodeRow : {ts : _} -> String -> Either Error (Row ts)\n"
"decodeRow s = go 1 ts $ fromCSV s\n"
"  where go : Nat -> (cs : Schema) -> List String -> Either Error (Row cs)\n"
"        go k []       []         = Right []\n"
"        go k []       (_ :: _)   = Left $ ExpectedEOI k s\n"
"        go k (_ :: _) []         = Left $ UnexpectedEOI k s\n"
"        go k (c :: cs) (s :: ss) = [| decodeField k c s :: go (S k) cs ss |]\n"
msgstr ""
"decodeField : Nat -> (c : ColType) -> String -> Either Error (IdrisType c)\n"
"decodeField k c s =\n"
"  let err = InvalidField k c s\n"
"   in case c of\n"
"        I64     => maybeToEither err $ read s\n"
"        Str     => maybeToEither err $ read s\n"
"        Boolean => maybeToEither err $ read s\n"
"        Float   => maybeToEither err $ read s\n"
"\n"
"decodeRow : {ts : _} -> String -> Either Error (Row ts)\n"
"decodeRow s = go 1 ts $ fromCSV s\n"
"  where go : Nat -> (cs : Schema) -> List String -> Either Error (Row cs)\n"
"        go k []       []         = Right []\n"
"        go k []       (_ :: _)   = Left $ ExpectedEOI k s\n"
"        go k (_ :: _) []         = Left $ UnexpectedEOI k s\n"
"        go k (c :: cs) (s :: ss) = [| decodeField k c s :: go (S k) cs ss |]\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1040
#, no-wrap
msgid ""
"There is no hard and fast rule about whether to pass an index as an\n"
"implicit argument or not. Some considerations:\n"
msgstr "关于是否将索引作为隐式参数传递没有硬性规定。一些考虑：\n"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid ""
"Pattern matching on explicit arguments comes with less syntactic overhead."
msgstr "显式参数的模式匹配具有较少的语法开销。"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid ""
"If an argument can be inferred from the context most of the time, consider "
"passing it as an implicit to make your function nicer to use in client code."
msgstr ""
"如果大多数时候可以从上下文中推断出参数，请考虑将其作为隐式传递，以使您的函数"
"更好地在客户端代码中使用。"

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid ""
"Use explicit (possibly erased) arguments for values that can't be inferred "
"by Idris most of the time."
msgstr "对于大多数时候 Idris 无法推断的值，请使用显式（可能已删除）参数。"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1052
#, no-wrap
msgid ""
"All that is missing now is a way to parse indices for accessing\n"
"the current table's rows. We use the conversion for indices to\n"
"start at one instead of zero, which feels more natural for most\n"
"non-programmers.\n"
msgstr "现在缺少的只是一种解析索引以访问当前表行的方法。我们使用索引的转换从 1 而不是 0 开始，这对于大多数非程序员来说感觉更自然。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1053
#, no-wrap
msgid ""
"readFin : {n : _} -> String -> Either Error (Fin n)\n"
"readFin s = do\n"
"  S k <- maybeToEither (NoNat s) $ parsePositive {a = Nat} s\n"
"    | Z => Left $ OutOfBounds n Z\n"
"  maybeToEither (OutOfBounds n $ S k) $ natToFin k n\n"
msgstr ""
"readFin : {n : _} -> String -> Either Error (Fin n)\n"
"readFin s = do\n"
"  S k <- maybeToEither (NoNat s) $ parsePositive {a = Nat} s\n"
"    | Z => Left $ OutOfBounds n Z\n"
"  maybeToEither (OutOfBounds n $ S k) $ natToFin k n\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1067
#, no-wrap
msgid ""
"We are finally able to implement a parser for user commands.\n"
"Function `Data.String.words` is used for splitting a string\n"
"at space characters. In most cases, we expect the name of\n"
"the command plus a single argument without additional spaces.\n"
"CSV rows can have additional space characters, however, so we\n"
"use `Data.String.unwords` on the split string.\n"
msgstr "我们终于能够为用户命令实现解析器。函数 `Data.String.words` 用于在空格字符处分割字符串。在大多数情况下，我们期望命令的名称加上一个没有额外空格的参数。但是，CSV 行可以有额外的空格字符，因此我们在拆分字符串上使用 `Data.String.unwords`。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1068
#, no-wrap
msgid ""
"readCommand :  (t : Table) -> String -> Either Error (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  _               => Left $ UnknownCommand s\n"
msgstr ""
"readCommand :  (t : Table) -> String -> Either Error (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  _               => Left $ UnknownCommand s\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:1081
#, no-wrap
msgid "Running the Application"
msgstr "运行应用程序"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1087
#, no-wrap
msgid ""
"All that's left to do is to write functions for\n"
"printing the results of commands to users and run\n"
"the application in a loop until command `\"quit\"`\n"
"is entered.\n"
msgstr "剩下要做的就是编写用于向用户打印命令结果的函数并循环运行应用程序，直到输入命令 `\"quit\"`。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1088
#, no-wrap
msgid ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (ts : List ColType) -> Row ts -> String\n"
"encodeRow ts = concat . intersperse \",\" . go ts\n"
"  where go : (cs : List ColType) -> Row cs -> Vect (length cs) String\n"
"        go []        []        = []\n"
"        go (c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize   = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)    = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r) = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)  = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit        = \"Goodbye.\"\n"
"result t (Get x)     =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (showError err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"
msgstr ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (ts : List ColType) -> Row ts -> String\n"
"encodeRow ts = concat . intersperse \",\" . go ts\n"
"  where go : (cs : List ColType) -> Row cs -> Vect (length cs) String\n"
"        go []        []        = []\n"
"        go (c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize   = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)    = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r) = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)  = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit        = \"Goodbye.\"\n"
"result t (Get x)     =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (showError err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1136
#, no-wrap
msgid ""
"The challenges presented here all deal with enhancing our\n"
"table editor in several interesting ways. Some of them are\n"
"more a matter of style and less a matter of learning to write\n"
"dependently typed programs, so feel free to solve these as you\n"
"please. Exercises 1 to 3 should be considered to be\n"
"mandatory.\n"
msgstr "这里提出的挑战都涉及以几种有趣的方式增强我们的表格编辑器。其中一些更多的是风格问题，而不是学习编写依赖类型程序的问题，所以请随意解决这些问题。练习 1 到 3 应该被认为是强制性的。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:1139
msgid "Add support for storing Idris types `Integer` and `Nat` in CSV columns"
msgstr "添加对在 CSV 列中存储 Idris 类型 `Integer` 和 `Nat` 的支持"

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:1142
msgid ""
"Add support for `Fin n` to CSV columns. Note: We need runtime access to `n` "
"in order for this to work."
msgstr ""
"添加对 `Fin n` 到 CSV 列的支持。注意：我们需要运行时访问 `n` 才能使其工作。"

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:1148
msgid ""
"Add support for optional types to CSV columns. Since missing values should "
"be encoded by empty strings, it makes no sense to allow for nested optional "
"types, meaning that types like `Maybe Nat` should be allowed while `Maybe "
"(Maybe Nat)` should not."
msgstr ""
"向 CSV 列添加对可选类型的支持。由于缺失值应该由空字符串编码，因此允许嵌套可选"
"类型没有意义，这意味着应该允许 `Maybe Nat` 等类型，而 `Maybe (Maybe Nat)` 不"
"被允许."

#. type: Plain text
#: ../src/Tutorial/DPair.md:1151
#, no-wrap
msgid ""
"   Hint: There are several ways to encode these, one being\n"
"   to add a boolean index to `ColType`.\n"
msgstr ""
"   提示：有几种编码方式，一种是\n"
"   为 `ColType` 添加一个布尔索引。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:1154
msgid ""
"Add a command for printing the whole table. Bonus points if all columns are "
"properly aligned."
msgstr "添加用于打印整个表格的命令。如果所有列都正确对齐，则加分。"

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:1158
msgid ""
"Add support for simple queries: Given a column number and a value, list all "
"rows where entries match the given value."
msgstr "添加对简单查询的支持：给定列号和值，列出条目与给定值匹配的所有行。"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1160
#, no-wrap
msgid "   This might be a challenge, as the types get pretty interesting.\n"
msgstr "   这可能是一个挑战，因为类型变得非常有趣。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:1164
msgid ""
"Add support for loading and saving tables from and to disk.  A table should "
"be stored in two files: One for the schema and one for the CSV content."
msgstr ""
"添加对从磁盘加载和保存表的支持。表应存储在两个文件中：一个用于模式，一个用于 "
"CSV 内容。"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1179
#, no-wrap
msgid ""
"   Note: Reading files in a provably total way can be pretty\n"
"   hard and will be a topic for another day. For now,\n"
"   just use function `readFile` exported from\n"
"   `System.File` in base for reading a file as a whole.\n"
"   This function is partial, because\n"
"   it will not terminate when used with an infinite input\n"
"   stream such as `/dev/urandom` or `/dev/zero`.\n"
"   It is important to *not* use `assert_total` here.\n"
"   Using partial functions like `readFile` might well impose\n"
"   a security risk in a real world application, so eventually,\n"
"   we'd have to deal with this and allow for some way to\n"
"   limit the size of accepted input. It is therefore best\n"
"   to make this partiality visible and annotate all downstream\n"
"   functions accordingly.\n"
msgstr ""
"   注意：以可证明的全部方式读取文件可能很困难，这将成为另一天的话题。目前，\n"
"   只需使用从 `System.File` 导出的函数 `readFile`\n"
"   用于读取整个文件。\n"
"   这是一个偏函数，因为\n"
"   与无限输入一起使用时不会终止\n"
"   流，例如 `/dev/urandom` 或 `/dev/zero`。\n"
"   重要的是 *不能* 在此处使用 `assert_total`。\n"
"   使用像 `readFile` 这样的部分函数可能会强加\n"
"   现实世界应用程序中的安全风险，所以最终，\n"
"   我们必须处理这个问题并允许某种方式\n"
"   限制接受输入的大小。因此最好\n"
"   使这种偏见可见并注释所有下游\n"
"   相应地函数。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1183
#, no-wrap
msgid ""
"You can find an implementation of these additions in the\n"
"solutions. A small example table can be found in folder\n"
"`resources`.\n"
msgstr "您可以在解决方案中找到这些添加的实现。可以在文件夹 `resources` 中找到一个小示例表。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1190
#, no-wrap
msgid ""
"Note: There are of course tons of projects to pursue from\n"
"here, such as writing a proper query language, calculating\n"
"new rows from existing ones, accumulating values in a\n"
"column, concatenating and zipping tables, and so on.\n"
"We will stop for now, probably coming back to this in\n"
"later examples.\n"
msgstr "注意：当然还有大量的项目要从这里开始，例如编写适当的查询语言、从现有行计算新行、在列中累积值、连接和压缩表等等。我们现在将停止，可能会在后面的示例中回到这一点。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1198
#, no-wrap
msgid ""
"Dependent pairs and records are necessary to at runtime\n"
"inspect the values defining the types we work with. By pattern\n"
"matching on these values, we learn about the types and\n"
"possible shapes of other values, allowing us to reduce\n"
"the number of potential bugs in our programs.\n"
msgstr "依赖对和记录对于在运行时检查定义我们使用的类型的值是必要的。通过对这些值进行模式匹配，我们可以了解其他值的类型和可能的形状，从而减少程序中潜在错误的数量。\n"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1204
#, no-wrap
msgid ""
"In the [next chapter](Eq.md) we start learning about how\n"
"to write data types, which we use as proofs that certain\n"
"contracts between values hold. These will eventually allow\n"
"us to define pre- and post conditions for our function\n"
"arguments and output types.\n"
msgstr "在[下一章](Eq.md)中，我们开始学习如何编写数据类型，我们将其用作值之间某些契约成立的证据。这些最终将允许我们为函数参数和输出类型定义前置和后置条件。\n"
