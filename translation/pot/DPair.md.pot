# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-08-02 23:16+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:16 ../src/Tutorial/DataTypes.md:25
#: ../src/Tutorial/DataTypes.md:60 ../src/Tutorial/DataTypes.md:112
#: ../src/Tutorial/DataTypes.md:130 ../src/Tutorial/DataTypes.md:152
#: ../src/Tutorial/DataTypes.md:163 ../src/Tutorial/DataTypes.md:184
#: ../src/Tutorial/DataTypes.md:215 ../src/Tutorial/DataTypes.md:253
#: ../src/Tutorial/DataTypes.md:283 ../src/Tutorial/DataTypes.md:327
#: ../src/Tutorial/DataTypes.md:348 ../src/Tutorial/DataTypes.md:359
#: ../src/Tutorial/DataTypes.md:378 ../src/Tutorial/DataTypes.md:408
#: ../src/Tutorial/DataTypes.md:415 ../src/Tutorial/DataTypes.md:441
#: ../src/Tutorial/DataTypes.md:449 ../src/Tutorial/DataTypes.md:482
#: ../src/Tutorial/DataTypes.md:505 ../src/Tutorial/DataTypes.md:518
#: ../src/Tutorial/DataTypes.md:546 ../src/Tutorial/DataTypes.md:559
#: ../src/Tutorial/DataTypes.md:587 ../src/Tutorial/DataTypes.md:598
#: ../src/Tutorial/DataTypes.md:617 ../src/Tutorial/DataTypes.md:628
#: ../src/Tutorial/DataTypes.md:638 ../src/Tutorial/DataTypes.md:654
#: ../src/Tutorial/DataTypes.md:667 ../src/Tutorial/DataTypes.md:681
#: ../src/Tutorial/DataTypes.md:693 ../src/Tutorial/DataTypes.md:701
#: ../src/Tutorial/DataTypes.md:716 ../src/Tutorial/DataTypes.md:729
#: ../src/Tutorial/DataTypes.md:804 ../src/Tutorial/DataTypes.md:828
#: ../src/Tutorial/DataTypes.md:861 ../src/Tutorial/DataTypes.md:897
#: ../src/Tutorial/DataTypes.md:908 ../src/Tutorial/DataTypes.md:942
#: ../src/Tutorial/DataTypes.md:957 ../src/Tutorial/DataTypes.md:967
#: ../src/Tutorial/DataTypes.md:992 ../src/Tutorial/DataTypes.md:1069
#: ../src/Tutorial/DataTypes.md:1081 ../src/Tutorial/DataTypes.md:1105
#: ../src/Tutorial/DataTypes.md:1143 ../src/Tutorial/DataTypes.md:1178
#: ../src/Tutorial/DataTypes.md:1208 ../src/Tutorial/DataTypes.md:1246
#: ../src/Tutorial/DataTypes.md:1269 ../src/Tutorial/DataTypes.md:1291
#: ../src/Tutorial/Dependent.md:10 ../src/Tutorial/Dependent.md:18
#: ../src/Tutorial/Dependent.md:42 ../src/Tutorial/Dependent.md:62
#: ../src/Tutorial/Dependent.md:70 ../src/Tutorial/Dependent.md:81
#: ../src/Tutorial/Dependent.md:111 ../src/Tutorial/Dependent.md:125
#: ../src/Tutorial/Dependent.md:136 ../src/Tutorial/Dependent.md:155
#: ../src/Tutorial/Dependent.md:174 ../src/Tutorial/Dependent.md:182
#: ../src/Tutorial/Dependent.md:227 ../src/Tutorial/Dependent.md:266
#: ../src/Tutorial/Dependent.md:278 ../src/Tutorial/Dependent.md:296
#: ../src/Tutorial/Dependent.md:388 ../src/Tutorial/Dependent.md:396
#: ../src/Tutorial/Dependent.md:404 ../src/Tutorial/Dependent.md:421
#: ../src/Tutorial/Dependent.md:429 ../src/Tutorial/Dependent.md:448
#: ../src/Tutorial/Dependent.md:465 ../src/Tutorial/Dependent.md:507
#: ../src/Tutorial/Dependent.md:517 ../src/Tutorial/Dependent.md:531
#: ../src/Tutorial/Dependent.md:564 ../src/Tutorial/Dependent.md:579
#: ../src/Tutorial/Dependent.md:600 ../src/Tutorial/Dependent.md:607
#: ../src/Tutorial/Dependent.md:617 ../src/Tutorial/Dependent.md:690
#: ../src/Tutorial/Dependent.md:705 ../src/Tutorial/Dependent.md:727
#: ../src/Tutorial/Dependent.md:748 ../src/Tutorial/Dependent.md:789
#: ../src/Tutorial/Dependent.md:797 ../src/Tutorial/Dependent.md:806
#: ../src/Tutorial/Dependent.md:820 ../src/Tutorial/Dependent.md:836
#: ../src/Tutorial/Dependent.md:846 ../src/Tutorial/DPair.md:19
#: ../src/Tutorial/DPair.md:47 ../src/Tutorial/DPair.md:76
#: ../src/Tutorial/DPair.md:93 ../src/Tutorial/DPair.md:116
#: ../src/Tutorial/DPair.md:132 ../src/Tutorial/DPair.md:148
#: ../src/Tutorial/DPair.md:165 ../src/Tutorial/DPair.md:174
#: ../src/Tutorial/DPair.md:203 ../src/Tutorial/DPair.md:216
#: ../src/Tutorial/DPair.md:226 ../src/Tutorial/DPair.md:243
#: ../src/Tutorial/DPair.md:255 ../src/Tutorial/DPair.md:266
#: ../src/Tutorial/DPair.md:285 ../src/Tutorial/DPair.md:298
#: ../src/Tutorial/DPair.md:307 ../src/Tutorial/DPair.md:315
#: ../src/Tutorial/DPair.md:327 ../src/Tutorial/DPair.md:339
#: ../src/Tutorial/DPair.md:373 ../src/Tutorial/DPair.md:405
#: ../src/Tutorial/DPair.md:416 ../src/Tutorial/DPair.md:428
#: ../src/Tutorial/DPair.md:459 ../src/Tutorial/DPair.md:481
#: ../src/Tutorial/DPair.md:498 ../src/Tutorial/DPair.md:513
#: ../src/Tutorial/DPair.md:532 ../src/Tutorial/DPair.md:545
#: ../src/Tutorial/DPair.md:555 ../src/Tutorial/DPair.md:584
#: ../src/Tutorial/DPair.md:631 ../src/Tutorial/DPair.md:781
#: ../src/Tutorial/DPair.md:792 ../src/Tutorial/DPair.md:808
#: ../src/Tutorial/DPair.md:824 ../src/Tutorial/DPair.md:840
#: ../src/Tutorial/DPair.md:911 ../src/Tutorial/DPair.md:930
#: ../src/Tutorial/DPair.md:991 ../src/Tutorial/DPair.md:1019
#: ../src/Tutorial/DPair.md:1053 ../src/Tutorial/DPair.md:1068
#: ../src/Tutorial/DPair.md:1088 ../src/Tutorial/Eq.md:10
#: ../src/Tutorial/Eq.md:27 ../src/Tutorial/Eq.md:56 ../src/Tutorial/Eq.md:115
#: ../src/Tutorial/Eq.md:129 ../src/Tutorial/Eq.md:135
#: ../src/Tutorial/Eq.md:144 ../src/Tutorial/Eq.md:173
#: ../src/Tutorial/Eq.md:181 ../src/Tutorial/Eq.md:204
#: ../src/Tutorial/Eq.md:222 ../src/Tutorial/Eq.md:254
#: ../src/Tutorial/Eq.md:316 ../src/Tutorial/Eq.md:337
#: ../src/Tutorial/Eq.md:347 ../src/Tutorial/Eq.md:358
#: ../src/Tutorial/Eq.md:374 ../src/Tutorial/Eq.md:388
#: ../src/Tutorial/Eq.md:423 ../src/Tutorial/Eq.md:454
#: ../src/Tutorial/Eq.md:495 ../src/Tutorial/Eq.md:531
#: ../src/Tutorial/Eq.md:544 ../src/Tutorial/Eq.md:577
#: ../src/Tutorial/Eq.md:587 ../src/Tutorial/Eq.md:618
#: ../src/Tutorial/Eq.md:634 ../src/Tutorial/Eq.md:643
#: ../src/Tutorial/Eq.md:652 ../src/Tutorial/Eq.md:668
#: ../src/Tutorial/Eq.md:711 ../src/Tutorial/Eq.md:753
#: ../src/Tutorial/Eq.md:798 ../src/Tutorial/Eq.md:810
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Eq.md:889
#: ../src/Tutorial/Eq.md:900 ../src/Tutorial/Eq.md:924
#: ../src/Tutorial/Eq.md:941 ../src/Tutorial/Eq.md:961
#: ../src/Tutorial/Eq.md:1002 ../src/Tutorial/Eq.md:1033
#: ../src/Tutorial/Eq.md:1074 ../src/Tutorial/Folds.md:23
#: ../src/Tutorial/Folds.md:51 ../src/Tutorial/Folds.md:64
#: ../src/Tutorial/Folds.md:74 ../src/Tutorial/Folds.md:89
#: ../src/Tutorial/Folds.md:104 ../src/Tutorial/Folds.md:118
#: ../src/Tutorial/Folds.md:134 ../src/Tutorial/Folds.md:188
#: ../src/Tutorial/Folds.md:205 ../src/Tutorial/Folds.md:216
#: ../src/Tutorial/Folds.md:230 ../src/Tutorial/Folds.md:254
#: ../src/Tutorial/Folds.md:282 ../src/Tutorial/Folds.md:303
#: ../src/Tutorial/Folds.md:320 ../src/Tutorial/Folds.md:384
#: ../src/Tutorial/Folds.md:393 ../src/Tutorial/Folds.md:400
#: ../src/Tutorial/Folds.md:406 ../src/Tutorial/Folds.md:429
#: ../src/Tutorial/Folds.md:438 ../src/Tutorial/Folds.md:446
#: ../src/Tutorial/Folds.md:452 ../src/Tutorial/Folds.md:458
#: ../src/Tutorial/Folds.md:465 ../src/Tutorial/Folds.md:495
#: ../src/Tutorial/Folds.md:521 ../src/Tutorial/Folds.md:544
#: ../src/Tutorial/Folds.md:609 ../src/Tutorial/Folds.md:621
#: ../src/Tutorial/Folds.md:638 ../src/Tutorial/Folds.md:656
#: ../src/Tutorial/Folds.md:720 ../src/Tutorial/Folds.md:737
#: ../src/Tutorial/Folds.md:766 ../src/Tutorial/Folds.md:847
#: ../src/Tutorial/Folds.md:869 ../src/Tutorial/Folds.md:892
#: ../src/Tutorial/Folds.md:935 ../src/Tutorial/Folds.md:951
#: ../src/Tutorial/Folds.md:996 ../src/Tutorial/Folds.md:1006
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/Folds.md:1040
#: ../src/Tutorial/Functions1.md:17 ../src/Tutorial/Functions1.md:29
#: ../src/Tutorial/Functions1.md:80 ../src/Tutorial/Functions1.md:96
#: ../src/Tutorial/Functions1.md:109 ../src/Tutorial/Functions1.md:127
#: ../src/Tutorial/Functions1.md:158 ../src/Tutorial/Functions1.md:178
#: ../src/Tutorial/Functions1.md:221 ../src/Tutorial/Functions1.md:246
#: ../src/Tutorial/Functions1.md:292 ../src/Tutorial/Functions1.md:349
#: ../src/Tutorial/Functions1.md:391 ../src/Tutorial/Functions1.md:472
#: ../src/Tutorial/Functions1.md:505 ../src/Tutorial/Functions2.md:16
#: ../src/Tutorial/Functions2.md:94 ../src/Tutorial/Functions2.md:164
#: ../src/Tutorial/Functions2.md:203 ../src/Tutorial/Functions2.md:220
#: ../src/Tutorial/Functions2.md:249 ../src/Tutorial/Functions2.md:277
#: ../src/Tutorial/Functions2.md:319 ../src/Tutorial/Functions2.md:372
#: ../src/Tutorial/Functions2.md:391 ../src/Tutorial/Functions2.md:408
#: ../src/Tutorial/Functions2.md:426 ../src/Tutorial/Functions2.md:440
#: ../src/Tutorial/Functions2.md:447 ../src/Tutorial/Functions2.md:455
#: ../src/Tutorial/Functions2.md:472 ../src/Tutorial/Functions2.md:510
#: ../src/Tutorial/Functions2.md:624 ../src/Tutorial/Functions2.md:634
#: ../src/Tutorial/Functions2.md:646 ../src/Tutorial/Functions2.md:659
#: ../src/Tutorial/Functions2.md:670 ../src/Tutorial/Functions2.md:707
#: ../src/Tutorial/Functions2.md:780 ../src/Tutorial/Functions2.md:869
#: ../src/Tutorial/Functions2.md:880 ../src/Tutorial/Functor.md:18
#: ../src/Tutorial/Functor.md:54 ../src/Tutorial/Functor.md:63
#: ../src/Tutorial/Functor.md:73 ../src/Tutorial/Functor.md:84
#: ../src/Tutorial/Functor.md:95 ../src/Tutorial/Functor.md:111
#: ../src/Tutorial/Functor.md:126 ../src/Tutorial/Functor.md:139
#: ../src/Tutorial/Functor.md:167 ../src/Tutorial/Functor.md:236
#: ../src/Tutorial/Functor.md:260 ../src/Tutorial/Functor.md:270
#: ../src/Tutorial/Functor.md:285 ../src/Tutorial/Functor.md:298
#: ../src/Tutorial/Functor.md:314 ../src/Tutorial/Functor.md:340
#: ../src/Tutorial/Functor.md:351 ../src/Tutorial/Functor.md:392
#: ../src/Tutorial/Functor.md:408 ../src/Tutorial/Functor.md:417
#: ../src/Tutorial/Functor.md:429 ../src/Tutorial/Functor.md:442
#: ../src/Tutorial/Functor.md:456 ../src/Tutorial/Functor.md:479
#: ../src/Tutorial/Functor.md:494 ../src/Tutorial/Functor.md:512
#: ../src/Tutorial/Functor.md:531 ../src/Tutorial/Functor.md:551
#: ../src/Tutorial/Functor.md:576 ../src/Tutorial/Functor.md:622
#: ../src/Tutorial/Functor.md:651 ../src/Tutorial/Functor.md:660
#: ../src/Tutorial/Functor.md:676 ../src/Tutorial/Functor.md:693
#: ../src/Tutorial/Functor.md:704 ../src/Tutorial/Functor.md:750
#: ../src/Tutorial/Functor.md:761 ../src/Tutorial/Functor.md:773
#: ../src/Tutorial/Functor.md:784 ../src/Tutorial/Functor.md:828
#: ../src/Tutorial/Functor.md:842 ../src/Tutorial/Functor.md:860
#: ../src/Tutorial/Functor.md:872 ../src/Tutorial/Functor.md:888
#: ../src/Tutorial/Functor.md:926 ../src/Tutorial/Functor.md:945
#: ../src/Tutorial/Functor.md:971 ../src/Tutorial/Functor.md:1082
#: ../src/Tutorial/Functor.md:1122 ../src/Tutorial/Functor.md:1135
#: ../src/Tutorial/Functor.md:1199 ../src/Tutorial/Functor.md:1257
#: ../src/Tutorial/Functor.md:1268 ../src/Tutorial/Functor.md:1278
#: ../src/Tutorial/Functor.md:1285 ../src/Tutorial/Interfaces.md:10
#: ../src/Tutorial/Interfaces.md:43 ../src/Tutorial/Interfaces.md:62
#: ../src/Tutorial/Interfaces.md:71 ../src/Tutorial/Interfaces.md:100
#: ../src/Tutorial/Interfaces.md:117 ../src/Tutorial/Interfaces.md:159
#: ../src/Tutorial/Interfaces.md:234 ../src/Tutorial/Interfaces.md:255
#: ../src/Tutorial/Interfaces.md:274 ../src/Tutorial/Interfaces.md:296
#: ../src/Tutorial/Interfaces.md:321 ../src/Tutorial/Interfaces.md:333
#: ../src/Tutorial/Interfaces.md:341 ../src/Tutorial/Interfaces.md:362
#: ../src/Tutorial/Interfaces.md:456 ../src/Tutorial/Interfaces.md:466
#: ../src/Tutorial/Interfaces.md:475 ../src/Tutorial/Interfaces.md:498
#: ../src/Tutorial/Interfaces.md:534 ../src/Tutorial/Interfaces.md:552
#: ../src/Tutorial/Interfaces.md:561 ../src/Tutorial/Interfaces.md:650
#: ../src/Tutorial/Interfaces.md:661 ../src/Tutorial/Interfaces.md:677
#: ../src/Tutorial/Interfaces.md:695 ../src/Tutorial/Interfaces.md:716
#: ../src/Tutorial/Interfaces.md:727 ../src/Tutorial/Intro.md:20
#: ../src/Tutorial/Intro.md:191 ../src/Tutorial/Intro.md:252
#: ../src/Tutorial/Intro.md:287 ../src/Tutorial/Intro.md:312
#: ../src/Tutorial/IO.md:8 ../src/Tutorial/IO.md:25 ../src/Tutorial/IO.md:84
#: ../src/Tutorial/IO.md:121 ../src/Tutorial/IO.md:217
#: ../src/Tutorial/IO.md:232 ../src/Tutorial/IO.md:240
#: ../src/Tutorial/IO.md:255 ../src/Tutorial/IO.md:299
#: ../src/Tutorial/IO.md:334 ../src/Tutorial/IO.md:342
#: ../src/Tutorial/IO.md:352 ../src/Tutorial/IO.md:374
#: ../src/Tutorial/IO.md:405 ../src/Tutorial/IO.md:417
#: ../src/Tutorial/IO.md:472 ../src/Tutorial/IO.md:493
#: ../src/Tutorial/IO.md:506 ../src/Tutorial/IO.md:517
#: ../src/Tutorial/IO.md:528 ../src/Tutorial/IO.md:563
#: ../src/Tutorial/IO.md:581 ../src/Tutorial/IO.md:650
#: ../src/Tutorial/IO.md:689 ../src/Tutorial/IO.md:696
#: ../src/Tutorial/IO.md:705 ../src/Tutorial/IO.md:713
#: ../src/Tutorial/IO.md:734 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/IO.md:875 ../src/Tutorial/IO.md:920
#: ../src/Tutorial/IO.md:960 ../src/Tutorial/IO.md:984
#: ../src/Tutorial/IO.md:997 ../src/Tutorial/Predicates.md:13
#: ../src/Tutorial/Predicates.md:108 ../src/Tutorial/Predicates.md:118
#: ../src/Tutorial/Predicates.md:139 ../src/Tutorial/Predicates.md:153
#: ../src/Tutorial/Predicates.md:165 ../src/Tutorial/Predicates.md:191
#: ../src/Tutorial/Predicates.md:203 ../src/Tutorial/Predicates.md:212
#: ../src/Tutorial/Predicates.md:224 ../src/Tutorial/Predicates.md:235
#: ../src/Tutorial/Predicates.md:252 ../src/Tutorial/Predicates.md:259
#: ../src/Tutorial/Predicates.md:277 ../src/Tutorial/Predicates.md:288
#: ../src/Tutorial/Predicates.md:352 ../src/Tutorial/Predicates.md:359
#: ../src/Tutorial/Predicates.md:368 ../src/Tutorial/Predicates.md:387
#: ../src/Tutorial/Predicates.md:406 ../src/Tutorial/Predicates.md:416
#: ../src/Tutorial/Predicates.md:447 ../src/Tutorial/Predicates.md:475
#: ../src/Tutorial/Predicates.md:493 ../src/Tutorial/Predicates.md:532
#: ../src/Tutorial/Predicates.md:550 ../src/Tutorial/Predicates.md:568
#: ../src/Tutorial/Predicates.md:603 ../src/Tutorial/Predicates.md:620
#: ../src/Tutorial/Predicates.md:639 ../src/Tutorial/Predicates.md:658
#: ../src/Tutorial/Predicates.md:719 ../src/Tutorial/Predicates.md:747
#: ../src/Tutorial/Predicates.md:768 ../src/Tutorial/Predicates.md:784
#: ../src/Tutorial/Predicates.md:798 ../src/Tutorial/Predicates.md:812
#: ../src/Tutorial/Predicates.md:821 ../src/Tutorial/Predicates.md:835
#: ../src/Tutorial/Predicates.md:850 ../src/Tutorial/Predicates.md:862
#: ../src/Tutorial/Predicates.md:872 ../src/Tutorial/Predicates.md:951
#: ../src/Tutorial/Predicates.md:963 ../src/Tutorial/Predicates.md:983
#: ../src/Tutorial/Predicates.md:999 ../src/Tutorial/Predicates.md:1024
#: ../src/Tutorial/Predicates.md:1035 ../src/Tutorial/Predicates.md:1044
#: ../src/Tutorial/Predicates.md:1066 ../src/Tutorial/Predicates.md:1080
#: ../src/Tutorial/Predicates.md:1094 ../src/Tutorial/Predicates.md:1105
#: ../src/Tutorial/Predicates.md:1113 ../src/Tutorial/Predicates.md:1121
#: ../src/Tutorial/Predicates.md:1134 ../src/Tutorial/Predicates.md:1163
#: ../src/Tutorial/Predicates.md:1199 ../src/Tutorial/Predicates.md:1236
#: ../src/Tutorial/Predicates.md:1287 ../src/Tutorial/Prim.md:8
#: ../src/Tutorial/Prim.md:164 ../src/Tutorial/Prim.md:175
#: ../src/Tutorial/Prim.md:190 ../src/Tutorial/Prim.md:201
#: ../src/Tutorial/Prim.md:210 ../src/Tutorial/Prim.md:218
#: ../src/Tutorial/Prim.md:232 ../src/Tutorial/Prim.md:246
#: ../src/Tutorial/Prim.md:263 ../src/Tutorial/Prim.md:271
#: ../src/Tutorial/Prim.md:324 ../src/Tutorial/Prim.md:346
#: ../src/Tutorial/Prim.md:357 ../src/Tutorial/Prim.md:389
#: ../src/Tutorial/Prim.md:399 ../src/Tutorial/Prim.md:412
#: ../src/Tutorial/Prim.md:425 ../src/Tutorial/Prim.md:672
#: ../src/Tutorial/Prim.md:684 ../src/Tutorial/Prim.md:757
#: ../src/Tutorial/Prim.md:768 ../src/Tutorial/Prim.md:780
#: ../src/Tutorial/Prim.md:801 ../src/Tutorial/Prim.md:809
#: ../src/Tutorial/Prim.md:818 ../src/Tutorial/Prim.md:840
#: ../src/Tutorial/Prim.md:892 ../src/Tutorial/Prim.md:911
#: ../src/Tutorial/Prim.md:926 ../src/Tutorial/Prim.md:984
#: ../src/Tutorial/Prim.md:1026 ../src/Tutorial/Prim.md:1046
#: ../src/Tutorial/Prim.md:1064 ../src/Tutorial/Prim.md:1073
#: ../src/Tutorial/Prim.md:1087 ../src/Tutorial/Prim.md:1101
#: ../src/Tutorial/Prim.md:1118 ../src/Tutorial/Prim.md:1176
#: ../src/Tutorial/Prim.md:1208 ../src/Tutorial/Traverse.md:17
#: ../src/Tutorial/Traverse.md:52 ../src/Tutorial/Traverse.md:62
#: ../src/Tutorial/Traverse.md:82 ../src/Tutorial/Traverse.md:105
#: ../src/Tutorial/Traverse.md:140 ../src/Tutorial/Traverse.md:173
#: ../src/Tutorial/Traverse.md:183 ../src/Tutorial/Traverse.md:194
#: ../src/Tutorial/Traverse.md:203 ../src/Tutorial/Traverse.md:267
#: ../src/Tutorial/Traverse.md:276 ../src/Tutorial/Traverse.md:285
#: ../src/Tutorial/Traverse.md:295 ../src/Tutorial/Traverse.md:308
#: ../src/Tutorial/Traverse.md:325 ../src/Tutorial/Traverse.md:332
#: ../src/Tutorial/Traverse.md:370 ../src/Tutorial/Traverse.md:388
#: ../src/Tutorial/Traverse.md:398 ../src/Tutorial/Traverse.md:406
#: ../src/Tutorial/Traverse.md:414 ../src/Tutorial/Traverse.md:463
#: ../src/Tutorial/Traverse.md:471 ../src/Tutorial/Traverse.md:489
#: ../src/Tutorial/Traverse.md:497 ../src/Tutorial/Traverse.md:506
#: ../src/Tutorial/Traverse.md:514 ../src/Tutorial/Traverse.md:525
#: ../src/Tutorial/Traverse.md:543 ../src/Tutorial/Traverse.md:591
#: ../src/Tutorial/Traverse.md:605 ../src/Tutorial/Traverse.md:771
#: ../src/Tutorial/Traverse.md:831 ../src/Tutorial/Traverse.md:852
#: ../src/Tutorial/Traverse.md:867 ../src/Tutorial/Traverse.md:899
#: ../src/Tutorial/Traverse.md:909 ../src/Tutorial/Traverse.md:929
#: ../src/Tutorial/Traverse.md:939 ../src/Tutorial/Traverse.md:975
#: ../src/Tutorial/Traverse.md:1030 ../src/Tutorial/Traverse.md:1056
#: ../src/Tutorial/Traverse.md:1067 ../src/Tutorial/Traverse.md:1077
#: ../src/Tutorial/Traverse.md:1095
#, no-wrap
msgid "idris"
msgstr ""

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:39 ../src/Tutorial/DataTypes.md:234
#: ../src/Tutorial/DataTypes.md:241 ../src/Tutorial/DataTypes.md:310
#: ../src/Tutorial/DataTypes.md:337 ../src/Tutorial/DataTypes.md:390
#: ../src/Tutorial/DataTypes.md:427 ../src/Tutorial/DataTypes.md:494
#: ../src/Tutorial/DataTypes.md:646 ../src/Tutorial/DataTypes.md:840
#: ../src/Tutorial/DataTypes.md:1009 ../src/Tutorial/DataTypes.md:1016
#: ../src/Tutorial/DataTypes.md:1024 ../src/Tutorial/DataTypes.md:1031
#: ../src/Tutorial/DataTypes.md:1038 ../src/Tutorial/DataTypes.md:1045
#: ../src/Tutorial/Dependent.md:197 ../src/Tutorial/Dependent.md:204
#: ../src/Tutorial/Dependent.md:239 ../src/Tutorial/Dependent.md:245
#: ../src/Tutorial/Dependent.md:309 ../src/Tutorial/Dependent.md:346
#: ../src/Tutorial/Dependent.md:364 ../src/Tutorial/Dependent.md:631
#: ../src/Tutorial/Dependent.md:866 ../src/Tutorial/DPair.md:66
#: ../src/Tutorial/DPair.md:234 ../src/Tutorial/DPair.md:713
#: ../src/Tutorial/Eq.md:74 ../src/Tutorial/Eq.md:93 ../src/Tutorial/Eq.md:153
#: ../src/Tutorial/Eq.md:397 ../src/Tutorial/Eq.md:404
#: ../src/Tutorial/Eq.md:436 ../src/Tutorial/Eq.md:505
#: ../src/Tutorial/Eq.md:518 ../src/Tutorial/Eq.md:679
#: ../src/Tutorial/Eq.md:778 ../src/Tutorial/Eq.md:984
#: ../src/Tutorial/Eq.md:1014 ../src/Tutorial/Folds.md:198
#: ../src/Tutorial/Folds.md:787 ../src/Tutorial/Folds.md:798
#: ../src/Tutorial/Folds.md:822 ../src/Tutorial/Folds.md:839
#: ../src/Tutorial/Folds.md:880 ../src/Tutorial/Folds.md:904
#: ../src/Tutorial/Functions1.md:37 ../src/Tutorial/Functions1.md:143
#: ../src/Tutorial/Functions1.md:165 ../src/Tutorial/Functions1.md:204
#: ../src/Tutorial/Functions1.md:228 ../src/Tutorial/Functions1.md:253
#: ../src/Tutorial/Functions1.md:261 ../src/Tutorial/Functions1.md:312
#: ../src/Tutorial/Functions1.md:333 ../src/Tutorial/Functions1.md:358
#: ../src/Tutorial/Functions1.md:366 ../src/Tutorial/Functions1.md:378
#: ../src/Tutorial/Functions1.md:488 ../src/Tutorial/Functions1.md:519
#: ../src/Tutorial/Functions1.md:568 ../src/Tutorial/Functions2.md:42
#: ../src/Tutorial/Functions2.md:63 ../src/Tutorial/Functions2.md:74
#: ../src/Tutorial/Functions2.md:114 ../src/Tutorial/Functions2.md:528
#: ../src/Tutorial/Functions2.md:541 ../src/Tutorial/Functions2.md:553
#: ../src/Tutorial/Functions2.md:560 ../src/Tutorial/Functions2.md:567
#: ../src/Tutorial/Functions2.md:719 ../src/Tutorial/Functions2.md:726
#: ../src/Tutorial/Functions2.md:735 ../src/Tutorial/Functions2.md:755
#: ../src/Tutorial/Functions2.md:763 ../src/Tutorial/Functions2.md:787
#: ../src/Tutorial/Functions2.md:811 ../src/Tutorial/Functions2.md:819
#: ../src/Tutorial/Functions2.md:835 ../src/Tutorial/Functions2.md:848
#: ../src/Tutorial/Functions2.md:899 ../src/Tutorial/Functor.md:187
#: ../src/Tutorial/Functor.md:201 ../src/Tutorial/Functor.md:216
#: ../src/Tutorial/Functor.md:610 ../src/Tutorial/Functor.md:801
#: ../src/Tutorial/Functor.md:903 ../src/Tutorial/Functor.md:1001
#: ../src/Tutorial/Functor.md:1100 ../src/Tutorial/Functor.md:1167
#: ../src/Tutorial/Functor.md:1219 ../src/Tutorial/Interfaces.md:36
#: ../src/Tutorial/Interfaces.md:140 ../src/Tutorial/Interfaces.md:505
#: ../src/Tutorial/Intro.md:122 ../src/Tutorial/Intro.md:134
#: ../src/Tutorial/Intro.md:148 ../src/Tutorial/Intro.md:158
#: ../src/Tutorial/Intro.md:167 ../src/Tutorial/Intro.md:227
#: ../src/Tutorial/Intro.md:270 ../src/Tutorial/Intro.md:279
#: ../src/Tutorial/Intro.md:300 ../src/Tutorial/Intro.md:326
#: ../src/Tutorial/Intro.md:337 ../src/Tutorial/Intro.md:349
#: ../src/Tutorial/IO.md:33 ../src/Tutorial/IO.md:94 ../src/Tutorial/IO.md:433
#: ../src/Tutorial/IO.md:442 ../src/Tutorial/IO.md:539
#: ../src/Tutorial/IO.md:621 ../src/Tutorial/IO.md:634
#: ../src/Tutorial/IO.md:1020 ../src/Tutorial/IO.md:1040
#: ../src/Tutorial/IO.md:1050 ../src/Tutorial/IO.md:1060
#: ../src/Tutorial/Predicates.md:428 ../src/Tutorial/Predicates.md:462
#: ../src/Tutorial/Predicates.md:926 ../src/Tutorial/Predicates.md:1337
#: ../src/Tutorial/Prim.md:124 ../src/Tutorial/Prim.md:312
#: ../src/Tutorial/Prim.md:527 ../src/Tutorial/Prim.md:550
#: ../src/Tutorial/Prim.md:574 ../src/Tutorial/Prim.md:584
#: ../src/Tutorial/Prim.md:596 ../src/Tutorial/Prim.md:611
#: ../src/Tutorial/Prim.md:622 ../src/Tutorial/Prim.md:638
#: ../src/Tutorial/Prim.md:647 ../src/Tutorial/Prim.md:703
#: ../src/Tutorial/Prim.md:1129 ../src/Tutorial/Traverse.md:38
#: ../src/Tutorial/Traverse.md:123 ../src/Tutorial/Traverse.md:158
#: ../src/Tutorial/Traverse.md:421 ../src/Tutorial/Traverse.md:737
#: ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid "repl"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:622
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:962
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:712
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:842
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1232
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:936
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:871
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1395
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:909
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1098
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Predicates.md:1369 ../src/Tutorial/Prim.md:1411
#: ../src/Tutorial/Traverse.md:1148
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2\n"
"-->\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/DPair.md:1
#, no-wrap
msgid "Sigma Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:18
msgid ""
"So far in our examples of dependently typed programming, type indices such "
"as the length of vectors were known at compile time or could be calculated "
"from values known at compile time. In real applications, however, such "
"information is often not available until runtime, where values depend on the "
"decisions made by users or the state of the surrounding world.  For "
"instance, if we store a file's content as a vector of lines of text, the "
"length of this vector is in general unknown until the file has been loaded "
"into memory.  As a consequence, the types of values we work with depend on "
"other values only known at runtime, and we can often only figure out these "
"types by pattern matching on the values they depend on.  To express these "
"dependencies, we need so called [*sigma types*](https://en.wikipedia.org/"
"wiki/Dependent_type#%CE%A3_type): Dependent pairs and their generalization, "
"dependent records."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:19
#, no-wrap
msgid ""
"module Tutorial.DPair\n"
"\n"
"import Control.Monad.State\n"
"\n"
"import Data.DPair\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.List\n"
"import Data.List1\n"
"import Data.Singleton\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import Text.CSV\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:38
#, no-wrap
msgid "Dependent Pairs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:46
msgid ""
"We've already seen several examples of how useful the length index of a "
"vector is to describe more precisely in the types what a function can and "
"can't do. For instance, `map` or `traverse` operating on a vector will "
"return a vector of exactly the same length. The types guarantee that this is "
"true, therefore the following function is perfectly safe and provably total:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:47
#, no-wrap
msgid ""
"parseAndDrop : Vect (3 + n) String -> Maybe (Vect n Nat)\n"
"parseAndDrop = map (drop 3) . traverse parsePositive\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:60
msgid ""
"Since the argument of `traverse parsePositive` is of type `Vect (3 + n) "
"String`, its result will be of type `Maybe (Vect (3 + n) Nat)`. It is "
"therefore safe to use this in a call to `drop 3`. Note, how all of this is "
"known at compile time: We encoded the prerequisite that the first argument "
"is a vector of at least three elements in the length index and could derive "
"the length of the result from this."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:61
#, no-wrap
msgid "Vectors of Unknown Length"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:65
msgid ""
"However, this is not always possible. Consider the following function, "
"defined on `List` and exported by `Data.List`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:66
#, no-wrap
msgid ""
"Tutorial.Relations> :t takeWhile\n"
"Data.List.takeWhile : (a -> Bool) -> List a -> List a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:75
msgid ""
"This will take the longest prefix of the list argument, for which the given "
"predicate returns `True`. In this case, it depends on the list elements and "
"the predicate, how long this prefix will be.  Can we write such a function "
"for vectors? Let's give it a try:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:76
#, no-wrap
msgid "takeWhile' : (a -> Bool) -> Vect n a -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:92
msgid ""
"Go ahead, and try to implement this. Don't try too long, as you will not be "
"able to do so in a provably total way. The question is: What is the problem "
"here? In order to understand this, we have to realize what the type of "
"`takeWhile'` promises: \"For all predicates operating on values on type `a`, "
"and for all vectors holding values of this type, and for all lengths `m`, I "
"give you a vector of length `m` holding values of type `a`\".  All three "
"arguments are said to be [*universally quantified*](https://en.wikipedia.org/"
"wiki/Universal_quantification): The caller of our function is free to choose "
"the predicate, the input vector, the type of values the vector holds, and "
"*the length of the output vector*. Don't believe me? See here:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:93
#, no-wrap
msgid ""
"-- This looks like trouble: We got a non-empty vector of `Void`...\n"
"voids : Vect 7 Void\n"
"voids = takeWhile' (const True) []\n"
"\n"
"-- ...from which immediately follows a proof of `Void`\n"
"proofOfVoid : Void\n"
"proofOfVoid = head voids\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:108
msgid ""
"See how I could freely decide on the value of `m` when invoking "
"`takeWhile'`? Although I passed `takeWhile'` an empty vector (the only "
"existing vector holding values of type `Void`), the function's type promises "
"me to return a possibly non-empty vector holding values of the same type, "
"from which I freely extracted the first one."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:115
msgid ""
"Luckily, Idris doesn't allow this: We won't be able to implement "
"`takeWhile'` without cheating (for instance, by turning totality checking "
"off and looping forever).  So, the question remains, how to express the "
"result of `takeWhile'` in a type. The answer to this is: \"Use a *dependent "
"pair*\", a vector paired with a value corresponding to its length."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:116
#, no-wrap
msgid ""
"record AnyVect a where\n"
"  constructor MkAnyVect\n"
"  length : Nat\n"
"  vect   : Vect length a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:131
msgid ""
"This corresponds to [*existential quantification*](https://en.wikipedia.org/"
"wiki/Existential_quantification)  in predicate logic: There is a natural "
"number, which corresponds to the length of the vector I have here. Note, how "
"from the outside of `AnyVect a`, the length of the wrapped vector is no "
"longer visible at the type level but we can still inspect it and learn "
"something about it at runtime, since it is wrapped up together with the "
"actual vector. We can implement `takeWhile` in such a way that it returns a "
"value of type `AnyVect a`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:132
#, no-wrap
msgid ""
"takeWhile : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile f []        = MkAnyVect 0 []\n"
"takeWhile f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect n ys = takeWhile f xs in MkAnyVect (S n) (x :: ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:147
msgid ""
"This works in a provably total way, because callers of this function can no "
"longer choose the length of the resulting vector themselves. Our function, "
"`takeWhile`, decides on this length and returns it together with the vector, "
"and the type checker verifies that we make no mistakes when pairing the two "
"values. In fact, the length can be inferred automatically by Idris, so we "
"can replace it with underscores, if we so desire:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:148
#, no-wrap
msgid ""
"takeWhile2 : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile2 f []        = MkAnyVect _ []\n"
"takeWhile2 f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect _ ys = takeWhile2 f xs in MkAnyVect _ (x :: ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:161
msgid ""
"To summarize: Parameters in generic function types are universally "
"quantified, and their values can be decided on at the call site of such "
"functions. Dependent record types allow us to describe existentially "
"quantified values. Callers cannot choose such values freely: They are "
"returned as part of a function's result."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:164
msgid ""
"Note, that Idris allows us to be explicit about universal quantification.  "
"The type of `takeWhile'` can also be written like so:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:165
#, no-wrap
msgid "takeWhile'' : forall a, n, m . (a -> Bool) -> Vect n a -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:173
msgid ""
"Universally quantified arguments are desugared to implicit erased arguments "
"by Idris. The above is a less verbose version of the following function "
"type, the likes of which we have seen before:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:174
#, no-wrap
msgid ""
"takeWhile''' :  {0 a : _}\n"
"             -> {0 n : _}\n"
"             -> {0 m : _}\n"
"             -> (a -> Bool)\n"
"             -> Vect n a\n"
"             -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:189
msgid ""
"In Idris, we are free to choose whether we want to be explicit about "
"universal quantification. Sometimes it can help understanding what's going "
"on at the type level. Other languages - for instance [PureScript](https://"
"www.purescript.org/) - are more strict about this: There, explicit "
"annotations on universally quantified parameters are [mandatory](https://"
"github.com/purescript/documentation/blob/master/language/Differences-from-"
"Haskell.md#explicit-forall)."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:190
#, no-wrap
msgid "The Essence of Dependent Pairs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:202
msgid ""
"It can take some time and experience to understand what's going on here. At "
"least in my case, it took many sessions programming in Idris, before I "
"figured out what dependent pairs are about: They pair a *value* of some type "
"with a second value of a type calculated from the first value.  For "
"instance, a natural number `n` (the value)  paired with a vector of length "
"`n` (the second value, the type of which *depends* on the first value).  "
"This is such a fundamental concept of programming with dependent types, that "
"a general dependent pair type is provided by the *Prelude*. Here is its "
"implementation (primed for disambiguation):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:203
#, no-wrap
msgid ""
"record DPair' (a : Type) (p : a -> Type) where\n"
"  constructor MkDPair'\n"
"  fst : a\n"
"  snd : p fst\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:215
msgid ""
"It is essential to understand what's going on here. There are two "
"parameters: A type `a`, and a function `p`, calculating a *type* from a "
"*value* of type `a`. Such a value (`fst`) is then used to calculate the "
"*type* of the second value (`snd`).  For instance, here is `AnyVect a` "
"represented as a `DPair`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:216
#, no-wrap
msgid ""
"AnyVect' : (a : Type) -> Type\n"
"AnyVect' a = DPair Nat (\\n => Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:225
#, no-wrap
msgid ""
"Note, how `\\n => Vect n a` is a function from `Nat` to `Type`.\n"
"Idris provides special syntax for describing dependent pairs, as\n"
"they are important building blocks for programming in languages\n"
"with first class types:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:226
#, no-wrap
msgid ""
"AnyVect'' : (a : Type) -> Type\n"
"AnyVect'' a = (n : Nat ** Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:233
msgid ""
"We can inspect at the REPL, that the right hand side of `AnyVect''` get's "
"desugared to the right hand side of `AnyVect'`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:234
#, no-wrap
msgid ""
"Tutorial.Relations> (n : Nat ** Vect n Int)\n"
"DPair Nat (\\n => Vect n Int)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:242
msgid ""
"Idris can infer, that `n` must be of type `Nat`, so we can drop this "
"information. (We still need to put the whole expression in parentheses.)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:243
#, no-wrap
msgid ""
"AnyVect3 : (a : Type) -> Type\n"
"AnyVect3 a = (n ** Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:254
msgid ""
"This allows us to pair a natural number `n` with a vector of length `n`, "
"which is exactly what we did with `AnyVect`. We can therefore rewrite "
"`takeWhile` to return a `DPair` instead of our custom type `AnyVect`. Note, "
"that like with regular pairs, we can use the same syntax `(x ** y)` for "
"creating and pattern matching on dependent pairs:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:255
#, no-wrap
msgid ""
"takeWhile3 : (a -> Bool) -> Vect m a -> (n ** Vect n a)\n"
"takeWhile3 f []        = (_ ** [])\n"
"takeWhile3 f (x :: xs) = case f x of\n"
"  False => (_ ** [])\n"
"  True  => let (_  ** ys) = takeWhile3 f xs in (_ ** x :: ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:265
msgid ""
"Just like with regular pairs, we can use the dependent pair syntax to define "
"dependent triples and larger tuples:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:266
#, no-wrap
msgid ""
"AnyMatrix : (a : Type) -> Type\n"
"AnyMatrix a = (m ** n ** Vect m (Vect n a))\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:271
#, no-wrap
msgid "Erased Existentials"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:281
msgid ""
"Sometimes, it is possible to determine the value of an index by pattern "
"matching on a value of the indexed type.  For instance, by pattern matching "
"on a vector, we can learn about its length index. In these cases, it is not "
"strictly necessary to carry around the index at runtime, and we can write a "
"special version of a dependent pair where the first argument has quantity "
"zero. Module `Data.DPair` from *base* exports data type `Exists` for this "
"use case."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:284
msgid ""
"As an example, here is a version of `takeWhile` returning a value of type "
"`Exists`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:285
#, no-wrap
msgid ""
"takeWhileExists : (a -> Bool) -> Vect m a -> Exists (\\n => Vect n a)\n"
"takeWhileExists f []        = Evidence _ []\n"
"takeWhileExists f (x :: xs) = case f x of\n"
"  True  => let Evidence _ ys = takeWhileExists f xs\n"
"            in Evidence _ (x :: ys)\n"
"  False => takeWhileExists f xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:297
msgid ""
"In order to restore an erased value, data type `Singleton` from *base* "
"module `Data.Singleton` can be useful: It is parameterized by the *value* it "
"stores:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:298
#, no-wrap
msgid ""
"true : Singleton True\n"
"true = Val True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:306
msgid ""
"This is called a *singleton* type: A type corresponding to exactly one "
"value. It is a type error to return any other value for constant `true`, and "
"Idris knows this:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:307
#, no-wrap
msgid ""
"true' : Singleton True\n"
"true' = Val _\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:314
msgid ""
"We can use this to conjure the (erased!) length of a vector out of thin air:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:315
#, no-wrap
msgid ""
"vectLength : Vect n a -> Singleton n\n"
"vectLength []        = Val 0\n"
"vectLength (x :: xs) = let Val k = vectLength xs in Val (S k)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:326
msgid ""
"This function comes with much stronger guarantees than `Data.Vect.length`: "
"The latter claims to just return *any* natural number, while `vectLength` "
"*must* return exactly `n` in order to type check. As a demonstration, here "
"is a well-typed bogus implementation of `length`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:327
#, no-wrap
msgid ""
"bogusLength : Vect n a -> Nat\n"
"bogusLength = const 0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:334
msgid ""
"This would not be accepted as a valid implementation of `vectLength`, as you "
"may quickly verify yourself."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:338
msgid ""
"With the help of `vectLength` (but not with `Data.Vect.length`)  we can "
"convert an erased existential to a proper dependent pair:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:339
#, no-wrap
msgid ""
"toDPair : Exists (\\n => Vect n a) -> (m ** Vect m a)\n"
"toDPair (Evidence _ as) = let Val m = vectLength as in (m ** as)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:347
msgid ""
"Again, as a quick exercise, try implementing `toDPair` in terms of `length`, "
"and note how Idris will fail to unify the result of `length` with the actual "
"length of the vector."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:352
msgid ""
"Declare and implement a function for filtering a vector similar to `Data."
"List.filter`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:356
msgid ""
"Declare and implement a function for mapping a partial function over the "
"values of a vector similar to `Data.List.mapMaybe`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:360
msgid ""
"Declare and implement a function similar to `Data.List.dropWhile` for "
"vectors. Use `Data.DPair.Exists` as your return type."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:363
msgid ""
"Repeat exercise 3 but return a proper dependent pair. Use the function from "
"exercise 3 in your implementation."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:364
#, no-wrap
msgid "Use Case: Nucleic Acids"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:372
msgid ""
"We'd like to come up with a small, simplified library for running "
"computations on nucleic acids: RNA and DNA. These are built from five types "
"of nucleobases, three of which are used in both types of nucleic acids and "
"two bases specific for each type of acid. We'd like to make sure that only "
"valid bases are in strands of nucleic acids.  Here's a possible encoding:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:373
#, no-wrap
msgid ""
"data BaseType = DNABase | RNABase\n"
"\n"
"data Nucleobase : BaseType -> Type where\n"
"  Adenine  : Nucleobase b\n"
"  Cytosine : Nucleobase b\n"
"  Guanine  : Nucleobase b\n"
"  Thymine  : Nucleobase DNABase\n"
"  Uracile  : Nucleobase RNABase\n"
"\n"
"NucleicAcid : BaseType -> Type\n"
"NucleicAcid = List . Nucleobase\n"
"\n"
"RNA : Type\n"
"RNA = NucleicAcid RNABase\n"
"\n"
"DNA : Type\n"
"DNA = NucleicAcid DNABase\n"
"\n"
"encodeBase : Nucleobase b -> Char\n"
"encodeBase Adenine  = 'A'\n"
"encodeBase Cytosine = 'C'\n"
"encodeBase Guanine  = 'G'\n"
"encodeBase Thymine  = 'T'\n"
"encodeBase Uracile  = 'U'\n"
"\n"
"encode : NucleicAcid b -> String\n"
"encode = pack . map encodeBase\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:404
msgid "It is a type error to use `Uracile` in a strand of DNA:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:405
#, no-wrap
msgid ""
"failing \"Mismatch between: RNABase and DNABase.\"\n"
"  errDNA : DNA\n"
"  errDNA = [Uracile, Adenine]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:415
msgid ""
"Note, how we used a variable for nucleobases `Adenine`, `Cytosine`, and "
"`Guanine`: These are again universally quantified, and client code is free "
"to choose a value here. This allows us to use these bases in strands of DNA "
"*and* RNA:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:416
#, no-wrap
msgid ""
"dna1 : DNA\n"
"dna1 = [Adenine, Cytosine, Guanine]\n"
"\n"
"rna1 : RNA\n"
"rna1 = [Adenine, Cytosine, Guanine]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:427
msgid ""
"With `Thymine` and `Uracile`, we are more restrictive: `Thymine` is only "
"allowed in DNA, while `Uracile` is restricted to be used in RNA strands.  "
"Let's write parsers for strands of DNA and RNA:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:428
#, no-wrap
msgid ""
"readAnyBase : Char -> Maybe (Nucleobase b)\n"
"readAnyBase 'A' = Just Adenine\n"
"readAnyBase 'C' = Just Cytosine\n"
"readAnyBase 'G' = Just Guanine\n"
"readAnyBase _   = Nothing\n"
"\n"
"readRNABase : Char -> Maybe (Nucleobase RNABase)\n"
"readRNABase 'U' = Just Uracile\n"
"readRNABase c   = readAnyBase c\n"
"\n"
"readDNABase : Char -> Maybe (Nucleobase DNABase)\n"
"readDNABase 'T' = Just Thymine\n"
"readDNABase c   = readAnyBase c\n"
"\n"
"readRNA : String -> Maybe RNA\n"
"readRNA = traverse readRNABase . unpack\n"
"\n"
"readDNA : String -> Maybe DNA\n"
"readDNA = traverse readDNABase . unpack\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:454
msgid ""
"Again, in case of the bases appearing in both kinds of strands, users of the "
"universally quantified `readAnyBase` are free to choose what base type they "
"want, but they will never get a `Thymine` or `Uracile` value."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:458
msgid ""
"We can now implement some simple calculations on sequences of nucleobases. "
"For instance, we can come up with the complementary strand:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:459
#, no-wrap
msgid ""
"complementRNA' : RNA -> RNA\n"
"complementRNA' = map calc\n"
"  where calc : Nucleobase RNABase -> Nucleobase RNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Uracile\n"
"        calc Uracile  = Adenine\n"
"\n"
"complementDNA' : DNA -> DNA\n"
"complementDNA' = map calc\n"
"  where calc : Nucleobase DNABase -> Nucleobase DNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Thymine\n"
"        calc Thymine  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:480
msgid ""
"Ugh, code repetition! Not too bad here, but imagine there were dozens of "
"bases with only few specialized ones. Surely, we can do better? "
"Unfortunately, the following won't work:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:481
#, no-wrap
msgid ""
"complementBase' : Nucleobase b -> Nucleobase b\n"
"complementBase' Adenine  = ?what_now\n"
"complementBase' Cytosine = Guanine\n"
"complementBase' Guanine  = Cytosine\n"
"complementBase' Thymine  = Adenine\n"
"complementBase' Uracile  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:497
msgid ""
"All goes well with the exception of the `Adenine` case. Remember: Parameter "
"`b` is universally quantified, and the *callers* of our function can decide "
"what `b` is supposed to be. We therefore can't just return `Thymine`: Idris "
"will respond with a type error since callers might want a `Nucleobase "
"RNABase` instead.  One way to go about this is to take an additional "
"unerased argument (explicit or implicit) representing the base type:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:498
#, no-wrap
msgid ""
"complementBase : (b : BaseType) -> Nucleobase b -> Nucleobase b\n"
"complementBase DNABase Adenine  = Thymine\n"
"complementBase RNABase Adenine  = Uracile\n"
"complementBase _       Cytosine = Guanine\n"
"complementBase _       Guanine  = Cytosine\n"
"complementBase _       Thymine  = Adenine\n"
"complementBase _       Uracile  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:512
msgid ""
"This is again an example of a dependent *function* type (also called a [*pi "
"type*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A0_type)): The input "
"and output types both *depend* on the *value* of the first argument.  We can "
"now use this to calculate the complement of any nucleic acid:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:513
#, no-wrap
msgid ""
"complement : (b : BaseType) -> NucleicAcid b -> NucleicAcid b\n"
"complement b = map (complementBase b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:528
msgid ""
"Now, here is an interesting use case: We'd like to read a sequence of "
"nucleobases from user input, accepting two strings: The first telling us, "
"whether the user plans to enter a DNA or RNA sequence, the second being the "
"sequence itself. What should be the type of such a function? Well, we're "
"describing computations with side effects, so something involving `IO` seems "
"about right. User input almost always needs to be validated or translated, "
"so something might go wrong and we need an error type for this case. "
"Finally, our users can decide whether they want to enter a strand of RNA or "
"DNA, so this distinction should be encoded as well."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:531
msgid ""
"Of course, it is always possible to write a custom sum type for such a use "
"case:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:532
#, no-wrap
msgid ""
"data Result : Type where\n"
"  UnknownBaseType : String -> Result\n"
"  InvalidSequence : String -> Result\n"
"  GotDNA          : DNA -> Result\n"
"  GotRNA          : RNA -> Result\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:544
msgid ""
"This has all possible outcomes encoded in a single data type.  However, it "
"is lacking in terms of flexibility. If we want to handle errors early on and "
"just extract a strand of RNA or DNA, we need yet another data type:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:545
#, no-wrap
msgid "data RNAOrDNA = ItsRNA RNA | ItsDNA DNA\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:552
msgid ""
"This might be the way to go, but for results with many options, this can get "
"cumbersome quickly. Also: Why come up with a custom data type when we "
"already have the tools to deal with this at our hands?"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:554
msgid "Here is how we can encode this with a dependent pair:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:555
#, no-wrap
msgid ""
"namespace InputError\n"
"  public export\n"
"  data InputError : Type where\n"
"    UnknownBaseType : String -> InputError\n"
"    InvalidSequence : String -> InputError\n"
"\n"
"readAcid : (b : BaseType) -> String -> Either InputError (NucleicAcid b)\n"
"readAcid b str =\n"
"  let err = InvalidSequence str\n"
"   in case b of\n"
"        DNABase => maybeToEither err $ readDNA str\n"
"        RNABase => maybeToEither err $ readRNA str\n"
"\n"
"getNucleicAcid : IO (Either InputError (b ** NucleicAcid b))\n"
"getNucleicAcid = do\n"
"  baseString <- getLine\n"
"  case baseString of\n"
"    \"DNA\" => map (MkDPair _) . readAcid DNABase <$> getLine\n"
"    \"RNA\" => map (MkDPair _) . readAcid RNABase <$> getLine\n"
"    _     => pure $ Left (UnknownBaseType baseString)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:583
msgid ""
"Note, how we paired the type of nucleobases with the nucleic acid sequence. "
"Assume now we implement a function for transcribing a strand of DNA to RNA, "
"and we'd like to convert a sequence of nucleobases from user input to the "
"corresponding RNA sequence.  Here's how to do this:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:584
#, no-wrap
msgid ""
"transcribeBase : Nucleobase DNABase -> Nucleobase RNABase\n"
"transcribeBase Adenine  = Uracile\n"
"transcribeBase Cytosine = Guanine\n"
"transcribeBase Guanine  = Cytosine\n"
"transcribeBase Thymine  = Adenine\n"
"\n"
"transcribe : DNA -> RNA\n"
"transcribe = map transcribeBase\n"
"\n"
"printRNA : RNA -> IO ()\n"
"printRNA = putStrLn . encode\n"
"\n"
"transcribeProg : IO ()\n"
"transcribeProg = do\n"
"  Right (b ** seq) <- getNucleicAcid\n"
"    | Left (InvalidSequence str) => putStrLn $ \"Invalid sequence: \" ++ str\n"
"    | Left (UnknownBaseType str) => putStrLn $ \"Unknown base type: \" ++ str\n"
"  case b of\n"
"    DNABase => printRNA $ transcribe seq\n"
"    RNABase => printRNA seq\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:611
msgid ""
"By pattern matching on the first value of the dependent pair we could "
"determine, whether the second value is an RNA or DNA sequence.  In the first "
"case, we had to transcribe the sequence first, in the second case, we could "
"invoke `printRNA` directly."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:620
msgid ""
"In a more interesting scenario, we would *translate* the RNA sequence to the "
"corresponding protein sequence. Still, this example shows how to deal with a "
"simplified real world scenario: Data may be encoded differently and coming "
"from different sources. By using precise types, we are forced to first "
"convert values to the correct format. Failing to do so leads to a compile "
"time exception instead of an error at runtime or - even worse - the program "
"silently running a bogus computation."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:621
#, no-wrap
msgid "Dependent Records vs Sum Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:630
msgid ""
"Dependent records as shown for `AnyVect a` are a generalization of dependent "
"pairs: We can have an arbitrary number of fields and use the values stored "
"therein to calculate the types of other values. For very simple cases like "
"the example with nucleobases, it doesn't matter too much, whether we use a "
"`DPair`, a custom dependent record, or even a sum type. In fact, the three "
"encodings are equally expressive:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:631
#, no-wrap
msgid ""
"Acid1 : Type\n"
"Acid1 = (b ** NucleicAcid b)\n"
"\n"
"record Acid2 where\n"
"  constructor MkAcid2\n"
"  baseType : BaseType\n"
"  sequence : NucleicAcid baseType\n"
"\n"
"data Acid3 : Type where\n"
"  SomeRNA : RNA -> Acid3\n"
"  SomeDNA : DNA -> Acid3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:652
msgid ""
"It is trivial to write lossless conversions between these encodings, and "
"with each encoding we can decide with a simple pattern match, whether we "
"currently have a sequence of RNA or DNA. However, dependent types can depend "
"on more than one value, as we will see in the exercises. In such cases, sum "
"types and dependent pairs quickly become unwieldy, and you should go for an "
"encoding as a dependent record."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:661
msgid ""
"Sharpen your skills in using dependent pairs and dependent records! In "
"exercises 2 to 7 you have to decide yourself, when a function should return "
"a dependent pair or record, when a function requires additional arguments, "
"on which you can pattern match, and what other utility functions might be "
"necessary."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:666
msgid ""
"Proof that the three encodings for nucleobases are *isomorphic* (meaning: of "
"the same structure) by writing lossless conversion functions from `Acid1` to "
"`Acid2` and back. Likewise for `Acid1` and `Acid3`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:673
msgid ""
"Sequences of nucleobases can be encoded in one of two directions: [*Sense* "
"and *antisense*](https://en.wikipedia.org/wiki/Sense_(molecular_biology)).  "
"Declare a new data type to describe the sense of a sequence of nucleobases, "
"and add this as an additional parameter to type `Nucleobase` and types `DNA` "
"and `RNA`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:677
msgid ""
"Refine the types of `complement` and `transcribe`, so that they reflect the "
"changing of *sense*. In case of `transcribe`, a strand of antisense DNA is "
"converted to a strand of sense RNA."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:680
msgid ""
"Define a dependent record storing the base type and sense together with a "
"sequence of nucleobases."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:685
msgid ""
"Adjust `readRNA` and `readDNA` in such a way that the *sense* of a sequence "
"is read from the input string.  Sense strands are encoded like so: \"5-"
"CGGTAG-3\". Antisense strands are encoded like so: \"3-CGGTAG-5\"."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:688
msgid "Adjust `encode` in such a way that it includes the sense in its output."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/DPair.md:693
msgid ""
"Enhance `getNucleicAcid` and `transcribeProg` in such a way that the sense "
"and base type are stored together with the sequence, and that "
"`transcribeProg` always prints the *sense* RNA strand (after transcription, "
"if necessary)."
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/DPair.md:695
msgid "Enjoy the fruits of your labour and test your program at the REPL."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:703
msgid ""
"Note: Instead of using a dependent record, we could again have used a sum "
"type of four constructors to encode the different types of sequences. "
"However, the number of constructors required corresponds to the *product* of "
"the number of values of each type level index. Therefore, this number can "
"grow quickly and sum type encodings can lead to lengthy blocks of pattern "
"matches in these cases."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:704
#, no-wrap
msgid "Use Case: CSV Files with a Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:712
msgid ""
"In this section, we are going to look at an extended example based on our "
"previous work on CSV parsers. We'd like to write a small command-line "
"program, where users can specify a schema for the CSV tables they'd like to "
"parse and load into memory. Before we begin, here is a REPL session running "
"the final program, which you will complete in the exercises:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:713
#, no-wrap
msgid ""
"Solutions.DPair> :exec main\n"
"Enter a command: load resources/example\n"
"Table loaded. Schema: str,str,fin2023,str?,boolean?\n"
"Enter a command: get 3\n"
"Row 3:\n"
"\n"
"str   | str    | fin2023 | str? | boolean?\n"
"------------------------------------------\n"
"Floor | Jansen | 1981    |      | t\n"
"\n"
"Enter a command: add Mikael,Stanne,1974,,\n"
"Row prepended:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: delete 1\n"
"Deleted row: 1.\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str | str     | fin2023 | str? | boolean?\n"
"-----------------------------------------\n"
"Rob | Halford | 1951    |      |\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:754
msgid ""
"This example was inspired by a similar program used as an example in the "
"[Type-Driven Development with Idris](https://www.manning.com/books/type-"
"driven-development-with-idris)  book."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:756
msgid "We'd like to focus on several things here:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
msgid ""
"Purity: With the exception of the main program loop, all functions used in "
"the implementation should be pure, which in this context means \"not running "
"in any monad with side effects such as `IO`\"."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
msgid ""
"Fail early: With the exception of the command parser, all functions updating "
"the table and handling queries should be typed and implemented in such a way "
"that they cannot fail."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:766
msgid ""
"We are often well advised to adhere to these two guidelines, as they can "
"make the majority of our functions easier to implement and test."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:772
msgid ""
"Since we allow users of our library to specify a schema (order and types of "
"columns) for the table they work with, this information is not known until "
"runtime. The same goes for the current size of the table. We will therefore "
"store both values as fields in a dependent record."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:773
#, no-wrap
msgid "Encoding the Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:780
msgid ""
"We need to inspect the table schema at runtime. Although theoretically "
"possible, it is not advisable to operate on Idris types directly here.  We'd "
"rather use a closed custom data type describing the types of columns we "
"understand. In a first try, we only support some Idris primitives:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:781
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:791
msgid ""
"Next, we need a way to convert a `Schema` to a list of Idris types, which we "
"will then use as the index of a heterogeneous list representing the rows in "
"our table:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:792
#, no-wrap
msgid ""
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:807
msgid ""
"We can now describe a table as a dependent record storing the table's "
"content as a vector of rows. In order to safely index rows of the table and "
"parse new rows to be added, the current schema and size of the table must be "
"known at runtime:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:808
#, no-wrap
msgid ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:823
msgid ""
"Finally, we define an indexed data type describing commands operating on the "
"current table. Using the current table as the command's index allows us to "
"make sure that indices for accessing and deleting rows are within bounds and "
"that new rows agree with the current schema. This is necessary to uphold our "
"second design principle: All functions operating on tables must do so "
"without the possibility of failure."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:824
#, no-wrap
msgid ""
"data Command : (t : Table) -> Type where\n"
"  PrintSchema : Command t\n"
"  PrintSize   : Command t\n"
"  New         : (newSchema : Schema) -> Command t\n"
"  Prepend     : Row (schema t) -> Command t\n"
"  Get         : Fin (size t) -> Command t\n"
"  Delete      : Fin (size t) -> Command t\n"
"  Quit        : Command t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:839
msgid ""
"We can now implement the main application logic: How user entered commands "
"affect the application's current state. As promised, this comes without the "
"risk of failure, so we don't have to wrap the return type in an `Either`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:840
#, no-wrap
msgid ""
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:857
msgid ""
"Please understand, that the constructors of `Command t` are typed in such a "
"way that indices are always within bounds (constructors `Get` and `Delete`), "
"and new rows adhere to the table's current schema (constructor `Prepend`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:866
msgid ""
"One thing you might not have seen so far is the call to `absurd` on the last "
"line. This is a derived function of the `Uninhabited` interface, which is "
"used to describe types such as `Void` or - in the case above - `Fin 0`, of "
"which there can be no value. Function `absurd` is then just another "
"manifestation of the principle of explosion. If this doesn't make too much "
"sense yet, don't worry. We will look at `Void` and its uses in the next "
"chapter."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:867
#, no-wrap
msgid "Parsing Commands"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:879
msgid ""
"User input validation is an important topic when writing applications. If it "
"happens early, you can keep larger parts of your application pure (which - "
"in this context - means: \"without the possibility of failure\") and "
"provably total.  If done properly, this step encodes and handles most if not "
"all ways in which things can go wrong in your program, allowing you to come "
"up with clear error messages telling users exactly what caused an issue. As "
"you surely have experienced yourself, there are few things more frustrating "
"than a non-trivial computer program terminating with an unhelpful \"There "
"was an error\" message."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:892
msgid ""
"So, in order to treat this important topic with all due respect, we are "
"first going to implement a custom error type. This is not *strictly* "
"necessary for small programs, but once your software gets more complex, it "
"can be tremendously helpful for keeping track of what can go wrong where. In "
"order to figure out what can possibly go wrong, we first need to decide on "
"how the commands should be entered.  Here, we use a single keyword for each "
"command, together with an optional number of arguments separated from the "
"keyword by a single space character. For instance: `\"new i64,boolean,str,str"
"\"`, for initializing an empty table with a new schema. With this settled, "
"here is a list of things that can go wrong, and the messages we'd like to "
"print:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"A bogus command is entered. We repeat the input with a message that we don't "
"know the command plus a list of commands we know about."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An invalid schema was entered. In this case, we list the position of the "
"first unknown type, the string we found there, and a list of types we know "
"about."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An invalid CSV encoding of a row was entered. We list the erroneous "
"position, the string encountered there, plus the expected type. In case of a "
"too small or too large number of fields, we also print a corresponding error "
"message."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An index was out of bounds. This can happen, when users try to access or "
"delete specific rows. We print the current number of rows plus the value "
"entered."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"A value not representing a natural number was entered as an index.  We print "
"an according error message."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:910
msgid ""
"That's a lot of stuff to keep track off, so let's encode this in a sum type:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:911
#, no-wrap
msgid ""
"data Error : Type where\n"
"  UnknownCommand : String -> Error\n"
"  UnknownType    : (pos : Nat) -> String -> Error\n"
"  InvalidField   : (pos : Nat) -> ColType -> String -> Error\n"
"  ExpectedEOI    : (pos : Nat) -> String -> Error\n"
"  UnexpectedEOI  : (pos : Nat) -> String -> Error\n"
"  OutOfBounds    : (size : Nat) -> (index : Nat) -> Error\n"
"  NoNat          : String -> Error\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:929
msgid ""
"In order to conveniently construct our error messages, it is best to use "
"Idris' string interpolation facilities: We can enclose arbitrary string "
"expressions in a string literal by enclosing them in curly braces, the first "
"of which must be escaped with a backslash. Like so: `\"foo \\{myExpr a b "
"c}\"`.  We can pair this with multiline string literals to get nicely "
"formatted error messages."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:930
#, no-wrap
msgid ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map showColType\n"
"\n"
"allTypes : String\n"
"allTypes = concat\n"
"         . List.intersperse \", \"\n"
"         . map showColType\n"
"         $ [I64,Str,Boolean,Float]\n"
"\n"
"showError : Error -> String\n"
"showError (UnknownCommand x) = \"\"\"\n"
"  Unknown command: \\{x}.\n"
"  Known commands are: clear, schema, size, new, add, get, delete, quit.\n"
"  \"\"\"\n"
"\n"
"showError (UnknownType pos x) = \"\"\"\n"
"  Unknown type at position \\{show pos}: \\{x}.\n"
"  Known types are: \\{allTypes}.\n"
"  \"\"\"\n"
"\n"
"showError (InvalidField pos tpe x) = \"\"\"\n"
"  Invalid value at position \\{show pos}.\n"
"  Expected type: \\{showColType tpe}.\n"
"  Value found: \\{x}.\n"
"  \"\"\"\n"
"\n"
"showError (ExpectedEOI k x) = \"\"\"\n"
"  Expected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (UnexpectedEOI k x) = \"\"\"\n"
"  Unxpected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (OutOfBounds size index) = \"\"\"\n"
"  Index out of bounds.\n"
"  Size of table: \\{show size}\n"
"  Index: \\{show index}\n"
"  Note: Indices start at 1.\n"
"  \"\"\"\n"
"\n"
"showError (NoNat x) = \"Not a natural number: \\{x}\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:990
msgid ""
"We can now write parsers for the different commands. We need facilities to "
"parse vector indices, schemata, and CSV rows.  Since we are using a CSV "
"format for encoding and decoding rows, it makes sense to also encode the "
"schema as a comma-separated list of values:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:991
#, no-wrap
msgid ""
"zipWithIndex : Traversable t => t a -> t (Nat, a)\n"
"zipWithIndex = evalState 1 . traverse pairWithIndex\n"
"  where pairWithIndex : a -> State Nat (Nat,a)\n"
"        pairWithIndex v = (,v) <$> get <* modify S\n"
"\n"
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"readColType : Nat -> String -> Either Error ColType\n"
"readColType _ \"i64\"      = Right I64\n"
"readColType _ \"str\"      = Right Str\n"
"readColType _ \"boolean\"  = Right Boolean\n"
"readColType _ \"float\"    = Right Float\n"
"readColType n s          = Left $ UnknownType n s\n"
"\n"
"readSchema : String -> Either Error Schema\n"
"readSchema = traverse (uncurry readColType) . zipWithIndex . fromCSV\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1018
msgid ""
"We also need to decode CSV content based on the current schema.  Note, how "
"we can do so in a type safe manner by pattern matching on the schema, which "
"will not be known until runtime. Unfortunately, we need to reimplement CSV-"
"parsing, because we want to add the expected type to the error messages (a "
"thing that would be much harder to do with interface `CSVLine` and error "
"type `CSVError`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1019
#, no-wrap
msgid ""
"decodeField : Nat -> (c : ColType) -> String -> Either Error (IdrisType c)\n"
"decodeField k c s =\n"
"  let err = InvalidField k c s\n"
"   in case c of\n"
"        I64     => maybeToEither err $ read s\n"
"        Str     => maybeToEither err $ read s\n"
"        Boolean => maybeToEither err $ read s\n"
"        Float   => maybeToEither err $ read s\n"
"\n"
"decodeRow : {ts : _} -> String -> Either Error (Row ts)\n"
"decodeRow s = go 1 ts $ fromCSV s\n"
"  where go : Nat -> (cs : Schema) -> List String -> Either Error (Row cs)\n"
"        go k []       []         = Right []\n"
"        go k []       (_ :: _)   = Left $ ExpectedEOI k s\n"
"        go k (_ :: _) []         = Left $ UnexpectedEOI k s\n"
"        go k (c :: cs) (s :: ss) = [| decodeField k c s :: go (S k) cs ss |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1040
msgid ""
"There is no hard and fast rule about whether to pass an index as an implicit "
"argument or not. Some considerations:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid ""
"Pattern matching on explicit arguments comes with less syntactic overhead."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid ""
"If an argument can be inferred from the context most of the time, consider "
"passing it as an implicit to make your function nicer to use in client code."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid ""
"Use explicit (possibly erased) arguments for values that can't be inferred "
"by Idris most of the time."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1052
msgid ""
"All that is missing now is a way to parse indices for accessing the current "
"table's rows. We use the conversion for indices to start at one instead of "
"zero, which feels more natural for most non-programmers."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1053
#, no-wrap
msgid ""
"readFin : {n : _} -> String -> Either Error (Fin n)\n"
"readFin s = do\n"
"  S k <- maybeToEither (NoNat s) $ parsePositive {a = Nat} s\n"
"    | Z => Left $ OutOfBounds n Z\n"
"  maybeToEither (OutOfBounds n $ S k) $ natToFin k n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1067
msgid ""
"We are finally able to implement a parser for user commands.  Function `Data."
"String.words` is used for splitting a string at space characters. In most "
"cases, we expect the name of the command plus a single argument without "
"additional spaces.  CSV rows can have additional space characters, however, "
"so we use `Data.String.unwords` on the split string."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1068
#, no-wrap
msgid ""
"readCommand :  (t : Table) -> String -> Either Error (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  _               => Left $ UnknownCommand s\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:1081
#, no-wrap
msgid "Running the Application"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1087
msgid ""
"All that's left to do is to write functions for printing the results of "
"commands to users and run the application in a loop until command `\"quit\"` "
"is entered."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1088
#, no-wrap
msgid ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (ts : List ColType) -> Row ts -> String\n"
"encodeRow ts = concat . intersperse \",\" . go ts\n"
"  where go : (cs : List ColType) -> Row cs -> Vect (length cs) String\n"
"        go []        []        = []\n"
"        go (c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize   = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)    = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r) = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)  = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit        = \"Goodbye.\"\n"
"result t (Get x)     =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (showError err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1136
msgid ""
"The challenges presented here all deal with enhancing our table editor in "
"several interesting ways. Some of them are more a matter of style and less a "
"matter of learning to write dependently typed programs, so feel free to "
"solve these as you please. Exercises 1 to 3 should be considered to be "
"mandatory."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:1139
msgid "Add support for storing Idris types `Integer` and `Nat` in CSV columns"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:1142
msgid ""
"Add support for `Fin n` to CSV columns. Note: We need runtime access to `n` "
"in order for this to work."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:1148
msgid ""
"Add support for optional types to CSV columns. Since missing values should "
"be encoded by empty strings, it makes no sense to allow for nested optional "
"types, meaning that types like `Maybe Nat` should be allowed while `Maybe "
"(Maybe Nat)` should not."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1151
#, no-wrap
msgid ""
"   Hint: There are several ways to encode these, one being\n"
"   to add a boolean index to `ColType`.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:1154
msgid ""
"Add a command for printing the whole table. Bonus points if all columns are "
"properly aligned."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:1158
msgid ""
"Add support for simple queries: Given a column number and a value, list all "
"rows where entries match the given value."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1160
#, no-wrap
msgid "   This might be a challenge, as the types get pretty interesting.\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:1164
msgid ""
"Add support for loading and saving tables from and to disk.  A table should "
"be stored in two files: One for the schema and one for the CSV content."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1179
#, no-wrap
msgid ""
"   Note: Reading files in a provably total way can be pretty\n"
"   hard and will be a topic for another day. For now,\n"
"   just use function `readFile` exported from\n"
"   `System.File` in base for reading a file as a whole.\n"
"   This function is partial, because\n"
"   it will not terminate when used with an infinite input\n"
"   stream such as `/dev/urandom` or `/dev/zero`.\n"
"   It is important to *not* use `assert_total` here.\n"
"   Using partial functions like `readFile` might well impose\n"
"   a security risk in a real world application, so eventually,\n"
"   we'd have to deal with this and allow for some way to\n"
"   limit the size of accepted input. It is therefore best\n"
"   to make this partiality visible and annotate all downstream\n"
"   functions accordingly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1183
msgid ""
"You can find an implementation of these additions in the solutions. A small "
"example table can be found in folder `resources`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1190
msgid ""
"Note: There are of course tons of projects to pursue from here, such as "
"writing a proper query language, calculating new rows from existing ones, "
"accumulating values in a column, concatenating and zipping tables, and so "
"on.  We will stop for now, probably coming back to this in later examples."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1198
msgid ""
"Dependent pairs and records are necessary to at runtime inspect the values "
"defining the types we work with. By pattern matching on these values, we "
"learn about the types and possible shapes of other values, allowing us to "
"reduce the number of potential bugs in our programs."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1204
msgid ""
"In the [next chapter](Eq.md) we start learning about how to write data "
"types, which we use as proofs that certain contracts between values hold. "
"These will eventually allow us to define pre- and post conditions for our "
"function arguments and output types."
msgstr ""
