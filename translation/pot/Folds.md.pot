# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-08-17 13:30+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:16 ../src/Tutorial/DataTypes.md:25
#: ../src/Tutorial/DataTypes.md:60 ../src/Tutorial/DataTypes.md:112
#: ../src/Tutorial/DataTypes.md:130 ../src/Tutorial/DataTypes.md:152
#: ../src/Tutorial/DataTypes.md:163 ../src/Tutorial/DataTypes.md:184
#: ../src/Tutorial/DataTypes.md:215 ../src/Tutorial/DataTypes.md:253
#: ../src/Tutorial/DataTypes.md:283 ../src/Tutorial/DataTypes.md:327
#: ../src/Tutorial/DataTypes.md:348 ../src/Tutorial/DataTypes.md:359
#: ../src/Tutorial/DataTypes.md:378 ../src/Tutorial/DataTypes.md:408
#: ../src/Tutorial/DataTypes.md:415 ../src/Tutorial/DataTypes.md:441
#: ../src/Tutorial/DataTypes.md:449 ../src/Tutorial/DataTypes.md:482
#: ../src/Tutorial/DataTypes.md:505 ../src/Tutorial/DataTypes.md:518
#: ../src/Tutorial/DataTypes.md:546 ../src/Tutorial/DataTypes.md:559
#: ../src/Tutorial/DataTypes.md:587 ../src/Tutorial/DataTypes.md:598
#: ../src/Tutorial/DataTypes.md:617 ../src/Tutorial/DataTypes.md:628
#: ../src/Tutorial/DataTypes.md:638 ../src/Tutorial/DataTypes.md:654
#: ../src/Tutorial/DataTypes.md:667 ../src/Tutorial/DataTypes.md:681
#: ../src/Tutorial/DataTypes.md:693 ../src/Tutorial/DataTypes.md:701
#: ../src/Tutorial/DataTypes.md:716 ../src/Tutorial/DataTypes.md:729
#: ../src/Tutorial/DataTypes.md:804 ../src/Tutorial/DataTypes.md:828
#: ../src/Tutorial/DataTypes.md:861 ../src/Tutorial/DataTypes.md:897
#: ../src/Tutorial/DataTypes.md:908 ../src/Tutorial/DataTypes.md:942
#: ../src/Tutorial/DataTypes.md:957 ../src/Tutorial/DataTypes.md:967
#: ../src/Tutorial/DataTypes.md:992 ../src/Tutorial/DataTypes.md:1069
#: ../src/Tutorial/DataTypes.md:1081 ../src/Tutorial/DataTypes.md:1105
#: ../src/Tutorial/DataTypes.md:1143 ../src/Tutorial/DataTypes.md:1178
#: ../src/Tutorial/DataTypes.md:1208 ../src/Tutorial/DataTypes.md:1246
#: ../src/Tutorial/DataTypes.md:1269 ../src/Tutorial/DataTypes.md:1291
#: ../src/Tutorial/Dependent.md:10 ../src/Tutorial/Dependent.md:18
#: ../src/Tutorial/Dependent.md:42 ../src/Tutorial/Dependent.md:62
#: ../src/Tutorial/Dependent.md:70 ../src/Tutorial/Dependent.md:81
#: ../src/Tutorial/Dependent.md:111 ../src/Tutorial/Dependent.md:125
#: ../src/Tutorial/Dependent.md:136 ../src/Tutorial/Dependent.md:155
#: ../src/Tutorial/Dependent.md:174 ../src/Tutorial/Dependent.md:182
#: ../src/Tutorial/Dependent.md:227 ../src/Tutorial/Dependent.md:266
#: ../src/Tutorial/Dependent.md:278 ../src/Tutorial/Dependent.md:296
#: ../src/Tutorial/Dependent.md:388 ../src/Tutorial/Dependent.md:396
#: ../src/Tutorial/Dependent.md:404 ../src/Tutorial/Dependent.md:421
#: ../src/Tutorial/Dependent.md:429 ../src/Tutorial/Dependent.md:448
#: ../src/Tutorial/Dependent.md:465 ../src/Tutorial/Dependent.md:508
#: ../src/Tutorial/Dependent.md:518 ../src/Tutorial/Dependent.md:532
#: ../src/Tutorial/Dependent.md:565 ../src/Tutorial/Dependent.md:580
#: ../src/Tutorial/Dependent.md:601 ../src/Tutorial/Dependent.md:608
#: ../src/Tutorial/Dependent.md:618 ../src/Tutorial/Dependent.md:691
#: ../src/Tutorial/Dependent.md:706 ../src/Tutorial/Dependent.md:728
#: ../src/Tutorial/Dependent.md:749 ../src/Tutorial/Dependent.md:790
#: ../src/Tutorial/Dependent.md:798 ../src/Tutorial/Dependent.md:807
#: ../src/Tutorial/Dependent.md:821 ../src/Tutorial/Dependent.md:837
#: ../src/Tutorial/Dependent.md:847 ../src/Tutorial/DPair.md:19
#: ../src/Tutorial/DPair.md:47 ../src/Tutorial/DPair.md:76
#: ../src/Tutorial/DPair.md:93 ../src/Tutorial/DPair.md:116
#: ../src/Tutorial/DPair.md:132 ../src/Tutorial/DPair.md:148
#: ../src/Tutorial/DPair.md:165 ../src/Tutorial/DPair.md:174
#: ../src/Tutorial/DPair.md:203 ../src/Tutorial/DPair.md:216
#: ../src/Tutorial/DPair.md:226 ../src/Tutorial/DPair.md:243
#: ../src/Tutorial/DPair.md:255 ../src/Tutorial/DPair.md:266
#: ../src/Tutorial/DPair.md:285 ../src/Tutorial/DPair.md:298
#: ../src/Tutorial/DPair.md:307 ../src/Tutorial/DPair.md:315
#: ../src/Tutorial/DPair.md:327 ../src/Tutorial/DPair.md:339
#: ../src/Tutorial/DPair.md:373 ../src/Tutorial/DPair.md:405
#: ../src/Tutorial/DPair.md:416 ../src/Tutorial/DPair.md:428
#: ../src/Tutorial/DPair.md:459 ../src/Tutorial/DPair.md:481
#: ../src/Tutorial/DPair.md:498 ../src/Tutorial/DPair.md:513
#: ../src/Tutorial/DPair.md:532 ../src/Tutorial/DPair.md:545
#: ../src/Tutorial/DPair.md:555 ../src/Tutorial/DPair.md:584
#: ../src/Tutorial/DPair.md:631 ../src/Tutorial/DPair.md:781
#: ../src/Tutorial/DPair.md:792 ../src/Tutorial/DPair.md:808
#: ../src/Tutorial/DPair.md:824 ../src/Tutorial/DPair.md:840
#: ../src/Tutorial/DPair.md:911 ../src/Tutorial/DPair.md:930
#: ../src/Tutorial/DPair.md:991 ../src/Tutorial/DPair.md:1019
#: ../src/Tutorial/DPair.md:1053 ../src/Tutorial/DPair.md:1068
#: ../src/Tutorial/DPair.md:1088 ../src/Tutorial/Eq.md:10
#: ../src/Tutorial/Eq.md:27 ../src/Tutorial/Eq.md:56 ../src/Tutorial/Eq.md:115
#: ../src/Tutorial/Eq.md:129 ../src/Tutorial/Eq.md:135
#: ../src/Tutorial/Eq.md:144 ../src/Tutorial/Eq.md:173
#: ../src/Tutorial/Eq.md:181 ../src/Tutorial/Eq.md:204
#: ../src/Tutorial/Eq.md:222 ../src/Tutorial/Eq.md:254
#: ../src/Tutorial/Eq.md:316 ../src/Tutorial/Eq.md:337
#: ../src/Tutorial/Eq.md:347 ../src/Tutorial/Eq.md:358
#: ../src/Tutorial/Eq.md:374 ../src/Tutorial/Eq.md:388
#: ../src/Tutorial/Eq.md:423 ../src/Tutorial/Eq.md:454
#: ../src/Tutorial/Eq.md:495 ../src/Tutorial/Eq.md:531
#: ../src/Tutorial/Eq.md:544 ../src/Tutorial/Eq.md:577
#: ../src/Tutorial/Eq.md:587 ../src/Tutorial/Eq.md:618
#: ../src/Tutorial/Eq.md:634 ../src/Tutorial/Eq.md:643
#: ../src/Tutorial/Eq.md:652 ../src/Tutorial/Eq.md:668
#: ../src/Tutorial/Eq.md:711 ../src/Tutorial/Eq.md:753
#: ../src/Tutorial/Eq.md:798 ../src/Tutorial/Eq.md:810
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Eq.md:889
#: ../src/Tutorial/Eq.md:900 ../src/Tutorial/Eq.md:924
#: ../src/Tutorial/Eq.md:941 ../src/Tutorial/Eq.md:961
#: ../src/Tutorial/Eq.md:1002 ../src/Tutorial/Eq.md:1033
#: ../src/Tutorial/Eq.md:1074 ../src/Tutorial/Folds.md:23
#: ../src/Tutorial/Folds.md:51 ../src/Tutorial/Folds.md:64
#: ../src/Tutorial/Folds.md:74 ../src/Tutorial/Folds.md:89
#: ../src/Tutorial/Folds.md:104 ../src/Tutorial/Folds.md:118
#: ../src/Tutorial/Folds.md:134 ../src/Tutorial/Folds.md:188
#: ../src/Tutorial/Folds.md:205 ../src/Tutorial/Folds.md:216
#: ../src/Tutorial/Folds.md:230 ../src/Tutorial/Folds.md:254
#: ../src/Tutorial/Folds.md:282 ../src/Tutorial/Folds.md:303
#: ../src/Tutorial/Folds.md:320 ../src/Tutorial/Folds.md:384
#: ../src/Tutorial/Folds.md:393 ../src/Tutorial/Folds.md:400
#: ../src/Tutorial/Folds.md:406 ../src/Tutorial/Folds.md:429
#: ../src/Tutorial/Folds.md:438 ../src/Tutorial/Folds.md:446
#: ../src/Tutorial/Folds.md:452 ../src/Tutorial/Folds.md:458
#: ../src/Tutorial/Folds.md:465 ../src/Tutorial/Folds.md:495
#: ../src/Tutorial/Folds.md:521 ../src/Tutorial/Folds.md:544
#: ../src/Tutorial/Folds.md:609 ../src/Tutorial/Folds.md:621
#: ../src/Tutorial/Folds.md:638 ../src/Tutorial/Folds.md:656
#: ../src/Tutorial/Folds.md:720 ../src/Tutorial/Folds.md:737
#: ../src/Tutorial/Folds.md:766 ../src/Tutorial/Folds.md:847
#: ../src/Tutorial/Folds.md:869 ../src/Tutorial/Folds.md:892
#: ../src/Tutorial/Folds.md:935 ../src/Tutorial/Folds.md:951
#: ../src/Tutorial/Folds.md:996 ../src/Tutorial/Folds.md:1006
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/Folds.md:1040
#: ../src/Tutorial/Functions1.md:17 ../src/Tutorial/Functions1.md:29
#: ../src/Tutorial/Functions1.md:80 ../src/Tutorial/Functions1.md:96
#: ../src/Tutorial/Functions1.md:109 ../src/Tutorial/Functions1.md:127
#: ../src/Tutorial/Functions1.md:158 ../src/Tutorial/Functions1.md:178
#: ../src/Tutorial/Functions1.md:221 ../src/Tutorial/Functions1.md:246
#: ../src/Tutorial/Functions1.md:292 ../src/Tutorial/Functions1.md:349
#: ../src/Tutorial/Functions1.md:391 ../src/Tutorial/Functions1.md:472
#: ../src/Tutorial/Functions1.md:505 ../src/Tutorial/Functions2.md:16
#: ../src/Tutorial/Functions2.md:94 ../src/Tutorial/Functions2.md:164
#: ../src/Tutorial/Functions2.md:203 ../src/Tutorial/Functions2.md:220
#: ../src/Tutorial/Functions2.md:249 ../src/Tutorial/Functions2.md:277
#: ../src/Tutorial/Functions2.md:319 ../src/Tutorial/Functions2.md:372
#: ../src/Tutorial/Functions2.md:391 ../src/Tutorial/Functions2.md:408
#: ../src/Tutorial/Functions2.md:426 ../src/Tutorial/Functions2.md:440
#: ../src/Tutorial/Functions2.md:447 ../src/Tutorial/Functions2.md:455
#: ../src/Tutorial/Functions2.md:472 ../src/Tutorial/Functions2.md:510
#: ../src/Tutorial/Functions2.md:624 ../src/Tutorial/Functions2.md:634
#: ../src/Tutorial/Functions2.md:646 ../src/Tutorial/Functions2.md:659
#: ../src/Tutorial/Functions2.md:670 ../src/Tutorial/Functions2.md:707
#: ../src/Tutorial/Functions2.md:780 ../src/Tutorial/Functions2.md:869
#: ../src/Tutorial/Functions2.md:880 ../src/Tutorial/Functor.md:18
#: ../src/Tutorial/Functor.md:54 ../src/Tutorial/Functor.md:63
#: ../src/Tutorial/Functor.md:73 ../src/Tutorial/Functor.md:84
#: ../src/Tutorial/Functor.md:95 ../src/Tutorial/Functor.md:111
#: ../src/Tutorial/Functor.md:126 ../src/Tutorial/Functor.md:139
#: ../src/Tutorial/Functor.md:167 ../src/Tutorial/Functor.md:236
#: ../src/Tutorial/Functor.md:260 ../src/Tutorial/Functor.md:270
#: ../src/Tutorial/Functor.md:285 ../src/Tutorial/Functor.md:298
#: ../src/Tutorial/Functor.md:314 ../src/Tutorial/Functor.md:340
#: ../src/Tutorial/Functor.md:351 ../src/Tutorial/Functor.md:392
#: ../src/Tutorial/Functor.md:408 ../src/Tutorial/Functor.md:417
#: ../src/Tutorial/Functor.md:429 ../src/Tutorial/Functor.md:442
#: ../src/Tutorial/Functor.md:456 ../src/Tutorial/Functor.md:479
#: ../src/Tutorial/Functor.md:494 ../src/Tutorial/Functor.md:512
#: ../src/Tutorial/Functor.md:531 ../src/Tutorial/Functor.md:551
#: ../src/Tutorial/Functor.md:576 ../src/Tutorial/Functor.md:622
#: ../src/Tutorial/Functor.md:651 ../src/Tutorial/Functor.md:660
#: ../src/Tutorial/Functor.md:676 ../src/Tutorial/Functor.md:693
#: ../src/Tutorial/Functor.md:704 ../src/Tutorial/Functor.md:750
#: ../src/Tutorial/Functor.md:761 ../src/Tutorial/Functor.md:773
#: ../src/Tutorial/Functor.md:784 ../src/Tutorial/Functor.md:828
#: ../src/Tutorial/Functor.md:842 ../src/Tutorial/Functor.md:860
#: ../src/Tutorial/Functor.md:872 ../src/Tutorial/Functor.md:888
#: ../src/Tutorial/Functor.md:926 ../src/Tutorial/Functor.md:945
#: ../src/Tutorial/Functor.md:971 ../src/Tutorial/Functor.md:1082
#: ../src/Tutorial/Functor.md:1122 ../src/Tutorial/Functor.md:1135
#: ../src/Tutorial/Functor.md:1199 ../src/Tutorial/Functor.md:1257
#: ../src/Tutorial/Functor.md:1268 ../src/Tutorial/Functor.md:1278
#: ../src/Tutorial/Functor.md:1285 ../src/Tutorial/Interfaces.md:10
#: ../src/Tutorial/Interfaces.md:43 ../src/Tutorial/Interfaces.md:62
#: ../src/Tutorial/Interfaces.md:71 ../src/Tutorial/Interfaces.md:100
#: ../src/Tutorial/Interfaces.md:117 ../src/Tutorial/Interfaces.md:159
#: ../src/Tutorial/Interfaces.md:234 ../src/Tutorial/Interfaces.md:255
#: ../src/Tutorial/Interfaces.md:274 ../src/Tutorial/Interfaces.md:296
#: ../src/Tutorial/Interfaces.md:321 ../src/Tutorial/Interfaces.md:333
#: ../src/Tutorial/Interfaces.md:341 ../src/Tutorial/Interfaces.md:362
#: ../src/Tutorial/Interfaces.md:456 ../src/Tutorial/Interfaces.md:466
#: ../src/Tutorial/Interfaces.md:475 ../src/Tutorial/Interfaces.md:498
#: ../src/Tutorial/Interfaces.md:534 ../src/Tutorial/Interfaces.md:552
#: ../src/Tutorial/Interfaces.md:561 ../src/Tutorial/Interfaces.md:650
#: ../src/Tutorial/Interfaces.md:661 ../src/Tutorial/Interfaces.md:677
#: ../src/Tutorial/Interfaces.md:695 ../src/Tutorial/Interfaces.md:716
#: ../src/Tutorial/Interfaces.md:727 ../src/Tutorial/Intro.md:20
#: ../src/Tutorial/Intro.md:191 ../src/Tutorial/Intro.md:252
#: ../src/Tutorial/Intro.md:287 ../src/Tutorial/Intro.md:312
#: ../src/Tutorial/IO.md:8 ../src/Tutorial/IO.md:25 ../src/Tutorial/IO.md:84
#: ../src/Tutorial/IO.md:121 ../src/Tutorial/IO.md:217
#: ../src/Tutorial/IO.md:232 ../src/Tutorial/IO.md:240
#: ../src/Tutorial/IO.md:255 ../src/Tutorial/IO.md:299
#: ../src/Tutorial/IO.md:334 ../src/Tutorial/IO.md:342
#: ../src/Tutorial/IO.md:352 ../src/Tutorial/IO.md:374
#: ../src/Tutorial/IO.md:405 ../src/Tutorial/IO.md:417
#: ../src/Tutorial/IO.md:472 ../src/Tutorial/IO.md:493
#: ../src/Tutorial/IO.md:506 ../src/Tutorial/IO.md:517
#: ../src/Tutorial/IO.md:528 ../src/Tutorial/IO.md:563
#: ../src/Tutorial/IO.md:581 ../src/Tutorial/IO.md:650
#: ../src/Tutorial/IO.md:689 ../src/Tutorial/IO.md:696
#: ../src/Tutorial/IO.md:705 ../src/Tutorial/IO.md:713
#: ../src/Tutorial/IO.md:734 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/IO.md:875 ../src/Tutorial/IO.md:920
#: ../src/Tutorial/IO.md:960 ../src/Tutorial/IO.md:984
#: ../src/Tutorial/IO.md:997 ../src/Tutorial/Predicates.md:13
#: ../src/Tutorial/Predicates.md:108 ../src/Tutorial/Predicates.md:118
#: ../src/Tutorial/Predicates.md:139 ../src/Tutorial/Predicates.md:153
#: ../src/Tutorial/Predicates.md:165 ../src/Tutorial/Predicates.md:191
#: ../src/Tutorial/Predicates.md:203 ../src/Tutorial/Predicates.md:212
#: ../src/Tutorial/Predicates.md:224 ../src/Tutorial/Predicates.md:235
#: ../src/Tutorial/Predicates.md:252 ../src/Tutorial/Predicates.md:259
#: ../src/Tutorial/Predicates.md:277 ../src/Tutorial/Predicates.md:288
#: ../src/Tutorial/Predicates.md:352 ../src/Tutorial/Predicates.md:359
#: ../src/Tutorial/Predicates.md:368 ../src/Tutorial/Predicates.md:387
#: ../src/Tutorial/Predicates.md:406 ../src/Tutorial/Predicates.md:416
#: ../src/Tutorial/Predicates.md:447 ../src/Tutorial/Predicates.md:475
#: ../src/Tutorial/Predicates.md:493 ../src/Tutorial/Predicates.md:532
#: ../src/Tutorial/Predicates.md:550 ../src/Tutorial/Predicates.md:568
#: ../src/Tutorial/Predicates.md:603 ../src/Tutorial/Predicates.md:620
#: ../src/Tutorial/Predicates.md:639 ../src/Tutorial/Predicates.md:658
#: ../src/Tutorial/Predicates.md:719 ../src/Tutorial/Predicates.md:747
#: ../src/Tutorial/Predicates.md:768 ../src/Tutorial/Predicates.md:784
#: ../src/Tutorial/Predicates.md:798 ../src/Tutorial/Predicates.md:812
#: ../src/Tutorial/Predicates.md:821 ../src/Tutorial/Predicates.md:835
#: ../src/Tutorial/Predicates.md:850 ../src/Tutorial/Predicates.md:862
#: ../src/Tutorial/Predicates.md:872 ../src/Tutorial/Predicates.md:951
#: ../src/Tutorial/Predicates.md:963 ../src/Tutorial/Predicates.md:983
#: ../src/Tutorial/Predicates.md:999 ../src/Tutorial/Predicates.md:1024
#: ../src/Tutorial/Predicates.md:1035 ../src/Tutorial/Predicates.md:1044
#: ../src/Tutorial/Predicates.md:1066 ../src/Tutorial/Predicates.md:1080
#: ../src/Tutorial/Predicates.md:1094 ../src/Tutorial/Predicates.md:1105
#: ../src/Tutorial/Predicates.md:1113 ../src/Tutorial/Predicates.md:1121
#: ../src/Tutorial/Predicates.md:1134 ../src/Tutorial/Predicates.md:1163
#: ../src/Tutorial/Predicates.md:1199 ../src/Tutorial/Predicates.md:1236
#: ../src/Tutorial/Predicates.md:1287 ../src/Tutorial/Prim.md:8
#: ../src/Tutorial/Prim.md:164 ../src/Tutorial/Prim.md:175
#: ../src/Tutorial/Prim.md:190 ../src/Tutorial/Prim.md:201
#: ../src/Tutorial/Prim.md:210 ../src/Tutorial/Prim.md:218
#: ../src/Tutorial/Prim.md:232 ../src/Tutorial/Prim.md:246
#: ../src/Tutorial/Prim.md:263 ../src/Tutorial/Prim.md:271
#: ../src/Tutorial/Prim.md:324 ../src/Tutorial/Prim.md:346
#: ../src/Tutorial/Prim.md:357 ../src/Tutorial/Prim.md:389
#: ../src/Tutorial/Prim.md:399 ../src/Tutorial/Prim.md:412
#: ../src/Tutorial/Prim.md:425 ../src/Tutorial/Prim.md:672
#: ../src/Tutorial/Prim.md:684 ../src/Tutorial/Prim.md:757
#: ../src/Tutorial/Prim.md:768 ../src/Tutorial/Prim.md:780
#: ../src/Tutorial/Prim.md:801 ../src/Tutorial/Prim.md:809
#: ../src/Tutorial/Prim.md:818 ../src/Tutorial/Prim.md:840
#: ../src/Tutorial/Prim.md:892 ../src/Tutorial/Prim.md:911
#: ../src/Tutorial/Prim.md:926 ../src/Tutorial/Prim.md:984
#: ../src/Tutorial/Prim.md:1026 ../src/Tutorial/Prim.md:1046
#: ../src/Tutorial/Prim.md:1064 ../src/Tutorial/Prim.md:1073
#: ../src/Tutorial/Prim.md:1087 ../src/Tutorial/Prim.md:1101
#: ../src/Tutorial/Prim.md:1118 ../src/Tutorial/Prim.md:1176
#: ../src/Tutorial/Prim.md:1208 ../src/Tutorial/Traverse.md:17
#: ../src/Tutorial/Traverse.md:52 ../src/Tutorial/Traverse.md:62
#: ../src/Tutorial/Traverse.md:82 ../src/Tutorial/Traverse.md:105
#: ../src/Tutorial/Traverse.md:140 ../src/Tutorial/Traverse.md:173
#: ../src/Tutorial/Traverse.md:183 ../src/Tutorial/Traverse.md:194
#: ../src/Tutorial/Traverse.md:203 ../src/Tutorial/Traverse.md:267
#: ../src/Tutorial/Traverse.md:276 ../src/Tutorial/Traverse.md:285
#: ../src/Tutorial/Traverse.md:295 ../src/Tutorial/Traverse.md:308
#: ../src/Tutorial/Traverse.md:325 ../src/Tutorial/Traverse.md:332
#: ../src/Tutorial/Traverse.md:370 ../src/Tutorial/Traverse.md:388
#: ../src/Tutorial/Traverse.md:398 ../src/Tutorial/Traverse.md:406
#: ../src/Tutorial/Traverse.md:414 ../src/Tutorial/Traverse.md:463
#: ../src/Tutorial/Traverse.md:471 ../src/Tutorial/Traverse.md:489
#: ../src/Tutorial/Traverse.md:497 ../src/Tutorial/Traverse.md:506
#: ../src/Tutorial/Traverse.md:514 ../src/Tutorial/Traverse.md:525
#: ../src/Tutorial/Traverse.md:543 ../src/Tutorial/Traverse.md:591
#: ../src/Tutorial/Traverse.md:605 ../src/Tutorial/Traverse.md:771
#: ../src/Tutorial/Traverse.md:831 ../src/Tutorial/Traverse.md:852
#: ../src/Tutorial/Traverse.md:867 ../src/Tutorial/Traverse.md:899
#: ../src/Tutorial/Traverse.md:909 ../src/Tutorial/Traverse.md:929
#: ../src/Tutorial/Traverse.md:939 ../src/Tutorial/Traverse.md:975
#: ../src/Tutorial/Traverse.md:1030 ../src/Tutorial/Traverse.md:1056
#: ../src/Tutorial/Traverse.md:1067 ../src/Tutorial/Traverse.md:1077
#: ../src/Tutorial/Traverse.md:1095
#, no-wrap
msgid "idris"
msgstr ""

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:39 ../src/Tutorial/DataTypes.md:234
#: ../src/Tutorial/DataTypes.md:241 ../src/Tutorial/DataTypes.md:310
#: ../src/Tutorial/DataTypes.md:337 ../src/Tutorial/DataTypes.md:390
#: ../src/Tutorial/DataTypes.md:427 ../src/Tutorial/DataTypes.md:494
#: ../src/Tutorial/DataTypes.md:646 ../src/Tutorial/DataTypes.md:840
#: ../src/Tutorial/DataTypes.md:1009 ../src/Tutorial/DataTypes.md:1016
#: ../src/Tutorial/DataTypes.md:1024 ../src/Tutorial/DataTypes.md:1031
#: ../src/Tutorial/DataTypes.md:1038 ../src/Tutorial/DataTypes.md:1045
#: ../src/Tutorial/Dependent.md:197 ../src/Tutorial/Dependent.md:204
#: ../src/Tutorial/Dependent.md:239 ../src/Tutorial/Dependent.md:245
#: ../src/Tutorial/Dependent.md:309 ../src/Tutorial/Dependent.md:346
#: ../src/Tutorial/Dependent.md:364 ../src/Tutorial/Dependent.md:499
#: ../src/Tutorial/Dependent.md:632 ../src/Tutorial/Dependent.md:867
#: ../src/Tutorial/DPair.md:66 ../src/Tutorial/DPair.md:234
#: ../src/Tutorial/DPair.md:713 ../src/Tutorial/Eq.md:74
#: ../src/Tutorial/Eq.md:93 ../src/Tutorial/Eq.md:153 ../src/Tutorial/Eq.md:397
#: ../src/Tutorial/Eq.md:404 ../src/Tutorial/Eq.md:436
#: ../src/Tutorial/Eq.md:505 ../src/Tutorial/Eq.md:518
#: ../src/Tutorial/Eq.md:679 ../src/Tutorial/Eq.md:778
#: ../src/Tutorial/Eq.md:984 ../src/Tutorial/Eq.md:1014
#: ../src/Tutorial/Folds.md:198 ../src/Tutorial/Folds.md:787
#: ../src/Tutorial/Folds.md:798 ../src/Tutorial/Folds.md:822
#: ../src/Tutorial/Folds.md:839 ../src/Tutorial/Folds.md:880
#: ../src/Tutorial/Folds.md:904 ../src/Tutorial/Functions1.md:37
#: ../src/Tutorial/Functions1.md:143 ../src/Tutorial/Functions1.md:165
#: ../src/Tutorial/Functions1.md:204 ../src/Tutorial/Functions1.md:228
#: ../src/Tutorial/Functions1.md:253 ../src/Tutorial/Functions1.md:261
#: ../src/Tutorial/Functions1.md:312 ../src/Tutorial/Functions1.md:333
#: ../src/Tutorial/Functions1.md:358 ../src/Tutorial/Functions1.md:366
#: ../src/Tutorial/Functions1.md:378 ../src/Tutorial/Functions1.md:488
#: ../src/Tutorial/Functions1.md:519 ../src/Tutorial/Functions1.md:568
#: ../src/Tutorial/Functions2.md:42 ../src/Tutorial/Functions2.md:63
#: ../src/Tutorial/Functions2.md:74 ../src/Tutorial/Functions2.md:114
#: ../src/Tutorial/Functions2.md:528 ../src/Tutorial/Functions2.md:541
#: ../src/Tutorial/Functions2.md:553 ../src/Tutorial/Functions2.md:560
#: ../src/Tutorial/Functions2.md:567 ../src/Tutorial/Functions2.md:719
#: ../src/Tutorial/Functions2.md:726 ../src/Tutorial/Functions2.md:735
#: ../src/Tutorial/Functions2.md:755 ../src/Tutorial/Functions2.md:763
#: ../src/Tutorial/Functions2.md:787 ../src/Tutorial/Functions2.md:811
#: ../src/Tutorial/Functions2.md:819 ../src/Tutorial/Functions2.md:835
#: ../src/Tutorial/Functions2.md:848 ../src/Tutorial/Functions2.md:899
#: ../src/Tutorial/Functor.md:187 ../src/Tutorial/Functor.md:201
#: ../src/Tutorial/Functor.md:216 ../src/Tutorial/Functor.md:610
#: ../src/Tutorial/Functor.md:801 ../src/Tutorial/Functor.md:903
#: ../src/Tutorial/Functor.md:1001 ../src/Tutorial/Functor.md:1100
#: ../src/Tutorial/Functor.md:1167 ../src/Tutorial/Functor.md:1219
#: ../src/Tutorial/Interfaces.md:36 ../src/Tutorial/Interfaces.md:140
#: ../src/Tutorial/Interfaces.md:505 ../src/Tutorial/Intro.md:122
#: ../src/Tutorial/Intro.md:134 ../src/Tutorial/Intro.md:148
#: ../src/Tutorial/Intro.md:158 ../src/Tutorial/Intro.md:167
#: ../src/Tutorial/Intro.md:227 ../src/Tutorial/Intro.md:270
#: ../src/Tutorial/Intro.md:279 ../src/Tutorial/Intro.md:300
#: ../src/Tutorial/Intro.md:326 ../src/Tutorial/Intro.md:337
#: ../src/Tutorial/Intro.md:349 ../src/Tutorial/IO.md:33
#: ../src/Tutorial/IO.md:94 ../src/Tutorial/IO.md:433 ../src/Tutorial/IO.md:442
#: ../src/Tutorial/IO.md:539 ../src/Tutorial/IO.md:621
#: ../src/Tutorial/IO.md:634 ../src/Tutorial/IO.md:1020
#: ../src/Tutorial/IO.md:1040 ../src/Tutorial/IO.md:1050
#: ../src/Tutorial/IO.md:1060 ../src/Tutorial/Predicates.md:428
#: ../src/Tutorial/Predicates.md:462 ../src/Tutorial/Predicates.md:926
#: ../src/Tutorial/Predicates.md:1337 ../src/Tutorial/Prim.md:124
#: ../src/Tutorial/Prim.md:312 ../src/Tutorial/Prim.md:527
#: ../src/Tutorial/Prim.md:550 ../src/Tutorial/Prim.md:574
#: ../src/Tutorial/Prim.md:584 ../src/Tutorial/Prim.md:596
#: ../src/Tutorial/Prim.md:611 ../src/Tutorial/Prim.md:622
#: ../src/Tutorial/Prim.md:638 ../src/Tutorial/Prim.md:647
#: ../src/Tutorial/Prim.md:703 ../src/Tutorial/Prim.md:1129
#: ../src/Tutorial/Traverse.md:38 ../src/Tutorial/Traverse.md:123
#: ../src/Tutorial/Traverse.md:158 ../src/Tutorial/Traverse.md:421
#: ../src/Tutorial/Traverse.md:737 ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid "repl"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:962
#: ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:712
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1232
#: ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:936
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085
#: ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524
#: ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1395
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1098
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Predicates.md:1369 ../src/Tutorial/Prim.md:1411
#: ../src/Tutorial/Traverse.md:1148
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2\n"
"-->\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Folds.md:996
#: ../src/Tutorial/Functor.md:417 ../src/Tutorial/Traverse.md:285
#, no-wrap
msgid ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Folds.md:1
#, no-wrap
msgid "Recursion and Folds"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:12
#, no-wrap
msgid ""
"In this chapter, we are going to have a closer look at the\n"
"computations we typically perform with *container types*:\n"
"Parameterized data types like `List`, `Maybe`, or\n"
"`Identity`, holding zero or more values of the parameter's\n"
"type. Many of these functions are recursive in nature,\n"
"so we start with a discourse about recursion in general,\n"
"and tail recursion as an important optimization technique\n"
"in particular. Most recursive functions in this part\n"
"will describe pure iterations over lists.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:17
#, no-wrap
msgid ""
"It is recursive functions, for which totality is hard\n"
"to determine, so we will next have a quick look at the\n"
"totality checker and learn, when it will refuse to\n"
"accept a function as being total and what to do about this.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:22
#, no-wrap
msgid ""
"Finally, we will start looking for common patterns in\n"
"the recursive functions from the first part and will\n"
"eventually introduce a new interface for consuming\n"
"container types: Interface `Foldable`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:23
#, no-wrap
msgid ""
"module Tutorial.Folds\n"
"\n"
"import Data.List1\n"
"import Data.Maybe\n"
"import Data.Vect\n"
"import Debug.Trace\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Folds.md:34
#, no-wrap
msgid "Recursion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:38
#, no-wrap
msgid ""
"In this section, we are going to have a closer look at\n"
"recursion in general and at tail recursion in particular.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:47
#, no-wrap
msgid ""
"Recursive functions are functions, which call themselves\n"
"to repeat a task or calculation until a certain aborting\n"
"condition (called the *base case*) holds.\n"
"Please note, that it is recursive functions, which\n"
"make it hard to verify totality: Non-recursive functions,\n"
"which are *covering* (they cover all possible cases in their\n"
"pattern matches) are automatically total if they only invoke\n"
"other total functions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:50
#, no-wrap
msgid ""
"Here is an example of a recursive function: It generates\n"
"a list of the given length filling it with identical values:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:51
#, no-wrap
msgid ""
"replicateList : Nat -> a -> List a\n"
"replicateList 0     _ = []\n"
"replicateList (S k) x = x :: replicateList k x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:63
#, no-wrap
msgid ""
"As you can see (this module has the `%default total` pragma at the top),\n"
"this function is provably total. Idris verifies, that the `Nat` argument\n"
"gets *strictly smaller* in each recursive call, and that therefore, the\n"
"function *must* eventually come to an end. Of course, we can do the\n"
"same thing for `Vect`, where we can even show that the length of the\n"
"resulting vector matches the given natural number:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:64
#, no-wrap
msgid ""
"replicateVect : (n : Nat) -> a -> Vect n a\n"
"replicateVect 0     _ = []\n"
"replicateVect (S k) x = x :: replicateVect k x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:73
#, no-wrap
msgid ""
"While we often use recursion to *create* values of data types like\n"
"`List` or `Vect`, we also use recursion, when we *consume* such values.\n"
"For instance, here is a function for calculating the length of a list:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:74
#, no-wrap
msgid ""
"len : List a -> Nat\n"
"len []        = 0\n"
"len (_ :: xs) = 1 + len xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:82
#, no-wrap
msgid ""
"Again, Idris can verify that `len` is total, as the list we pass in\n"
"the recursive case is strictly smaller than the original list argument.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:88
#, no-wrap
msgid ""
"But when is a recursive function non-total? Here is an example: The\n"
"following function creates a sequence of values until the given\n"
"generation function (`gen`) returns a `Nothing`. Note, how we use\n"
"a *state* value (of generic type `s`) and use `gen` to calculate\n"
"a value together with the next state:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:89
#, no-wrap
msgid ""
"covering\n"
"unfold : (gen : s -> Maybe (s,a)) -> s -> List a\n"
"unfold gen vs = case gen vs of\n"
"  Just (vs',va) => va :: unfold gen vs'\n"
"  Nothing       => []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:103
#, no-wrap
msgid ""
"With `unfold`, Idris can't verify that any of its arguments is\n"
"converging towards the base case. It therefore rightfully\n"
"refuses to accept that `unfold` is total. And indeed, the following\n"
"function produces an infinite list (so please, don't try to inspect\n"
"this at the REPL, as doing so will consume all your computer's\n"
"memory):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:104
#, no-wrap
msgid ""
"fiboHelper : (Nat,Nat) -> ((Nat,Nat),Nat)\n"
"fiboHelper (f0,f1) = ((f1, f0 + f1), f0)\n"
"\n"
"covering\n"
"fibonacci : List Nat\n"
"fibonacci = unfold (Just . fiboHelper) (1,1)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:117
#, no-wrap
msgid ""
"In order to safely create a (finite) sequence of Fibonacci numbers,\n"
"we need to make sure the function generating the sequence will\n"
"stop after a finite number of steps, for instance by limiting\n"
"the length of the list:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:118
#, no-wrap
msgid ""
"unfoldTot : Nat -> (gen : s -> Maybe (s,a)) -> s -> List a\n"
"unfoldTot 0     _   _  = []\n"
"unfoldTot (S k) gen vs = case gen vs of\n"
"  Just (vs',va) => va :: unfoldTot k gen vs'\n"
"  Nothing       => []\n"
"\n"
"fibonacciN : Nat -> List Nat\n"
"fibonacciN n = unfoldTot n (Just . fiboHelper) (1,1)\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:129
#, no-wrap
msgid "The Call Stack"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:133
#, no-wrap
msgid ""
"In order to demonstrate what tail recursion is about, we require\n"
"the following `main` function:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:134
#, no-wrap
msgid ""
"main : IO ()\n"
"main = printLn . len $ replicateList 10000 10\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:144
#, no-wrap
msgid ""
"If you have [Node.js](https://nodejs.org/en/) installed on your system,\n"
"you might try the following experiment. Compile and run this\n"
"module using the *Node.js* backend of Idris instead of the default\n"
"*Chez Scheme* backend and run the resulting JavaScript source file\n"
"with the Node.js binary:\n"
msgstr ""

#. type: Code fence info string
#: ../src/Tutorial/Folds.md:145 ../src/Tutorial/Folds.md:241
#: ../src/Tutorial/Folds.md:326 ../src/Tutorial/Folds.md:582
#: ../src/Tutorial/Intro.md:199 ../src/Tutorial/Intro.md:208
#: ../src/Tutorial/Intro.md:223 ../src/Tutorial/Prim.md:38
#, no-wrap
msgid "sh"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:145
#, no-wrap
msgid ""
"idris2 --cg node -o test.js --find-ipkg -src/Tutorial/Folds.md\n"
"node build/exec/test.js\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:154
#, no-wrap
msgid ""
"Node.js will fail with the following error message and a lengthy\n"
"stack trace: `RangeError: Maximum call stack size exceeded`.\n"
"What's going on here? How can it be that `main` fails with an\n"
"exception although it is provably total?\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:169
#, no-wrap
msgid ""
"First, remember that a function\n"
"being total means that it will eventually produce a value\n"
"of the given type in a finite amount of time, *given\n"
"enough resources like computer memory*. Here, `main` hasn't\n"
"been given enough resources as Node.js has a very small size\n"
"limit on its call stack. The *call stack* can be thought\n"
"of as a stack data structure (first in, last out), where\n"
"nested function calls are put. In case of recursive functions,\n"
"the stack size increases by one with every recursive function\n"
"call. In case of our `main` function, we create and consume\n"
"a list of length 10'000, so the call stack will hold\n"
"at least 10'000 function calls before they are being invoked\n"
"and the stack's size is reduced again. This exceeds Node.js's\n"
"stack size limit by far, hence the overflow error.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:180
#, no-wrap
msgid ""
"Now, before we look at a solution how to circumvent this issue,\n"
"please note that this is a very serious and limiting source of\n"
"bugs when using the JavaScript backends of Idris. In Idris, having no\n"
"access to control structures like `for` or `while` loops, we *always*\n"
"have to resort to recursion in order to describe iterative\n"
"computations. Luckily (or should I say \"unfortunately\", since otherwise\n"
"this issue would already have been addressed with all seriousness),\n"
"the Scheme backends don't have this issue, as their stack size\n"
"limit is much larger and they perform all kinds of optimizations\n"
"internally to prevent the call stack from overflowing.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:181
#, no-wrap
msgid "Tail Recursion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:187
#, no-wrap
msgid ""
"A recursive function is said to be *tail recursive*, if\n"
"all recursive calls occur at *tail position*: The last\n"
"function call in a (sub)expression. For instance, the following\n"
"version of `len` is tail recursive:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:188
#, no-wrap
msgid ""
"lenOnto : Nat -> List a -> Nat\n"
"lenOnto k []        = k\n"
"lenOnto k (_ :: xs) = lenOnto (k + 1) xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:197
#, no-wrap
msgid ""
"Compare this to `len` as defined above: There, the last\n"
"function call is an invocation of operator `(+)`, and\n"
"the recursive call happens in one of its arguments:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:198
#, no-wrap
msgid "len (_ :: xs) = 1 + len xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:204
#, no-wrap
msgid ""
"We can use `lenOnto` as a utility to implement a tail recursive\n"
"version of `len` without the additional `Nat` argument:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:205
#, no-wrap
msgid ""
"lenTR : List a -> Nat\n"
"lenTR = lenOnto 0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:215
#, no-wrap
msgid ""
"This is a common pattern when writing tail recursive functions:\n"
"We typically add an additional function argument for accumulating\n"
"intermediary results, which is then passed on explicitly at each\n"
"recursive call. For instance, here is a tail recursive version\n"
"of `replicateList`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:216
#, no-wrap
msgid ""
"replicateListTR : Nat -> a -> List a\n"
"replicateListTR n v = go Nil n\n"
"  where go : List a -> Nat -> List a\n"
"        go xs 0     = xs\n"
"        go xs (S k) = go (v :: xs) k\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:229
#, no-wrap
msgid ""
"The big advantage of tail recursive functions is, that they\n"
"can be easily converted to efficient, imperative loops by the Idris\n"
"compiler, and are thus *stack safe*: Recursive function calls\n"
"are *not* added to the call stack, thus avoiding the dreaded\n"
"stack overflow errors.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:230
#, no-wrap
msgid ""
"main1 : IO ()\n"
"main1 = printLn . lenTR $ replicateListTR 10000 10\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:240
#, no-wrap
msgid ""
"We can again run `main1` using the *Node.js* backend. This time,\n"
"we use slightly different syntax to execute a function other than\n"
"`main` (Remember: The dollar prefix is only there to distinghish\n"
"a terminal command from its output. It is not part of the\n"
"command you enter in a terminal sesssion.):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:241
#, no-wrap
msgid ""
"$ idris2 --cg node --exec main1 --find-ipkg src/Tutorial/Folds.md\n"
"10000\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:248
#, no-wrap
msgid ""
"As you can see, this time the computation finished without\n"
"overflowing the call stack.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:253
#, no-wrap
msgid ""
"Tail recursive functions are allowed to consist of\n"
"(possibly nested) pattern matches, with recursive\n"
"calls at tail position in several of the branches.\n"
"Here is an example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:254
#, no-wrap
msgid ""
"countTR : (a -> Bool) -> List a -> Nat\n"
"countTR p = go 0\n"
"  where go : Nat -> List a -> Nat\n"
"        go k []        = k\n"
"        go k (x :: xs) = case p x of\n"
"          True  => go (S k) xs\n"
"          False => go k xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:266
#, no-wrap
msgid ""
"Note, how each invocation of `go` is in tail position in\n"
"its branch of the case expression.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:267
#, no-wrap
msgid "Mutual Recursion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:281
#, no-wrap
msgid ""
"It is sometimes convenient to implement several related\n"
"functions, which call each other recursively. In Idris,\n"
"unlike in many other programming languages,\n"
"a function must be declared in a source file\n"
"*before* it can be called by other functions, as in general\n"
"a function's implementation must\n"
"be available during type checking (because Idris has\n"
"dependent types). There are two ways around this, which\n"
"actually result in the same internal representation in the\n"
"compiler. Our first option is to write down the functions' declarations\n"
"first with the implementations following after. Here's a\n"
"silly example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:282
#, no-wrap
msgid ""
"even : Nat -> Bool\n"
"\n"
"odd : Nat -> Bool\n"
"\n"
"even 0     = True\n"
"even (S k) = odd k\n"
"\n"
"odd 0     = False\n"
"odd (S k) = even k\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:297
#, no-wrap
msgid ""
"As you can see, function `even` is allowed to call function `odd` in\n"
"its implementation, since `odd` has already been declared (but not yet\n"
"implemented).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:302
#, no-wrap
msgid ""
"If you're like me and want to keep declarations and implementations\n"
"next to each other, you can introduce a `mutual` block, which has\n"
"the same effect. Like with other code blocks, functions in a `mutual`\n"
"block must all be indented by the same amount of whitespace:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:303
#, no-wrap
msgid ""
"mutual\n"
"  even' : Nat -> Bool\n"
"  even' 0     = True\n"
"  even' (S k) = odd' k\n"
"\n"
"  odd' : Nat -> Bool\n"
"  odd' 0     = False\n"
"  odd' (S k) = even' k\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:319
#, no-wrap
msgid ""
"Just like with single recursive functions, mutually recursive\n"
"functions can be optimized to imperative loops if all\n"
"recursive calls occur at tail position. This is the case\n"
"with functions `even` and `odd`, as can again be\n"
"verified at the *Node.js* backend:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:320
#, no-wrap
msgid ""
"main2 : IO ()\n"
"main2 =  printLn (even 100000)\n"
"      >> printLn (odd 100000)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:326
#, no-wrap
msgid ""
"$ idris2 --cg node --exec main2 --find-ipkg src/Tutorial/Folds.md\n"
"True\n"
"False\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:332
#, no-wrap
msgid "Final Remarks"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:336
#, no-wrap
msgid ""
"In this section, we learned about several important aspects\n"
"of recursion and totality checking, which are summarized here:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:339
msgid ""
"In pure functional programming, recursion is the way to implement iterative "
"procedures."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:343
msgid ""
"Recursive functions pass the totality checker, if it can verify that one of "
"the arguments is getting strictly smaller in every recursive function call."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:346
msgid ""
"Arbitrary recursion can lead to stack overflow exceptions on backends with "
"small stack size limits."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:350
msgid ""
"The JavaScript backends of Idris perform mutual tail call optimization: Tail "
"recursive functions are converted to stack safe, imperative loops."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:354
#, no-wrap
msgid ""
"Note, that not all Idris backends you will come across in the wild\n"
"will perform tail call optimization. Please check the corresponding\n"
"documentation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:372
#, no-wrap
msgid ""
"Note also, that most recursive functions in the core libraries (*prelude*\n"
"and *base*) do not yet make use of tail recursion. There is an\n"
"important reason for this: In many cases, non-tail recursive\n"
"functions are easier to use in compile-time proofs, as they\n"
"unify more naturally than their tail recursive counterparts.\n"
"Compile-time proofs are an important aspect of programming\n"
"in Idris (as we will see in later chapters), so there is a\n"
"compromise to be made between what performs well at runtime\n"
"and what works well at compile time. Eventually, the way\n"
"to go might be to provide two implementations for most\n"
"recursive functions with a *transform rule* telling the\n"
"compiler to use the optimized version at runtime whenever\n"
"programmers use the non-optimized version in their code.\n"
"Such transform rules have - for instance - already been\n"
"written for functions `pack` and `unpack` (which use\n"
"`fastPack` and `fastUnpack` at runtime; see the corresponding\n"
"rules in [the following source file](https://github.com/idris-lang/Idris2/blob/main/libs/prelude/Prelude/Types.idr)).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:379
#, no-wrap
msgid ""
"In these exercises you are going to implement several\n"
"recursive functions. Make sure to use tail recursion\n"
"whenever possible and quickly verify the correct\n"
"behavior of all functions at the REPL.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Folds.md:383
msgid ""
"Implement functions `anyList` and `allList`, which return `True` if any "
"element (or all elements in case of `allList`) in a list fulfills the given "
"predicate:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:384
#, no-wrap
msgid ""
"   anyList : (a -> Bool) -> List a -> Bool\n"
"\n"
"   allList : (a -> Bool) -> List a -> Bool\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:392
msgid ""
"Implement function `findList`, which returns the first value (if any) "
"fulfilling the given predicate:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:393
#, no-wrap
msgid "   findList : (a -> Bool) -> List a -> Maybe a\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:399
msgid ""
"Implement function `collectList`, which returns the first value (if any), "
"for which the given function returns a `Just`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:400
#, no-wrap
msgid "   collectList : (a -> Maybe b) -> List a -> Maybe b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:405
#, no-wrap
msgid "   Implement `lookupList` in terms of `collectList`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:406
#, no-wrap
msgid "   lookupList : Eq a => a -> List (a,b) -> Maybe b\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:423
msgid ""
"For functions like `map` or `filter`, which must loop over a list without "
"affecting the order of elements, it is harder to write a tail recursive "
"implementation.  The safest way to do so is by using a `SnocList` (a "
"*reverse* kind of list that's built from head to tail instead of from tail "
"to head) to accumulate intermediate results. Its two constructors are `Lin` "
"and `(:<)` (called the *snoc* operator).  Module `Data.SnocList` exports two "
"tail recursive operators called *fish* and *chips* (`(<><)` and `(<>>)`) for "
"going from `SnocList` to `List` and vice versa. Have a look at the types of "
"all new data constructors and operators before continuing with the exercise."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:428
#, no-wrap
msgid ""
"   Implement a tail recursive version of `map` for `List`\n"
"   by using a `SnocList` to reassemble the mapped list. Use then\n"
"   the *chips* operator with a `Nil` argument to\n"
"   in the end convert the `SnocList` back to a `List`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:429
#, no-wrap
msgid "   mapTR : (a -> b) -> List a -> List b\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:437
msgid ""
"Implement a tail recursive version of `filter`, which only keeps those "
"values in a list, which fulfill the given predicate. Use the same technique "
"as described in exercise 4."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:438
#, no-wrap
msgid "   filterTR : (a -> Bool) -> List a -> List a\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Folds.md:445
msgid ""
"Implement a tail recursive version of `mapMaybe`, which only keeps those "
"values in a list, for which the given function argument returns a `Just`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:446
#, no-wrap
msgid "   mapMaybeTR : (a -> Maybe b) -> List a -> List b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:451
#, no-wrap
msgid "   Implement `catMaybesTR` in terms of `mapMaybeTR`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:452
#, no-wrap
msgid "   catMaybesTR : List (Maybe a) -> List a\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Folds.md:457
msgid "Implement a tail recursive version of list concatenation:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:458
#, no-wrap
msgid "   concatTR : List a -> List a -> List a\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Folds.md:464
msgid "Implement tail recursive versions of *bind* and `join` for `List`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:465
#, no-wrap
msgid ""
"   bindTR : List a -> (a -> List b) -> List b\n"
"\n"
"   joinTR : List (List a) -> List a\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Folds.md:471
#, no-wrap
msgid "A few Notes on Totality Checking"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:482
#, no-wrap
msgid ""
"The totality checker in Idris verifies, that at least one\n"
"(possibly erased!) argument in a recursive call converges towards\n"
"a base case. For instance, with natural numbers, if the base case\n"
"is zero (corresponding to data constructor `Z`), and we continue\n"
"with `k` after pattern matching on `S k`, Idris can derive from\n"
"`Nat`'s constructors, that `k` is strictly smaller than `S k`\n"
"and therefore the recursive call must converge towards a base case.\n"
"Exactly the same reasoning is used when pattern matching on a list\n"
"and continuing only with its tail in the recursive call.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:487
#, no-wrap
msgid ""
"While this works in many cases, it doesn't always go as expected.\n"
"Below, I'll show you a couple of examples where totality checking\n"
"fails, although *we* know, that the functions in question are definitely\n"
"total.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:488
#, no-wrap
msgid "Case 1: Recursion over a Primitive"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:494
#, no-wrap
msgid ""
"Idris doesn't know anything about the internal structure of\n"
"primitive data types. So the following function, although\n"
"being obviously total, will not be accepted by the totality\n"
"checker:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:495
#, no-wrap
msgid ""
"covering\n"
"replicatePrim : Bits32 -> a -> List a\n"
"replicatePrim 0 v = []\n"
"replicatePrim x v = v :: replicatePrim (x - 1) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:514
#, no-wrap
msgid ""
"Unlike with natural numbers (`Nat`), which are defined as an inductive\n"
"data type and are only converted to integer primitives during compilation,\n"
"Idris can't tell that `x - 1` is strictly smaller than `x`, and so it\n"
"fails to verify that this must converge towards the base case.\n"
"(The reason is, that `x - 1` is implemented in terms of primitive\n"
"function `prim__sub_Bits32`, which is built into the compiler and\n"
"must be implemented by each backend individually. The totality\n"
"checker knows about data types, constructors, and functions\n"
"defined in Idris, but not about (primitive) functions and foreign functions\n"
"implemented at the backends. While it is theoretically possible to\n"
"also define and use laws for primitive and foreign functions, this hasn't yet\n"
"been done for most of them.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:520
#, no-wrap
msgid ""
"Since non-totality is highly contagious (all functions invoking a\n"
"partial function are themselves considered to be partial by the\n"
"totality checker), there is utility function `assert_smaller`, which\n"
"we can use to convince the totality checker and still annotate our\n"
"functions with the `total` keyword:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:521
#, no-wrap
msgid ""
"replicatePrim' : Bits32 -> a -> List a\n"
"replicatePrim' 0 v = []\n"
"replicatePrim' x v = v :: replicatePrim' (assert_smaller x $ x - 1) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:532
#, no-wrap
msgid ""
"Please note, though, that whenever you use `assert_smaller` to\n"
"silence the totality checker, the burden of proving totality rests\n"
"on your shoulders. Failing to do so can lead to arbitrary and\n"
"unpredictable program behavior (which is the default with most\n"
"other programming languages).\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Folds.md:533
#, no-wrap
msgid "Ex Falso Quodlibet"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:543
#, no-wrap
msgid ""
"Below - as a demonstration - is a simple proof of `Void`.\n"
"`Void` is an *uninhabited type*: a type with no values.\n"
"*Proofing `Void`* means, that we implement a function accepted\n"
"by the totality checker, which returns a value of type `Void`,\n"
"although this is supposed to be impossible as there is no\n"
"such value. Doing so allows us to completely\n"
"disable the type system together with all the guarantees it provides.\n"
"Here's the code and its dire consequences:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:544
#, no-wrap
msgid ""
"-- In order to proof `Void`, we just loop forever, using\n"
"-- `assert_smaller` to silence the totality checker.\n"
"proofOfVoid : Bits8 -> Void\n"
"proofOfVoid n = proofOfVoid (assert_smaller n n)\n"
"\n"
"-- From a value of type `Void`, anything follows!\n"
"-- This function is safe and total, as there is no\n"
"-- value of type `Void`!\n"
"exFalsoQuodlibet : Void -> a\n"
"exFalsoQuodlibet _ impossible\n"
"\n"
"-- By passing our proof of void to `exFalsoQuodlibet`\n"
"-- (exported by the *Prelude* by the name of `void`), we\n"
"-- can coerce any value to a value of any other type.\n"
"-- This renders type checking completely useless, as\n"
"-- we can freely convert between values of different\n"
"-- types.\n"
"coerce : a -> b\n"
"coerce _ = exFalsoQuodlibet (proofOfVoid 0)\n"
"\n"
"-- Finally, we invoke `putStrLn` with a number instead\n"
"-- of a string. `coerce` allows us to do just that.\n"
"pain : IO ()\n"
"pain = putStrLn $ coerce 0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:576
#, no-wrap
msgid ""
"Please take a moment to marvel at provably total function `coerce`:\n"
"It claims to convert *any* value to a value of *any* other type.\n"
"And it is completely safe, as it only uses total functions in its\n"
"implementation. The problem is - of course - that `proofOfVoid` should\n"
"never ever have been a total function.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:581
#, no-wrap
msgid ""
"In `pain` we use `coerce` to conjure a string from an integer.\n"
"In the end, we get what we deserve: The program crashes with an error.\n"
"While things could have been much worse, it can still be quite\n"
"time consuming and annoying to localize the source of such an error.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:582
#, no-wrap
msgid ""
"$ idris2 --cg node --exec pain --find-ipkg src/Tutorial/Folds.md\n"
"ERROR: No clauses\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:590
#, no-wrap
msgid ""
"So, with a single thoughtless placement of `assert_smaller` we wrought\n"
"havoc within our pure and total codebase sacrificing totality and\n"
"type safety in one fell swoop. Therefore: Use at your own risk!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:594
#, no-wrap
msgid ""
"Note: I do not expect you to understand all the dark magic at\n"
"work in the code above. I'll explain the details in due time\n"
"in another chapter.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:602
#, no-wrap
msgid ""
"Second note: *Ex falso quodlibet*, also called\n"
"[the principle of explosion](https://en.wikipedia.org/wiki/Principle_of_explosion)\n"
"is a law in classical logic: From a contradiction, any statement can be proven.\n"
"In our case, the contradiction was our proof of `Void`: The claim that we wrote\n"
"a total function producing such a value, although `Void` is an uninhabited type.\n"
"You can verify this by inspecting `Void` at the REPL with `:doc Void`: It\n"
"has no data constructors.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:603
#, no-wrap
msgid "Case 2: Recursion via Function Calls"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:608
#, no-wrap
msgid ""
"Below is an implementation of a [*rose tree*](https://en.wikipedia.org/wiki/Rose_tree).\n"
"Rose trees can represent search paths in computer algorithms,\n"
"for instance in graph theory.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:609
#, no-wrap
msgid ""
"record Tree a where\n"
"  constructor Node\n"
"  value  : a\n"
"  forest : List (Tree a)\n"
"\n"
"Forest : Type -> Type\n"
"Forest = List . Tree\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:620
#, no-wrap
msgid "We could try and compute the size of such a tree as follows:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:621
#, no-wrap
msgid ""
"covering\n"
"size : Tree a -> Nat\n"
"size (Node _ forest) = S . sum $ map size forest\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:632
#, no-wrap
msgid ""
"In the code above, the recursive call happens within `map`. *We* know that\n"
"we are using only subtrees in the recursive calls (since we know how `map`\n"
"is implemented for `List`), but Idris can't know this (teaching a totality\n"
"checker how to figure this out on its own seems to be an open research\n"
"question). So it will refuse to accept the function as being total.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:637
#, no-wrap
msgid ""
"There are two ways to handle the case above. If we don't mind writing\n"
"a bit of otherwise unneeded boilerplate code, we can use explicit recursion.\n"
"In fact, since we often also work with search *forests*, this is\n"
"the preferable way here.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:638
#, no-wrap
msgid ""
"mutual\n"
"  treeSize : Tree a -> Nat\n"
"  treeSize (Node _ forest) = S $ forestSize forest\n"
"\n"
"  forestSize : Forest a -> Nat\n"
"  forestSize []        = 0\n"
"  forestSize (x :: xs) = treeSize x + forestSize xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:652
#, no-wrap
msgid ""
"In the case above, Idris can verify that we don't blow up our trees behind\n"
"its back as we are explicit about what happens in each recursive step.\n"
"This is the safe, preferable way of going about this, especially if you are\n"
"new to the language and totality checking in general.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:655
#, no-wrap
msgid ""
"However, sometimes the solution presented above is just too cumbersome to\n"
"write. For instance, here is an implementation of `Show` for rose trees:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:656
#, no-wrap
msgid ""
"Show a => Show (Tree a) where\n"
"  showPrec p (Node v ts) =\n"
"    assert_total $ showCon p \"Node\" (showArg v ++ showArg ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:667
#, no-wrap
msgid ""
"In this case, we'd have to manually reimplement `Show` for lists of trees:\n"
"A tedious task - and error-prone on its own. Instead, we resort to using the\n"
"mighty sledgehammer of totality checking: `assert_total`. Needless to say\n"
"that this comes with the same risks as `assert_smaller`, so be very\n"
"careful.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:673
#, no-wrap
msgid ""
"Implement the following functions in a provably total\n"
"way without \"cheating\". Note: It is not necessary to\n"
"implement these in a tail recursive way.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:682
#, no-wrap
msgid ""
"<!-- textlint-disable terminology -->\n"
"1. Implement function `depth` for rose trees. This\n"
"   should return the maximal number of `Node` constructors\n"
"   from the current node to the farthest child node.\n"
"   For instance, the current node should be at depth one,\n"
"   all its direct child nodes are at depth two, their\n"
"   immediate child nodes at depth three and so on.\n"
"<!-- textlint-enable -->\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:684
msgid "Implement interface `Eq` for rose trees."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:686
msgid "Implement interface `Functor` for rose trees."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:688
msgid "For the fun of it: Implement interface `Show` for rose trees."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:692
msgid ""
"In order not to forget how to program with dependent types, implement "
"function `treeToVect` for converting a rose tree to a vector of the correct "
"size."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:696
#, no-wrap
msgid ""
"   Hint: Make sure to follow the same recursion scheme as in\n"
"   the implementation of `treeSize`. Otherwise, this might be\n"
"   very hard to get to work.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Folds.md:697
#, no-wrap
msgid "Interface Foldable"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:707
#, no-wrap
msgid ""
"When looking back at all the exercises we solved\n"
"in the section about recursion, most tail recursive functions\n"
"on lists were of the following pattern: Iterate\n"
"over all list elements from head to tail while\n"
"passing along some state for accumulating intermediate\n"
"results. At the end of the list,\n"
"return the final state or convert it with an\n"
"additional function call.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:708
#, no-wrap
msgid "Left Folds"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:719
#, no-wrap
msgid ""
"This is functional programming, and we'd like to abstract\n"
"over such reoccurring patterns. In order to tail recursively\n"
"iterate over a list, all we need is an accumulator function\n"
"and some initial state. But what should be the type of\n"
"the accumulator? Well, it combines the current state\n"
"with the list's next element and returns an updated\n"
"state: `state -> elem -> state`. Surely, we can come\n"
"up with a higher-order function to encapsulate this\n"
"behavior:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:720
#, no-wrap
msgid ""
"leftFold : (acc : state -> el -> state) -> (st : state) -> List el -> state\n"
"leftFold _   st []        = st\n"
"leftFold acc st (x :: xs) = leftFold acc (acc st x) xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:734
#, no-wrap
msgid ""
"We call this function a *left fold*, as it iterates over\n"
"the list from left to right (head to tail), collapsing (or\n"
"*folding*) the list until just a single value remains.\n"
"This new value might still be a list or other container type,\n"
"but the original list has been consumed from head to tail.\n"
"Note how `leftFold` is tail recursive, and therefore all\n"
"functions implemented in terms of `leftFold` are\n"
"tail recursive (and thus, stack safe!) as well.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:736
#, no-wrap
msgid "Here are a few examples:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:737
#, no-wrap
msgid ""
"sumLF : Num a => List a -> a\n"
"sumLF = leftFold (+) 0\n"
"\n"
"reverseLF : List a -> List a\n"
"reverseLF = leftFold (flip (::)) Nil\n"
"\n"
"-- this is more natural than `reverseLF`!\n"
"toSnocListLF : List a -> SnocList a\n"
"toSnocListLF = leftFold (:<) Lin\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:749
#, no-wrap
msgid "Right Folds"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:760
#, no-wrap
msgid ""
"The example functions we implemented in terms of `leftFold` had\n"
"to always completely traverse the whole list, as every single\n"
"element was required to compute the result. This is not always\n"
"necessary, however. For instance, if you look at `findList` from\n"
"the exercises, we could abort iterating over the list as soon\n"
"as our search was successful. It is *not* possible to implement\n"
"this more efficient behavior in terms of `leftFold`: There,\n"
"the result will only be returned when our pattern match reaches\n"
"the `Nil` case.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:765
#, no-wrap
msgid ""
"Interestingly, there is another, non-tail recursive fold, which\n"
"reflects the list structure more naturally, we can use for\n"
"breaking out early from an iteration. We call this a\n"
"*right fold*. Here is its implementation:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:766
#, no-wrap
msgid ""
"rightFold : (acc : el -> state -> state) -> state -> List el -> state\n"
"rightFold acc st []        = st\n"
"rightFold acc st (x :: xs) = acc x (rightFold acc st xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:775
#, no-wrap
msgid ""
"Now, it might not immediately be obvious how this differs from `leftFold`.\n"
"In order to see this, we will have to talk about lazy evaluation\n"
"first.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Folds.md:776
#, no-wrap
msgid "Lazy Evaluation in Idris"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:784
#, no-wrap
msgid ""
"For some computations, it is not necessary to evaluate all function\n"
"arguments in order to return a result. For instance, consider\n"
"boolean operator `(&&)`: If the first argument evaluates to `False`,\n"
"we already know that the result is `False` without even looking at\n"
"the second argument. In such a case, we don't want to unnecessarily evaluate\n"
"the second argument, as this might include a lengthy computation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:786
#, no-wrap
msgid "Consider the following REPL session:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:787
#, no-wrap
msgid ""
"Tutorial.Folds> False && (length [1..10000000000] > 100)\n"
"False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:797
#, no-wrap
msgid ""
"If the second argument were evaluated, this computation would most\n"
"certainly blow up your computer's memory, or at least take a very long\n"
"time to run to completion. However, in this case, the result `False` is\n"
"printed immediately. If you look at the type of `(&&)`, you'll see\n"
"the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:798
#, no-wrap
msgid ""
"Tutorial.Folds> :t (&&)\n"
"Prelude.&& : Bool -> Lazy Bool -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:816
#, no-wrap
msgid ""
"As you can see, the second argument is wrapped in a `Lazy` type\n"
"constructor. This is a built-in type, and the details are handled\n"
"by Idris automatically most of the time. For instance, when passing\n"
"arguments to `(&&)`, we don't have to manually wrap the values in\n"
"some data constructor.\n"
"A lazy function argument will only be evaluated at the moment it\n"
"is *required* in the function's implementation, for instance,\n"
"because it is being pattern matched on, or it is being passed\n"
"as a strict argument to another function. In the implementation\n"
"of `(&&)`, the pattern match happens\n"
"on the first argument, so the second will only be evaluated if\n"
"the first argument is `True` and the second is returned as the function's\n"
"(strict) result.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:821
#, no-wrap
msgid ""
"There are two utility functions for working with lazy evaluation:\n"
"Function `delay` wraps a value in the `Lazy` data type. Note, that\n"
"the argument of `delay` is strict, so the following might take\n"
"several seconds to print its result:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:822
#, no-wrap
msgid ""
"Tutorial.Folds> False && (delay $ length [1..10000] > 100)\n"
"False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:829
#, no-wrap
msgid ""
"In addition, there is function `force`, which forces evaluation\n"
"of a `Lazy` value.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Folds.md:830
#, no-wrap
msgid "Lazy Evaluation and Right Folds"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:838
#, no-wrap
msgid ""
"We will now learn how to make use of `rightFold` and lazy evaluation\n"
"to implement folds, which can break out from iteration early.\n"
"Note, that in the implementation of `rightFold` the result of\n"
"folding over the remainder of the list is passed as an argument\n"
"to the accumulator (instead of the result of invoking the accumulator\n"
"being used in the recursive call):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:839
#, no-wrap
msgid "rightFold acc st (x :: xs) = acc x (rightFold acc st xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:846
#, no-wrap
msgid ""
"If the second argument of `acc` were lazily evaluated, it would be possible\n"
"to abort the computation of `acc`'s result without having to iterate\n"
"till the end of the list:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:847
#, no-wrap
msgid ""
"foldHead : List a -> Maybe a\n"
"foldHead = force . rightFold first Nothing\n"
"  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)\n"
"        first v _ = Just v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:858
#, no-wrap
msgid ""
"Note, how Idris takes care of the bookkeeping of laziness most of the time. (It\n"
"doesn't handle the curried invocation of `rightFold` correctly, though, so we\n"
"either must pass on the list argument of `foldHead` explicitly, or compose\n"
"the curried function with `force` to get the types right.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:865
#, no-wrap
msgid ""
"In order to verify that this works correctly, we need a debugging utility\n"
"called `trace` from module `Debug.Trace`. This \"function\" allows us to\n"
"print debugging messages to the console at certain points in our pure\n"
"code. Please note, that this is for debugging purposes only and should\n"
"never be left lying around in production code, as, strictly speaking,\n"
"printing stuff to the console breaks referential transparency.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:868
#, no-wrap
msgid ""
"Here is an adjusted version of `foldHead`, which prints \"folded\" to\n"
"standard output every time utility function `first` is being invoked:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:869
#, no-wrap
msgid ""
"foldHeadTraced : List a -> Maybe a\n"
"foldHeadTraced = force . rightFold first Nothing\n"
"  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)\n"
"        first v _ = trace \"folded\" (Just v)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:879
#, no-wrap
msgid ""
"In order to test this at the REPL, we need to know that `trace` uses `unsafePerformIO`\n"
"internally and therefore will not reduce during evaluation. We have to\n"
"resort to the `:exec` command to see this in action at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:880
#, no-wrap
msgid ""
"Tutorial.Folds> :exec printLn $ foldHeadTraced [1..10]\n"
"folded\n"
"Just 1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:888
#, no-wrap
msgid ""
"As you can see, although the list holds ten elements, `first` is only called\n"
"once resulting in a considerable increase of efficiency.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:891
#, no-wrap
msgid ""
"Let's see what happens, if we change the implementation of `first` to\n"
"use strict evaluation:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:892
#, no-wrap
msgid ""
"foldHeadTracedStrict : List a -> Maybe a\n"
"foldHeadTracedStrict = rightFold first Nothing\n"
"  where first : a -> Maybe a -> Maybe a\n"
"        first v _ = trace \"folded\" (Just v)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:903
#, no-wrap
msgid ""
"Although we don't use the second argument in the implementation of `first`,\n"
"it is still being evaluated before evaluating the body of `first`, because\n"
"Idris - unlike Haskell! - defaults to use strict semantics. Here's how this\n"
"behaves at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:904
#, no-wrap
msgid ""
"Tutorial.Folds> :exec printLn $ foldHeadTracedStrict [1..10]\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"Just 1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:925
#, no-wrap
msgid ""
"While this technique can sometimes lead to very elegant code, always\n"
"remember that `rightFold` is not stack safe in the general case. So,\n"
"unless your accumulator is not guaranteed to return a result after\n"
"not too many iterations, consider implementing your function\n"
"tail recursively with an explicit pattern match. Your code will be\n"
"slightly more verbose, but with the guaranteed benefit of stack safety.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:926
#, no-wrap
msgid "Folds and Monoids"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:934
#, no-wrap
msgid ""
"Left and right folds share a common pattern: In both cases, we start\n"
"with an initial *state* value and use an accumulator function for\n"
"combining the current state with the current element. This principle\n"
"of *combining values* after starting from an *initial value* lies\n"
"at the heart of an interface we've already learned about: `Monoid`.\n"
"It therefore makes sense to fold a list over a monoid:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:935
#, no-wrap
msgid ""
"foldMapList : Monoid m => (a -> m) -> List a -> m\n"
"foldMapList f = leftFold (\\vm,va => vm <+> f va) neutral\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:946
#, no-wrap
msgid ""
"Note how, with `foldMapList`, we no longer need to pass an accumulator\n"
"function. All we need is a conversion from the element type to\n"
"a type with an implementation of `Monoid`. As we have already seen\n"
"in the chapter about [interfaces](Interfaces.md), there are *many*\n"
"monoids in functional programming, and therefore, `foldMapList` is\n"
"an incredibly useful function.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:950
#, no-wrap
msgid ""
"We could make this even shorter: If the elements in our list already\n"
"are of a type with a monoid implementation, we don't even need a\n"
"conversion function to collapse the list:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:951
#, no-wrap
msgid ""
"concatList : Monoid m => List m -> m\n"
"concatList = foldMapList id\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:956
#, no-wrap
msgid "Stop Using `List` for Everything"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:971
#, no-wrap
msgid ""
"And here we are, finally, looking at a large pile of utility functions\n"
"all dealing in some way with the concept of collapsing (or folding)\n"
"a list of values into a single result. But all of these folding functions\n"
"are just as useful when working with vectors, with non-empty lists, with\n"
"rose trees, even with single-value containers like `Maybe`, `Either e`,\n"
"or `Identity`. Heck, for the sake of completeness, they are even useful\n"
"when working with zero-value containers like `Control.Applicative.Const e`!\n"
"And since there are so many of these functions, we'd better look out for\n"
"an essential set of them in terms of which we can implement all\n"
"the others, and wrap up the whole bunch in an interface. This interface\n"
"is called `Foldable`, and is available from the `Prelude`. When you\n"
"look at its definition in the REPL (`:doc Foldable`), you'll see that\n"
"it consists of six essential functions:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`foldr`, for folds from the right"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`foldl`, for folds from the left"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`null`, for testing if the container is empty or not"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`foldlM`, for effectful folds in a monad"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`toList`, for converting the container to a list of values"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`foldMap`, for folding over a monoid"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:987
#, no-wrap
msgid ""
"For a minimal implementation of `Foldable`, it is sufficient to only\n"
"implement `foldr`. However, consider implementing all six functions\n"
"manually, because folds over container types are often performance\n"
"critical operations, and each of them should be optimized accordingly.\n"
"For instance, implementing `toList` in terms of `foldr` for `List`\n"
"just makes no sense, as this is a non-tail recursive function\n"
"running in linear time complexity, while a hand-written implementation\n"
"can just return its argument without any modifications.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:993
#, no-wrap
msgid ""
"In these exercises, you are going to implement `Foldable`\n"
"for different data types. Make sure to try and manually\n"
"implement all six functions of the interface.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Folds.md:995
msgid "Implement `Foldable` for `Crud i`:"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:1005
msgid "Implement `Foldable` for `Response e i`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1006 ../src/Tutorial/Functor.md:429
#: ../src/Tutorial/Traverse.md:295
#, no-wrap
msgid ""
"   data Response : (e, i, a : Type) -> Type where\n"
"     Created : (id : i) -> (value : a) -> Response e i a\n"
"     Updated : (id : i) -> (value : a) -> Response e i a\n"
"     Found   : (values : List a) -> Response e i a\n"
"     Deleted : (id : i) -> Response e i a\n"
"     Error   : (err : e) -> Response e i a\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:1018
msgid ""
"Implement `Foldable` for `List01`. Use tail recursion in the implementations "
"of `toList`, `foldMap`, and `foldl`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/Traverse.md:267
#, no-wrap
msgid ""
"   data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"     Nil  : List01 False a\n"
"     (::) : a -> List01 False a -> List01 ne a\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:1030
msgid ""
"Implement `Foldable` for `Tree`. There is no need to use tail recursion in "
"your implementations, but your functions must be accepted by the totality "
"checker, and you are not allowed to cheat by using `assert_smaller` or "
"`assert_total`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1034
#, no-wrap
msgid ""
"   Hint: You can test the correct behavior of your implementations\n"
"   by running the same folds on the result of `treeToVect` and\n"
"   verify that the outcome is the same.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:1039
msgid ""
"Like `Functor` and `Applicative`, `Foldable` composes: The product and "
"composition of two foldable container types are again foldable container "
"types. Proof this by implementing `Foldable` for `Comp` and `Product`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1040 ../src/Tutorial/Traverse.md:308
#, no-wrap
msgid ""
"   record Comp (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkComp\n"
"     unComp  : f (g a)\n"
"\n"
"   record Product (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkProduct\n"
"     fst : f a\n"
"     snd : g a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1058
#, no-wrap
msgid ""
"We learned a lot about recursion, totality checking, and folds\n"
"in this chapter, all of which are important concepts in pure\n"
"functional programming in general. Wrapping one's head\n"
"around recursion takes time and experience. Therefore - as\n"
"usual - try to solve as many exercises as you can.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1062
#, no-wrap
msgid ""
"In the next chapter, we are taking the concept of iterating\n"
"over container types one step further and look at\n"
"effectful data traversals.\n"
msgstr ""
