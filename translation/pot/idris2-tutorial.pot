# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-08-28 19:51+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: ../README.md:2
#, no-wrap
msgid "> [Chinese Translation](translation/README.md)\n"
msgstr ""

#. type: Title #
#: ../README.md:3
#, no-wrap
msgid "Functional Programming in Idris 2"
msgstr ""

#. type: Plain text
#: ../README.md:11
#, no-wrap
msgid ""
"The goal of this project is quickly explained: To become a more\n"
"or less comprehensive guide to the Idris programming language,\n"
"with a lot of introductory material targeted at newcomers to\n"
"functional programming.\n"
msgstr ""

#. type: Plain text
#: ../README.md:19
#, no-wrap
msgid ""
"The content will be organized in several parts, with the part\n"
"about the core language features being the main guide to\n"
"functional programming in Idris. Every part consists of several\n"
"chapters, each trying to cover in depth a certain aspect\n"
"of the Idris programming language and its core libraries. Most\n"
"chapters come with (sometimes lots of) exercises, with\n"
"solutions available in directory `src/Solutions`.\n"
msgstr ""

#. type: Plain text
#: ../README.md:24
#, no-wrap
msgid ""
"Right now, even the part about core language features is not\n"
"yet finished, but is being actively developed and tried on\n"
"several of my own students, some of which are completely\n"
"new to functional programming.\n"
msgstr ""

#. type: Title ##
#: ../README.md:25
#, no-wrap
msgid "Table of Contents"
msgstr ""

#. type: Title ###
#: ../README.md:27
#, no-wrap
msgid "Part 1: Core Language Features"
msgstr ""

#. type: Plain text
#: ../README.md:33
#, no-wrap
msgid ""
"This part tries to give a solid introduction to the\n"
"Idris programming language. If you are new to functional programming,\n"
"make sure to follow these chapters in order and *solve all the\n"
"exercises*.\n"
msgstr ""

#. type: Plain text
#: ../README.md:38
#, no-wrap
msgid ""
"If you already used other pure functional programming languages like\n"
"Haskell, you might go through the introductory material (Functions Part 1,\n"
"Algebraic Data Types, and Interfaces) pretty quickly, as most of this\n"
"stuff will already be familiar to you.\n"
msgstr ""

#. type: Plain text
#: ../README.md:107
#, no-wrap
msgid ""
"1. [Introduction](src/Tutorial/Intro.md)\n"
"   1. [About the Idris Programming "
"Language](src/Tutorial/Intro.md#about-the-idris-programming-language)\n"
"   2. [Using the REPL](src/Tutorial/Intro.md#using-the-repl)\n"
"   3. [A First Idris Program](src/Tutorial/Intro.md#a-first-idris-program)\n"
"   4. [The Shape of an Idris "
"Definition](src/Tutorial/Intro.md#the-shape-of-an-idris-definition)\n"
"   5. [Where to get Help](src/Tutorial/Intro.md#where-to-get-help)\n"
"2. [Functions Part 1](src/Tutorial/Functions1.md)\n"
"   1. [Functions with more that one "
"Argument](src/Tutorial/Functions1.md#functions-with-more-that-one-argument)\n"
"   2. [Function "
"Composition](src/Tutorial/Functions1.md#function-composition)\n"
"   3. [Higher-order "
"Functions](src/Tutorial/Functions1.md#higher-order-functions)\n"
"   4. [Currying](src/Tutorial/Functions1.md#currying)\n"
"   5. [Anonymous "
"Functions](src/Tutorial/Functions1.md#anonymous-functions)\n"
"   6. [Operators](src/Tutorial/Functions1.md#operators)\n"
"3. [Algebraic Data Types](src/Tutorial/DataTypes.md)\n"
"   1. [Enumerations](src/Tutorial/DataTypes.md#enumerations)\n"
"   2. [Sum Types](src/Tutorial/DataTypes.md#sum-types)\n"
"   3. [Records](src/Tutorial/DataTypes.md#records)\n"
"   4. [Generic Data Types](src/Tutorial/DataTypes.md#generic-data-types)\n"
"   5. [Alternative Syntax for Data "
"Definitions](src/Tutorial/DataTypes.md#alternative-syntax-for-data-definitions)\n"
"4. [Interfaces](src/Tutorial/Interfaces.md)\n"
"   1. [Interface Basics](src/Tutorial/Interfaces.md#interface-basics)\n"
"   2. [More about "
"Interfaces](src/Tutorial/Interfaces.md#more-about-interfaces)\n"
"   3. [Interfaces in the "
"Prelude](src/Tutorial/Interfaces.md#interfaces-in-the-prelude)\n"
"5. [Functions Part 2](src/Tutorial/Functions2.md)\n"
"   1. [Let Bindings and Local "
"Definitions](src/Tutorial/Functions2.md#let-bindings-and-local-definitions)\n"
"   2. [The Truth about Function "
"Arguments](src/Tutorial/Functions2.md#the-truth-about-function-arguments)\n"
"   3. [Programming with "
"Holes](src/Tutorial/Functions2.md#programming-with-holes)\n"
"6. [Dependent Types](src/Tutorial/Dependent.md)\n"
"   1. [Length-Indexed "
"Lists](src/Tutorial/Dependent.md#length-indexed-lists)\n"
"   2. [Fin: Safe Indexing into "
"Vectors](src/Tutorial/Dependent.md#fin-safe-indexing-into-vectors)\n"
"   3. [Compile-Time "
"Computations](src/Tutorial/Dependent.md#compile-time-computations)\n"
"7. [IO: Programming with Side Effects](src/Tutorial/IO.md)\n"
"   1. [Pure Side Effects?](src/Tutorial/IO.md#pure-side-effects)\n"
"   2. [Do Blocks, Desugared](src/Tutorial/IO.md#do-blocks-desugared)\n"
"   3. [Working with Files](src/Tutorial/IO.md#working-with-files)\n"
"   4. [How IO is Implemented](src/Tutorial/IO.md#how-io-is-implemented)\n"
"8. [Functor and Friends](src/Tutorial/Functor.md)\n"
"   1. [Functor](src/Tutorial/Functor.md#functor)\n"
"   2. [Applicative](src/Tutorial/Functor.md#applicative)\n"
"   3. [Monad](src/Tutorial/Functor.md#monad)\n"
"   4. [Background and further "
"Reading](src/Tutorial/Functor.md#background-and-further-reading)\n"
"9. [Recursion and Folds](src/Tutorial/Folds.md)\n"
"   1. [Recursion](src/Tutorial/Folds.md#recursion)\n"
"   2. [A few Notes on Totality "
"Checking](src/Tutorial/Folds.md#a-few-notes-on-totality-checking)\n"
"   3. [Interface Foldable](src/Tutorial/Folds.md#interface-foldable)\n"
"10. [Effectful Traversals](src/Tutorial/Traverse.md)\n"
"    1. [Reading CSV Tables](src/Tutorial/Traverse.md#reading-csv-tables)\n"
"    2. [Programming with "
"State](src/Tutorial/Traverse.md#programming-with-state)\n"
"    3. [The Power of "
"Composition](src/Tutorial/Traverse.md#the-power-of-composition)\n"
"11. [Sigma Types](src/Tutorial/DPair.md)\n"
"    1. [Dependent Pairs](src/Tutorial/DPair.md#dependent-pairs)\n"
"    2. [Use Case: Nucleic "
"Acids](src/Tutorial/DPair.md#use-case-nucleic-acids)\n"
"    3. [Use Case: CSV Files with a "
"Schema](src/Tutorial/DPair.md#use-case-csv-files-with-a-schema)\n"
"12. [Propositional Equality](src/Tutorial/Eq.md)\n"
"    1. [Equality as a Type](src/Tutorial/Eq.md#equality-as-a-type)\n"
"    2. [Programs as Proofs](src/Tutorial/Eq.md#programs-as-proofs)\n"
"    3. [Into the Void](src/Tutorial/Eq.md#into-the-void)\n"
"    4. [Rewrite Rules](src/Tutorial/Eq.md#rewrite-rules)\n"
"13. [Predicates and Proof Search](src/Tutorial/Predicates.md)\n"
"    1. [Preconditions](src/Tutorial/Predicates.md#preconditions)\n"
"    2. [Contracts between "
"Values](src/Tutorial/Predicates.md#contracts-between-values)\n"
"    3. [Use Case: Flexible Error "
"Handling](src/Tutorial/Predicates.md#use-case-flexible-error-handling)\n"
"    4. [The Truth about "
"Interfaces](src/Tutorial/Predicates.md#the-truth-about-interfaces)\n"
"14. [Primitives](src/Tutorial/Prim.md)\n"
"    1. [How Primitives are "
"Implemented](src/Tutorial/Prim.md#how-primitives-are-implemented)\n"
"    2. [Working with Strings](src/Tutorial/Prim.md#working-with-strings)\n"
"    3. [Integers](src/Tutorial/Prim.md#integers)\n"
"    4. [Refined Primitives](src/Tutorial/Prim.md#refined-primitives)\n"
msgstr ""

#. type: Title ###
#: ../README.md:108
#, no-wrap
msgid "Part 2: Appendices"
msgstr ""

#. type: Plain text
#: ../README.md:114
#, no-wrap
msgid ""
"The appendices can be used as references for the topics at\n"
"hand. I plan to eventually have a concise reference on Idris\n"
"syntax, typical error messages, the module system, interactive\n"
"editing and possibly others.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../README.md:116
msgid "[Interactive Editing in Neovim](src/Appendices/Neovim.md)"
msgstr ""

#. type: Title ##
#: ../README.md:117
#, no-wrap
msgid "Prerequisites"
msgstr ""

#. type: Plain text
#: ../README.md:123
#, no-wrap
msgid ""
"At the moment, this project is being actively developed and\n"
"evolved against the main branch of the Idris 2 repository.\n"
"It is being tested nightly on GitHub and built against\n"
"the latest commit of the Idris 2 main branch as well as the\n"
"Idris 2 commit listed in file `.idris-version`.\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/DataTypes.md:1
#, no-wrap
msgid "Algebraic Data Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:8
#, no-wrap
msgid ""
"In the [previous chapter](Functions1.md),\n"
"we learned how to write our own functions and combine\n"
"them to create more complex functionality. Of equal importance\n"
"is the ability to define our own data types and use them\n"
"as arguments and results in functions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:15
#, no-wrap
msgid ""
"This is a lengthy chapter, densely packed with information.\n"
"If you are new to Idris and functional programming, make\n"
"sure to follow along slowly, experimenting with the examples,\n"
"and possibly coming up with your own. Make sure to try\n"
"and solve *all* exercises. The solutions to the exercises\n"
"can be found [here](../Solutions/DataTypes.idr).\n"
msgstr ""

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:16 ../src/Tutorial/DataTypes.md:25 ../src/Tutorial/DataTypes.md:60 ../src/Tutorial/DataTypes.md:112 ../src/Tutorial/DataTypes.md:130 ../src/Tutorial/DataTypes.md:152 ../src/Tutorial/DataTypes.md:163 ../src/Tutorial/DataTypes.md:184 ../src/Tutorial/DataTypes.md:215 ../src/Tutorial/DataTypes.md:253 ../src/Tutorial/DataTypes.md:283 ../src/Tutorial/DataTypes.md:327 ../src/Tutorial/DataTypes.md:348 ../src/Tutorial/DataTypes.md:359 ../src/Tutorial/DataTypes.md:378 ../src/Tutorial/DataTypes.md:408 ../src/Tutorial/DataTypes.md:415 ../src/Tutorial/DataTypes.md:441 ../src/Tutorial/DataTypes.md:449 ../src/Tutorial/DataTypes.md:482 ../src/Tutorial/DataTypes.md:505 ../src/Tutorial/DataTypes.md:518 ../src/Tutorial/DataTypes.md:546 ../src/Tutorial/DataTypes.md:559 ../src/Tutorial/DataTypes.md:587 ../src/Tutorial/DataTypes.md:598 ../src/Tutorial/DataTypes.md:617 ../src/Tutorial/DataTypes.md:628 ../src/Tutorial/DataTypes.md:638 ../src/Tutorial/DataTypes.md:654 ../src/Tutorial/DataTypes.md:667 ../src/Tutorial/DataTypes.md:681 ../src/Tutorial/DataTypes.md:693 ../src/Tutorial/DataTypes.md:701 ../src/Tutorial/DataTypes.md:716 ../src/Tutorial/DataTypes.md:729 ../src/Tutorial/DataTypes.md:804 ../src/Tutorial/DataTypes.md:828 ../src/Tutorial/DataTypes.md:861 ../src/Tutorial/DataTypes.md:897 ../src/Tutorial/DataTypes.md:908 ../src/Tutorial/DataTypes.md:942 ../src/Tutorial/DataTypes.md:957 ../src/Tutorial/DataTypes.md:967 ../src/Tutorial/DataTypes.md:992 ../src/Tutorial/DataTypes.md:1069 ../src/Tutorial/DataTypes.md:1081 ../src/Tutorial/DataTypes.md:1105 ../src/Tutorial/DataTypes.md:1143 ../src/Tutorial/DataTypes.md:1178 ../src/Tutorial/DataTypes.md:1208 ../src/Tutorial/DataTypes.md:1246 ../src/Tutorial/DataTypes.md:1269 ../src/Tutorial/DataTypes.md:1291 ../src/Tutorial/Dependent.md:10 ../src/Tutorial/Dependent.md:18 ../src/Tutorial/Dependent.md:42 ../src/Tutorial/Dependent.md:62 ../src/Tutorial/Dependent.md:70 ../src/Tutorial/Dependent.md:81 ../src/Tutorial/Dependent.md:111 ../src/Tutorial/Dependent.md:125 ../src/Tutorial/Dependent.md:136 ../src/Tutorial/Dependent.md:155 ../src/Tutorial/Dependent.md:174 ../src/Tutorial/Dependent.md:182 ../src/Tutorial/Dependent.md:227 ../src/Tutorial/Dependent.md:266 ../src/Tutorial/Dependent.md:278 ../src/Tutorial/Dependent.md:296 ../src/Tutorial/Dependent.md:388 ../src/Tutorial/Dependent.md:396 ../src/Tutorial/Dependent.md:404 ../src/Tutorial/Dependent.md:421 ../src/Tutorial/Dependent.md:429 ../src/Tutorial/Dependent.md:448 ../src/Tutorial/Dependent.md:465 ../src/Tutorial/Dependent.md:508 ../src/Tutorial/Dependent.md:518 ../src/Tutorial/Dependent.md:532 ../src/Tutorial/Dependent.md:565 ../src/Tutorial/Dependent.md:580 ../src/Tutorial/Dependent.md:601 ../src/Tutorial/Dependent.md:608 ../src/Tutorial/Dependent.md:618 ../src/Tutorial/Dependent.md:691 ../src/Tutorial/Dependent.md:706 ../src/Tutorial/Dependent.md:728 ../src/Tutorial/Dependent.md:749 ../src/Tutorial/Dependent.md:790 ../src/Tutorial/Dependent.md:798 ../src/Tutorial/Dependent.md:807 ../src/Tutorial/Dependent.md:821 ../src/Tutorial/Dependent.md:837 ../src/Tutorial/Dependent.md:847 ../src/Tutorial/DPair.md:19 ../src/Tutorial/DPair.md:47 ../src/Tutorial/DPair.md:76 ../src/Tutorial/DPair.md:93 ../src/Tutorial/DPair.md:116 ../src/Tutorial/DPair.md:132 ../src/Tutorial/DPair.md:148 ../src/Tutorial/DPair.md:165 ../src/Tutorial/DPair.md:174 ../src/Tutorial/DPair.md:203 ../src/Tutorial/DPair.md:216 ../src/Tutorial/DPair.md:226 ../src/Tutorial/DPair.md:243 ../src/Tutorial/DPair.md:255 ../src/Tutorial/DPair.md:266 ../src/Tutorial/DPair.md:285 ../src/Tutorial/DPair.md:298 ../src/Tutorial/DPair.md:307 ../src/Tutorial/DPair.md:315 ../src/Tutorial/DPair.md:327 ../src/Tutorial/DPair.md:339 ../src/Tutorial/DPair.md:373 ../src/Tutorial/DPair.md:405 ../src/Tutorial/DPair.md:416 ../src/Tutorial/DPair.md:428 ../src/Tutorial/DPair.md:459 ../src/Tutorial/DPair.md:481 ../src/Tutorial/DPair.md:498 ../src/Tutorial/DPair.md:513 ../src/Tutorial/DPair.md:532 ../src/Tutorial/DPair.md:545 ../src/Tutorial/DPair.md:555 ../src/Tutorial/DPair.md:584 ../src/Tutorial/DPair.md:631 ../src/Tutorial/DPair.md:781 ../src/Tutorial/DPair.md:792 ../src/Tutorial/DPair.md:808 ../src/Tutorial/DPair.md:824 ../src/Tutorial/DPair.md:840 ../src/Tutorial/DPair.md:911 ../src/Tutorial/DPair.md:930 ../src/Tutorial/DPair.md:991 ../src/Tutorial/DPair.md:1019 ../src/Tutorial/DPair.md:1053 ../src/Tutorial/DPair.md:1068 ../src/Tutorial/DPair.md:1088 ../src/Tutorial/Eq.md:10 ../src/Tutorial/Eq.md:27 ../src/Tutorial/Eq.md:56 ../src/Tutorial/Eq.md:115 ../src/Tutorial/Eq.md:129 ../src/Tutorial/Eq.md:135 ../src/Tutorial/Eq.md:144 ../src/Tutorial/Eq.md:173 ../src/Tutorial/Eq.md:181 ../src/Tutorial/Eq.md:204 ../src/Tutorial/Eq.md:222 ../src/Tutorial/Eq.md:254 ../src/Tutorial/Eq.md:316 ../src/Tutorial/Eq.md:337 ../src/Tutorial/Eq.md:347 ../src/Tutorial/Eq.md:358 ../src/Tutorial/Eq.md:374 ../src/Tutorial/Eq.md:388 ../src/Tutorial/Eq.md:423 ../src/Tutorial/Eq.md:454 ../src/Tutorial/Eq.md:495 ../src/Tutorial/Eq.md:531 ../src/Tutorial/Eq.md:544 ../src/Tutorial/Eq.md:577 ../src/Tutorial/Eq.md:587 ../src/Tutorial/Eq.md:618 ../src/Tutorial/Eq.md:634 ../src/Tutorial/Eq.md:643 ../src/Tutorial/Eq.md:652 ../src/Tutorial/Eq.md:668 ../src/Tutorial/Eq.md:711 ../src/Tutorial/Eq.md:753 ../src/Tutorial/Eq.md:798 ../src/Tutorial/Eq.md:810 ../src/Tutorial/Eq.md:842 ../src/Tutorial/Eq.md:889 ../src/Tutorial/Eq.md:900 ../src/Tutorial/Eq.md:924 ../src/Tutorial/Eq.md:941 ../src/Tutorial/Eq.md:961 ../src/Tutorial/Eq.md:1002 ../src/Tutorial/Eq.md:1033 ../src/Tutorial/Eq.md:1074 ../src/Tutorial/Folds.md:23 ../src/Tutorial/Folds.md:51 ../src/Tutorial/Folds.md:64 ../src/Tutorial/Folds.md:74 ../src/Tutorial/Folds.md:89 ../src/Tutorial/Folds.md:104 ../src/Tutorial/Folds.md:118 ../src/Tutorial/Folds.md:134 ../src/Tutorial/Folds.md:188 ../src/Tutorial/Folds.md:205 ../src/Tutorial/Folds.md:216 ../src/Tutorial/Folds.md:230 ../src/Tutorial/Folds.md:254 ../src/Tutorial/Folds.md:282 ../src/Tutorial/Folds.md:303 ../src/Tutorial/Folds.md:320 ../src/Tutorial/Folds.md:384 ../src/Tutorial/Folds.md:393 ../src/Tutorial/Folds.md:400 ../src/Tutorial/Folds.md:406 ../src/Tutorial/Folds.md:429 ../src/Tutorial/Folds.md:438 ../src/Tutorial/Folds.md:446 ../src/Tutorial/Folds.md:452 ../src/Tutorial/Folds.md:458 ../src/Tutorial/Folds.md:465 ../src/Tutorial/Folds.md:495 ../src/Tutorial/Folds.md:521 ../src/Tutorial/Folds.md:544 ../src/Tutorial/Folds.md:609 ../src/Tutorial/Folds.md:621 ../src/Tutorial/Folds.md:638 ../src/Tutorial/Folds.md:656 ../src/Tutorial/Folds.md:720 ../src/Tutorial/Folds.md:737 ../src/Tutorial/Folds.md:766 ../src/Tutorial/Folds.md:847 ../src/Tutorial/Folds.md:869 ../src/Tutorial/Folds.md:892 ../src/Tutorial/Folds.md:935 ../src/Tutorial/Folds.md:951 ../src/Tutorial/Folds.md:996 ../src/Tutorial/Folds.md:1006 ../src/Tutorial/Folds.md:1019 ../src/Tutorial/Folds.md:1040 ../src/Tutorial/Functions1.md:17 ../src/Tutorial/Functions1.md:29 ../src/Tutorial/Functions1.md:80 ../src/Tutorial/Functions1.md:96 ../src/Tutorial/Functions1.md:109 ../src/Tutorial/Functions1.md:127 ../src/Tutorial/Functions1.md:158 ../src/Tutorial/Functions1.md:178 ../src/Tutorial/Functions1.md:221 ../src/Tutorial/Functions1.md:246 ../src/Tutorial/Functions1.md:292 ../src/Tutorial/Functions1.md:349 ../src/Tutorial/Functions1.md:391 ../src/Tutorial/Functions1.md:472 ../src/Tutorial/Functions1.md:505 ../src/Tutorial/Functions2.md:16 ../src/Tutorial/Functions2.md:94 ../src/Tutorial/Functions2.md:164 ../src/Tutorial/Functions2.md:203 ../src/Tutorial/Functions2.md:220 ../src/Tutorial/Functions2.md:249 ../src/Tutorial/Functions2.md:277 ../src/Tutorial/Functions2.md:319 ../src/Tutorial/Functions2.md:372 ../src/Tutorial/Functions2.md:391 ../src/Tutorial/Functions2.md:408 ../src/Tutorial/Functions2.md:426 ../src/Tutorial/Functions2.md:440 ../src/Tutorial/Functions2.md:447 ../src/Tutorial/Functions2.md:455 ../src/Tutorial/Functions2.md:472 ../src/Tutorial/Functions2.md:510 ../src/Tutorial/Functions2.md:624 ../src/Tutorial/Functions2.md:634 ../src/Tutorial/Functions2.md:646 ../src/Tutorial/Functions2.md:659 ../src/Tutorial/Functions2.md:670 ../src/Tutorial/Functions2.md:707 ../src/Tutorial/Functions2.md:780 ../src/Tutorial/Functions2.md:869 ../src/Tutorial/Functions2.md:880 ../src/Tutorial/Functor.md:18 ../src/Tutorial/Functor.md:54 ../src/Tutorial/Functor.md:63 ../src/Tutorial/Functor.md:73 ../src/Tutorial/Functor.md:84 ../src/Tutorial/Functor.md:95 ../src/Tutorial/Functor.md:111 ../src/Tutorial/Functor.md:126 ../src/Tutorial/Functor.md:139 ../src/Tutorial/Functor.md:167 ../src/Tutorial/Functor.md:236 ../src/Tutorial/Functor.md:260 ../src/Tutorial/Functor.md:270 ../src/Tutorial/Functor.md:285 ../src/Tutorial/Functor.md:298 ../src/Tutorial/Functor.md:314 ../src/Tutorial/Functor.md:340 ../src/Tutorial/Functor.md:351 ../src/Tutorial/Functor.md:392 ../src/Tutorial/Functor.md:408 ../src/Tutorial/Functor.md:417 ../src/Tutorial/Functor.md:429 ../src/Tutorial/Functor.md:442 ../src/Tutorial/Functor.md:456 ../src/Tutorial/Functor.md:479 ../src/Tutorial/Functor.md:494 ../src/Tutorial/Functor.md:512 ../src/Tutorial/Functor.md:531 ../src/Tutorial/Functor.md:551 ../src/Tutorial/Functor.md:576 ../src/Tutorial/Functor.md:622 ../src/Tutorial/Functor.md:651 ../src/Tutorial/Functor.md:660 ../src/Tutorial/Functor.md:676 ../src/Tutorial/Functor.md:693 ../src/Tutorial/Functor.md:704 ../src/Tutorial/Functor.md:750 ../src/Tutorial/Functor.md:761 ../src/Tutorial/Functor.md:773 ../src/Tutorial/Functor.md:784 ../src/Tutorial/Functor.md:828 ../src/Tutorial/Functor.md:842 ../src/Tutorial/Functor.md:860 ../src/Tutorial/Functor.md:872 ../src/Tutorial/Functor.md:888 ../src/Tutorial/Functor.md:926 ../src/Tutorial/Functor.md:945 ../src/Tutorial/Functor.md:971 ../src/Tutorial/Functor.md:1082 ../src/Tutorial/Functor.md:1122 ../src/Tutorial/Functor.md:1135 ../src/Tutorial/Functor.md:1199 ../src/Tutorial/Functor.md:1257 ../src/Tutorial/Functor.md:1268 ../src/Tutorial/Functor.md:1278 ../src/Tutorial/Functor.md:1285 ../src/Tutorial/Interfaces.md:10 ../src/Tutorial/Interfaces.md:43 ../src/Tutorial/Interfaces.md:62 ../src/Tutorial/Interfaces.md:71 ../src/Tutorial/Interfaces.md:100 ../src/Tutorial/Interfaces.md:117 ../src/Tutorial/Interfaces.md:159 ../src/Tutorial/Interfaces.md:234 ../src/Tutorial/Interfaces.md:255 ../src/Tutorial/Interfaces.md:274 ../src/Tutorial/Interfaces.md:296 ../src/Tutorial/Interfaces.md:321 ../src/Tutorial/Interfaces.md:333 ../src/Tutorial/Interfaces.md:341 ../src/Tutorial/Interfaces.md:362 ../src/Tutorial/Interfaces.md:456 ../src/Tutorial/Interfaces.md:466 ../src/Tutorial/Interfaces.md:475 ../src/Tutorial/Interfaces.md:498 ../src/Tutorial/Interfaces.md:534 ../src/Tutorial/Interfaces.md:552 ../src/Tutorial/Interfaces.md:561 ../src/Tutorial/Interfaces.md:650 ../src/Tutorial/Interfaces.md:661 ../src/Tutorial/Interfaces.md:677 ../src/Tutorial/Interfaces.md:695 ../src/Tutorial/Interfaces.md:716 ../src/Tutorial/Interfaces.md:727 ../src/Tutorial/Intro.md:20 ../src/Tutorial/Intro.md:191 ../src/Tutorial/Intro.md:252 ../src/Tutorial/Intro.md:287 ../src/Tutorial/Intro.md:312 ../src/Tutorial/IO.md:8 ../src/Tutorial/IO.md:25 ../src/Tutorial/IO.md:84 ../src/Tutorial/IO.md:121 ../src/Tutorial/IO.md:217 ../src/Tutorial/IO.md:232 ../src/Tutorial/IO.md:240 ../src/Tutorial/IO.md:255 ../src/Tutorial/IO.md:299 ../src/Tutorial/IO.md:334 ../src/Tutorial/IO.md:342 ../src/Tutorial/IO.md:352 ../src/Tutorial/IO.md:374 ../src/Tutorial/IO.md:405 ../src/Tutorial/IO.md:417 ../src/Tutorial/IO.md:472 ../src/Tutorial/IO.md:493 ../src/Tutorial/IO.md:506 ../src/Tutorial/IO.md:517 ../src/Tutorial/IO.md:528 ../src/Tutorial/IO.md:563 ../src/Tutorial/IO.md:581 ../src/Tutorial/IO.md:650 ../src/Tutorial/IO.md:689 ../src/Tutorial/IO.md:696 ../src/Tutorial/IO.md:705 ../src/Tutorial/IO.md:713 ../src/Tutorial/IO.md:734 ../src/Tutorial/IO.md:753 ../src/Tutorial/IO.md:875 ../src/Tutorial/IO.md:920 ../src/Tutorial/IO.md:960 ../src/Tutorial/IO.md:984 ../src/Tutorial/IO.md:997 ../src/Tutorial/Predicates.md:13 ../src/Tutorial/Predicates.md:108 ../src/Tutorial/Predicates.md:118 ../src/Tutorial/Predicates.md:139 ../src/Tutorial/Predicates.md:153 ../src/Tutorial/Predicates.md:165 ../src/Tutorial/Predicates.md:191 ../src/Tutorial/Predicates.md:203 ../src/Tutorial/Predicates.md:212 ../src/Tutorial/Predicates.md:224 ../src/Tutorial/Predicates.md:235 ../src/Tutorial/Predicates.md:252 ../src/Tutorial/Predicates.md:259 ../src/Tutorial/Predicates.md:277 ../src/Tutorial/Predicates.md:288 ../src/Tutorial/Predicates.md:352 ../src/Tutorial/Predicates.md:359 ../src/Tutorial/Predicates.md:368 ../src/Tutorial/Predicates.md:387 ../src/Tutorial/Predicates.md:406 ../src/Tutorial/Predicates.md:416 ../src/Tutorial/Predicates.md:447 ../src/Tutorial/Predicates.md:475 ../src/Tutorial/Predicates.md:493 ../src/Tutorial/Predicates.md:532 ../src/Tutorial/Predicates.md:550 ../src/Tutorial/Predicates.md:568 ../src/Tutorial/Predicates.md:603 ../src/Tutorial/Predicates.md:620 ../src/Tutorial/Predicates.md:639 ../src/Tutorial/Predicates.md:658 ../src/Tutorial/Predicates.md:719 ../src/Tutorial/Predicates.md:747 ../src/Tutorial/Predicates.md:768 ../src/Tutorial/Predicates.md:784 ../src/Tutorial/Predicates.md:798 ../src/Tutorial/Predicates.md:812 ../src/Tutorial/Predicates.md:821 ../src/Tutorial/Predicates.md:835 ../src/Tutorial/Predicates.md:850 ../src/Tutorial/Predicates.md:862 ../src/Tutorial/Predicates.md:872 ../src/Tutorial/Predicates.md:951 ../src/Tutorial/Predicates.md:963 ../src/Tutorial/Predicates.md:983 ../src/Tutorial/Predicates.md:999 ../src/Tutorial/Predicates.md:1024 ../src/Tutorial/Predicates.md:1035 ../src/Tutorial/Predicates.md:1044 ../src/Tutorial/Predicates.md:1066 ../src/Tutorial/Predicates.md:1080 ../src/Tutorial/Predicates.md:1094 ../src/Tutorial/Predicates.md:1105 ../src/Tutorial/Predicates.md:1113 ../src/Tutorial/Predicates.md:1121 ../src/Tutorial/Predicates.md:1134 ../src/Tutorial/Predicates.md:1163 ../src/Tutorial/Predicates.md:1199 ../src/Tutorial/Predicates.md:1236 ../src/Tutorial/Predicates.md:1287 ../src/Tutorial/Prim.md:8 ../src/Tutorial/Prim.md:164 ../src/Tutorial/Prim.md:175 ../src/Tutorial/Prim.md:190 ../src/Tutorial/Prim.md:201 ../src/Tutorial/Prim.md:210 ../src/Tutorial/Prim.md:218 ../src/Tutorial/Prim.md:232 ../src/Tutorial/Prim.md:246 ../src/Tutorial/Prim.md:263 ../src/Tutorial/Prim.md:271 ../src/Tutorial/Prim.md:324 ../src/Tutorial/Prim.md:346 ../src/Tutorial/Prim.md:357 ../src/Tutorial/Prim.md:389 ../src/Tutorial/Prim.md:399 ../src/Tutorial/Prim.md:412 ../src/Tutorial/Prim.md:425 ../src/Tutorial/Prim.md:672 ../src/Tutorial/Prim.md:684 ../src/Tutorial/Prim.md:757 ../src/Tutorial/Prim.md:768 ../src/Tutorial/Prim.md:780 ../src/Tutorial/Prim.md:801 ../src/Tutorial/Prim.md:809 ../src/Tutorial/Prim.md:818 ../src/Tutorial/Prim.md:840 ../src/Tutorial/Prim.md:892 ../src/Tutorial/Prim.md:911 ../src/Tutorial/Prim.md:926 ../src/Tutorial/Prim.md:984 ../src/Tutorial/Prim.md:1026 ../src/Tutorial/Prim.md:1046 ../src/Tutorial/Prim.md:1064 ../src/Tutorial/Prim.md:1073 ../src/Tutorial/Prim.md:1087 ../src/Tutorial/Prim.md:1101 ../src/Tutorial/Prim.md:1118 ../src/Tutorial/Prim.md:1176 ../src/Tutorial/Prim.md:1208 ../src/Tutorial/Traverse.md:17 ../src/Tutorial/Traverse.md:52 ../src/Tutorial/Traverse.md:62 ../src/Tutorial/Traverse.md:82 ../src/Tutorial/Traverse.md:105 ../src/Tutorial/Traverse.md:140 ../src/Tutorial/Traverse.md:173 ../src/Tutorial/Traverse.md:183 ../src/Tutorial/Traverse.md:194 ../src/Tutorial/Traverse.md:203 ../src/Tutorial/Traverse.md:267 ../src/Tutorial/Traverse.md:276 ../src/Tutorial/Traverse.md:285 ../src/Tutorial/Traverse.md:295 ../src/Tutorial/Traverse.md:308 ../src/Tutorial/Traverse.md:325 ../src/Tutorial/Traverse.md:332 ../src/Tutorial/Traverse.md:370 ../src/Tutorial/Traverse.md:388 ../src/Tutorial/Traverse.md:398 ../src/Tutorial/Traverse.md:406 ../src/Tutorial/Traverse.md:414 ../src/Tutorial/Traverse.md:463 ../src/Tutorial/Traverse.md:471 ../src/Tutorial/Traverse.md:489 ../src/Tutorial/Traverse.md:497 ../src/Tutorial/Traverse.md:506 ../src/Tutorial/Traverse.md:514 ../src/Tutorial/Traverse.md:525 ../src/Tutorial/Traverse.md:543 ../src/Tutorial/Traverse.md:591 ../src/Tutorial/Traverse.md:605 ../src/Tutorial/Traverse.md:771 ../src/Tutorial/Traverse.md:831 ../src/Tutorial/Traverse.md:852 ../src/Tutorial/Traverse.md:867 ../src/Tutorial/Traverse.md:899 ../src/Tutorial/Traverse.md:909 ../src/Tutorial/Traverse.md:929 ../src/Tutorial/Traverse.md:939 ../src/Tutorial/Traverse.md:975 ../src/Tutorial/Traverse.md:1030 ../src/Tutorial/Traverse.md:1056 ../src/Tutorial/Traverse.md:1067 ../src/Tutorial/Traverse.md:1077 ../src/Tutorial/Traverse.md:1095 ../src/Appendices/Neovim.md:32 ../src/Appendices/Neovim.md:86 ../src/Appendices/Neovim.md:116 ../src/Appendices/Neovim.md:149 ../src/Appendices/Neovim.md:174 ../src/Appendices/Neovim.md:191 ../src/Appendices/Neovim.md:209 ../src/Appendices/Neovim.md:232 ../src/Appendices/Neovim.md:248 ../src/Appendices/Neovim.md:267 ../src/Appendices/Neovim.md:280 ../src/Appendices/Neovim.md:348 ../src/Appendices/Neovim.md:359
#, no-wrap
msgid "idris"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:16
#, no-wrap
msgid "module Tutorial.DataTypes\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:20
#, no-wrap
msgid "Enumerations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:24
#, no-wrap
msgid ""
"Let's start with a data type for the days of the week as an\n"
"example.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:25
#, no-wrap
msgid ""
"data Weekday = Monday\n"
"             | Tuesday\n"
"             | Wednesday\n"
"             | Thursday\n"
"             | Friday\n"
"             | Saturday\n"
"             | Sunday\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:38
#, no-wrap
msgid ""
"The declaration above defines a new *type* (`Weekday`) and\n"
"several new *values* (`Monday` to `Sunday`) of the given\n"
"type. Go ahead, and verify this at the REPL:\n"
msgstr ""

#. type: Code fence info string
#: ../src/Tutorial/DataTypes.md:39 ../src/Tutorial/DataTypes.md:234 ../src/Tutorial/DataTypes.md:241 ../src/Tutorial/DataTypes.md:310 ../src/Tutorial/DataTypes.md:337 ../src/Tutorial/DataTypes.md:390 ../src/Tutorial/DataTypes.md:427 ../src/Tutorial/DataTypes.md:494 ../src/Tutorial/DataTypes.md:646 ../src/Tutorial/DataTypes.md:840 ../src/Tutorial/DataTypes.md:1009 ../src/Tutorial/DataTypes.md:1016 ../src/Tutorial/DataTypes.md:1024 ../src/Tutorial/DataTypes.md:1031 ../src/Tutorial/DataTypes.md:1038 ../src/Tutorial/DataTypes.md:1045 ../src/Tutorial/Dependent.md:197 ../src/Tutorial/Dependent.md:204 ../src/Tutorial/Dependent.md:239 ../src/Tutorial/Dependent.md:245 ../src/Tutorial/Dependent.md:309 ../src/Tutorial/Dependent.md:346 ../src/Tutorial/Dependent.md:364 ../src/Tutorial/Dependent.md:499 ../src/Tutorial/Dependent.md:632 ../src/Tutorial/Dependent.md:867 ../src/Tutorial/DPair.md:66 ../src/Tutorial/DPair.md:234 ../src/Tutorial/DPair.md:713 ../src/Tutorial/Eq.md:74 ../src/Tutorial/Eq.md:93 ../src/Tutorial/Eq.md:153 ../src/Tutorial/Eq.md:397 ../src/Tutorial/Eq.md:404 ../src/Tutorial/Eq.md:436 ../src/Tutorial/Eq.md:505 ../src/Tutorial/Eq.md:518 ../src/Tutorial/Eq.md:679 ../src/Tutorial/Eq.md:778 ../src/Tutorial/Eq.md:984 ../src/Tutorial/Eq.md:1014 ../src/Tutorial/Folds.md:198 ../src/Tutorial/Folds.md:787 ../src/Tutorial/Folds.md:798 ../src/Tutorial/Folds.md:822 ../src/Tutorial/Folds.md:839 ../src/Tutorial/Folds.md:880 ../src/Tutorial/Folds.md:904 ../src/Tutorial/Functions1.md:37 ../src/Tutorial/Functions1.md:143 ../src/Tutorial/Functions1.md:165 ../src/Tutorial/Functions1.md:204 ../src/Tutorial/Functions1.md:228 ../src/Tutorial/Functions1.md:253 ../src/Tutorial/Functions1.md:261 ../src/Tutorial/Functions1.md:312 ../src/Tutorial/Functions1.md:333 ../src/Tutorial/Functions1.md:358 ../src/Tutorial/Functions1.md:366 ../src/Tutorial/Functions1.md:378 ../src/Tutorial/Functions1.md:488 ../src/Tutorial/Functions1.md:519 ../src/Tutorial/Functions1.md:568 ../src/Tutorial/Functions2.md:42 ../src/Tutorial/Functions2.md:63 ../src/Tutorial/Functions2.md:74 ../src/Tutorial/Functions2.md:114 ../src/Tutorial/Functions2.md:528 ../src/Tutorial/Functions2.md:541 ../src/Tutorial/Functions2.md:553 ../src/Tutorial/Functions2.md:560 ../src/Tutorial/Functions2.md:567 ../src/Tutorial/Functions2.md:719 ../src/Tutorial/Functions2.md:726 ../src/Tutorial/Functions2.md:735 ../src/Tutorial/Functions2.md:755 ../src/Tutorial/Functions2.md:763 ../src/Tutorial/Functions2.md:787 ../src/Tutorial/Functions2.md:811 ../src/Tutorial/Functions2.md:819 ../src/Tutorial/Functions2.md:835 ../src/Tutorial/Functions2.md:848 ../src/Tutorial/Functions2.md:899 ../src/Tutorial/Functor.md:187 ../src/Tutorial/Functor.md:201 ../src/Tutorial/Functor.md:216 ../src/Tutorial/Functor.md:610 ../src/Tutorial/Functor.md:801 ../src/Tutorial/Functor.md:903 ../src/Tutorial/Functor.md:1001 ../src/Tutorial/Functor.md:1100 ../src/Tutorial/Functor.md:1167 ../src/Tutorial/Functor.md:1219 ../src/Tutorial/Interfaces.md:36 ../src/Tutorial/Interfaces.md:140 ../src/Tutorial/Interfaces.md:505 ../src/Tutorial/Intro.md:122 ../src/Tutorial/Intro.md:134 ../src/Tutorial/Intro.md:148 ../src/Tutorial/Intro.md:158 ../src/Tutorial/Intro.md:167 ../src/Tutorial/Intro.md:227 ../src/Tutorial/Intro.md:270 ../src/Tutorial/Intro.md:279 ../src/Tutorial/Intro.md:300 ../src/Tutorial/Intro.md:326 ../src/Tutorial/Intro.md:337 ../src/Tutorial/Intro.md:349 ../src/Tutorial/IO.md:33 ../src/Tutorial/IO.md:94 ../src/Tutorial/IO.md:433 ../src/Tutorial/IO.md:442 ../src/Tutorial/IO.md:539 ../src/Tutorial/IO.md:621 ../src/Tutorial/IO.md:634 ../src/Tutorial/IO.md:1020 ../src/Tutorial/IO.md:1040 ../src/Tutorial/IO.md:1050 ../src/Tutorial/IO.md:1060 ../src/Tutorial/Predicates.md:428 ../src/Tutorial/Predicates.md:462 ../src/Tutorial/Predicates.md:926 ../src/Tutorial/Predicates.md:1337 ../src/Tutorial/Prim.md:124 ../src/Tutorial/Prim.md:312 ../src/Tutorial/Prim.md:527 ../src/Tutorial/Prim.md:550 ../src/Tutorial/Prim.md:574 ../src/Tutorial/Prim.md:584 ../src/Tutorial/Prim.md:596 ../src/Tutorial/Prim.md:611 ../src/Tutorial/Prim.md:622 ../src/Tutorial/Prim.md:638 ../src/Tutorial/Prim.md:647 ../src/Tutorial/Prim.md:703 ../src/Tutorial/Prim.md:1129 ../src/Tutorial/Traverse.md:38 ../src/Tutorial/Traverse.md:123 ../src/Tutorial/Traverse.md:158 ../src/Tutorial/Traverse.md:421 ../src/Tutorial/Traverse.md:737 ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid "repl"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:39
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Monday\n"
"Tutorial.DataTypes.Monday : Weekday\n"
"Tutorial.DataTypes> :t Weekday\n"
"Tutorial.DataTypes.Weekday : Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:48
#, no-wrap
msgid ""
"So, `Monday` is of type `Weekday`, while `Weekday` itself is of\n"
"type `Type`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:52
#, no-wrap
msgid ""
"It is important to note, that a value of type `Weekday` can only\n"
"ever be one of the values listed above. It is a *type error* to\n"
"use anything else where a `Weekday` is expected.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:53
#, no-wrap
msgid "Pattern Matching"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:59
#, no-wrap
msgid ""
"In order to use our new data type as a function argument, we\n"
"need to learn about an important concept in functional programming\n"
"languages: Pattern matching. Let's implement a function, which calculates\n"
"the successor of a weekday:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:60
#, no-wrap
msgid ""
"total\n"
"next : Weekday -> Weekday\n"
"next Monday    = Tuesday\n"
"next Tuesday   = Wednesday\n"
"next Wednesday = Thursday\n"
"next Thursday  = Friday\n"
"next Friday    = Saturday\n"
"next Saturday  = Sunday\n"
"next Sunday    = Monday\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:81
#, no-wrap
msgid ""
"In order to inspect a `Weekday` argument, we match on the\n"
"different possible values and return a result for each of them.\n"
"This is a very powerful concept, as it allows us to match\n"
"on and extract values from deeply nested data structures.\n"
"The different cases in a pattern match are inspected from\n"
"top to bottom, each being compared against the current\n"
"function argument. Once a matching pattern is found, the\n"
"computation on the right hand side of this pattern is\n"
"evaluated. Later patterns are then ignored.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:89
#, no-wrap
msgid ""
"For instance, if we invoke `next` with argument `Thursday`,\n"
"the first three patterns (`Monaday`, `Tuesday`, and `Wednesday`)\n"
"will be checked against the argument, but they do not match.\n"
"The fourth pattern is a match, and result `Friday` is being\n"
"returned. Later patterns are then ignored, even if they would\n"
"also match the input (this becomes relevant with catch-all patterns,\n"
"which we will talk about in a moment).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:98
#, no-wrap
msgid ""
"The function above is provably total. Idris knows about the\n"
"possible values of type `Weekday`, and can therefore figure\n"
"out that our pattern match covers all possible cases. We can\n"
"therefore annotate the function with the `total` keyword, and\n"
"Idris will answer with a type error, if it can't verify the\n"
"function's totality. (Go ahead, and try removing one of\n"
"the clauses in `next` to get an idea about how an error\n"
"message from the coverage checker looks like.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:105
#, no-wrap
msgid ""
"Please remember, that these are very strong guarantees from\n"
"the type checker: Given enough resources,\n"
"a provably total function will *always* return\n"
"a result of the given type in a finite amount of time\n"
"(*resources* here meaning computational resources like\n"
"memory or, in case of recursive functions, stack space).\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:106
#, no-wrap
msgid "Catch-all Patterns"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:111
#, no-wrap
msgid ""
"Sometimes, it is convenient to only match on a subset\n"
"of the possible values and collect the remaining possibilities\n"
"in a catch-all clause:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:112
#, no-wrap
msgid ""
"total\n"
"isWeekend : Weekday -> Bool\n"
"isWeekend Saturday = True\n"
"isWeekend Sunday   = True\n"
"isWeekend _        = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:125
#, no-wrap
msgid ""
"The final line with the catch-all pattern is only invoked,\n"
"if the argument is not equal to `Saturday` or `Sunday`.\n"
"Remember: Patterns in a pattern match are matched against\n"
"the input from top to bottom and the first match decides,\n"
"which path on the right hand side will be taken.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:129
#, no-wrap
msgid ""
"We can use catch-all patterns to implement an equality test for\n"
"`Weekday` (we will not yet use the `==` operator for this; this will\n"
"have to wait until we learn about *interfaces*):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:130
#, no-wrap
msgid ""
"total\n"
"eqWeekday : Weekday -> Weekday -> Bool\n"
"eqWeekday Monday Monday        = True\n"
"eqWeekday Tuesday Tuesday      = True\n"
"eqWeekday Wednesday Wednesday  = True\n"
"eqWeekday Thursday Thursday    = True\n"
"eqWeekday Friday Friday        = True\n"
"eqWeekday Saturday Saturday    = True\n"
"eqWeekday Sunday Sunday        = True\n"
"eqWeekday _ _                  = False\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:143
#, no-wrap
msgid "Enumeration Types in the Prelude"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:151
#, no-wrap
msgid ""
"Data types like `Weekday` consisting of a finite set\n"
"of values are sometimes called *enumerations*. The Idris\n"
"*Prelude* defines some common enumerations for us, for\n"
"instance `Bool` and `Ordering`. As with `Weekday`,\n"
"we can use pattern matching when implementing functions\n"
"on these types:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:152
#, no-wrap
msgid ""
"-- this is how `not` is implemented in the *Prelude*\n"
"total\n"
"negate : Bool -> Bool\n"
"negate False = True\n"
"negate True  = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:162
#, no-wrap
msgid ""
"The `Ordering` data type describes an ordering relation\n"
"between two values. For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:163
#, no-wrap
msgid ""
"total\n"
"compareBool : Bool -> Bool -> Ordering\n"
"compareBool False False = EQ\n"
"compareBool False True  = LT\n"
"compareBool True True   = EQ\n"
"compareBool True False  = GT\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:176
#, no-wrap
msgid ""
"Here, `LT` means that the first argument is *less than*\n"
"the second, `EQ` means that the two arguments are *equal*\n"
"and `GT` means, that the first argument is *greater than*\n"
"the second.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:177
#, no-wrap
msgid "Case Expressions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:183
#, no-wrap
msgid ""
"Sometimes we need to perform a computation with one\n"
"of the arguments and want to pattern match on the result\n"
"of this computation. We can use *case expressions* in this\n"
"situation:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:184
#, no-wrap
msgid ""
"-- returns the larger of the two arguments\n"
"total\n"
"maxBits8 : Bits8 -> Bits8 -> Bits8\n"
"maxBits8 x y =\n"
"  case compare x y of\n"
"    LT => y\n"
"    _  => x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:202
#, no-wrap
msgid ""
"The first line of the case expression (`case compare x y of`)\n"
"will invoke function `compare` with arguments `x` and `y`. On\n"
"the following (indented) lines, we pattern match on the result\n"
"of this computation. This is of type `Ordering`, so we expect\n"
"one of the three constructors `LT`, `EQ`, or `GT` as the result.\n"
"On the first line, we handle the `LT` case explicitly, while\n"
"the other two cases are handled with an underscore as a catch-all\n"
"pattern.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:206
#, no-wrap
msgid ""
"Note, that indentation matters here: The case block as a whole\n"
"must be indented (if it starts on a new line), and the different\n"
"cases must also be indented by the same amount of whitespace.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:209
#, no-wrap
msgid ""
"Function `compare` is overloaded for many data types. We will\n"
"learn how this works when we talk about interfaces.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/DataTypes.md:210
#, no-wrap
msgid "If Then Else"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:214
#, no-wrap
msgid ""
"When working with `Bool`, there is an alternative to pattern matching\n"
"common to most programming languages:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:215
#, no-wrap
msgid ""
"total\n"
"maxBits8' : Bits8 -> Bits8 -> Bits8\n"
"maxBits8' x y = if compare x y == LT then y else x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:225
#, no-wrap
msgid ""
"Note, that the `if then else` expression always returns a value\n"
"and therefore, the `else` branch cannot be dropped. This is different\n"
"from the behavior in typical imperative languages, where `if` is\n"
"a statement with possible side effects.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:226
#, no-wrap
msgid "Naming Conventions: Identifiers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:233
#, no-wrap
msgid ""
"While we are free to use lower-case and upper-case identifiers for\n"
"function names, type- and data constructors must be given upper-case\n"
"identifiers in order not to confuse Idris (operators are also fine).\n"
"For instance, the following data definition is not valid, and Idris\n"
"will complain that it expected upper-case identifiers:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:234
#, no-wrap
msgid "data foo = bar | baz\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:240
#, no-wrap
msgid ""
"The same goes for similar data definitions like records and sum types\n"
"(both will be explained below):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:241
#, no-wrap
msgid ""
"-- not valid Idris\n"
"record Foo where\n"
"  constructor mkfoo\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:252
#, no-wrap
msgid ""
"On the other hand, we typically use lower-case identifiers for function\n"
"names, unless we plan to use them mostly during type checking (more on "
"this\n"
"later). This is not enforced by Idris, however, so if you are working in\n"
"a domain where upper-case identifiers are preferable, feel free to use\n"
"those:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:253
#, no-wrap
msgid ""
"foo : Bits32 -> Bits32\n"
"foo = (* 2)\n"
"\n"
"Bar : Bits32 -> Bits32\n"
"Bar = foo\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:261 ../src/Tutorial/Dependent.md:444 ../src/Tutorial/DPair.md:348 ../src/Tutorial/Eq.md:279 ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381 ../src/Tutorial/Interfaces.md:189 ../src/Tutorial/IO.md:317 ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448 ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:267
msgid ""
"Use pattern matching to implement your own versions of boolean operators "
"`(&&)` and `(||)` calling them `and` and `or` respectively."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:274
#, no-wrap
msgid ""
"   Note: One way to go about this is to enumerate\n"
"   all four possible combinations of two boolean\n"
"   values and give the result for each. However, there\n"
"   is a shorter, more clever way,\n"
"   requiring only two pattern matches for each of the\n"
"   two functions.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:282
msgid ""
"Define your own data type representing different units of time (seconds, "
"minutes, hours, days, weeks), and implement the following functions for "
"converting between time spans using different units. Hint: Use integer "
"division (`div`)  when going from seconds to some larger unit like hours)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:283
#, no-wrap
msgid ""
"   data UnitOfTime = Second -- add additional values\n"
"\n"
"   -- calculate the number of seconds from a\n"
"   -- number of steps in the given unit of time\n"
"   total\n"
"   toSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- Given a number of seconds, calculate the\n"
"   -- number of steps in the given unit of time\n"
"   total\n"
"   fromSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- convert the number of steps in a given unit of time\n"
"   -- to the number of steps in another unit of time.\n"
"   -- use `fromSeconds` and `toSeconds` in your implementation\n"
"   total\n"
"   convert : UnitOfTime -> Integer -> UnitOfTime -> Integer\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:306
msgid ""
"Define a data type for representing a subset of the chemical elements: "
"Hydrogen (H), Carbon (C), Nitrogen (N), Oxygen (O), and Fluorine (F)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:309
#, no-wrap
msgid ""
"   Declare and implement function `atomicMass`, which for each element\n"
"   returns its atomic mass in dalton:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:310
#, no-wrap
msgid ""
"   Hydrogen : 1.008\n"
"   Carbon : 12.011\n"
"   Nitrogen : 14.007\n"
"   Oxygen : 15.999\n"
"   Fluorine : 18.9984\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:318
#, no-wrap
msgid "Sum Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:326
#, no-wrap
msgid ""
"Assume we'd like to write some web form, where users of our\n"
"web application can decide how they like to be addressed.\n"
"We give them a choice between two common predefined\n"
"forms of address (Mr and Mrs), but also allow them to\n"
"decide on a customized form. The possible\n"
"choices can be encapsulated in an Idris data type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:327
#, no-wrap
msgid "data Title = Mr | Mrs | Other String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:336
#, no-wrap
msgid ""
"This looks almost like an enumeration type, with the exception\n"
"that there is a new thing, called a *data constructor*,\n"
"which accepts a `String` argument (actually, the values\n"
"in an enumeration are also called (nullary) data constructors).\n"
"If we inspect the types at the REPL, we learn the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:337
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Mr\n"
"Tutorial.DataTypes.Mr : Title\n"
"Tutorial.DataTypes> :t Other\n"
"Tutorial.DataTypes.Other : String -> Title\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:347
#, no-wrap
msgid ""
"So, `Other` is a *function* from `String` to `Title`. This\n"
"means, that we can pass `Other` a `String` argument and get\n"
"a `Title` as the result:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:348
#, no-wrap
msgid ""
"total\n"
"dr : Title\n"
"dr = Other \"Dr.\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:358
#, no-wrap
msgid ""
"Again, a value of type `Title` can only consist of one\n"
"of the three choices listed above, and again,\n"
"we can use pattern matching to implement functions\n"
"on the `Title` data type in a provably total way:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:359
#, no-wrap
msgid ""
"total\n"
"showTitle : Title -> String\n"
"showTitle Mr        = \"Mr.\"\n"
"showTitle Mrs       = \"Mrs.\"\n"
"showTitle (Other x) = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:372
#, no-wrap
msgid ""
"Note, how in the last pattern match, the string value stored\n"
"in the `Other` data constructor is *bound* to local variable `x`.\n"
"Also, the `Other x` pattern has to be wrapped in parentheses,\n"
"as otherwise Idris would think `Other` and `x` were to\n"
"distinct function arguments.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:377
#, no-wrap
msgid ""
"This is a very common way to extract the values from\n"
"data constructors.\n"
"We can use `showTitle` to implement a function for creating\n"
"a courteous greeting:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:378
#, no-wrap
msgid ""
"total\n"
"greet : Title -> String -> String\n"
"greet t name = \"Hello, \" ++ showTitle t ++ \" \" ++ name ++ \"!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:387
#, no-wrap
msgid ""
"In the implementation of `greet`, we use string literals\n"
"and the string concatenation operator `(++)` to\n"
"assemble the greeting from its parts.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:389
#, no-wrap
msgid "At the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:390
#, no-wrap
msgid ""
"Tutorial.DataTypes> greet dr \"Höck\"\n"
"\"Hello, Dr. Höck!\"\n"
"Tutorial.DataTypes> greet Mrs \"Smith\"\n"
"\"Hello, Mrs. Smith!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:400
#, no-wrap
msgid ""
"Data types like `Title` are called *sum types* as they consist\n"
"of the sum of their different parts: A value of type `Title`\n"
"is either a `Mr`, a `Mrs`, or a `String` wrapped up in `Other`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:407
#, no-wrap
msgid ""
"Here's another (drastically simplified) example of a sum type.\n"
"Assume we allow two forms of authentication in our web application:\n"
"Either by entering a username plus a password (for which we'll use\n"
"an unsigned 64 bit integer here), or by providing user name\n"
"plus a (very complex) secret key.\n"
"Here's a data type to encapsulate this use case:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:408
#, no-wrap
msgid "data Credentials = Password String Bits64 | Key String String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:414
#, no-wrap
msgid ""
"As an example of a very primitive login function, we can\n"
"hard-code some known credentials:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:415
#, no-wrap
msgid ""
"total\n"
"login : Credentials -> String\n"
"login (Password \"Anderson\" 6665443) = greet Mr \"Anderson\"\n"
"login (Key \"Y\" \"xyz\")               = greet (Other \"Agent\") \"Y\"\n"
"login _                             = \"Access denied!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:426
#, no-wrap
msgid ""
"As can be seen in the example above, we can also pattern\n"
"match against primitive values by using integer and\n"
"string literals. Give `login` a go at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:427
#, no-wrap
msgid ""
"Tutorial.DataTypes> login (Password \"Anderson\" 6665443)\n"
"\"Hello, Mr. Anderson!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"xyz\")\n"
"\"Hello, Agent Y!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"foo\")\n"
"\"Access denied!\"\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:436 ../src/Tutorial/Dependent.md:623 ../src/Tutorial/DPair.md:653 ../src/Tutorial/Eq.md:555 ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:962 ../src/Tutorial/Interfaces.md:352 ../src/Tutorial/IO.md:728 ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:712 ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:440
msgid ""
"Implement an equality test for `Title` (you can use the equality operator "
"`(==)` for comparing two `String`s):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:441
#, no-wrap
msgid ""
"   total\n"
"   eqTitle : Title -> Title -> Bool\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:448
msgid ""
"For `Title`, implement a simple test to check, whether a custom title is "
"being used:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:449
#, no-wrap
msgid ""
"   total\n"
"   isOther : Title -> Bool\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:456
msgid ""
"Given our simple `Credentials` type, there are three ways for authentication "
"to fail:"
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
msgid "An unknown username was used."
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
msgid "The password given does not match the one associated with the username."
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
msgid "An invalid key was used."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:467
#, no-wrap
msgid ""
"   Encapsulate these three possibilities in a sum type\n"
"   called `LoginError`,\n"
"   but make sure not to disclose any confidential information:\n"
"   An invalid username should be stored in the corresponding\n"
"   error value, but an invalid password or key should not.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:471
msgid ""
"Implement function `showError : LoginError -> String`, which can be used to "
"display an error message to the user who unsuccessfully tried to login into "
"our web application."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:472
#, no-wrap
msgid "Records"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:481
#, no-wrap
msgid ""
"It is often useful to group together several values\n"
"as a logical unit. For instance, in our web application\n"
"we might want to group information about a user\n"
"in a single data type. Such data types are often called\n"
"*product types* (see below for an explanation).\n"
"The most common and convenient way to\n"
"define them is the `record` construct:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:482
#, no-wrap
msgid ""
"record User where\n"
"  constructor MkUser\n"
"  name  : String\n"
"  title : Title\n"
"  age   : Bits8\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:493
#, no-wrap
msgid ""
"The declaration above creates a new *type* called `User`,\n"
"and a new *data constructor* called `MkUser`. As usual,\n"
"have a look at their types in the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:494
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t User\n"
"Tutorial.DataTypes.User : Type\n"
"Tutorial.DataTypes> :t MkUser\n"
"Tutorial.DataTypes.MkUser : String -> Title -> Bits8 -> User\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:504
#, no-wrap
msgid ""
"We can use `MkUser` (which is a function from\n"
"`String` to `Title` to `Bits8` to `User`)\n"
"to create values of type `User`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:505
#, no-wrap
msgid ""
"total\n"
"agentY : User\n"
"agentY = MkUser \"Y\" (Other \"Agent\") 51\n"
"\n"
"total\n"
"drNo : User\n"
"drNo = MkUser \"No\" dr 73\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:517
#, no-wrap
msgid ""
"We can also use pattern matching to extract the fields from\n"
"a `User` value (they can again be bound to local variables):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:518
#, no-wrap
msgid ""
"total\n"
"greetUser : User -> String\n"
"greetUser (MkUser n t _) = greet t n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:530
#, no-wrap
msgid ""
"In the example above, the `name` and `title` field\n"
"are bound to two new local variables (`n` and `t` respectively),\n"
"which can then be used on the right hand side of `greetUser`'s\n"
"implementation. For the `age` field, which is not used\n"
"on the right hand side, we can use an underscore as a catch-all\n"
"pattern.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:545
#, no-wrap
msgid ""
"Note, how Idris will prevent us from making\n"
"a common mistake: If we confuse the order of arguments, the\n"
"implementation will no longer type check. We can verify this\n"
"by putting the erroneous code in a `failing` block: This\n"
"is an indented code block, which will lead to an error\n"
"during elaboration (type checking). We can give part\n"
"of the expected error message as an optional string argument to\n"
"a failing block. If this does not match part of\n"
"the error message (or the whole code block does not fail\n"
"to type check) the `failing` block itself fails to type\n"
"check. This is a useful tool to demonstrate that type\n"
"safety works in two directions: We can show that valid\n"
"code type checks but also that invalid code is rejected\n"
"by the Idris elaborator:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:546
#, no-wrap
msgid ""
"failing \"Mismatch between: String and Title\"\n"
"  greetUser' : User -> String\n"
"  greetUser' (MkUser n t _) = greet n t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:558
#, no-wrap
msgid ""
"In addition, for every record field, Idris creates an\n"
"extractor function of the same name. This can either\n"
"be used as a regular function, or it can be used in\n"
"postfix notation by appending it to a variable of\n"
"the record type separated by a dot. Here are two examples\n"
"for extracting the age from a user:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:559
#, no-wrap
msgid ""
"getAgeFunction : User -> Bits8\n"
"getAgeFunction u = age u\n"
"\n"
"getAgePostfix : User -> Bits8\n"
"getAgePostfix u = u.age\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:567
#, no-wrap
msgid "Syntactic Sugar for Records"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:581
#, no-wrap
msgid ""
"As was already mentioned in the [intro](Intro.md), Idris\n"
"is a *pure* functional programming language. In pure functions,\n"
"we are not allowed to modify global mutable state. As such,\n"
"if we want to modify a record value, we will always\n"
"create a *new* value with the original value remaining\n"
"unchanged: Records and other Idris values are *immutable*.\n"
"While this *can* have a slight impact on performance, it has\n"
"the benefit that we can freely pass a record value to\n"
"different functions, without fear of the functions modifying\n"
"the value by in-place mutation. These are, again, very strong\n"
"guarantees, which makes it drastically easier to reason\n"
"about our code.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:586
#, no-wrap
msgid ""
"There are several ways to modify a record, the most\n"
"general being to pattern match on the record and\n"
"adjust each field as desired. If, for instance, we'd like\n"
"to increase the age of a `User` by one, we could do the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:587
#, no-wrap
msgid ""
"total\n"
"incAge : User -> User\n"
"incAge (MkUser name title age) = MkUser name title (age + 1)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:597
#, no-wrap
msgid ""
"That's a lot of code for such a simple thing, so Idris offers\n"
"several syntactic conveniences for this. For instance,\n"
"using *record* syntax, we can just access and update the `age`\n"
"field of a value:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:598
#, no-wrap
msgid ""
"total\n"
"incAge2 : User -> User\n"
"incAge2 u = { age := u.age + 1 } u\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:607
#, no-wrap
msgid ""
"Assignment operator `:=` assigns a new value to the `age` field\n"
"in `u`. Remember, that this will create a new `User` value. The original\n"
"value `u` remains unaffected by this.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:613
#, no-wrap
msgid ""
"We can access a record field, either by using the field name\n"
"as a projection function (`age u`; also have a look at `:t age`\n"
"in the REPL), or by using dot syntax: `u.age`. This is special\n"
"syntax and *not* related to the dot operator for function\n"
"composition (`(.)`).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:616
#, no-wrap
msgid ""
"The use case of modifying a record field is so common\n"
"that Idris provides special syntax for this as well:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:617
#, no-wrap
msgid ""
"total\n"
"incAge3 : User -> User\n"
"incAge3 u = { age $= (+ 1) } u\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:627
#, no-wrap
msgid ""
"Here, I used an *operator section* (`(+ 1)`) to make\n"
"the code more concise.\n"
"As an alternative to an operator section,\n"
"we could have used an anonymous function like so:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:628
#, no-wrap
msgid ""
"total\n"
"incAge4 : User -> User\n"
"incAge4 u = { age $= \\x => x + 1 } u\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:637
#, no-wrap
msgid ""
"Finally, since our function's argument `u` is only used\n"
"once at the very end, we can drop it altogether,\n"
"to get the following, highly concise version:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:638
#, no-wrap
msgid ""
"total\n"
"incAge5 : User -> User\n"
"incAge5 = { age $= (+ 1) }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:645
#, no-wrap
msgid "As usual, we should have a look at the result at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:646
#, no-wrap
msgid ""
"Tutorial.DataTypes> incAge5 drNo\n"
"MkUser \"No\" (Other \"Dr.\") 74\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:653
#, no-wrap
msgid ""
"It is possible to use this syntax to set and/or update\n"
"several record fields at once:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:654
#, no-wrap
msgid ""
"total\n"
"drNoJunior : User\n"
"drNoJunior = { name $= (++ \" Jr.\"), title := Mr, age := 17 } drNo\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:660
#, no-wrap
msgid "Tuples"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:666
#, no-wrap
msgid ""
"I wrote above that a record is also called a *product type*.\n"
"This is quite obvious when we consider the number\n"
"of possible values inhabiting a given type. For instance, consider\n"
"the following custom record:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:667
#, no-wrap
msgid ""
"record Foo where\n"
"  constructor MkFoo\n"
"  wd   : Weekday\n"
"  bool : Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:678
#, no-wrap
msgid ""
"How many possible values of type `Foo` are there? The answer is `7 * 2 = "
"14`,\n"
"as we can pair every possible `Weekday` (seven in total) with every "
"possible\n"
"`Bool` (two in total). So, the number of possible values of a record type\n"
"is the *product* of the number of possible values for each field.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:680
#, no-wrap
msgid ""
"The canonical product type is the `Pair`, which is available from the "
"*Prelude*:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:681
#, no-wrap
msgid ""
"total\n"
"weekdayAndBool : Weekday -> Bool -> Pair Weekday Bool\n"
"weekdayAndBool wd b = MkPair wd b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:692
#, no-wrap
msgid ""
"Since it is quite common to return several values from a function\n"
"wrapped in a `Pair` or larger tuple, Idris provides some syntactic\n"
"sugar for working with these. Instead of `Pair Weekday Bool`, we\n"
"can just write `(Weekday, Bool)`. Likewise, instead of `MkPair wd b`,\n"
"we can just write `(wd, b)` (the space is optional):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:693
#, no-wrap
msgid ""
"total\n"
"weekdayAndBool2 : Weekday -> Bool -> (Weekday, Bool)\n"
"weekdayAndBool2 wd b = (wd, b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:700
#, no-wrap
msgid "This works also for nested tuples:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:701
#, no-wrap
msgid ""
"total\n"
"triple : Pair Bool (Pair Weekday String)\n"
"triple = MkPair False (Friday, \"foo\")\n"
"\n"
"total\n"
"triple2 : (Bool, Weekday, String)\n"
"triple2 = (False, Friday, \"foo\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:713
#, no-wrap
msgid ""
"In the example above, `triple2` is converted to the form\n"
"used in `triple` by the Idris compiler.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:715
#, no-wrap
msgid "We can even use tuple syntax in pattern matches:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:716
#, no-wrap
msgid ""
"total\n"
"bar : Bool\n"
"bar = case triple of\n"
"  (b,wd,_) => b && isWeekend wd\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:723
#, no-wrap
msgid "As Patterns"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:728
#, no-wrap
msgid ""
"Sometimes, we'd like to take apart a value by pattern matching\n"
"on it but still retain the value as a whole for using it\n"
"in further computations:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:729
#, no-wrap
msgid ""
"total\n"
"baz : (Bool,Weekday,String) -> (Nat,Bool,Weekday,String)\n"
"baz t@(_,_,s) = (length s, t)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:741
#, no-wrap
msgid ""
"In `baz`, variable `t` is *bound* to the triple as a whole, which\n"
"is then reused to construct the resulting quadruple. Remember,\n"
"that `(Nat,Bool,Weekday,String)` is just sugar for\n"
"`Pair Nat (Bool,Weekday,String)`, and `(length s, t)` is just\n"
"sugar for `MkPair (length s) t`. Hence, the implementation above\n"
"is correct as is confirmed by the type checker.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:742 ../src/Tutorial/Dependent.md:843 ../src/Tutorial/DPair.md:1128 ../src/Tutorial/Eq.md:826 ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1232 ../src/Tutorial/Interfaces.md:624 ../src/Tutorial/IO.md:949 ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:936 ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:748
#, no-wrap
msgid ""
"1. Define a record type for time spans by pairing a `UnitOfTime`\n"
"with an integer representing the duration of the time span in\n"
"the given unit of time. Define also a function for converting\n"
"a time span to an `Integer` representing the duration in seconds.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:752
#, no-wrap
msgid ""
"2. Implement an equality check for time spans: Two time spans\n"
"should be considered equal, if and only if they correspond to\n"
"the same number of seconds.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:757
#, no-wrap
msgid ""
"3. Implement a function for pretty printing time spans:\n"
"The resulting string should display the time span in its\n"
"given unit, plus show the number of seconds in parentheses,\n"
"if the unit is not already seconds.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:761
#, no-wrap
msgid ""
"4. Implement a function for adding two time spans. If the\n"
"two time spans use different units of time, use the smaller\n"
"unit of time to ensure a lossless conversion.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:762
#, no-wrap
msgid "Generic Data Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:772
#, no-wrap
msgid ""
"Sometimes, a concept is general enough that we'd like\n"
"to apply it not only to a single type, but to all\n"
"kinds of types. For instance, we might not want to define\n"
"data types for lists of integers, lists of strings, and lists\n"
"of booleans, as this would lead to a lot of code duplication.\n"
"Instead, we'd like to have a single generic list type *parameterized*\n"
"by the type of values it stores. This section explains how\n"
"to define and use generic types.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:773
#, no-wrap
msgid "Maybe"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:786
#, no-wrap
msgid ""
"Consider the case of parsing\n"
"a `Weekday` from user input. Surely, such\n"
"a function should return `Saturday`, if the\n"
"string input was `\"Saturday\"`, but what if the\n"
"input was `\"sdfkl332\"`? We have several options here.\n"
"For instance, we could just return a default result\n"
"(`Sunday` perhaps?). But is this the behavior\n"
"programmers expect when using our library? Maybe not. To silently\n"
"continue with a default value in the face of invalid user input\n"
"is hardly ever the best choice and may lead to a lot of\n"
"confusion.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:792
#, no-wrap
msgid ""
"In an imperative language, our function would probably\n"
"throw an exception. We could do this in Idris as\n"
"well (there is function `idris_crash` in the *Prelude* for\n"
"this), but doing so, we would abandon totality! A high\n"
"price to pay for such a common thing as a parsing error.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:803
#, no-wrap
msgid ""
"In languages like Java, our function might also return some\n"
"kind of `null` value (leading to the dreaded `NullPointerException`s if\n"
"not handled properly in client code). Our solution will\n"
"be similar, but instead of silently returning `null`,\n"
"we will make the possibility of failure visible in the types!\n"
"We define a custom data type, which encapsulates the possibility\n"
"of failure. Defining new data types in Idris is very cheap\n"
"(in terms of the amount of code needed), therefore this is\n"
"often the way to go in order to increase type safety.\n"
"Here's an example how to do this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:804
#, no-wrap
msgid ""
"data MaybeWeekday = WD Weekday | NoWeekday\n"
"\n"
"total\n"
"readWeekday : String -> MaybeWeekday\n"
"readWeekday \"Monday\"    = WD Monday\n"
"readWeekday \"Tuesday\"   = WD Tuesday\n"
"readWeekday \"Wednesday\" = WD Wednesday\n"
"readWeekday \"Thursday\"  = WD Thursday\n"
"readWeekday \"Friday\"    = WD Friday\n"
"readWeekday \"Saturday\"  = WD Saturday\n"
"readWeekday \"Sunday\"    = WD Sunday\n"
"readWeekday _           = NoWeekday\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:823
#, no-wrap
msgid ""
"But assume now, we'd also like to read `Bool` values from\n"
"user input. We'd now have to write a custom data type\n"
"`MaybeBool` and so on for all types we'd like to read\n"
"from `String`, and the conversion of which might fail.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:827
#, no-wrap
msgid ""
"Idris, like many other programming languages, allows us\n"
"to generalize this behavior by using *generic data\n"
"types*. Here's an example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:828
#, no-wrap
msgid ""
"data Option a = Some a | None\n"
"\n"
"total\n"
"readBool : String -> Option Bool\n"
"readBool \"True\"    = Some True\n"
"readBool \"False\"   = Some False\n"
"readBool _         = None\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:839
#, no-wrap
msgid "It is important to go to the REPL and look at the types:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:840
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Some\n"
"Tutorial.DataTypes.Some : a -> Option a\n"
"Tutorial.DataTypes> :t None\n"
"Tutorial.DataTypes.None : Optin a\n"
"Tutorial.DataTypes> :t Option\n"
"Tutorial.DataTypes.Option : Type -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:857
#, no-wrap
msgid ""
"We need to introduce some jargon here. `Option` is what we call\n"
"a *type constructor*. It is not yet a saturated type: It is\n"
"a function from `Type` to `Type`.\n"
"However, `Option Bool` is a type, as is `Option Weekday`.\n"
"Even `Option (Option Bool)` is a valid type. `Option` is\n"
"a type constructor *parameterized* over a *parameter* of type `Type`.\n"
"`Some` and `None` are `Option`s *data constructors*: The functions\n"
"used to create values of type `Option a` for a type `a`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:860
#, no-wrap
msgid ""
"Let's see some other use cases for `Option`. Below is a safe\n"
"division operation:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:861
#, no-wrap
msgid ""
"total\n"
"safeDiv : Integer -> Integer -> Option Integer\n"
"safeDiv n 0 = None\n"
"safeDiv n k = Some (n `div` k)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:872
#, no-wrap
msgid ""
"The possibility of returning some kind of *null* value in the\n"
"face of invalid input is so common, that there is a data type\n"
"like `Option` already in the *Prelude*: `Maybe`, with\n"
"data constructors `Just` and `Nothing`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:884
#, no-wrap
msgid ""
"It is important to understand the difference between returning `Maybe "
"Integer`\n"
"in a function, which might fail, and returning\n"
"`null` in languages like Java: In the former case, the\n"
"possibility of failure is visible in the types. The type checker\n"
"will force us to treat `Maybe Integer` differently than\n"
"`Integer`: Idris will *not* allow us to forget to\n"
"eventually handle the failure case.\n"
"Not so, if `null` is silently returned without adjusting the\n"
"types. Programmers may (and often *will*) forget to handle the\n"
"`null` case, leading to unexpected and sometimes\n"
"hard to debug runtime exceptions.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:885
#, no-wrap
msgid "Either"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:896
#, no-wrap
msgid ""
"While `Maybe` is very useful to quickly provide a default\n"
"value to signal some kind of failure, this value (`Nothing`) is\n"
"not very informative. It will not tell us *what exactly*\n"
"went wrong. For instance, in case of our `Weekday`\n"
"reading function, it might be interesting later on to know\n"
"the value of the invalid input string. And just like with\n"
"`Maybe` and `Option` above, this concept is general enough\n"
"that we might encounter other types of invalid values.\n"
"Here's a data type to encapsulate this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:897
#, no-wrap
msgid "data Validated e a = Invalid e | Valid a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:907
#, no-wrap
msgid ""
"`Validated` is a type constructor parameterized over two\n"
"type parameters `e` and `a`. It's data constructors\n"
"are `Invalid` and `Valid`,\n"
"the former holding a value describing some error condition,\n"
"the latter the result in case of a successful computation.\n"
"Let's see this in action:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:908
#, no-wrap
msgid ""
"total\n"
"readWeekdayV : String -> Validated String Weekday\n"
"readWeekdayV \"Monday\"    = Valid Monday\n"
"readWeekdayV \"Tuesday\"   = Valid Tuesday\n"
"readWeekdayV \"Wednesday\" = Valid Wednesday\n"
"readWeekdayV \"Thursday\"  = Valid Thursday\n"
"readWeekdayV \"Friday\"    = Valid Friday\n"
"readWeekdayV \"Saturday\"  = Valid Saturday\n"
"readWeekdayV \"Sunday\"    = Valid Sunday\n"
"readWeekdayV s           = Invalid (\"Not a weekday: \" ++ s)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:929
#, no-wrap
msgid ""
"Again, this is such a general concept that a data type\n"
"similar to `Validated` is already available from the\n"
"*Prelude*: `Either` with data constructors `Left` and `Right`.\n"
"It is very common for functions to encapsulate the possibility\n"
"of failure by returning an `Either err val`, where `err`\n"
"is the error type and `val` is the desired return type. This\n"
"is the type safe (and total!) alternative to throwing a catchable\n"
"exception in an imperative language.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:934
#, no-wrap
msgid ""
"Note, however, that the semantics of `Either` are not always \"`Left` is\n"
"an error and `Right` a success\". A function returning an `Either` just\n"
"means that it can have to different types of results, each of which\n"
"are *tagged* with the corresponding data constructor.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:935
#, no-wrap
msgid "List"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:941
#, no-wrap
msgid ""
"One of the most important data structures in pure functional\n"
"programming is the singly linked list. Here is its definition\n"
"(called `Seq` in order for it not to collide with `List`,\n"
"which is of course already available from the Prelude):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:942
#, no-wrap
msgid "data Seq a = Nil | (::) a (Seq a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:953
#, no-wrap
msgid ""
"This calls for some explanations. `Seq` consists of two *data "
"constructors*:\n"
"`Nil` (representing an empty sequence of values) and `(::)` (also\n"
"called the *cons operator*), which prepends a new value of type `a` to\n"
"an already existing list of values of the same type. As you can see,\n"
"we can also use operators as data constructors, but please do not overuse\n"
"this. Use clear names for your functions and data constructors and only\n"
"introduce new operators when it truly helps readability!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:956
#, no-wrap
msgid ""
"Here is an example of how to use the `List` constructors\n"
"(I use `List` here, as this is what you should use in your own code):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:957
#, no-wrap
msgid ""
"total\n"
"ints : List Int64\n"
"ints = 1 :: 2 :: -3 :: Nil\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:966
#, no-wrap
msgid ""
"However, there is a more concise way of writing the above. Idris\n"
"accepts special syntax for constructing data types consisting\n"
"exactly of the two constructors `Nil` and `(::)`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:967
#, no-wrap
msgid ""
"total\n"
"ints2 : List Int64\n"
"ints2 = [1, 2, -3]\n"
"\n"
"total\n"
"ints3 : List Int64\n"
"ints3 = []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:980
#, no-wrap
msgid ""
"The two definitions `ints` and `ints2`\n"
"are treated identically by the compiler.\n"
"Note, that list syntax can also be used in pattern matches.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:991
#, no-wrap
msgid ""
"There is another thing that's special about\n"
"`Seq` and `List`: Each of them is defined\n"
"in terms of itself (the cons operator accepts a value\n"
"and another `Seq` as arguments). We call such data types\n"
"*recursive* data types, and their recursive nature means, that in order to\n"
"decompose or consume them, we typically require recursive\n"
"functions. In an imperative language, we might use a for loop or\n"
"similar construct to iterate over the values of a `List` or a `Seq`,\n"
"but these things do not exist in a language without in-place\n"
"mutation. Here's how to sum a list of integers:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:992
#, no-wrap
msgid ""
"total\n"
"intSum : List Integer -> Integer\n"
"intSum Nil       = 0\n"
"intSum (n :: ns) = n + intSum ns\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1004
#, no-wrap
msgid ""
"Recursive functions can be hard to grasp at first, so I'll break\n"
"this down a bit. If we invoke `intSum` with the empty list,\n"
"the first pattern matches and the function returns zero immediately.\n"
"If, however, we invoke `intSum` with a non-empty list - `[7,5,9]`\n"
"for instance - the following happens:\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:1008
msgid ""
"The second pattern matches and splits the list into two parts: Its head "
"(`7`) is bound to variable `n` and its tail (`[5,9]`) is bound to `ns`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1009
#, no-wrap
msgid "   7 + intSum [5,9]\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:1015
msgid ""
"In a second invocation, `intSum` is called with a new list: `[5,9]`.  The "
"second pattern matches and `n` is bound to `5` and `ns` is bound to `[9]`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1016
#, no-wrap
msgid "   7 + (5 + intSum [9])\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:1023
msgid ""
"In a third invocation `intSum` is called with list `[9]`.  The second "
"pattern matches and `n` is bound to `9` and `ns` is bound to `[]`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1024
#, no-wrap
msgid "   7 + (5 + (9 + intSum [])\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:1030
msgid ""
"In a fourth invocation, `intSum` is called with list `[]` and returns `0` "
"immediately:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1031
#, no-wrap
msgid "   7 + (5 + (9 + 0)\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DataTypes.md:1037
msgid "In the third invocation, `9` and `0` are added and `9` is returned:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1038
#, no-wrap
msgid "   7 + (5 + 9)\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DataTypes.md:1044
msgid "In the second invocation, `5` and `9` are added and `14` is returned:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1045
#, no-wrap
msgid "   7 + 14\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/DataTypes.md:1051
msgid ""
"Finally, our initial invocation of `intSum` adds `7` and `14` and returns "
"`21`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1055
#, no-wrap
msgid ""
"Thus, the recursive implementation of `intSum` leads to a sequence of\n"
"nested calls to `intSum`, which terminates once the argument is the\n"
"empty list.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1056
#, no-wrap
msgid "Generic Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1062
#, no-wrap
msgid ""
"In order to fully appreciate the versatility that comes with\n"
"generic data types, we also need to talk about generic functions.\n"
"Like generic types, these are parameterized over one or more\n"
"type parameters.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1068
#, no-wrap
msgid ""
"Consider for instance the case of breaking out of the\n"
"`Option` data type. In case of a `Some`, we'd like to return\n"
"the stored value, while for the `None` case we provide\n"
"a default value. Here's how to do this, specialized to\n"
"`Integer`s:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1069
#, no-wrap
msgid ""
"total\n"
"integerFromOption : Integer -> Option Integer -> Integer\n"
"integerFromOption _ (Some y) = y\n"
"integerFromOption x None     = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1080
#, no-wrap
msgid ""
"It's pretty obvious that this, again, is not general enough.\n"
"Surely, we'd also like to break out of `Option Bool` or\n"
"`Option String` in a similar fashion. That's exactly\n"
"what the generic function `fromOption` does:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1081
#, no-wrap
msgid ""
"total\n"
"fromOption : a -> Option a -> a\n"
"fromOption _ (Some y) = y\n"
"fromOption x None     = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1095
#, no-wrap
msgid ""
"The lower-case `a` is again a *type parameter*. You can read\n"
"the type signature as follows: \"For any type `a`, given a *value*\n"
"of type `a`, and an `Option a`, we can return a value of\n"
"type `a`.\" Note, that `fromOption` knows nothing else about\n"
"`a`, other than it being a type. It is therefore not possible,\n"
"to conjure a value of type `a` out of thin air. We *must* have\n"
"a value available to deal with the `None` case.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1098
#, no-wrap
msgid ""
"The pendant to `fromOption` for `Maybe` is called `fromMaybe`\n"
"and is available from module `Data.Maybe` from the *base* library.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1104
#, no-wrap
msgid ""
"Sometimes, `fromOption` is not general enough. Assume we'd like to\n"
"print the value of a freshly parsed `Bool`, giving some generic\n"
"error message in case of a `None`. We can't use `fromOption`\n"
"for this, as we have an `Option Bool` and we'd like to\n"
"return a `String`. Here's how to do this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1105
#, no-wrap
msgid ""
"total\n"
"option : b -> (a -> b) -> Option a -> b\n"
"option _ f (Some y) = f y\n"
"option x _ None     = x\n"
"\n"
"total\n"
"handleBool : Option Bool -> String\n"
"handleBool = option \"Not a boolean value.\" show\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1121
#, no-wrap
msgid ""
"Function `option` is parameterized over *two* type parameters:\n"
"`a` represents the type of values stored in the `Option`,\n"
"while `b` is the return type. In case of a `Just`, we need\n"
"a way to convert the stored `a` to a `b`, an that's done\n"
"using the function argument of type `a -> b`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1126
#, no-wrap
msgid ""
"In Idris, lower-case identifiers in function types are\n"
"treated as *type parameters*, while upper-case identifiers\n"
"are treated as types or type constructors that must\n"
"be in scope.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1127 ../src/Tutorial/Eq.md:1056
#, no-wrap
msgid "Exercises part 4"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1137
#, no-wrap
msgid ""
"If this is your first time programming in a purely\n"
"functional language, the exercises below are *very*\n"
"important. Do not skip any of them! Take your time and\n"
"work through them all. In most cases,\n"
"the types should be enough to explain what's going\n"
"on, even though they might appear cryptic in the\n"
"beginning. Otherwise, have a look at the comments (if any)\n"
"of each exercise.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1140
#, no-wrap
msgid ""
"Remember, that lower-case identifiers in a function\n"
"signature are treated as type parameters.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:1142
msgid "Implement the following generic functions for `Maybe`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1143
#, no-wrap
msgid ""
"   -- make sure to map a `Just` to a `Just`.\n"
"   total\n"
"   mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- Example: `appMaybe (Just (+2)) (Just 20) = Just 22`\n"
"   total\n"
"   appMaybe : Maybe (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- Example: `bindMaybe (Just 12) Just = Just 12`\n"
"   total\n"
"   bindMaybe : Maybe a -> (a -> Maybe b) -> Maybe b\n"
"\n"
"   -- keep the value in a `Just` only if the given predicate holds\n"
"   total\n"
"   filterMaybe : (a -> Bool) -> Maybe a -> Maybe a\n"
"\n"
"   -- keep the first value that is not a `Nothing` (if any)\n"
"   total\n"
"   first : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- keep the last value that is not a `Nothing` (if any)\n"
"   total\n"
"   last : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- this is another general way to extract a value from a `Maybe`.\n"
"   -- Make sure the following holds:\n"
"   -- `foldMaybe (+) 5 Nothing = 5`\n"
"   -- `foldMaybe (+) 5 (Just 12) = 17`\n"
"   total\n"
"   foldMaybe : (acc -> el -> acc) -> acc -> Maybe el -> acc\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:1177
msgid "Implement the following generic functions for `Either`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1178
#, no-wrap
msgid ""
"   total\n"
"   mapEither : (a -> b) -> Either e a -> Either e b\n"
"\n"
"   -- In case of both `Either`s being `Left`s, keep the\n"
"   -- value stored in the first `Left`.\n"
"   total\n"
"   appEither : Either e (a -> b) -> Either e a -> Either e b\n"
"\n"
"   total\n"
"   bindEither : Either e a -> (a -> Either e b) -> Either e b\n"
"\n"
"   -- Keep the first value that is not a `Left`\n"
"   -- If both `Either`s are `Left`s, use the given accumulator\n"
"   -- for the error values\n"
"   total\n"
"   firstEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   -- Keep the last value that is not a `Left`\n"
"   -- If both `Either`s are `Left`s, use the given accumulator\n"
"   -- for the error values\n"
"   total\n"
"   lastEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   total\n"
"   fromEither : (e -> c) -> (a -> c) -> Either e a -> c\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:1207
msgid "Implement the following generic functions for `List`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1208
#, no-wrap
msgid ""
"   total\n"
"   mapList : (a -> b) -> List a -> List b\n"
"\n"
"   total\n"
"   filterList : (a -> Bool) -> List a -> List a\n"
"\n"
"   -- return the first value of a list, if it is non-empty\n"
"   total\n"
"   headMaybe : List a -> Maybe a\n"
"\n"
"   -- return everything but the first value of a list, if it is non-empty\n"
"   total\n"
"   tailMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- return the last value of a list, if it is non-empty\n"
"   total\n"
"   lastMaybe : List a -> Maybe a\n"
"\n"
"   -- return everything but the last value of a list,\n"
"   -- if it is non-empty\n"
"   total\n"
"   initMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- accumulate the values in a list using the given\n"
"   -- accumulator function and initial value\n"
"   --\n"
"   -- Examples:\n"
"   -- `foldList (+) 10 [1,2,7] = 20`\n"
"   -- `foldList String.(++) \"\" [\"Hello\",\"World\"] = \"HelloWorld\"`\n"
"   -- `foldList last Nothing (mapList Just [1,2,3]) = Just 3`\n"
"   total\n"
"   foldList : (acc -> el -> acc) -> acc -> List el -> acc\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:1245
msgid "Assume we store user data for our web application in the following record:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1246
#, no-wrap
msgid ""
"   record Client where\n"
"     constructor MkClient\n"
"     name          : String\n"
"     title         : Title\n"
"     age           : Bits8\n"
"     passwordOrKey : Either Bits64 String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1260
#, no-wrap
msgid ""
"   Using `LoginError` from an earlier exercise,\n"
"   implement function `login`, which, given a list of `Client`s\n"
"   plus a value of type `Credentials` will return either a `LoginError`\n"
"   in case no valid credentials where provided, or the first `Client`\n"
"   for whom the credentials match.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DataTypes.md:1264
msgid ""
"Using your data type for chemical elements from an earlier exercise, "
"implement a function for calculating the molar mass of a molecular formula."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1268
#, no-wrap
msgid ""
"   Use a list of elements each paired with its count\n"
"   (a natural number) for representing formulae. For\n"
"   instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1269
#, no-wrap
msgid ""
"   ethanol : List (Element,Nat)\n"
"   ethanol = [(C,2),(H,6),(O,1)]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1276
#, no-wrap
msgid ""
"   Hint: You can use function `cast` to convert a natural\n"
"   number to a `Double`.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1277
#, no-wrap
msgid "Alternative Syntax for Data Definitions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1285
#, no-wrap
msgid ""
"While the examples in the section about parameterized\n"
"data types are short and concise, there is a slightly\n"
"more verbose but much more general form for writing such\n"
"definitions, which makes it much clearer what's going on.\n"
"In my opinion, this more general form should be preferred\n"
"in all but the most simple data definitions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1290
#, no-wrap
msgid ""
"Here are the definitions of `Option`, `Validated`, and `Seq` again,\n"
"using this more general form (I put them in their own *namespace*,\n"
"so Idris will not complain about identical names in\n"
"the same source file):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1291
#, no-wrap
msgid ""
"-- GADT is an acronym for \"generalized algebraic data type\"\n"
"namespace GADT\n"
"  data Option : Type -> Type where\n"
"    Some : a -> Option a\n"
"    None : Option a\n"
"\n"
"  data Validated : Type -> Type -> Type where\n"
"    Invalid : e -> Validated e a\n"
"    Valid   : a -> Validated e a\n"
"\n"
"  data Seq : Type -> Type where\n"
"    Nil  : Seq a\n"
"    (::) : a -> GADT.Seq a -> Seq a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1318
#, no-wrap
msgid ""
"Here, `Option` is clearly declared as a type constructor\n"
"(a function of type `Type -> Type`), while `Some`\n"
"is a generic function of type `a -> Option a` (where `a` is\n"
"a *type parameter*)\n"
"and `None` is a nullary generic function of type `Option a`\n"
"(`a` again being a type parameter).\n"
"Likewise for `Validated` and `Seq`. Note, that in case\n"
"of `Seq` we had to disambiguate between the different\n"
"`Seq` definitions in the recursive case. Since we will\n"
"usually not define several data types with the same name in\n"
"a source file, this is not necessary most of the time.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872 ../src/Tutorial/DPair.md:1191 ../src/Tutorial/Eq.md:1085 ../src/Tutorial/Folds.md:1051 ../src/Tutorial/Functions1.md:524 ../src/Tutorial/Functions2.md:924 ../src/Tutorial/Functor.md:1395 ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/IO.md:1095 ../src/Tutorial/Predicates.md:1358 ../src/Tutorial/Traverse.md:1109 ../src/Appendices/Neovim.md:364
#, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1323
#, no-wrap
msgid ""
"We covered a lot of ground in this chapter,\n"
"so I'll summarize the most important points below:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1326
#, no-wrap
msgid ""
"* Enumerations are data types consisting of a finite\n"
"number of possible *values*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1330
#, no-wrap
msgid ""
"* Sum types are data types with more than one data\n"
"constructor, where each constructor describes a\n"
"*choice* that can be made.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1333
#, no-wrap
msgid ""
"* Product types are data types with a single constructor\n"
"used to group several values of possibly different types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1337
#, no-wrap
msgid ""
"* We use pattern matching to deconstruct immutable\n"
"values in Idris. The possible patterns correspond to\n"
"a data type's data constructors.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1341
#, no-wrap
msgid ""
"* We can *bind* variables to values in a pattern or\n"
"use an underscore as a placeholder for a value that's\n"
"not needed on the right hand side of an implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1344
#, no-wrap
msgid ""
"* We can pattern match on an intermediary result by introducing\n"
"a *case block*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1349
#, no-wrap
msgid ""
"* The preferred way to define new product types is\n"
"to define them as *records*, since these come with\n"
"additional syntactic conveniences for setting and\n"
"modifying individual *record fields*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1354
#, no-wrap
msgid ""
"* Generic types and functions allow us generalize\n"
"certain concepts and make them available for many\n"
"types by using *type parameters* instead of\n"
"concrete types in function and type signatures.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1361
#, no-wrap
msgid ""
"* Common concepts like *nullary values* (`Maybe`),\n"
"computations that might fail with some error\n"
"condition (`Either`), and handling collections\n"
"of values of the same type at once (`List`) are\n"
"example use cases of generic types and functions\n"
"already provided by the *Prelude*.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904 ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954 ../src/Tutorial/Interfaces.md:813 ../src/Tutorial/IO.md:1118
#, no-wrap
msgid "What's next"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1366
#, no-wrap
msgid ""
"In the [next section](Interfaces.md), we will introduce\n"
"*interfaces*, another approach to *function overloading*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910 ../src/Tutorial/DPair.md:1206 ../src/Tutorial/Eq.md:1098 ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583 ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427 ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/IO.md:1125 ../src/Tutorial/Predicates.md:1369 ../src/Tutorial/Prim.md:1411 ../src/Tutorial/Traverse.md:1148 ../src/Appendices/Neovim.md:374
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2\n"
"-->\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Dependent.md:1 ../src/Tutorial/Intro.md:76
#, no-wrap
msgid "Dependent Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:9
#, no-wrap
msgid ""
"The ability to calculate types from values, pass them as arguments\n"
"to functions, and return them as results from functions - in\n"
"short, being a dependently typed language - is one of the\n"
"most distinguishing features of Idris. Many of the more advanced\n"
"type level extensions of languages like Haskell (and quite a\n"
"bit more) can be treated in one fell swoop with dependent types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:10
#, no-wrap
msgid ""
"module Tutorial.Dependent\n"
"\n"
"%default total\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:17
#, no-wrap
msgid "Consider the following functions:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:18
#, no-wrap
msgid ""
"bogusMapList : (a -> b) -> List a -> List b\n"
"bogusMapList _ _ = []\n"
"\n"
"bogusZipList : (a -> b -> c) -> List a -> List b -> List c\n"
"bogusZipList _ _ _ = []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:35
#, no-wrap
msgid ""
"The implementations type check, and still, they are obviously not\n"
"what users of our library would expect. In the first example, we'd expect\n"
"the implementation to apply the function argument to all values stored\n"
"in the list, without dropping any of them or changing their order.\n"
"The second is trickier: The two list arguments might be of different "
"length.\n"
"What are we supposed to do when that's the case? Return a list of the same\n"
"length as the smaller of the two? Return an empty list? Or shouldn't\n"
"we in most use cases expect the two lists to be of the same length?\n"
"How could we even describe such a precondition?\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Dependent.md:36
#, no-wrap
msgid "Length-Indexed Lists"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:41
#, no-wrap
msgid ""
"The answer to the issues described above is of course: Dependent types.\n"
"And the most common introductory example is the *vector*: A list indexed\n"
"by its length:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:42
#, no-wrap
msgid ""
"data Vect : (len : Nat) -> (a : Type) -> Type where\n"
"  Nil  : Vect 0 a\n"
"  (::) : (x : a) -> (xs : Vect n a) -> Vect (S n) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:58
#, no-wrap
msgid ""
"Before we move on, please compare this with the implementation of `Seq` in\n"
"the [section about algebraic data types](DataTypes.md). The constructors\n"
"are exactly the same: `Nil` and `(::)`. But there is an important "
"difference:\n"
"`Vect`, unlike `Seq` or `List`, is not a function from `Type` to `Type`, it "
"is\n"
"a function from `Nat` to `Type` to `Type`. Go ahead! Open the REPL and\n"
"verify this! The `Nat` argument (also called an *index*) represents\n"
"the *length* of the vector here.\n"
"`Nil` has type `Vect 0 a`: A vector of length\n"
"zero. *Cons* has type `a -> Vect n a -> Vect (S n) a`: It is exactly one\n"
"element longer (`S n`) than its second argument, which is of length `n`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:61
#, no-wrap
msgid ""
"Let's experiment with this idea to gain a better understanding.\n"
"There is only one way to come up with a vector of length zero:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:62
#, no-wrap
msgid ""
"ex1 : Vect 0 Integer\n"
"ex1 = Nil\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:69
#, no-wrap
msgid ""
"The following, on the other hand, leads to a type error (a pretty "
"complicated\n"
"one, actually):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:70
#, no-wrap
msgid ""
"failing \"Mismatch between: S ?n and 0.\"\n"
"  ex2 : Vect 0 Integer\n"
"  ex2 = [12]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:80
#, no-wrap
msgid ""
"The problem: `[12]` gets desugared to `12 :: Nil`, but this has the wrong\n"
"type! Since `Nil` has type `Vect 0 Integer` here, `12 :: Nil` has type\n"
"`Vect (S 0) Integer`, which is identical to `Vect 1 Integer`. Idris "
"verifies,\n"
"at compile time, that our vector is of the correct length!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:81
#, no-wrap
msgid ""
"ex3 : Vect 1 Integer\n"
"ex3 = [12]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:93
#, no-wrap
msgid ""
"So, we found a way to encode the *length* of a list-like data structure in\n"
"its *type*, and it is a *type error* if the number of elements in\n"
"a vector does not agree with then length given in its type. We will\n"
"shortly see several use cases, where this additional piece of information\n"
"allows us to be more precise in the types and rule out additional\n"
"programming mistakes. But first, we need to quickly clarify some\n"
"terminology.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Dependent.md:94
#, no-wrap
msgid "Type Indices versus Type Parameters"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:101
#, no-wrap
msgid ""
"`Vect` is not only a generic type, parameterized over the type\n"
"of elements it holds, it is actually a *family of types*, each\n"
"of them associated with a natural number representing it's\n"
"length. We also say, the type family `Vect` is *indexed* by\n"
"its length.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:108
#, no-wrap
msgid ""
"The difference between a type parameter and an index is, that\n"
"the latter can and does change across data constructors, while\n"
"the former is the same for all data constructors. Or, put differently,\n"
"we can learn about the *value* of an index by pattern matching\n"
"on a *value* of the type family, while this is not possible\n"
"with a type parameter.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:110
#, no-wrap
msgid "Let's demonstrate this with a contrived example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:111
#, no-wrap
msgid ""
"data Indexed : Nat -> Type where\n"
"  I0 : Indexed 0\n"
"  I3 : Indexed 3\n"
"  I4 : String -> Indexed 4\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:124
#, no-wrap
msgid ""
"Here, `Indexed` is indexed over its `Nat` argument, as\n"
"values of the index changes across constructors (I chose some\n"
"arbitrary value for each constructor), and we\n"
"can learn about these values by pattern matching on `Indexed` values.\n"
"We can use this, for instance, to create a `Vect` of the same length\n"
"as the index of `Indexed`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:125
#, no-wrap
msgid "fromIndexed : Indexed n -> a -> Vect n a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:133
#, no-wrap
msgid ""
"Go ahead, and try implementing this yourself! Work with\n"
"holes, pattern match on the `Indexed` argument, and\n"
"learn about the expected output type in each case by\n"
"inspecting the holes and their context.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:135
#, no-wrap
msgid "Here is my implementation:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:136
#, no-wrap
msgid ""
"fromIndexed I0     va = []\n"
"fromIndexed I3     va = [va, va, va]\n"
"fromIndexed (I4 _) va = [va, va, va, va]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:146
#, no-wrap
msgid ""
"As you can see, by pattern matching on the value of the\n"
"`Indexed n` argument, we learned about the value of\n"
"the `n` index itself, which was necessary to return a\n"
"`Vect` of the correct length.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Dependent.md:147
#, no-wrap
msgid "Length-Preserving `map`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:154
#, no-wrap
msgid ""
"Function `bogusMapList` behaved unexpectedly, because it always\n"
"returned the empty list. With `Vect`, we need to be true to the\n"
"types here. If we map over a `Vect`, the argument *and* output type\n"
"contain a length index, and these length indices will tell us\n"
"*exactly*, if and how the lengths of our vectors are modified:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:155
#, no-wrap
msgid ""
"map3_1 : (a -> b) -> Vect 3 a -> Vect 1 b\n"
"map3_1 f [_,y,_] = [f y]\n"
"\n"
"map5_0 : (a -> b) -> Vect 5 a -> Vect 0 b\n"
"map5_0 f _ = []\n"
"\n"
"map5_10 : (a -> b) -> Vect 5 a -> Vect 10 b\n"
"map5_10 f [u,v,w,x,y] = [f u, f u, f v, f v, f w, f w, f x, f x, f y, f y]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:173
#, no-wrap
msgid ""
"While these examples are quite interesting,\n"
"they are not really useful, are they? That's because they are too\n"
"specialized. We'd like to have a *general* function for mapping\n"
"vectors of any length.\n"
"Instead of using concrete lengths in type signatures,\n"
"we can also use *variables* as already seen in the definition of `Vect`.\n"
"This allows us to declare the general case:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:174
#, no-wrap
msgid "mapVect' : (a -> b) -> Vect n a -> Vect n b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:181
#, no-wrap
msgid ""
"This type describes a length-preserving map. It is actually\n"
"more instructive (but not necessary) to include the\n"
"implicit arguments as well:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:182
#, no-wrap
msgid "mapVect : {0 a,b : _} -> {0 n : Nat} -> (a -> b) -> Vect n a -> Vect n b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:196
#, no-wrap
msgid ""
"We ignore the two type parameters `a`, and `b`, as these just\n"
"describe a generic function (note, however, that we can group arguments\n"
"of the same type and quantity in a single pair of curly braces; this\n"
"is optional, but it sometimes helps making type signatures a bit\n"
"shorter). The implicit argument of type `Nat`, however, tells us that the\n"
"input and output `Vect` are of the same length. It is a type error\n"
"to not uphold to this contract. When implementing `mapVect`, it\n"
"is very instructive to follow along and use some holes. In order\n"
"to get *any* information about the length of the `Vect` argument,\n"
"we need to pattern match on it:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:197
#, no-wrap
msgid ""
"mapVect _ Nil       = ?impl_0\n"
"mapVect f (x :: xs) = ?impl_1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:203
#, no-wrap
msgid "At the REPL, we learn the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:204
#, no-wrap
msgid ""
"Tutorial.Dependent> :t impl_0\n"
" 0 a : Type\n"
" 0 b : Type\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_0 : Vect 0 b\n"
"\n"
"\n"
"Tutorial.Dependent> :t impl_1\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_1 : Vect (S n) b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:226
#, no-wrap
msgid ""
"The first hole, `impl_0` is of type `Vect 0 b`. There is only one such\n"
"value, as discussed above:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:227
#, no-wrap
msgid "mapVect _ Nil       = Nil\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:238
#, no-wrap
msgid ""
"The second case is again more interesting. We note, that `xs` is\n"
"of type `Vect n a`, for an arbitrary length `n` (given as an erased\n"
"argument), while the result is of type `Vect (S n) b`. So, the\n"
"result has to be one element longer than `xs`. Luckily, we already\n"
"have a value of type `a` (bound to variable `x`) and a function\n"
"from `a` to `b` (bound to variable `f`), so we can apply `f`\n"
"to `x` and prepend the result to a yet unknown remainder:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:239
#, no-wrap
msgid "mapVect f (x :: xs) = f x :: ?rest\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:244
#, no-wrap
msgid "Let's inspect the new hole at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:245
#, no-wrap
msgid ""
"Tutorial.Dependent> :t rest\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"rest : Vect n b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:265
#, no-wrap
msgid ""
"Now, we have a `Vect n a` and need a `Vect n b`, without knowing anything\n"
"else about `n`. We *could* learn more about `n` by pattern matching "
"further\n"
"on `xs`, but this would quickly lead us down a rabbit hole, since after\n"
"such a pattern match, we'd end up with another `Nil` case and another\n"
"*cons* case, with a new tail of unknown length. Instead, we can invoke\n"
"`mapVect` recursively to convert the remainder (`xs`) to a `Vect n b`.\n"
"The type checker guarantees, that the lengths of `xs` and `mapVect f xs`\n"
"are the same, so the whole expression type checks and we are done:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:266
#, no-wrap
msgid "mapVect f (x :: xs) = f x :: mapVect f xs\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Dependent.md:270
#, no-wrap
msgid "Zipping Vectors"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:277
#, no-wrap
msgid ""
"Let us now have a look at `bogusZipList`: We'd like to pairwise merge\n"
"two lists holding elements of (possibly) distinct types through a\n"
"given binary function. As discussed above, the most reasonable thing\n"
"to do is to expect the two lists as well as the result to be of equal "
"length.\n"
"With `Vect`, this can be expressed and implemented as follows:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:278
#, no-wrap
msgid ""
"zipWith : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"zipWith f []        []         = Nil\n"
"zipWith f (x :: xs) (y :: ys)  = f x y :: zipWith f xs ys\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:295
#, no-wrap
msgid ""
"Now, here is an interesting thing: The totality checker (activated\n"
"throughout this source file due to the initial `%default total` pragma)\n"
"accepts the above implementation as being total, although it is\n"
"missing two more cases. This works, because Idris\n"
"can figure out on its own, that the other two cases are *impossible*.\n"
"From the pattern match on the first `Vect` argument, Idris learns\n"
"whether `n` is zero or the successor of another natural number. But\n"
"from this it can derive, whether the second vector, being also\n"
"of length `n`, is a `Nil` or a *cons*. Still, it can be informative to add "
"the\n"
"impossible cases explicitly. We can use keyword `impossible` to\n"
"do so:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:296
#, no-wrap
msgid ""
"zipWith _ [] (_ :: _) impossible\n"
"zipWith _ (_ :: _) [] impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:306
#, no-wrap
msgid ""
"It is - of course - a type error to annotate a case in a pattern\n"
"match with `impossible`, if Idris cannot verify that this case is\n"
"indeed impossible. We will learn in a later section what to do,\n"
"when we think we are right about an impossible case\n"
"and Idris is not.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:308
#, no-wrap
msgid "Let's give `zipWith` a spin at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:309
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20,30]\n"
"[10, 40, 90]\n"
"Tutorial.Dependent> zipWith (\\x,y => x ++ \": \" ++ show y) [\"The "
"answer\"] [42]\n"
"[\"The answer: 42\"]\n"
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20]\n"
"... Nasty type error ...\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Dependent.md:318
#, no-wrap
msgid "Simplifying Type Errors"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:329
#, no-wrap
msgid ""
"It is amazing to experience the amount of work Idris can do\n"
"for us and the amount of things it can infer on its own when\n"
"things go well. When things don't go well, however, the\n"
"error messages we get from Idris can\n"
"be quite long and hard to understand, especially\n"
"for programmers new to the language. For instance, the error\n"
"message in the last REPL example above was pretty long, listing\n"
"different things Idris tried to do together with the reason\n"
"why each of them failed.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:341
#, no-wrap
msgid ""
"If this happens, it often means that a combination of a type error\n"
"and an ambiguity resulting from overloaded function names is\n"
"at work. In the example above, the two vectors are of distinct\n"
"length, which leads to a type error if we interpret the list\n"
"literals as vectors. However, list literals are overloaded to work\n"
"with all data types with constructors `Nil` and `(::)`, so Idris\n"
"will now try other data constructors than those of `Vect` (the\n"
"ones of `List` and `Stream` from the *Prelude* in this case),\n"
"each of which will again fail with a type error since `zipWith`\n"
"expects arguments of type `Vect`, and neither `List` nor `Stream`\n"
"will work.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:345
#, no-wrap
msgid ""
"If this happens, prefixing overloaded function names with\n"
"their namespaces can often simplify things, as Idris no\n"
"longer needs to disambiguate these functions:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:346
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) (Dependent.(::) 1 Dependent.Nil) "
"Dependent.Nil\n"
"Error: When unifying:\n"
"    Vect 0 ?c\n"
"and:\n"
"    Vect 1 ?c\n"
"Mismatch between: 0 and 1.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:360
#, no-wrap
msgid ""
"Here, the message is much clearer: Idris can't *unify* the lengths of the\n"
"two vectors. *Unification* means: Idris tries to at compile time convert\n"
"two expressions to the same normal form. If this succeeds,\n"
"the two expressions are considered to be equivalent,\n"
"if it doesn't, Idris fails with a unification error.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:363
#, no-wrap
msgid ""
"As an alternative to prefixing overloaded functions with their\n"
"namespace, we can use `the` to help with type inference:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:364
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) (the (Vect 3 _) [1,2,3]) (the (Vect 2 _) "
"[10,20])\n"
"Error: When unifying:\n"
"    Vect 2 ?c\n"
"and:\n"
"    Vect 3 ?c\n"
"Mismatch between: 0 and 1.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:379
#, no-wrap
msgid ""
"It is interesting to note, that the error above is not \"Mismatch between: 2 "
"and 3\"\n"
"but \"Mismatch between: 0 and 1\" instead. Here's what's going on: Idris "
"tries to\n"
"unify integer literals `2` and `3`, which are first converted to the\n"
"corresponding `Nat` values `S (S Z)` and `S (S (S Z))`, respectively.\n"
"The two patterns match until we arrive at `Z` vs `S Z`, corresponding\n"
"to values `0` and `1`, which is the discrepancy reported in the error "
"message.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Dependent.md:380
#, no-wrap
msgid "Creating Vectors"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:387
#, no-wrap
msgid ""
"So far, we were able to learn something about the lengths\n"
"of vectors by pattern matching on them. In the `Nil`\n"
"case, it was clear that the length is 0, while in the *cons*\n"
"case the length was the successor of another natural number.\n"
"This is not possible when we want to create a new vector:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:388
#, no-wrap
msgid ""
"failing \"Mismatch between: S ?n and n.\"\n"
"  fill : a -> Vect n a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:395
#, no-wrap
msgid ""
"You will have a hard time implementing `fill`. The following,\n"
"for instance, leads to a type error:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:396
#, no-wrap
msgid "  fill va = [va,va]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:403
#, no-wrap
msgid ""
"The problem is, that *the callers of our function decide about\n"
"the length of the resulting vector*. The full type of `fill` is\n"
"actually the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:404
#, no-wrap
msgid "fill' : {0 a : Type} -> {0 n : Nat} -> a -> Vect n a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:415
#, no-wrap
msgid ""
"You can read this type as follows: For every type `a` and for\n"
"every natural number `n` (about which I know *nothing* at runtime,\n"
"since it has quantity zero), given a value of type `a`, I'll give\n"
"you a vector holding exactly `n` elements of type `a`. This is\n"
"like saying: \"Think about a natural number `n`, and\n"
"I'll give you `n` apples without you telling me the value of `n`\".\n"
"Idris is powerful, but it is not a clairvoyant.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:420
#, no-wrap
msgid ""
"In order to implement `fill`, we need to know what\n"
"`n` actually is: We need to pass `n` as an explicit, unerased argument, "
"which\n"
"will allow us to pattern match on it and decide - based on this pattern\n"
"match - which constructors of `Vect` to use:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:421
#, no-wrap
msgid "replicate : (n : Nat) -> a -> Vect n a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:428
#, no-wrap
msgid ""
"Now, `replicate` is a *dependent function type*: The output type\n"
"*depends* on the value of one of the arguments. It is straight forward\n"
"to implement `replicate` by pattern matching on `n`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:429
#, no-wrap
msgid ""
"replicate 0     _  = []\n"
"replicate (S k) va = va :: replicate k va\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:443
#, no-wrap
msgid ""
"This is a pattern that comes up often when working with\n"
"indexed types: We can learn about the values of the indices\n"
"by pattern matching on the values of the type family. However,\n"
"in order to return a value of the type family from a function,\n"
"we need to either know the values of the indices at compile\n"
"time (see constants `ex1` or `ex3`, for instance), or we\n"
"need to have access to the values of the indices at runtime, in\n"
"which case we can pattern match on them and learn from\n"
"this, which constructor(s) of the type family to use.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:447
msgid "Implement function `head` for non-empty vectors:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:448
#, no-wrap
msgid "   head : Vect (S n) a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:457
#, no-wrap
msgid ""
"   Note, how we can describe non-emptiness by using a *pattern*\n"
"   in the length of `Vect`. This rules out the `Nil` case, and we can\n"
"   return a value of type `a`, without having to wrap it in\n"
"   a `Maybe`! Make sure to add an `impossible` clause for the `Nil`\n"
"   case (although this is not strictly necessary here).\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:461
msgid ""
"Using `head` as a reference, declare and implement function `tail` for "
"non-empty vectors. The types should reflect that the output is exactly one "
"element shorter than the input."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:464
msgid ""
"Implement `zipWith3`. If possible, try to doing so without looking at the "
"implementation of `zipWith`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:465
#, no-wrap
msgid ""
"   zipWith3 : (a -> b -> c -> d) -> Vect n a -> Vect n b -> Vect n c -> Vect "
"n d\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Dependent.md:474
msgid ""
"Declare and implement a function `foldSemi` for accumulating the values "
"stored in a `List` through `Semigroup`s append operator (`(<+>)`).  (Make "
"sure to only use a `Semigroup` constraint, as opposed to a `Monoid` "
"constraint.)"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Dependent.md:477
msgid ""
"Do the same as in Exercise 4, but for non-empty vectors. How does a vector's "
"non-emptiness affect the output type?"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Dependent.md:482
msgid ""
"Given an initial value of type `a` and a function `a -> a`, we'd like to "
"generate `Vect`s of `a`s, the first value of which is `a`, the second value "
"being `f a`, the third being `f (f a)` and so on."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:485
#, no-wrap
msgid ""
"   For instance, if `a` is 1 and `f` is `(* 2)`, we'd like\n"
"   to get results similar to the following: `[1,2,4,8,16,...]`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:489
#, no-wrap
msgid ""
"   Declare and implement function `iterate`, which should\n"
"   encapsulate this behavior. Get some inspiration from `replicate`\n"
"   if you don't know where to start.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Dependent.md:495
msgid ""
"Given an initial value of a state type `s` and a function `fun : s -> "
"(s,a)`, we'd like to generate `Vect`s of `a`s. Declare and implement "
"function `generate`, which should encapsulate this behavior. Make sure to "
"use the updated state in every new invocation of `fun`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:498
#, no-wrap
msgid ""
"   Here's an example how this can be used to generate the first\n"
"   `n` Fibonacci numbers:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:499
#, no-wrap
msgid ""
"   generate 10 (\\(x,y) => let z = x + y in ((y,z),z)) (0,1)\n"
"   [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Dependent.md:507
msgid ""
"Implement function `fromList`, which converts a list of values to a `Vect` "
"of the same length. Use holes if you get stuck:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:508
#, no-wrap
msgid "   fromList : (as : List a) -> Vect (length as) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:515
#, no-wrap
msgid ""
"   Note how, in the type of `fromList`, we can *calculate* the\n"
"   length of the resulting vector by passing the list argument\n"
"   to function *length*.\n"
msgstr ""

#. type: Bullet: '9. '
#: ../src/Tutorial/Dependent.md:517
msgid "Consider the following declarations:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:518
#, no-wrap
msgid ""
"   maybeSize : Maybe a -> Nat\n"
"\n"
"   fromMaybe : (m : Maybe a) -> Vect (maybeSize m) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:526
#, no-wrap
msgid ""
"   Choose a reasonable implementation for `maybeSize` and\n"
"   implement `fromMaybe` afterwards.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Dependent.md:527
#, no-wrap
msgid "`Fin`: Safe Indexing into Vectors"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:531
#, no-wrap
msgid ""
"Consider function `index`, which tries to extract a value from\n"
"a `List` at the given position:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:532
#, no-wrap
msgid ""
"indexList : (pos : Nat) -> List a -> Maybe a\n"
"indexList _     []        = Nothing\n"
"indexList 0     (x :: _)  = Just x\n"
"indexList (S k) (_ :: xs) = indexList k xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:553
#, no-wrap
msgid ""
"Now, here is a thing to consider when writing functions like `indexList`:\n"
"Do we want to express the possibility of failure in the output type,\n"
"or do we want to restrict the accepted arguments,\n"
"so the function can no longer fail? These are important design decisions,\n"
"especially in larger applications.\n"
"Returning a `Maybe` or `Either` from a function forces client code to "
"eventually\n"
"deal with the `Nothing` or `Left` case, and until this happens, all "
"intermediary\n"
"results will carry the `Maybe` or `Either` stain, which will make it more\n"
"cumbersome to run calculations with these intermediary results.\n"
"On the other hand, restricting the\n"
"values accepted as input will complicate the argument types\n"
"and will put the burden of input validation on our functions' callers,\n"
"(although, at compile time we can get help from Idris, as we will\n"
"see when we talk about auto implicits) while keeping the output pure and "
"clean.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:558
#, no-wrap
msgid ""
"Languages without dependent types (like Haskell), can often only take\n"
"the route described above: To wrap the result in a `Maybe` or `Either`.\n"
"However, in Idris we can often *refine* the input types to restrict the\n"
"set of accepted values, thus ruling out the possibility of failure.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:564
#, no-wrap
msgid ""
"Assume, as an example, we'd like to extract a value from a `Vect n a`\n"
"at (zero-based) index `k`. Surely, this can succeed if and only if\n"
"`k` is a natural number strictly smaller than the length `n` of\n"
"the vector. Luckily, we can express this precondition in an indexed\n"
"type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:565
#, no-wrap
msgid ""
"data Fin : (n : Nat) -> Type where\n"
"  FZ : {0 n : Nat} -> Fin (S n)\n"
"  FS : (k : Fin n) -> Fin (S n)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:577
#, no-wrap
msgid ""
"`Fin n` is the type of natural numbers strictly smaller than `n`.\n"
"It is defined inductively: `FZ` corresponds to natural number *zero*,\n"
"which, as can be seen in its type, is strictly smaller than\n"
"`S n` for any natural number `n`. `FS` is the inductive case:\n"
"If `k` is strictly smaller than `n` (`k` being of type `Fin n`),\n"
"then `FS k` is strictly smaller than `S n`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:579
#, no-wrap
msgid "Let's come up with some values of type `Fin`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:580
#, no-wrap
msgid ""
"fin0_5 : Fin 5\n"
"fin0_5 = FZ\n"
"\n"
"fin0_7 : Fin 7\n"
"fin0_7 = FZ\n"
"\n"
"fin1_3 : Fin 3\n"
"fin1_3 = FS FZ\n"
"\n"
"fin4_5 : Fin 5\n"
"fin4_5 = FS (FS (FS (FS FZ)))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:597
#, no-wrap
msgid ""
"Note, that there is no value of type `Fin 0`. We will learn\n"
"in a later session, how to express \"there is no value of type `x`\"\n"
"in a type.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:600
#, no-wrap
msgid ""
"Let us now check, whether we can use `Fin` to safely index\n"
"into a `Vect`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:601
#, no-wrap
msgid "index : Fin n -> Vect n a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:607
#, no-wrap
msgid ""
"Before you continue, try to implement `index` yourself, making use\n"
"of holes if you get stuck.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:608
#, no-wrap
msgid ""
"index FZ     (x :: _) = x\n"
"index (FS k) (_ :: xs) = index k xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:617
#, no-wrap
msgid ""
"Note, how there is no `Nil` case and the totality checker is still\n"
"happy. That's because `Nil` is of type `Vect 0 a`, but there is no\n"
"value of type `Fin 0`! We can verify this by adding the missing\n"
"impossible clauses:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:618
#, no-wrap
msgid ""
"index FZ     Nil impossible\n"
"index (FS _) Nil impossible\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:627
msgid ""
"Implement function `update`, which, given a function of type `a -> a`, "
"updates the value in a`Vect n a` at position `k < n`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:631
msgid ""
"Implement function `insert`, which inserts a value of type `a` at position "
"`k <= n` in a `Vect n a`. Note, that `k` is the index of the freshly "
"inserted value, so that the following holds:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:632
#, no-wrap
msgid "   index k (insert k v vs) = v\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:638
msgid ""
"Implement function `delete`, which deletes a value from a vector at the "
"given index."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:641
#, no-wrap
msgid ""
"   This is trickier than Exercises 1 and 2, as we have to properly\n"
"   encode in the types that the vector is getting one element shorter.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Dependent.md:644
msgid ""
"We can use `Fin` to implement safe indexing into `List`s as well. Try to "
"come up with a type and implementation for `safeIndexList`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:648
#, no-wrap
msgid ""
"   Note: If you don't know how to start, look at the type of `fromList`\n"
"   for some inspiration. You might also need give the arguments in\n"
"   a different order than for `index`.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Dependent.md:653
msgid ""
"Implement function `finToNat`, which converts a `Fin n` to the corresponding "
"natural number, and use this to declare and implement function `take` for "
"splitting of the first `k` elements of a `Vect n a` with `k <= n`."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Dependent.md:656
msgid ""
"Implement function `minus` for subtracting a value `k` from a natural number "
"`n` with `k <= n`."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Dependent.md:660
msgid ""
"Use `minus` from Exercise 6 to declare and implement function `drop`, for "
"dropping the first `k` values from a `Vect n a`, with `k <= n`."
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Dependent.md:664
msgid ""
"Implement function `splitAt` for splitting a `Vect n a` at position `k <= "
"n`, returning the prefix and suffix of the vector wrapped in a pair."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:666
#, no-wrap
msgid "   Hint: Use `take` and `drop` in your implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:670
#, no-wrap
msgid ""
"Hint: Since `Fin n` consists of the values strictly smaller\n"
"than `n`, `Fin (S n)` consists of the values smaller than\n"
"or equal to `n`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:675
#, no-wrap
msgid ""
"Note: Functions `take`, `drop`, and `splitAt`, while correct and\n"
"provably total, are rather cumbersome to type.\n"
"There is an alternative way to declare their types,\n"
"as we will see in the next section.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Dependent.md:676
#, no-wrap
msgid "Compile-Time Computations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:683
#, no-wrap
msgid ""
"In the last section - especially in some of the exercises - we\n"
"started more and more to use compile time computations to\n"
"describe the types of our functions and values.\n"
"This is a very powerful concept, as it allows us to\n"
"compute output types from input types. Here's an example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:690
#, no-wrap
msgid ""
"It is possible to concatenate two `List`s with the `(++)`\n"
"operator. Surely, this should also be possible for\n"
"`Vect`. But `Vect` is indexed by its length, so we have\n"
"to reflect in the types exactly how the lengths of the\n"
"inputs affect the lengths of the output. Here's how to\n"
"do this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:691
#, no-wrap
msgid ""
"(++) : Vect m a -> Vect n a -> Vect (m + n) a\n"
"(++) []        ys = ys\n"
"(++) (x :: xs) ys = x :: (xs ++ ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:700
#, no-wrap
msgid ""
"Note, how we keep track of the lengths at the type-level, again\n"
"ruling out certain common programming errors like inadvertently dropping\n"
"some values.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:705
#, no-wrap
msgid ""
"We can also use type-level computations as patterns\n"
"on the input types. Here is an alternative type and implementation\n"
"for `drop`, which you implemented in the exercises by\n"
"using a `Fin n` argument:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:706
#, no-wrap
msgid ""
"drop' : (m : Nat) -> Vect (m + n) a -> Vect n a\n"
"drop' 0     xs        = xs\n"
"drop' (S k) (_ :: xs) = drop' k xs\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Dependent.md:712
#, no-wrap
msgid "Limitations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:718
#, no-wrap
msgid ""
"After all the examples and exercises in this section\n"
"you might have come to the conclusion that we can\n"
"use arbitrary expressions in the types and Idris\n"
"will happily evaluate and unify all of them for us.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:724
#, no-wrap
msgid ""
"I'm afraid that's not even close to the truth. The examples\n"
"in this section were hand-picked because they are known\n"
"to *just work*. The reason being, that there was always\n"
"a direct link between our own pattern matches and the\n"
"implementations of functions we used at compile time.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:727
#, no-wrap
msgid ""
"For instance, here is the implementation of addition of\n"
"natural numbers:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:728
#, no-wrap
msgid ""
"add : Nat -> Nat -> Nat\n"
"add Z     n = n\n"
"add (S k) n = S $ add k n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:745
#, no-wrap
msgid ""
"As you can see, `add` is implemented via a pattern match\n"
"on its *first* argument, while the second argument is never\n"
"inspected. Note, how this is exactly how `(++)` for `Vect`\n"
"is implemented: There, we also pattern match on the first\n"
"argument, returning the second unmodified in the `Nil`\n"
"case, and prepending the head to the result of appending\n"
"the tail in the *cons* case. Since there is a direct\n"
"correspondence between the two pattern matches, it\n"
"is possible for Idris to unify `0 + n` with `n` in the\n"
"`Nil` case, and `(S k) + n` with `S (k + n)` in the\n"
"*cons* case.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:748
#, no-wrap
msgid ""
"Here is a simple example, where Idris will not longer\n"
"be convinced without some help from us:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:749
#, no-wrap
msgid ""
"failing \"Can't solve constraint\"\n"
"  reverse : Vect n a -> Vect n a\n"
"  reverse []        = []\n"
"  reverse (x :: xs) = reverse xs ++ [x]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:768
#, no-wrap
msgid ""
"When we type-check the above,\n"
"Idris will fail with the following error message:\n"
"\"Can't solve constraint between: plus n 1 and S n.\"\n"
"Here's what's going on: From the pattern match on the\n"
"left hand side, Idris knows that the length of the\n"
"vector is `S n`, for some natural number `n`\n"
"corresponding to the length of `xs`. The length\n"
"of the vector on the right hand side is `n + 1`,\n"
"according to the type of `(++)` and the lengths\n"
"of `xs` and `[x]`. Overloaded operator `(+)`\n"
"is implemented via function `Prelude.plus`, that's\n"
"why Idris replaces `(+)` with `plus` in the error message.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:780
#, no-wrap
msgid ""
"As you can see from the above, Idris can't verify on\n"
"its own that `1 + n` is the same thing as `n + 1`.\n"
"It can accept some help from us, though. If we come\n"
"up with a *proof* that the above equality holds\n"
"(or - more generally - that our implementation of\n"
"addition for natural numbers is *commutative*),\n"
"we can use this proof to *rewrite* the types on\n"
"the right hand side of `reverse`. Writing proofs and\n"
"using `rewrite` will require some in-depth explanations\n"
"and examples. Therefore, these things will have to wait\n"
"until another chapter.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Dependent.md:781
#, no-wrap
msgid "Unrestricted Implicits"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:789
#, no-wrap
msgid ""
"In functions like `replicate`, we pass a natural number `n`\n"
"as an explicit, unrestricted argument from which we infer\n"
"the length of the vector to return.\n"
"In some circumstances, `n` can be inferred from the context.\n"
"For instance, in the following example it is tedious to\n"
"pass `n` explicitly:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:790
#, no-wrap
msgid ""
"ex4 : Vect 3 Integer\n"
"ex4 = zipWith (*) (replicate 3 10) (replicate 3 11)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:797
#, no-wrap
msgid ""
"The value `n` is clearly derivable from the context, which\n"
"can be confirmed by replacing it with underscores:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:798
#, no-wrap
msgid ""
"ex5 : Vect 3 Integer\n"
"ex5 = zipWith (*) (replicate _ 10) (replicate _ 11)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:806
#, no-wrap
msgid ""
"We therefore can implement an alternative version of `replicate`,\n"
"where we pass `n` as an implicit argument of *unrestricted*\n"
"quantity:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:807
#, no-wrap
msgid ""
"replicate' : {n : _} -> a -> Vect n a\n"
"replicate' = replicate n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:814
#, no-wrap
msgid ""
"Note how, in the implementation of `replicate'`, we can refer to `n`\n"
"and pass it as an explicit argument to `replicate`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:820
#, no-wrap
msgid ""
"Deciding whether to pass potentially inferable arguments to a function "
"implicitly\n"
"or explicitly is a question of how often the arguments actually *are* "
"inferable\n"
"by Idris. Sometimes it might even be useful to have both verions\n"
"of a function. Remember, however, that even in case of an implicit "
"argument\n"
"we can still pass the value explicitly:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:821
#, no-wrap
msgid ""
"ex6 : Vect ? Bool\n"
"ex6 = replicate' {n = 2} True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:829
#, no-wrap
msgid ""
"In the type signature above, the question mark (`?`) means, that Idris\n"
"should try and figure out the value on its own by unification. This\n"
"forces us to specify `n` explicitly on the right hand side of `ex6`.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Dependent.md:830
#, no-wrap
msgid "Pattern Matching on Implicits"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:836
#, no-wrap
msgid ""
"The implementation of `replicate'` makes use of function `replicate`,\n"
"where we could pattern match on the explicit argument `n`. However, it\n"
"is also possible to pattern match on implicit, named arguments of\n"
"non-zero quantity:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:837
#, no-wrap
msgid ""
"replicate'' : {n : _} -> a -> Vect n a\n"
"replicate'' {n = Z}   _ = Nil\n"
"replicate'' {n = S _} v = v :: replicate'' v\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:846
msgid "Here is a function declaration for flattening a `List` of `List`s:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:847
#, no-wrap
msgid "   flattenList : List (List a) -> List a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:853
#, no-wrap
msgid ""
"   Implement `flattenList` and declare and implement a similar\n"
"   function `flattenVect` for flattening vectors of vectors.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:857
msgid ""
"Implement functions `take'` and `splitAt'` like in the exercises of the "
"previous section but using the technique shown for `drop'`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:861
msgid ""
"Implement function `transpose` for converting an `m x n`-matrix (represented "
"as a `Vect m (Vect n a)`)  to an `n x m`-matrix."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:864
#, no-wrap
msgid ""
"   Note: This might be a challenging exercise, but make sure\n"
"   to give it a try. As usual, make use of holes if you get stuck!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:866
#, no-wrap
msgid "   Here is an example how this should work in action:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:867
#, no-wrap
msgid ""
"   Solutions.Dependent> transpose [[1,2,3],[4,5,6]]\n"
"   [[1, 4], [2, 5], [3, 6]]\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:878
msgid ""
"Dependent types allow us to calculate types from values.  This makes it "
"possible to encode properties of values at the type-level and verify these "
"properties at compile time."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:882
msgid ""
"Length-indexed lists (vectors) let us rule out certain implementation "
"errors, by forcing us to be precise about the lengths of input and output "
"vectors."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:886
msgid ""
"We can use patterns in type signatures, for instance to express that the "
"length of a vector is non-zero and therefore, the vector is non-empty."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:891
msgid ""
"When creating values of a type family, the values of the indices need to be "
"known at compile time, or they need to be passed as arguments to the "
"function creating the values, where we can pattern match on them to figure "
"out, which constructors to use."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:894
msgid ""
"We can use `Fin n`, the type of natural numbers strictly smaller than `n`, "
"to safely index into a vector of length `n`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:899
msgid ""
"Sometimes, it is convenient to pass inferable arguments as non-erased "
"implicits, in which case we can still inspect them by pattern matching or "
"pass them to other functions, while Idris will try and fill in the values "
"for us."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:903
#, no-wrap
msgid ""
"Note, that data type `Vect` together with many of the functions we\n"
"implemented here is available from module `Data.Vect` from the *base*\n"
"library. Likewise, `Fin` is available from `Data.Fin` from *base*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:908
#, no-wrap
msgid ""
"In the [next section](IO.md), it is time to learn how to write effectful "
"programs\n"
"and how to do this while still staying *pure*.\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/DPair.md:1
#, no-wrap
msgid "Sigma Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:18
#, no-wrap
msgid ""
"So far in our examples of dependently typed programming,\n"
"type indices such as the length of vectors were known at\n"
"compile time or could be calculated from values known at\n"
"compile time. In real applications, however, such information is\n"
"often not available until runtime, where values depend on\n"
"the decisions made by users or the state of the surrounding world.\n"
"For instance, if we store a file's content as a vector of lines\n"
"of text, the length of this vector is in general unknown until\n"
"the file has been loaded into memory.\n"
"As a consequence, the types of values we work with depend on\n"
"other values only known at runtime, and we can often only figure out\n"
"these types by pattern matching on the values they depend on.\n"
"To express these dependencies, we need so called\n"
"[*sigma types*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A3_type):\n"
"Dependent pairs and their generalization, dependent records.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:19
#, no-wrap
msgid ""
"module Tutorial.DPair\n"
"\n"
"import Control.Monad.State\n"
"\n"
"import Data.DPair\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.List\n"
"import Data.List1\n"
"import Data.Singleton\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import Text.CSV\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:38
#, no-wrap
msgid "Dependent Pairs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:46
#, no-wrap
msgid ""
"We've already seen several examples of how useful the length\n"
"index of a vector is to describe more precisely in the types what\n"
"a function can and can't do. For instance, `map` or `traverse`\n"
"operating on a vector will return a vector of exactly\n"
"the same length. The types guarantee that this is true, therefore\n"
"the following function is perfectly safe and provably total:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:47
#, no-wrap
msgid ""
"parseAndDrop : Vect (3 + n) String -> Maybe (Vect n Nat)\n"
"parseAndDrop = map (drop 3) . traverse parsePositive\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:60
#, no-wrap
msgid ""
"Since the argument of `traverse parsePositive`\n"
"is of type `Vect (3 + n) String`, its result will be of\n"
"type `Maybe (Vect (3 + n) Nat)`. It is therefore\n"
"safe to use this in a call to `drop 3`. Note, how all of this\n"
"is known at compile time: We encoded the prerequisite\n"
"that the first argument is a vector of at least three elements\n"
"in the length index and could derive the length\n"
"of the result from this.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:61
#, no-wrap
msgid "Vectors of Unknown Length"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:65
#, no-wrap
msgid ""
"However, this is not always possible. Consider the following function,\n"
"defined on `List` and exported by `Data.List`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:66
#, no-wrap
msgid ""
"Tutorial.Relations> :t takeWhile\n"
"Data.List.takeWhile : (a -> Bool) -> List a -> List a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:75
#, no-wrap
msgid ""
"This will take the longest prefix of the list argument, for which\n"
"the given predicate returns `True`. In this case, it depends on\n"
"the list elements and the predicate, how long this prefix will be.\n"
"Can we write such a function for vectors? Let's give it a try:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:76
#, no-wrap
msgid "takeWhile' : (a -> Bool) -> Vect n a -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:92
#, no-wrap
msgid ""
"Go ahead, and try to implement this. Don't try too long, as you will not\n"
"be able to do so in a provably total way. The question is: What is the\n"
"problem here?\n"
"In order to understand this, we have to realize what the type of "
"`takeWhile'`\n"
"promises: \"For all predicates operating on values on type `a`, and for\n"
"all vectors holding values of this type, and for all lengths `m`, I\n"
"give you a vector of length `m` holding values of type `a`\".\n"
"All three arguments are said to be\n"
"[*universally "
"quantified*](https://en.wikipedia.org/wiki/Universal_quantification):\n"
"The caller of our function is free to choose the predicate,\n"
"the input vector, the type of values the vector holds,\n"
"and *the length of the output vector*. Don't believe me? See here:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:93
#, no-wrap
msgid ""
"-- This looks like trouble: We got a non-empty vector of `Void`...\n"
"voids : Vect 7 Void\n"
"voids = takeWhile' (const True) []\n"
"\n"
"-- ...from which immediately follows a proof of `Void`\n"
"proofOfVoid : Void\n"
"proofOfVoid = head voids\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:108
#, no-wrap
msgid ""
"See how I could freely decide on the value of `m` when invoking "
"`takeWhile'`?\n"
"Although I passed `takeWhile'` an empty vector (the only existing vector\n"
"holding values of type `Void`), the function's type promises me\n"
"to return a possibly non-empty vector holding values of the same\n"
"type, from which I freely extracted the first one.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:115
#, no-wrap
msgid ""
"Luckily, Idris doesn't allow this: We won't be able to\n"
"implement `takeWhile'` without cheating (for instance, by\n"
"turning totality checking off and looping forever).\n"
"So, the question remains, how to express the result of `takeWhile'`\n"
"in a type. The answer to this is: \"Use a *dependent pair*\", a vector\n"
"paired with a value corresponding to its length.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:116
#, no-wrap
msgid ""
"record AnyVect a where\n"
"  constructor MkAnyVect\n"
"  length : Nat\n"
"  vect   : Vect length a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:131
#, no-wrap
msgid ""
"This corresponds to [*existential "
"quantification*](https://en.wikipedia.org/wiki/Existential_quantification)\n"
"in predicate logic: There is a natural number, which corresponds to\n"
"the length of the vector I have here. Note, how from the outside\n"
"of `AnyVect a`, the length of the wrapped vector is no longer\n"
"visible at the type level but we can still inspect it and learn\n"
"something about it at runtime, since it is wrapped up together\n"
"with the actual vector. We can implement `takeWhile` in such\n"
"a way that it returns a value of type `AnyVect a`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:132
#, no-wrap
msgid ""
"takeWhile : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile f []        = MkAnyVect 0 []\n"
"takeWhile f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect n ys = takeWhile f xs in MkAnyVect (S n) (x :: "
"ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:147
#, no-wrap
msgid ""
"This works in a provably total way, because callers of this function\n"
"can no longer choose the length of the resulting vector themselves. Our\n"
"function, `takeWhile`, decides on this length and returns it together\n"
"with the vector, and the type checker verifies that we\n"
"make no mistakes when pairing the two values. In fact,\n"
"the length can be inferred automatically by Idris, so we can replace\n"
"it with underscores, if we so desire:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:148
#, no-wrap
msgid ""
"takeWhile2 : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile2 f []        = MkAnyVect _ []\n"
"takeWhile2 f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect _ ys = takeWhile2 f xs in MkAnyVect _ (x :: ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:161
#, no-wrap
msgid ""
"To summarize: Parameters in generic function types are\n"
"universally quantified, and their values can be decided on at the\n"
"call site of such functions. Dependent record types allow us\n"
"to describe existentially quantified values. Callers cannot choose\n"
"such values freely: They are returned as part of a function's result.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:164
#, no-wrap
msgid ""
"Note, that Idris allows us to be explicit about universal quantification.\n"
"The type of `takeWhile'` can also be written like so:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:165
#, no-wrap
msgid "takeWhile'' : forall a, n, m . (a -> Bool) -> Vect n a -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:173
#, no-wrap
msgid ""
"Universally quantified arguments are desugared to implicit\n"
"erased arguments by Idris. The above is a less verbose version\n"
"of the following function type, the likes of which we have seen\n"
"before:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:174
#, no-wrap
msgid ""
"takeWhile''' :  {0 a : _}\n"
"             -> {0 n : _}\n"
"             -> {0 m : _}\n"
"             -> (a -> Bool)\n"
"             -> Vect n a\n"
"             -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:189
#, no-wrap
msgid ""
"In Idris, we are free to choose whether we want to be explicit\n"
"about universal quantification. Sometimes it can help understanding\n"
"what's going on at the type level. Other languages - for instance\n"
"[PureScript](https://www.purescript.org/) - are more strict about\n"
"this: There, explicit annotations on universally quantified parameters\n"
"are "
"[mandatory](https://github.com/purescript/documentation/blob/master/language/Differences-from-Haskell.md#explicit-forall).\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:190
#, no-wrap
msgid "The Essence of Dependent Pairs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:202
#, no-wrap
msgid ""
"It can take some time and experience to understand what's going on "
"here. At\n"
"least in my case, it took many sessions programming in Idris, before I "
"figured\n"
"out what dependent pairs are about: They pair a *value* of some type with\n"
"a second value of a type calculated from the first value.\n"
"For instance, a natural number `n` (the value)\n"
"paired with a vector of length `n` (the second value, the type\n"
"of which *depends* on the first value).\n"
"This is such a fundamental concept of programming with dependent types, "
"that\n"
"a general dependent pair type is provided by the *Prelude*. Here is its\n"
"implementation (primed for disambiguation):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:203
#, no-wrap
msgid ""
"record DPair' (a : Type) (p : a -> Type) where\n"
"  constructor MkDPair'\n"
"  fst : a\n"
"  snd : p fst\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:215
#, no-wrap
msgid ""
"It is essential to understand what's going on here. There are two\n"
"parameters: A type `a`, and a function `p`, calculating a *type*\n"
"from a *value* of type `a`. Such a value (`fst`) is then used\n"
"to calculate the *type* of the second value (`snd`).\n"
"For instance, here is `AnyVect a` represented as a `DPair`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:216
#, no-wrap
msgid ""
"AnyVect' : (a : Type) -> Type\n"
"AnyVect' a = DPair Nat (\\n => Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:225
#, no-wrap
msgid ""
"Note, how `\\n => Vect n a` is a function from `Nat` to `Type`.\n"
"Idris provides special syntax for describing dependent pairs, as\n"
"they are important building blocks for programming in languages\n"
"with first class types:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:226
#, no-wrap
msgid ""
"AnyVect'' : (a : Type) -> Type\n"
"AnyVect'' a = (n : Nat ** Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:233
#, no-wrap
msgid ""
"We can inspect at the REPL, that the right hand side of `AnyVect''`\n"
"get's desugared to the right hand side of `AnyVect'`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:234
#, no-wrap
msgid ""
"Tutorial.Relations> (n : Nat ** Vect n Int)\n"
"DPair Nat (\\n => Vect n Int)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:242
#, no-wrap
msgid ""
"Idris can infer, that `n` must be of type `Nat`, so we can drop\n"
"this information. (We still need to put the whole expression in\n"
"parentheses.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:243
#, no-wrap
msgid ""
"AnyVect3 : (a : Type) -> Type\n"
"AnyVect3 a = (n ** Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:254
#, no-wrap
msgid ""
"This allows us to pair a natural number `n` with a vector of\n"
"length `n`, which is exactly what we did with `AnyVect`. We can\n"
"therefore rewrite `takeWhile` to return a `DPair` instead of\n"
"our custom type `AnyVect`. Note, that like with regular pairs,\n"
"we can use the same syntax `(x ** y)` for creating and\n"
"pattern matching on dependent pairs:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:255
#, no-wrap
msgid ""
"takeWhile3 : (a -> Bool) -> Vect m a -> (n ** Vect n a)\n"
"takeWhile3 f []        = (_ ** [])\n"
"takeWhile3 f (x :: xs) = case f x of\n"
"  False => (_ ** [])\n"
"  True  => let (_  ** ys) = takeWhile3 f xs in (_ ** x :: ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:265
#, no-wrap
msgid ""
"Just like with regular pairs, we can use the dependent pair\n"
"syntax to define dependent triples and larger tuples:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:266
#, no-wrap
msgid ""
"AnyMatrix : (a : Type) -> Type\n"
"AnyMatrix a = (m ** n ** Vect m (Vect n a))\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:271
#, no-wrap
msgid "Erased Existentials"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:281
#, no-wrap
msgid ""
"Sometimes, it is possible to determine the value of an\n"
"index by pattern matching on a value of the indexed type.\n"
"For instance, by pattern matching on a vector, we can learn\n"
"about its length index. In these cases, it is not strictly\n"
"necessary to carry around the index at runtime,\n"
"and we can write a special version of a dependent pair\n"
"where the first argument has quantity zero. Module `Data.DPair`\n"
"from *base* exports data type `Exists` for this use case.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:284
#, no-wrap
msgid ""
"As an example, here is a version of `takeWhile` returning\n"
"a value of type `Exists`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:285
#, no-wrap
msgid ""
"takeWhileExists : (a -> Bool) -> Vect m a -> Exists (\\n => Vect n a)\n"
"takeWhileExists f []        = Evidence _ []\n"
"takeWhileExists f (x :: xs) = case f x of\n"
"  True  => let Evidence _ ys = takeWhileExists f xs\n"
"            in Evidence _ (x :: ys)\n"
"  False => takeWhileExists f xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:297
#, no-wrap
msgid ""
"In order to restore an erased value, data type `Singleton`\n"
"from *base* module `Data.Singleton` can be useful: It is\n"
"parameterized by the *value* it stores:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:298
#, no-wrap
msgid ""
"true : Singleton True\n"
"true = Val True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:306
#, no-wrap
msgid ""
"This is called a *singleton* type: A type corresponding to\n"
"exactly one value. It is a type error to return any other\n"
"value for constant `true`, and Idris knows this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:307
#, no-wrap
msgid ""
"true' : Singleton True\n"
"true' = Val _\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:314
#, no-wrap
msgid ""
"We can use this to conjure the (erased!) length of a vector\n"
"out of thin air:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:315
#, no-wrap
msgid ""
"vectLength : Vect n a -> Singleton n\n"
"vectLength []        = Val 0\n"
"vectLength (x :: xs) = let Val k = vectLength xs in Val (S k)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:326
#, no-wrap
msgid ""
"This function comes with much stronger guarantees\n"
"than `Data.Vect.length`: The latter claims to just return\n"
"*any* natural number, while `vectLength` *must* return\n"
"exactly `n` in order to type check. As a demonstration,\n"
"here is a well-typed bogus implementation of `length`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:327
#, no-wrap
msgid ""
"bogusLength : Vect n a -> Nat\n"
"bogusLength = const 0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:334
#, no-wrap
msgid ""
"This would not be accepted as a valid implementation of\n"
"`vectLength`, as you may quickly verify yourself.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:338
#, no-wrap
msgid ""
"With the help of `vectLength` (but not with `Data.Vect.length`)\n"
"we can convert an erased existential to a proper dependent\n"
"pair:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:339
#, no-wrap
msgid ""
"toDPair : Exists (\\n => Vect n a) -> (m ** Vect m a)\n"
"toDPair (Evidence _ as) = let Val m = vectLength as in (m ** as)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:347
#, no-wrap
msgid ""
"Again, as a quick exercise, try implementing `toDPair` in terms\n"
"of `length`, and note how Idris will fail to unify the\n"
"result of `length` with the actual length of the vector.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:352
msgid ""
"Declare and implement a function for filtering a vector similar to "
"`Data.List.filter`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:356
msgid ""
"Declare and implement a function for mapping a partial function over the "
"values of a vector similar to `Data.List.mapMaybe`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:360
msgid ""
"Declare and implement a function similar to `Data.List.dropWhile` for "
"vectors. Use `Data.DPair.Exists` as your return type."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:363
msgid ""
"Repeat exercise 3 but return a proper dependent pair. Use the function from "
"exercise 3 in your implementation."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:364
#, no-wrap
msgid "Use Case: Nucleic Acids"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:372
#, no-wrap
msgid ""
"We'd like to come up with a small, simplified library for running "
"computations\n"
"on nucleic acids: RNA and DNA. These are built from five types of\n"
"nucleobases, three of which are used in both types of nucleic\n"
"acids and two bases specific for each type of acid. We'd like\n"
"to make sure that only valid bases are in strands of nucleic acids.\n"
"Here's a possible encoding:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:373
#, no-wrap
msgid ""
"data BaseType = DNABase | RNABase\n"
"\n"
"data Nucleobase : BaseType -> Type where\n"
"  Adenine  : Nucleobase b\n"
"  Cytosine : Nucleobase b\n"
"  Guanine  : Nucleobase b\n"
"  Thymine  : Nucleobase DNABase\n"
"  Uracile  : Nucleobase RNABase\n"
"\n"
"NucleicAcid : BaseType -> Type\n"
"NucleicAcid = List . Nucleobase\n"
"\n"
"RNA : Type\n"
"RNA = NucleicAcid RNABase\n"
"\n"
"DNA : Type\n"
"DNA = NucleicAcid DNABase\n"
"\n"
"encodeBase : Nucleobase b -> Char\n"
"encodeBase Adenine  = 'A'\n"
"encodeBase Cytosine = 'C'\n"
"encodeBase Guanine  = 'G'\n"
"encodeBase Thymine  = 'T'\n"
"encodeBase Uracile  = 'U'\n"
"\n"
"encode : NucleicAcid b -> String\n"
"encode = pack . map encodeBase\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:404
#, no-wrap
msgid "It is a type error to use `Uracile` in a strand of DNA:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:405
#, no-wrap
msgid ""
"failing \"Mismatch between: RNABase and DNABase.\"\n"
"  errDNA : DNA\n"
"  errDNA = [Uracile, Adenine]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:415
#, no-wrap
msgid ""
"Note, how we used a variable for nucleobases `Adenine`, `Cytosine`, and\n"
"`Guanine`: These are again universally quantified,\n"
"and client code is free to choose a value here. This allows us\n"
"to use these bases in strands of DNA *and* RNA:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:416
#, no-wrap
msgid ""
"dna1 : DNA\n"
"dna1 = [Adenine, Cytosine, Guanine]\n"
"\n"
"rna1 : RNA\n"
"rna1 = [Adenine, Cytosine, Guanine]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:427
#, no-wrap
msgid ""
"With `Thymine` and `Uracile`, we are more restrictive: `Thymine` is only\n"
"allowed in DNA, while `Uracile` is restricted to be used in RNA strands.\n"
"Let's write parsers for strands of DNA and RNA:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:428
#, no-wrap
msgid ""
"readAnyBase : Char -> Maybe (Nucleobase b)\n"
"readAnyBase 'A' = Just Adenine\n"
"readAnyBase 'C' = Just Cytosine\n"
"readAnyBase 'G' = Just Guanine\n"
"readAnyBase _   = Nothing\n"
"\n"
"readRNABase : Char -> Maybe (Nucleobase RNABase)\n"
"readRNABase 'U' = Just Uracile\n"
"readRNABase c   = readAnyBase c\n"
"\n"
"readDNABase : Char -> Maybe (Nucleobase DNABase)\n"
"readDNABase 'T' = Just Thymine\n"
"readDNABase c   = readAnyBase c\n"
"\n"
"readRNA : String -> Maybe RNA\n"
"readRNA = traverse readRNABase . unpack\n"
"\n"
"readDNA : String -> Maybe DNA\n"
"readDNA = traverse readDNABase . unpack\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:454
#, no-wrap
msgid ""
"Again, in case of the bases appearing in both kinds of strands,\n"
"users of the universally quantified `readAnyBase`\n"
"are free to choose what base type they want, but they will\n"
"never get a `Thymine` or `Uracile` value.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:458
#, no-wrap
msgid ""
"We can now implement some simple calculations on sequences of\n"
"nucleobases. For instance, we can come up with the complementary\n"
"strand:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:459
#, no-wrap
msgid ""
"complementRNA' : RNA -> RNA\n"
"complementRNA' = map calc\n"
"  where calc : Nucleobase RNABase -> Nucleobase RNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Uracile\n"
"        calc Uracile  = Adenine\n"
"\n"
"complementDNA' : DNA -> DNA\n"
"complementDNA' = map calc\n"
"  where calc : Nucleobase DNABase -> Nucleobase DNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Thymine\n"
"        calc Thymine  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:480
#, no-wrap
msgid ""
"Ugh, code repetition! Not too bad here, but imagine there were\n"
"dozens of bases with only few specialized ones. Surely, we can\n"
"do better? Unfortunately, the following won't work:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:481
#, no-wrap
msgid ""
"complementBase' : Nucleobase b -> Nucleobase b\n"
"complementBase' Adenine  = ?what_now\n"
"complementBase' Cytosine = Guanine\n"
"complementBase' Guanine  = Cytosine\n"
"complementBase' Thymine  = Adenine\n"
"complementBase' Uracile  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:497
#, no-wrap
msgid ""
"All goes well with the exception of the `Adenine` case. Remember:\n"
"Parameter `b` is universally quantified, and the *callers* of\n"
"our function can decide what `b` is supposed to\n"
"be. We therefore can't just return `Thymine`: Idris will respond\n"
"with a type error since callers might want a `Nucleobase RNABase` instead.\n"
"One way to go about this is to take an additional unerased argument\n"
"(explicit or implicit) representing the base type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:498
#, no-wrap
msgid ""
"complementBase : (b : BaseType) -> Nucleobase b -> Nucleobase b\n"
"complementBase DNABase Adenine  = Thymine\n"
"complementBase RNABase Adenine  = Uracile\n"
"complementBase _       Cytosine = Guanine\n"
"complementBase _       Guanine  = Cytosine\n"
"complementBase _       Thymine  = Adenine\n"
"complementBase _       Uracile  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:512
#, no-wrap
msgid ""
"This is again an example of a dependent *function* type (also called a\n"
"[*pi type*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A0_type)):\n"
"The input and output types both *depend* on the *value* of the first "
"argument.\n"
"We can now use this to calculate the complement of any nucleic acid:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:513
#, no-wrap
msgid ""
"complement : (b : BaseType) -> NucleicAcid b -> NucleicAcid b\n"
"complement b = map (complementBase b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:528
#, no-wrap
msgid ""
"Now, here is an interesting use case: We'd like to read a sequence\n"
"of nucleobases from user input, accepting two strings: The first\n"
"telling us, whether the user plans to enter a DNA or RNA sequence,\n"
"the second being the sequence itself. What should be the type of\n"
"such a function? Well, we're describing computations with side effects,\n"
"so something involving `IO` seems about right. User input almost\n"
"always needs to be validated or translated, so something might go wrong\n"
"and we need an error type for this case. Finally, our users can\n"
"decide whether they want to enter a strand of RNA or DNA, so this\n"
"distinction should be encoded as well.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:531
#, no-wrap
msgid ""
"Of course, it is always possible to write a custom sum type for\n"
"such a use case:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:532
#, no-wrap
msgid ""
"data Result : Type where\n"
"  UnknownBaseType : String -> Result\n"
"  InvalidSequence : String -> Result\n"
"  GotDNA          : DNA -> Result\n"
"  GotRNA          : RNA -> Result\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:544
#, no-wrap
msgid ""
"This has all possible outcomes encoded in a single data type.\n"
"However, it is lacking in terms of flexibility. If we want to handle\n"
"errors early on and just extract a strand of RNA or DNA, we need\n"
"yet another data type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:545
#, no-wrap
msgid "data RNAOrDNA = ItsRNA RNA | ItsDNA DNA\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:552
#, no-wrap
msgid ""
"This might be the way to go, but for results with many options, this\n"
"can get cumbersome quickly. Also: Why come up with a custom data type when\n"
"we already have the tools to deal with this at our hands?\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:554
#, no-wrap
msgid "Here is how we can encode this with a dependent pair:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:555
#, no-wrap
msgid ""
"namespace InputError\n"
"  public export\n"
"  data InputError : Type where\n"
"    UnknownBaseType : String -> InputError\n"
"    InvalidSequence : String -> InputError\n"
"\n"
"readAcid : (b : BaseType) -> String -> Either InputError (NucleicAcid b)\n"
"readAcid b str =\n"
"  let err = InvalidSequence str\n"
"   in case b of\n"
"        DNABase => maybeToEither err $ readDNA str\n"
"        RNABase => maybeToEither err $ readRNA str\n"
"\n"
"getNucleicAcid : IO (Either InputError (b ** NucleicAcid b))\n"
"getNucleicAcid = do\n"
"  baseString <- getLine\n"
"  case baseString of\n"
"    \"DNA\" => map (MkDPair _) . readAcid DNABase <$> getLine\n"
"    \"RNA\" => map (MkDPair _) . readAcid RNABase <$> getLine\n"
"    _     => pure $ Left (UnknownBaseType baseString)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:583
#, no-wrap
msgid ""
"Note, how we paired the type of nucleobases with the nucleic acid\n"
"sequence. Assume now we implement a function for transcribing\n"
"a strand of DNA to RNA, and we'd like to convert a sequence of\n"
"nucleobases from user input to the corresponding RNA sequence.\n"
"Here's how to do this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:584
#, no-wrap
msgid ""
"transcribeBase : Nucleobase DNABase -> Nucleobase RNABase\n"
"transcribeBase Adenine  = Uracile\n"
"transcribeBase Cytosine = Guanine\n"
"transcribeBase Guanine  = Cytosine\n"
"transcribeBase Thymine  = Adenine\n"
"\n"
"transcribe : DNA -> RNA\n"
"transcribe = map transcribeBase\n"
"\n"
"printRNA : RNA -> IO ()\n"
"printRNA = putStrLn . encode\n"
"\n"
"transcribeProg : IO ()\n"
"transcribeProg = do\n"
"  Right (b ** seq) <- getNucleicAcid\n"
"    | Left (InvalidSequence str) => putStrLn $ \"Invalid sequence: \" ++ "
"str\n"
"    | Left (UnknownBaseType str) => putStrLn $ \"Unknown base type: \" ++ "
"str\n"
"  case b of\n"
"    DNABase => printRNA $ transcribe seq\n"
"    RNABase => printRNA seq\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:611
#, no-wrap
msgid ""
"By pattern matching on the first value of the dependent pair we could\n"
"determine, whether the second value is an RNA or DNA sequence.\n"
"In the first case, we had to transcribe the\n"
"sequence first, in the second case, we could invoke `printRNA` directly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:620
#, no-wrap
msgid ""
"In a more interesting scenario, we would *translate* the RNA sequence\n"
"to the corresponding protein sequence. Still, this example shows\n"
"how to deal with a simplified real world scenario: Data may be\n"
"encoded differently and coming from different sources. By using precise\n"
"types, we are forced to first convert values to the correct\n"
"format. Failing to do so leads to a compile time exception instead of\n"
"an error at runtime or - even worse - the program silently running\n"
"a bogus computation.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:621
#, no-wrap
msgid "Dependent Records vs Sum Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:630
#, no-wrap
msgid ""
"Dependent records as shown for `AnyVect a` are a generalization\n"
"of dependent pairs: We can have an arbitrary number of fields\n"
"and use the values stored therein to calculate the types of\n"
"other values. For very simple cases like the example with nucleobases,\n"
"it doesn't matter too much, whether we use a `DPair`, a custom\n"
"dependent record, or even a sum type. In fact, the three encodings\n"
"are equally expressive:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:631
#, no-wrap
msgid ""
"Acid1 : Type\n"
"Acid1 = (b ** NucleicAcid b)\n"
"\n"
"record Acid2 where\n"
"  constructor MkAcid2\n"
"  baseType : BaseType\n"
"  sequence : NucleicAcid baseType\n"
"\n"
"data Acid3 : Type where\n"
"  SomeRNA : RNA -> Acid3\n"
"  SomeDNA : DNA -> Acid3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:652
#, no-wrap
msgid ""
"It is trivial to write lossless conversions between these\n"
"encodings, and with each encoding we can decide with a simple\n"
"pattern match, whether we currently have a sequence of\n"
"RNA or DNA. However, dependent types can depend on more than\n"
"one value, as we will see in the exercises. In such cases,\n"
"sum types and dependent pairs quickly become unwieldy, and\n"
"you should go for an encoding as a dependent record.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:661
#, no-wrap
msgid ""
"Sharpen your skills in using dependent pairs and dependent\n"
"records! In exercises 2 to 7 you have to decide yourself,\n"
"when a function should return a dependent pair or record,\n"
"when a function requires additional arguments, on which you\n"
"can pattern match, and what other utility functions might be\n"
"necessary.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:666
msgid ""
"Proof that the three encodings for nucleobases are *isomorphic* (meaning: of "
"the same structure) by writing lossless conversion functions from `Acid1` to "
"`Acid2` and back. Likewise for `Acid1` and `Acid3`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:673
msgid ""
"Sequences of nucleobases can be encoded in one of two directions: [*Sense* "
"and *antisense*](https://en.wikipedia.org/wiki/Sense_(molecular_biology)).  "
"Declare a new data type to describe the sense of a sequence of nucleobases, "
"and add this as an additional parameter to type `Nucleobase` and types `DNA` "
"and `RNA`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:677
msgid ""
"Refine the types of `complement` and `transcribe`, so that they reflect the "
"changing of *sense*. In case of `transcribe`, a strand of antisense DNA is "
"converted to a strand of sense RNA."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:680
msgid ""
"Define a dependent record storing the base type and sense together with a "
"sequence of nucleobases."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:685
msgid ""
"Adjust `readRNA` and `readDNA` in such a way that the *sense* of a sequence "
"is read from the input string.  Sense strands are encoded like so: "
"\"5´-CGGTAG-3´\". Antisense strands are encoded like so: "
"\"3´-CGGTAG-5´\"."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:688
msgid "Adjust `encode` in such a way that it includes the sense in its output."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/DPair.md:693
msgid ""
"Enhance `getNucleicAcid` and `transcribeProg` in such a way that the sense "
"and base type are stored together with the sequence, and that "
"`transcribeProg` always prints the *sense* RNA strand (after transcription, "
"if necessary)."
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/DPair.md:695
msgid "Enjoy the fruits of your labour and test your program at the REPL."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:703
#, no-wrap
msgid ""
"Note: Instead of using a dependent record, we could again\n"
"have used a sum type of four constructors to encode the different\n"
"types of sequences. However, the number of constructors\n"
"required corresponds to the *product* of the number of values\n"
"of each type level index. Therefore, this number can grow quickly\n"
"and sum type encodings can lead to lengthy blocks of pattern matches\n"
"in these cases.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:704
#, no-wrap
msgid "Use Case: CSV Files with a Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:712
#, no-wrap
msgid ""
"In this section, we are going to look at an extended example\n"
"based on our previous work on CSV parsers. We'd like to\n"
"write a small command-line program, where users can specify a\n"
"schema for the CSV tables they'd like to parse and load into\n"
"memory. Before we begin, here is a REPL session running\n"
"the final program, which you will complete in the exercises:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:713
#, no-wrap
msgid ""
"Solutions.DPair> :exec main\n"
"Enter a command: load resources/example\n"
"Table loaded. Schema: str,str,fin2023,str?,boolean?\n"
"Enter a command: get 3\n"
"Row 3:\n"
"\n"
"str   | str    | fin2023 | str? | boolean?\n"
"------------------------------------------\n"
"Floor | Jansen | 1981    |      | t\n"
"\n"
"Enter a command: add Mikael,Stanne,1974,,\n"
"Row prepended:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: delete 1\n"
"Deleted row: 1.\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str | str     | fin2023 | str? | boolean?\n"
"-----------------------------------------\n"
"Rob | Halford | 1951    |      |\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:754
#, no-wrap
msgid ""
"This example was inspired by a similar program used as an example\n"
"in the [Type-Driven Development with "
"Idris](https://www.manning.com/books/type-driven-development-with-idris)\n"
"book.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:756
#, no-wrap
msgid "We'd like to focus on several things here:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
msgid ""
"Purity: With the exception of the main program loop, all functions used in "
"the implementation should be pure, which in this context means \"not running "
"in any monad with side effects such as `IO`\"."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
msgid ""
"Fail early: With the exception of the command parser, all functions updating "
"the table and handling queries should be typed and implemented in such a way "
"that they cannot fail."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:766
#, no-wrap
msgid ""
"We are often well advised to adhere to these two guidelines, as they can\n"
"make the majority of our functions easier to implement and test.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:772
#, no-wrap
msgid ""
"Since we allow users of our library to specify a schema (order and\n"
"types of columns) for the table they work with, this information is\n"
"not known until runtime. The same goes for the current size of the\n"
"table. We will therefore store both values as fields in a\n"
"dependent record.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:773
#, no-wrap
msgid "Encoding the Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:780
#, no-wrap
msgid ""
"We need to inspect the table schema at runtime. Although theoretically\n"
"possible, it is not advisable to operate on Idris types directly here.\n"
"We'd rather use a closed custom data type describing the types of\n"
"columns we understand. In a first try, we only support some Idris\n"
"primitives:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:781
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:791
#, no-wrap
msgid ""
"Next, we need a way to convert a `Schema` to a list of Idris\n"
"types, which we will then use as the index of a heterogeneous\n"
"list representing the rows in our table:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:792
#, no-wrap
msgid ""
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:807
#, no-wrap
msgid ""
"We can now describe a table as a dependent record storing\n"
"the table's content as a vector of rows. In order to safely\n"
"index rows of the table and parse new rows to be added, the\n"
"current schema and size of the table must be known at runtime:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:808
#, no-wrap
msgid ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:823
#, no-wrap
msgid ""
"Finally, we define an indexed data type describing commands\n"
"operating on the current table. Using the current table as\n"
"the command's index allows us to make sure that indices for\n"
"accessing and deleting rows are within bounds and that\n"
"new rows agree with the current schema. This is necessary\n"
"to uphold our second design principle: All functions\n"
"operating on tables must do so without the possibility of failure.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:824
#, no-wrap
msgid ""
"data Command : (t : Table) -> Type where\n"
"  PrintSchema : Command t\n"
"  PrintSize   : Command t\n"
"  New         : (newSchema : Schema) -> Command t\n"
"  Prepend     : Row (schema t) -> Command t\n"
"  Get         : Fin (size t) -> Command t\n"
"  Delete      : Fin (size t) -> Command t\n"
"  Quit        : Command t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:839
#, no-wrap
msgid ""
"We can now implement the main application logic: How user\n"
"entered commands affect the application's current state. As promised,\n"
"this comes without the risk of failure, so we don't have to\n"
"wrap the return type in an `Either`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:840
#, no-wrap
msgid ""
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:857
#, no-wrap
msgid ""
"Please understand, that the constructors of `Command t` are typed\n"
"in such a way that indices are always within bounds (constructors\n"
"`Get` and `Delete`), and new rows adhere to the table's\n"
"current schema (constructor `Prepend`).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:866
#, no-wrap
msgid ""
"One thing you might not have seen so far is the call to `absurd`\n"
"on the last line. This is a derived function of the\n"
"`Uninhabited` interface, which is used to describe types such\n"
"as `Void` or - in the case above - `Fin 0`, of which there can\n"
"be no value. Function `absurd` is then just another manifestation\n"
"of the principle of explosion. If this doesn't make too much sense\n"
"yet, don't worry. We will look at `Void` and its uses in the\n"
"next chapter.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:867
#, no-wrap
msgid "Parsing Commands"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:879
#, no-wrap
msgid ""
"User input validation is an important topic when writing\n"
"applications. If it happens early, you can keep larger parts\n"
"of your application pure (which - in this context - means:\n"
"\"without the possibility of failure\") and provably total.\n"
"If done properly, this step encodes and handles most if not all\n"
"ways in which things can go wrong in your program, allowing\n"
"you to come up with clear error messages telling users exactly what caused\n"
"an issue. As you surely have experienced yourself, there are few\n"
"things more frustrating than a non-trivial computer program terminating\n"
"with an unhelpful \"There was an error\" message.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:892
#, no-wrap
msgid ""
"So, in order to treat this important topic with all due respect,\n"
"we are first going to implement a custom error type. This is\n"
"not *strictly* necessary for small programs, but once your software\n"
"gets more complex, it can be tremendously helpful for keeping track\n"
"of what can go wrong where. In order to figure out what can possibly\n"
"go wrong, we first need to decide on how the commands should be entered.\n"
"Here, we use a single keyword for each command, together with an\n"
"optional number of arguments separated from the keyword by a single\n"
"space character. For instance: `\"new i64,boolean,str,str\"`,\n"
"for initializing an empty table with a new schema. With this settled,\n"
"here is a list of things that can go wrong, and the messages we'd\n"
"like to print:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"A bogus command is entered. We repeat the input with a message that we don't "
"know the command plus a list of commands we know about."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An invalid schema was entered. In this case, we list the position of the "
"first unknown type, the string we found there, and a list of types we know "
"about."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An invalid CSV encoding of a row was entered. We list the erroneous "
"position, the string encountered there, plus the expected type. In case of a "
"too small or too large number of fields, we also print a corresponding error "
"message."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An index was out of bounds. This can happen, when users try to access or "
"delete specific rows. We print the current number of rows plus the value "
"entered."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"A value not representing a natural number was entered as an index.  We print "
"an according error message."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:910
#, no-wrap
msgid ""
"That's a lot of stuff to keep track off, so let's encode this in\n"
"a sum type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:911
#, no-wrap
msgid ""
"data Error : Type where\n"
"  UnknownCommand : String -> Error\n"
"  UnknownType    : (pos : Nat) -> String -> Error\n"
"  InvalidField   : (pos : Nat) -> ColType -> String -> Error\n"
"  ExpectedEOI    : (pos : Nat) -> String -> Error\n"
"  UnexpectedEOI  : (pos : Nat) -> String -> Error\n"
"  OutOfBounds    : (size : Nat) -> (index : Nat) -> Error\n"
"  NoNat          : String -> Error\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:929
#, no-wrap
msgid ""
"In order to conveniently construct our error messages, it is best\n"
"to use Idris' string interpolation facilities: We can enclose\n"
"arbitrary string expressions in a string literal by enclosing\n"
"them in curly braces, the first of which must be escaped with\n"
"a backslash. Like so: `\"foo \\{myExpr a b c}\"`.\n"
"We can pair this with multiline string literals to get\n"
"nicely formatted error messages.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:930
#, no-wrap
msgid ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map showColType\n"
"\n"
"allTypes : String\n"
"allTypes = concat\n"
"         . List.intersperse \", \"\n"
"         . map showColType\n"
"         $ [I64,Str,Boolean,Float]\n"
"\n"
"showError : Error -> String\n"
"showError (UnknownCommand x) = \"\"\"\n"
"  Unknown command: \\{x}.\n"
"  Known commands are: clear, schema, size, new, add, get, delete, quit.\n"
"  \"\"\"\n"
"\n"
"showError (UnknownType pos x) = \"\"\"\n"
"  Unknown type at position \\{show pos}: \\{x}.\n"
"  Known types are: \\{allTypes}.\n"
"  \"\"\"\n"
"\n"
"showError (InvalidField pos tpe x) = \"\"\"\n"
"  Invalid value at position \\{show pos}.\n"
"  Expected type: \\{showColType tpe}.\n"
"  Value found: \\{x}.\n"
"  \"\"\"\n"
"\n"
"showError (ExpectedEOI k x) = \"\"\"\n"
"  Expected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (UnexpectedEOI k x) = \"\"\"\n"
"  Unxpected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (OutOfBounds size index) = \"\"\"\n"
"  Index out of bounds.\n"
"  Size of table: \\{show size}\n"
"  Index: \\{show index}\n"
"  Note: Indices start at 1.\n"
"  \"\"\"\n"
"\n"
"showError (NoNat x) = \"Not a natural number: \\{x}\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:990
#, no-wrap
msgid ""
"We can now write parsers for the different commands. We need facilities\n"
"to parse vector indices, schemata, and CSV rows.\n"
"Since we are using a CSV format for encoding\n"
"and decoding rows, it makes sense to also encode the schema\n"
"as a comma-separated list of values:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:991
#, no-wrap
msgid ""
"zipWithIndex : Traversable t => t a -> t (Nat, a)\n"
"zipWithIndex = evalState 1 . traverse pairWithIndex\n"
"  where pairWithIndex : a -> State Nat (Nat,a)\n"
"        pairWithIndex v = (,v) <$> get <* modify S\n"
"\n"
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"readColType : Nat -> String -> Either Error ColType\n"
"readColType _ \"i64\"      = Right I64\n"
"readColType _ \"str\"      = Right Str\n"
"readColType _ \"boolean\"  = Right Boolean\n"
"readColType _ \"float\"    = Right Float\n"
"readColType n s          = Left $ UnknownType n s\n"
"\n"
"readSchema : String -> Either Error Schema\n"
"readSchema = traverse (uncurry readColType) . zipWithIndex . fromCSV\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1018
#, no-wrap
msgid ""
"We also need to decode CSV content based on the current schema.\n"
"Note, how we can do so in a type safe manner by pattern matching\n"
"on the schema, which will not be known until runtime. Unfortunately,\n"
"we need to reimplement CSV-parsing, because we want to add the\n"
"expected type to the error messages (a thing that would be\n"
"much harder to do with interface `CSVLine`\n"
"and error type `CSVError`).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1019
#, no-wrap
msgid ""
"decodeField : Nat -> (c : ColType) -> String -> Either Error (IdrisType c)\n"
"decodeField k c s =\n"
"  let err = InvalidField k c s\n"
"   in case c of\n"
"        I64     => maybeToEither err $ read s\n"
"        Str     => maybeToEither err $ read s\n"
"        Boolean => maybeToEither err $ read s\n"
"        Float   => maybeToEither err $ read s\n"
"\n"
"decodeRow : {ts : _} -> String -> Either Error (Row ts)\n"
"decodeRow s = go 1 ts $ fromCSV s\n"
"  where go : Nat -> (cs : Schema) -> List String -> Either Error (Row cs)\n"
"        go k []       []         = Right []\n"
"        go k []       (_ :: _)   = Left $ ExpectedEOI k s\n"
"        go k (_ :: _) []         = Left $ UnexpectedEOI k s\n"
"        go k (c :: cs) (s :: ss) = [| decodeField k c s :: go (S k) cs ss "
"|]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1040
#, no-wrap
msgid ""
"There is no hard and fast rule about whether to pass an index as an\n"
"implicit argument or not. Some considerations:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid "Pattern matching on explicit arguments comes with less syntactic overhead."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid ""
"If an argument can be inferred from the context most of the time, consider "
"passing it as an implicit to make your function nicer to use in client code."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid ""
"Use explicit (possibly erased) arguments for values that can't be inferred "
"by Idris most of the time."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1052
#, no-wrap
msgid ""
"All that is missing now is a way to parse indices for accessing\n"
"the current table's rows. We use the conversion for indices to\n"
"start at one instead of zero, which feels more natural for most\n"
"non-programmers.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1053
#, no-wrap
msgid ""
"readFin : {n : _} -> String -> Either Error (Fin n)\n"
"readFin s = do\n"
"  S k <- maybeToEither (NoNat s) $ parsePositive {a = Nat} s\n"
"    | Z => Left $ OutOfBounds n Z\n"
"  maybeToEither (OutOfBounds n $ S k) $ natToFin k n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1067
#, no-wrap
msgid ""
"We are finally able to implement a parser for user commands.\n"
"Function `Data.String.words` is used for splitting a string\n"
"at space characters. In most cases, we expect the name of\n"
"the command plus a single argument without additional spaces.\n"
"CSV rows can have additional space characters, however, so we\n"
"use `Data.String.unwords` on the split string.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1068
#, no-wrap
msgid ""
"readCommand :  (t : Table) -> String -> Either Error (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  _               => Left $ UnknownCommand s\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:1081
#, no-wrap
msgid "Running the Application"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1087
#, no-wrap
msgid ""
"All that's left to do is to write functions for\n"
"printing the results of commands to users and run\n"
"the application in a loop until command `\"quit\"`\n"
"is entered.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1088
#, no-wrap
msgid ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (ts : List ColType) -> Row ts -> String\n"
"encodeRow ts = concat . intersperse \",\" . go ts\n"
"  where go : (cs : List ColType) -> Row cs -> Vect (length cs) String\n"
"        go []        []        = []\n"
"        go (c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize   = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)    = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r) = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)  = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit        = \"Goodbye.\"\n"
"result t (Get x)     =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (showError err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1136
#, no-wrap
msgid ""
"The challenges presented here all deal with enhancing our\n"
"table editor in several interesting ways. Some of them are\n"
"more a matter of style and less a matter of learning to write\n"
"dependently typed programs, so feel free to solve these as you\n"
"please. Exercises 1 to 3 should be considered to be\n"
"mandatory.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:1139
msgid "Add support for storing Idris types `Integer` and `Nat` in CSV columns"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:1142
msgid ""
"Add support for `Fin n` to CSV columns. Note: We need runtime access to `n` "
"in order for this to work."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:1148
msgid ""
"Add support for optional types to CSV columns. Since missing values should "
"be encoded by empty strings, it makes no sense to allow for nested optional "
"types, meaning that types like `Maybe Nat` should be allowed while `Maybe "
"(Maybe Nat)` should not."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1151
#, no-wrap
msgid ""
"   Hint: There are several ways to encode these, one being\n"
"   to add a boolean index to `ColType`.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:1154
msgid ""
"Add a command for printing the whole table. Bonus points if all columns are "
"properly aligned."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:1158
msgid ""
"Add support for simple queries: Given a column number and a value, list all "
"rows where entries match the given value."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1160
#, no-wrap
msgid "   This might be a challenge, as the types get pretty interesting.\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:1164
msgid ""
"Add support for loading and saving tables from and to disk.  A table should "
"be stored in two files: One for the schema and one for the CSV content."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1179
#, no-wrap
msgid ""
"   Note: Reading files in a provably total way can be pretty\n"
"   hard and will be a topic for another day. For now,\n"
"   just use function `readFile` exported from\n"
"   `System.File` in base for reading a file as a whole.\n"
"   This function is partial, because\n"
"   it will not terminate when used with an infinite input\n"
"   stream such as `/dev/urandom` or `/dev/zero`.\n"
"   It is important to *not* use `assert_total` here.\n"
"   Using partial functions like `readFile` might well impose\n"
"   a security risk in a real world application, so eventually,\n"
"   we'd have to deal with this and allow for some way to\n"
"   limit the size of accepted input. It is therefore best\n"
"   to make this partiality visible and annotate all downstream\n"
"   functions accordingly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1183
#, no-wrap
msgid ""
"You can find an implementation of these additions in the\n"
"solutions. A small example table can be found in folder\n"
"`resources`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1190
#, no-wrap
msgid ""
"Note: There are of course tons of projects to pursue from\n"
"here, such as writing a proper query language, calculating\n"
"new rows from existing ones, accumulating values in a\n"
"column, concatenating and zipping tables, and so on.\n"
"We will stop for now, probably coming back to this in\n"
"later examples.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1198
#, no-wrap
msgid ""
"Dependent pairs and records are necessary to at runtime\n"
"inspect the values defining the types we work with. By pattern\n"
"matching on these values, we learn about the types and\n"
"possible shapes of other values, allowing us to reduce\n"
"the number of potential bugs in our programs.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1204
#, no-wrap
msgid ""
"In the [next chapter](Eq.md) we start learning about how\n"
"to write data types, which we use as proofs that certain\n"
"contracts between values hold. These will eventually allow\n"
"us to define pre- and post conditions for our function\n"
"arguments and output types.\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Eq.md:1
#, no-wrap
msgid "Propositional Equality"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:9
#, no-wrap
msgid ""
"In the [last chapter](DPair.md) we learned, how dependent pairs\n"
"and records can be used to calculate *types* from values only known\n"
"at runtime by pattern matching on these values. We will now look\n"
"at how we can describe relations - or *contracts* - between\n"
"values as types, and how we can use values of these types as\n"
"proofs that the contracts hold.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:10
#, no-wrap
msgid ""
"module Tutorial.Eq\n"
"\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.Vect\n"
"import Data.String\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:21
#, no-wrap
msgid "Equality as a Type"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:26
#, no-wrap
msgid ""
"Imagine, we'd like to concatenate the contents of two CSV files,\n"
"both of which we stored on disk as tables together with their schemata\n"
"as shown in our discussion about dependent pairs:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:27
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
"\n"
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"concatTables1 : Table -> Table -> Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:55
#, no-wrap
msgid ""
"We will not be able to implement `concatTables` by appending the\n"
"two row vectors, unless we can somehow verify that the two schemata\n"
"are identical. \"Well,\" I hear you say, \"that shouldn't be a big issue!\n"
"Just implement `Eq` for `ColType`\". Let's give this a try:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:56
#, no-wrap
msgid ""
"Eq ColType where\n"
"  I64     == I64     = True\n"
"  Str     == Str     = True\n"
"  Boolean == Boolean = True\n"
"  Float   == Float   = True\n"
"  _       == _       = False\n"
"\n"
"concatTables1 (MkTable s1 m rs1) (MkTable s2 n rs2) = case s1 == s2 of\n"
"  True  => ?what_now\n"
"  False => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:73
#, no-wrap
msgid ""
"Somehow, this doesn't seem to work. If we inspect the context of hole\n"
"`what_now`, Idris still thinks that `s1` and `s2` are different, and\n"
"if we go ahead and invoke `Vect.(++)` anyway in the `True` case,\n"
"Idris will respond with a type error.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:74
#, no-wrap
msgid ""
"Tutorial.Relations> :t what_now\n"
"   m : Nat\n"
"   s1 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s1))\n"
"   n : Nat\n"
"   s2 : List ColType\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"------------------------------\n"
"what_now : Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:92
#, no-wrap
msgid ""
"The problem is, that there is no reason for Idris to unify the two\n"
"values, even though `(==)` returned `True` because the result of `(==)`\n"
"holds no other information than the type being a `Bool`. *We* think,\n"
"if this is `True` the two values should be identical, but Idris is not\n"
"convinced. In fact, the following implementation of `Eq ColType`\n"
"would be perfectly fine as far as the type checker is concerned:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:93
#, no-wrap
msgid ""
"Eq ColType where\n"
"  _       == _       = True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:106
#, no-wrap
msgid ""
"So Idris is right in not trusting us. You might expect it to inspect the\n"
"implementation of `(==)` and figure out on its own, what the `True` result\n"
"means, but this is not how these things work in general, because most of "
"the\n"
"time the number of computational paths to check would be far too large.\n"
"As a consequence, Idris is able to evaluate functions during\n"
"unification, but it will not trace back information about function\n"
"arguments from a function's result for us. We can do so manually, however,\n"
"as we will see later.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:107
#, no-wrap
msgid "A Type for equal Schemata"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:114
#, no-wrap
msgid ""
"The problem described above is similar to what we saw when\n"
"we talked about the benefit of [singleton "
"types](DPair.md#erased-existentials):\n"
"The types are not precise enough. What we are going to do now,\n"
"is something we'll repeat time again for different use cases:\n"
"We encode a contract between values in an indexed data type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:115
#, no-wrap
msgid ""
"data SameSchema : (s1 : Schema) -> (s2 : Schema) -> Type where\n"
"  Same : SameSchema s s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:124
#, no-wrap
msgid ""
"First, note how `SameSchema` is a family of types indexed over two\n"
"values of type `Schema`. But note also that the sole constructor\n"
"restricts the values we allow for `s1` and `s2`: The two indices\n"
"*must* be identical.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:128
#, no-wrap
msgid ""
"Why is this useful? Well, imagine we had a function for checking\n"
"the equality of two schemata, which would try and return a value\n"
"of type `SameSchema s1 s2`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:129
#, no-wrap
msgid "sameSchema : (s1, s2 : Schema) -> Maybe (SameSchema s1 s2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:134
#, no-wrap
msgid "We could then use this function to implement `concatTables`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:135
#, no-wrap
msgid ""
"concatTables : Table -> Table -> Maybe Table\n"
"concatTables (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 "
"of\n"
"  Just Same => Just $ MkTable s1 _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:143
#, no-wrap
msgid "It worked! What's going on here? Well, let's inspect the types involved:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:144
#, no-wrap
msgid ""
"concatTables2 : Table -> Table -> Maybe Table\n"
"concatTables2 (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 "
"of\n"
"  Just Same => ?almost_there\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:152
#, no-wrap
msgid "At the REPL, we get the following context for `almost_there`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:153
#, no-wrap
msgid ""
"Tutorial.Relations> :t almost_there\n"
"   m : Nat\n"
"   s2 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s2))\n"
"   n : Nat\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"   s1 : List ColType\n"
"------------------------------\n"
"almost_there : Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:168
#, no-wrap
msgid ""
"See, how the types of `rs1` and `rs2` unify? Value `Same`, coming as the\n"
"result of `sameSchema s1 s2`, is a *witness* that `s1` and `s2` are "
"actually\n"
"identical, because this is what we specified in the definition of `Same`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:172
#, no-wrap
msgid ""
"All that remains to do is to implement `sameSchema`. For this, we will "
"write\n"
"another data type for specifying when two values of type `ColType` are\n"
"identical:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:173
#, no-wrap
msgid ""
"data SameColType : (c1, c2 : ColType) -> Type where\n"
"  SameCT : SameColType c1 c1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:180
#, no-wrap
msgid ""
"We can now define several utility functions. First, one for figuring out\n"
"if two column types are identical:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:181
#, no-wrap
msgid ""
"sameColType : (c1, c2 : ColType) -> Maybe (SameColType c1 c2)\n"
"sameColType I64     I64     = Just SameCT\n"
"sameColType Str     Str     = Just SameCT\n"
"sameColType Boolean Boolean = Just SameCT\n"
"sameColType Float   Float   = Just SameCT\n"
"sameColType _ _             = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:195
#, no-wrap
msgid ""
"This will convince Idris, because in each pattern match, the return\n"
"type will be adjusted according to the values we matched on. For instance,\n"
"on the first line, the output type is `Maybe (SameColType I64 I64)` as\n"
"you can easily verify yourself by inserting a hole and checking its\n"
"type at the REPL.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:203
#, no-wrap
msgid ""
"We will need two additional utilities: Functions for creating values\n"
"of type `SameSchema` for the nil and cons cases. Please note, how\n"
"the implementations are trivial. Still, we often have to quickly\n"
"write such small proofs (I'll explain in the next section, why I\n"
"call them *proofs*), which will then be used to convince the\n"
"type checker about some fact we already take for granted but Idris\n"
"does not.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:204
#, no-wrap
msgid ""
"sameNil : SameSchema [] []\n"
"sameNil = Same\n"
"\n"
"sameCons :  SameColType c1 c2\n"
"         -> SameSchema s1 s2\n"
"         -> SameSchema (c1 :: s1) (c2 :: s2)\n"
"sameCons SameCT Same = Same\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:221
#, no-wrap
msgid ""
"As usual, it can help understanding what's going on by replacing\n"
"the right hand side of `sameCons` with a hole an check out its\n"
"type and context at the REPL. The presence of values `SameCT`\n"
"and `Same` on the left hand side forces Idris to unify `c1` and `c2`\n"
"as well as `s1` and `s2`, from which the unification of\n"
"`c1 :: s1` and `c2 :: s2` immediately follows.\n"
"With these, we can finally implement `sameSchema`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:222
#, no-wrap
msgid ""
"sameSchema []        []        = Just sameNil\n"
"sameSchema (x :: xs) (y :: ys) =\n"
"  [| sameCons (sameColType x y) (sameSchema xs ys) |]\n"
"sameSchema (x :: xs) []        = Nothing\n"
"sameSchema []        (x :: xs) = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:238
#, no-wrap
msgid ""
"What we described here is a far stronger form of equality\n"
"than what is provided by interface `Eq` and the `(==)`\n"
"operator: Equality of values that is accepted by the\n"
"type checker when trying to unify type level indices.\n"
"This is also called *propositional equality*: We will see\n"
"below, that we can view types as mathematical *propositions*,\n"
"and values of these types a *proofs* that these propositions\n"
"hold.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:239
#, no-wrap
msgid "Type `Equal`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:251
#, no-wrap
msgid ""
"Propositional equality is such a fundamental concept, that the *Prelude*\n"
"exports a general data type for this already: `Equal`, with its only\n"
"data constructor `Refl`. In addition, there is a built-in operator\n"
"for expressing propositional equality, which gets desugared to `Equal`:\n"
"`(=)`. This can sometimes lead to some confusion, because the equals\n"
"symbol is also used for *definitional equality*: Describing in function\n"
"implementations that the left-hand side and right-hand side are\n"
"defined to be equal. If you want to disambiguate propositional from\n"
"definitional equality, you can also use operator `(===)` for the\n"
"former.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:253
#, no-wrap
msgid "Here is another implementation of `concatTables`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:254
#, no-wrap
msgid ""
"eqColType : (c1,c2 : ColType) -> Maybe (c1 = c2)\n"
"eqColType I64     I64     = Just Refl\n"
"eqColType Str     Str     = Just Refl\n"
"eqColType Boolean Boolean = Just Refl\n"
"eqColType Float   Float   = Just Refl\n"
"eqColType _ _             = Nothing\n"
"\n"
"eqCons :  {0 c1,c2 : a}\n"
"       -> {0 s1,s2 : List a}\n"
"       -> c1 = c2 -> s1 = s2 ->  c1 :: s1 = c2 :: s2\n"
"eqCons Refl Refl = Refl\n"
"\n"
"eqSchema : (s1,s2 : Schema) -> Maybe (s1 = s2)\n"
"eqSchema []        []        = Just Refl\n"
"eqSchema (x :: xs) (y :: ys) = [| eqCons (eqColType x y) (eqSchema xs ys) "
"|]\n"
"eqSchema (x :: xs) []        = Nothing\n"
"eqSchema []        (x :: xs) = Nothing\n"
"\n"
"concatTables3 : Table -> Table -> Maybe Table\n"
"concatTables3 (MkTable s1 m rs1) (MkTable s2 n rs2) = case eqSchema s1 s2 "
"of\n"
"  Just Refl => Just $ MkTable _ _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:285
#, no-wrap
msgid ""
"In the following exercises, you are going to implement\n"
"some very basic properties of equality proofs. You'll\n"
"have to come up with the types of the functions yourself,\n"
"as the implementations will be incredibly simple.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:289
#, no-wrap
msgid ""
"Note: If you can't remember what the terms \"reflexive\",\n"
"\"symmetric\", and \"transitive\" mean, quickly read about\n"
"equivalence relations "
"[here](https://en.wikipedia.org/wiki/Equivalence_relation).\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:291
msgid "Show that `SameColType` is a reflexive relation."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:293
msgid "Show that `SameColType` is a symmetric relation."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:295
msgid "Show that `SameColType` is a transitive relation."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:299
msgid ""
"Let `f` be a function of type `ColType -> a` for an arbitrary type `a`. Show "
"that from a value of type `SameColType c1 c2` follows that `f c1` and `f c2` "
"are equal."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:303
#, no-wrap
msgid ""
"For `(=)` the above properties are available from the *Prelude*\n"
"as functions `sym`, `trans`, and `cong`. Reflexivity comes\n"
"from the data constructor `Refl` itself.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:307
msgid ""
"Implement a function for verifying that two natural numbers are "
"identical. Try using `cong` in your implementation."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:310
msgid ""
"Use the function from exercise 5 for zipping two `Table`s if they have the "
"same number of rows."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:315
#, no-wrap
msgid ""
"   Hint: Use `Vect.zipWith`. You will need to implement\n"
"   custom function `appRows` for this, since Idris will\n"
"   not automatically figure out that the types unify when\n"
"   using `HList.(++)`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:316
#, no-wrap
msgid "   appRows : {ts1 : _} -> Row ts1 -> Row ts2 -> Row (ts1 ++ ts2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:323
#, no-wrap
msgid ""
"We will later learn how to use *rewrite rules* to circumvent\n"
"the need of writing custom functions like `appRows` and use\n"
"`(++)` in `zipWith` directly.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:324
#, no-wrap
msgid "Programs as Proofs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:333
#, no-wrap
msgid ""
"A famous observation by mathematician *Haskell Curry* and\n"
"logician *William Alvin Howard* leads to the conclusion,\n"
"that we can view a *type* in a programming language with\n"
"a sufficiently rich type system as a mathematical proposition\n"
"and a total program calculating a *value* of this type as a\n"
"proof that the proposition holds. This is also known as the\n"
"[Curry-Howard "
"isomorphism](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:336
#, no-wrap
msgid ""
"For instance, here is a simple proof that one plus one\n"
"equals two:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:337
#, no-wrap
msgid ""
"onePlusOne : the Nat 1 + 1 = 2\n"
"onePlusOne = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:346
#, no-wrap
msgid ""
"The above proof is trivial, as Idris solves this by unification.\n"
"But we already stated some more interesting things in the\n"
"exercises. For instance, the symmetry and transitivity of\n"
"`SameColType`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:347
#, no-wrap
msgid ""
"sctSymmetric : SameColType c1 c2 -> SameColType c2 c1\n"
"sctSymmetric SameCT = SameCT\n"
"\n"
"sctTransitive : SameColType c1 c2 -> SameColType c2 c3 -> SameColType c1 "
"c3\n"
"sctTransitive SameCT SameCT = SameCT\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:357
#, no-wrap
msgid ""
"Note, that a type alone is not a proof. For instance, we are free\n"
"to state that one plus one equals three:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:358
#, no-wrap
msgid "onePlusOneWrong : the Nat 1 + 1 = 3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:365
#, no-wrap
msgid ""
"We will, however, have a hard time implementing this in a provably\n"
"total way. We say: \"The type `the Nat 1 + 1 = 3` is *uninhabited*\",\n"
"meaning, that there is no value of this type.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:366
#, no-wrap
msgid "When Proofs replace Tests"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:373
#, no-wrap
msgid ""
"We will see several different use cases for compile time proofs, a\n"
"very straight forward one being to show that our functions behave\n"
"as they should by proofing some properties about them. For instance,\n"
"here is a proposition that `map` on list does not change the number of\n"
"elements in the list:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:374
#, no-wrap
msgid ""
"mapListLength : (f : a -> b) -> (as : List a) -> length as = length (map f "
"as)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:381
#, no-wrap
msgid ""
"Read this as a universally quantified statement: For all functions `f`\n"
"from `a` to `b` and for all lists `as` holding values of type `a`,\n"
"the length of `map f as` is the same the as the length of the original "
"list.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:387
#, no-wrap
msgid ""
"We can implement `mapListLength` by pattern matching on `as`. The `Nil` "
"case\n"
"will be trivial: Idris solves this by unification. It knows the value of "
"the\n"
"input list (`Nil`), and since `map` is implemented by pattern matching on\n"
"the input as well, it follows immediately that the result will be `Nil` as\n"
"well:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:388
#, no-wrap
msgid "mapListLength f []        = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:395
#, no-wrap
msgid ""
"The `cons` case is more involved, and we will do this stepwise.\n"
"First, note that we can proof that the length of a map over the\n"
"tail will stay the same by means of recursion:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:397
#, no-wrap
msgid ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => ?mll1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:403
#, no-wrap
msgid "Let's inspect the types and context we have here:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:404
#, no-wrap
msgid ""
" 0 b : Type\n"
" 0 a : Type\n"
"   xs : List a\n"
"   f : a -> b\n"
"   x : a\n"
"   prf : length xs = length (map f xs)\n"
"------------------------------\n"
"mll1 : S (length xs) = S (length (map f xs))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:422
#, no-wrap
msgid ""
"So, we have a proof of type `length xs = length (map f xs)`,\n"
"and from the implementation of `map` Idris concludes that what\n"
"we are actually looking for is a result of type\n"
"`S (length xs) = S (length (map f xs))`. This is exactly what\n"
"function `cong` from the *Prelude* is for (\"cong\" is an abbreviation\n"
"for *congruence*). We can thus implement the *cons* case\n"
"concisely like so:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:423
#, no-wrap
msgid "mapListLength f (x :: xs) = cong S $ mapListLength f xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:431
#, no-wrap
msgid ""
"Please take a moment to appreciate what we achieved here:\n"
"A *proof* in the mathematical sense that our function will not\n"
"affect the length of our list. We no longer need a unit test\n"
"or similar program to verify this.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:435
#, no-wrap
msgid ""
"Before we continue, please note an important thing: In our\n"
"case expression, we used a *variable* for the result from the\n"
"recursive call:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:436
#, no-wrap
msgid ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => cong S prf\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:448
#, no-wrap
msgid ""
"Here, we did not want the two lengths to unify, because we\n"
"needed the distinction in our call to `cong`. Therefore: If\n"
"you need a proof of type `x = y` in order for two variables\n"
"to unify, use the `Refl` data constructor in the pattern match.\n"
"If, on the other hand, you need to run further computations on\n"
"such a proof, use a variable and the left and right-hand sides\n"
"will remain distinct.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:453
#, no-wrap
msgid ""
"Here is another example from the last chapter: We want to show\n"
"that parsing and printing column types behaves correctly.\n"
"Writing proofs about parsers can be very hard in general, but\n"
"here it can be done with a mere pattern match:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:454
#, no-wrap
msgid ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"readColType : String -> Maybe ColType\n"
"readColType \"i64\"      = Just I64\n"
"readColType \"str\"      = Just Str\n"
"readColType \"boolean\"  = Just Boolean\n"
"readColType \"float\"    = Just Float\n"
"readColType s          = Nothing\n"
"\n"
"showReadColType : (c : ColType) -> readColType (showColType c) = Just c\n"
"showReadColType I64     = Refl\n"
"showReadColType Str     = Refl\n"
"showReadColType Boolean = Refl\n"
"showReadColType Float   = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:477
#, no-wrap
msgid ""
"Such simple proofs give us quick but strong guarantees\n"
"that we did not make any stupid mistakes.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:485
#, no-wrap
msgid ""
"The examples we saw so far were very easy to implement. In general,\n"
"this is not the case, and we will have to learn about several\n"
"additional techniques in order to proof interesting things about\n"
"our programs. However, when we use Idris as a general purpose\n"
"programming language and not as a proof assistant, we are free\n"
"to choose whether some aspect of our code needs such strong\n"
"guarantees or not.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:486
#, no-wrap
msgid "A Note of Caution: Lowercase Identifiers in Function Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:494
#, no-wrap
msgid ""
"When writing down the types of proofs as we did above, one\n"
"has to be very careful not to fall into the following trap:\n"
"In general, Idris will treat lowercase identifiers in\n"
"function types as type parameters (erased implicit arguments).\n"
"For instance, here is a try at proofing the identity functor\n"
"law for `Maybe`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:495
#, no-wrap
msgid ""
"mapMaybeId1 : (ma : Maybe a) -> map id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:504
#, no-wrap
msgid ""
"You will not be able to implement the `Just` case, because\n"
"Idris treats `id` as an implicit argument as can easily be\n"
"seen when inspecting the context of `mapMaybeId1_rhs`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:505
#, no-wrap
msgid ""
"Tutorial.Relations> :t mapMaybeId1_rhs\n"
" 0 a : Type\n"
" 0 id : a -> a\n"
"   x : a\n"
"------------------------------\n"
"mapMaybeId1_rhs : Just (id x) = Just x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:517
#, no-wrap
msgid ""
"As you can see, `id` is an erased argument of type `a -> a`. And in\n"
"fact, when type-checking this module, Idris will issue a warning that\n"
"parameter `id` is shadowing an existing function:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:518
#, no-wrap
msgid ""
"Warning: We are about to implicitly bind the following lowercase names.\n"
"You may be unintentionally shadowing the associated global definitions:\n"
"  id is shadowing Prelude.Basics.id\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:527
#, no-wrap
msgid ""
"The same is not true for `map`: Since we explicitly pass arguments\n"
"to `map`, Idris treats this as a function name and not as an\n"
"implicit argument.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:530
#, no-wrap
msgid ""
"You have several options here. For instance, you could use an uppercase\n"
"identifier, as these will never be treated as implicit arguments:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:531
#, no-wrap
msgid ""
"Id : a -> a\n"
"Id = id\n"
"\n"
"mapMaybeId2 : (ma : Maybe a) -> map Id ma = ma\n"
"mapMaybeId2 Nothing  = Refl\n"
"mapMaybeId2 (Just x) = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:543
#, no-wrap
msgid ""
"As an alternative - and this is the preferred way to handle this case -\n"
"you can prefix `id` with part of its namespace, which will immediately\n"
"resolve the issue:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:544
#, no-wrap
msgid ""
"mapMaybeId : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId Nothing  = Refl\n"
"mapMaybeId (Just x) = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:554
#, no-wrap
msgid ""
"Note: If you have semantic highlighting turned on in your editor\n"
"(for instance, by using the [idris2-lsp "
"plugin](https://github.com/idris-community/idris2-lsp)),\n"
"you will note that `map` and `id` in `mapMaybeId1` get\n"
"highlighted differently: `map` as a function name, `id` as a bound "
"variable.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:562
#, no-wrap
msgid ""
"In these exercises, you are going to proof several simple properties\n"
"of small functions. When writing proofs, it is even more important\n"
"to use holes to figure out what Idris expects from you next. Use\n"
"the tools given to you, instead of trying to find your way in the\n"
"dark!\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:564
msgid "Proof that `map id` on an `Either e` returns the value unmodified."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:566
msgid "Proof that `map id` on a list returns the list unmodified."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:570
msgid ""
"Proof that complementing a strand of a nucleobase (see the [previous "
"chapter](DPair.md#use-case-nucleic-acids))  twice leads to the original "
"strand."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:574
#, no-wrap
msgid ""
"   Hint: Proof this for single bases first, and use `cong2`\n"
"   from the *Prelude* in your implementation for sequences\n"
"   of nucleic acids.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:576
msgid "Implement function `replaceVect`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:577
#, no-wrap
msgid "   replaceVect : (ix : Fin n) -> a -> Vect n a -> Vect n a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:584
#, no-wrap
msgid ""
"   Now proof, that after replacing an element in a vector\n"
"   using `replaceAt` accessing the same element using\n"
"   `index` will return the value we just added.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:586
msgid "Implement function `insertVect`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:587
#, no-wrap
msgid "   insertVect : (ix : Fin (S n)) -> a -> Vect n a -> Vect (S n) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:593
#, no-wrap
msgid ""
"   Use a similar proof as in exercise 4 to show that this\n"
"   behaves correctly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:596
#, no-wrap
msgid ""
"Note: Functions `replaceVect` and `insertVect` are available\n"
"from `Data.Vect` as `replaceAt` and `insertAt`.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:597
#, no-wrap
msgid "Into the Void"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:612
#, no-wrap
msgid ""
"Remember function `onePlusOneWrong` from above? This was definitely\n"
"a wrong statement: One plus one does not equal three. Sometimes,\n"
"we want to express exactly this: That a certain statement is false\n"
"and does not hold. Consider for a moment what it means to proof\n"
"a statement in Idris: Such a statement (or proposition) is a\n"
"type, and a proof of the statement is a value or expression of\n"
"this type: The type is said to be *inhabited*.\n"
"If a statement is not true, there can be no value\n"
"of the given type. We say, the given type is *uninhabited*.\n"
"If we still manage to get our hands on a value of an uninhabited\n"
"type, that is a logical contradiction and from this, anything\n"
"follows (remember\n"
"[ex falso "
"quodlibet](https://en.wikipedia.org/wiki/Principle_of_explosion)).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:617
#, no-wrap
msgid ""
"So this is how to express that a proposition does not hold: We\n"
"state that if it *would* hold, this would lead to a contradiction.\n"
"The most natural way to express a contradiction in Idris is\n"
"to return a value of type `Void`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:618
#, no-wrap
msgid ""
"onePlusOneWrongProvably : the Nat 1 + 1 = 3 -> Void\n"
"onePlusOneWrongProvably Refl impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:628
#, no-wrap
msgid ""
"See how this is a provably total implementation of the\n"
"given type: A function from `1 + 1 = 3` to `Void`. We\n"
"implement this by pattern matching, and there is only\n"
"one constructor to match on, which leads to an impossible\n"
"case.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:633
#, no-wrap
msgid ""
"We can also use contradictory statements to proof other such\n"
"statements. For instance, here is a proof that if the lengths\n"
"of two lists are not the same, then the two list can't be\n"
"the same either:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:634
#, no-wrap
msgid ""
"notSameLength1 : (List.length as = length bs -> Void) -> as = bs -> Void\n"
"notSameLength1 f prf = f (cong length prf)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:642
#, no-wrap
msgid ""
"This is cumbersome to write and pretty hard to read, so there\n"
"is function `Not` in the prelude to express the same thing\n"
"more naturally:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:643
#, no-wrap
msgid ""
"notSameLength : Not (List.length as = length bs) -> Not (as = bs)\n"
"notSameLength f prf = f (cong length prf)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:651
#, no-wrap
msgid ""
"Actually, this is just a specialized version of the contraposition of\n"
"`cong`: If from `a = b` follows `f a = f b`, then from\n"
"`not (f a = f b)` follows `not (a = b)`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:652
#, no-wrap
msgid ""
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:657
#, no-wrap
msgid "Interface `Uninhabited`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:664
#, no-wrap
msgid ""
"There is an interface in the *Prelude* for uninhabited types: "
"`Uninhabited`\n"
"with its sole function `uninhabited`. Have a look at its documentation at\n"
"the REPL. You will see, that there is already an impressive number\n"
"of implementations available, many of which involve data type\n"
"`Equal`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:667
#, no-wrap
msgid ""
"We can use `Uninhabited`, to for instance express that\n"
"the empty schema is not equal to a non-empty schema:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:668
#, no-wrap
msgid ""
"Uninhabited (SameSchema [] (h :: t)) where\n"
"  uninhabited Same impossible\n"
"\n"
"Uninhabited (SameSchema (h :: t) []) where\n"
"  uninhabited Same impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:678
#, no-wrap
msgid ""
"There is a related function you need to know about: `absurd`, which\n"
"combines `uninhabited` with `void`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:679
#, no-wrap
msgid ""
"Tutorial.Eq> :printdef absurd\n"
"Prelude.absurd : Uninhabited t => t -> a\n"
"absurd h = void (uninhabited h)\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:685
#, no-wrap
msgid "Decidable Equality"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:703
#, no-wrap
msgid ""
"When we implemented `sameColType`, we got a proof that two\n"
"column types are indeed the same, from which we could figure out,\n"
"whether two schemata are identical. The types guarantee\n"
"we do not generate any false positives: If we generate a value\n"
"of type `SameSchema s1 s2`, we have a proof that `s1` and `s2`\n"
"are indeed identical.\n"
"However, `sameColType` and thus `sameSchema` could theoretically\n"
"still produce false negatives by returning `Nothing`\n"
"although the two values are identical. For instance,\n"
"we could implement `sameColType` in such a way that it\n"
"always returns `Nothing`. This would be in agreement with\n"
"the types, but definitely not what we want. So, here is\n"
"what we'd like to do in order to get yet stronger guarantees:\n"
"We'd either want to return a proof that the two schemata\n"
"are the same, or return a proof that the two schemata\n"
"are not the same. (Remember that `Not a` is an alias for `a -> Void`).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:708
#, no-wrap
msgid ""
"We call a property, which either holds or leads to a\n"
"contradiction a *decidable property*, and the *Prelude*\n"
"exports data type `Dec prop`, which encapsulates this\n"
"distinction.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:710
#, no-wrap
msgid "Here is a way to encode this for `ColType`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:711
#, no-wrap
msgid ""
"decSameColType :  (c1,c2 : ColType) -> Dec (SameColType c1 c2)\n"
"decSameColType I64 I64         = Yes SameCT\n"
"decSameColType I64 Str         = No $ \\case SameCT impossible\n"
"decSameColType I64 Boolean     = No $ \\case SameCT impossible\n"
"decSameColType I64 Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Str I64         = No $ \\case SameCT impossible\n"
"decSameColType Str Str         = Yes SameCT\n"
"decSameColType Str Boolean     = No $ \\case SameCT impossible\n"
"decSameColType Str Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Boolean I64     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Str     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Boolean = Yes SameCT\n"
"decSameColType Boolean Float   = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Float I64       = No $ \\case SameCT impossible\n"
"decSameColType Float Str       = No $ \\case SameCT impossible\n"
"decSameColType Float Boolean   = No $ \\case SameCT impossible\n"
"decSameColType Float Float     = Yes SameCT\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:741
#, no-wrap
msgid ""
"First, note how we could use a pattern match in a single\n"
"argument lambda directly. This is sometimes called the\n"
"*lambda case* style, named after an extension of the Haskell\n"
"programming language. If we use the `SameCT` constructor\n"
"in the pattern match, Idris is forced to try and unify for instance\n"
"`Float` with `I64`. This is not possible, so the case as\n"
"a whole is impossible.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:749
#, no-wrap
msgid ""
"Yet, this was pretty cumbersome to implement. In order to\n"
"convince Idris we did not miss a case,\n"
"there is no way around treating every possible pairing\n"
"of constructors explicitly.\n"
"However, we get *much* stronger guarantees out of this: We\n"
"can no longer create false positives *or* false negatives, and\n"
"therefore, `decSameColType` is provably correct.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:752
#, no-wrap
msgid ""
"Doing the same thing for schemata requires some utility functions,\n"
"the types of which we can figure out by placing some holes:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:753
#, no-wrap
msgid ""
"decSameSchema' :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema' []        []        = Yes Same\n"
"decSameSchema' []        (y :: ys) = No ?decss1\n"
"decSameSchema' (x :: xs) []        = No ?decss2\n"
"decSameSchema' (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema' xs ys of\n"
"    Yes Same => Yes Same\n"
"    No  contra => No $ \\prf => ?decss3\n"
"  No  contra => No $ \\prf => ?decss4\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:770
#, no-wrap
msgid ""
"The first two cases are not too hard. The type of `decss1` is\n"
"`SameSchema [] (y :: ys) -> Void`, which you can easily verify\n"
"at the REPL. But that's just `uninhabited`, specialized to\n"
"`SameSchema [] (y :: ys)`, and this we already implemented\n"
"further above. The same goes for `decss2`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:777
#, no-wrap
msgid ""
"The other two cases are harder, so I already filled in as much stuff\n"
"as possible. We know that we want to return a `No`, if either the\n"
"heads or tails are provably distinct. The `No` holds a\n"
"function, so I already added a lambda, leaving a hole only for\n"
"the return value. Here are the type and - more important -\n"
"context of `decss3`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:778
#, no-wrap
msgid ""
"Tutorial.Relations> :t decss3\n"
"   y : ColType\n"
"   xs : List ColType\n"
"   ys : List ColType\n"
"   x : ColType\n"
"   contra : SameSchema xs ys -> Void\n"
"   prf : SameSchema (y :: xs) (y :: ys)\n"
"------------------------------\n"
"decss3 : Void\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:797
#, no-wrap
msgid ""
"The types of `contra` and `prf` are what we need here:\n"
"If `xs` and `ys` are distinct, then `y :: xs` and `y :: ys`\n"
"must be distinct as well. This is the contraposition of the\n"
"following statement: If `x :: xs` is the same as `y :: ys`,\n"
"then `xs` and `ys` are the same as well. We must therefore\n"
"implement a lemma, which proves that the *cons* constructor\n"
"is [*injective*](https://en.wikipedia.org/wiki/Injective_function):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:798
#, no-wrap
msgid ""
"consInjective :  SameSchema (c1 :: cs1) (c2 :: cs2)\n"
"              -> (SameColType c1 c2, SameSchema cs1 cs2)\n"
"consInjective Same = (SameCT, Same)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:809
#, no-wrap
msgid ""
"We can now pass `prf` to `consInjective` to extract a value of\n"
"type `SameSchema xs ys`, which we then pass to `contra` in\n"
"order to get the desired value of type `Void`.\n"
"With these observations and utilities, we can now implement\n"
"`decSameSchema`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:810
#, no-wrap
msgid ""
"decSameSchema :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema []        []        = Yes Same\n"
"decSameSchema []        (y :: ys) = No absurd\n"
"decSameSchema (x :: xs) []        = No absurd\n"
"decSameSchema (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema xs ys of\n"
"    Yes Same   => Yes Same\n"
"    No  contra => No $ contra . snd . consInjective\n"
"  No  contra => No $ contra . fst . consInjective\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:825
#, no-wrap
msgid ""
"There is an interface called `DecEq` exported by module "
"`Decidable.Equality`\n"
"for types for which we can implement a decision procedure for "
"propositional\n"
"equality. We can implement this to figure out if two values are equal or "
"not.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:830
msgid ""
"Show that there can be no non-empty vector of `Void` by writing a "
"corresponding implementation of uninhabited"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:832
msgid "Generalize exercise 1 for all uninhabited element types."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:835
msgid "Show that if `a = b` cannot hold, then `b = a` cannot hold either."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:838
msgid ""
"Show that if `a = b` holds, and `b = c` cannot hold, then `a = c` cannot "
"hold either."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:841
msgid "Implement `Uninhabited` for `Crud i a`. Try to be as general as possible."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Folds.md:996 ../src/Tutorial/Functor.md:417 ../src/Tutorial/Traverse.md:285
#, no-wrap
msgid ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:851
msgid "Implement `DecEq` for `ColType`."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Eq.md:856
msgid ""
"Implementations such as the one from exercise 6 are cumbersome to write as "
"they require a quadratic number of pattern matches with relation to the "
"number of data constructors. Here is a trick how to make this more bearable."
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Eq.md:859
msgid ""
"Implement a function `ctNat`, which assigns every value of type `ColType` a "
"unique natural number."
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Eq.md:864
msgid ""
"Proof that `ctNat` is injective.  Hint: You will need to pattern match on "
"the `ColType` values, but four matches should be enough to satisfy the "
"coverage checker."
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Eq.md:869
msgid ""
"In your implementation of `DecEq` for `ColType`, use `decEq` on the result "
"of applying both column types to `ctNat`, thus reducing it to only two lines "
"of code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:877
#, no-wrap
msgid ""
"   We will later talk about `with` rules: Special forms of\n"
"   dependent pattern matches, that allow us to learn something\n"
"   about the shape of function arguments by performing\n"
"   computations on them. These will allow us to use\n"
"   a similar technique as shown here to implement `DecEq`\n"
"   requiring only `n` pattern matches\n"
"   for arbitrary sum types with `n` data constructors.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:878
#, no-wrap
msgid "Rewrite Rules"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:888
#, no-wrap
msgid ""
"One of the most important use cases of propositional equality\n"
"is to replace or *rewrite* existing types, which Idris can't\n"
"unify automatically otherwise. For instance,\n"
"the following is no problem:\n"
"Idris know that `0 + n` equals `n`, because `plus` on\n"
"natural numbers is implemented by pattern matching on the\n"
"first argument. The two vector lengths therefore unify\n"
"just fine.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:889
#, no-wrap
msgid ""
"leftZero :  List (Vect n Nat)\n"
"         -> List (Vect (0 + n) Nat)\n"
"         -> List (Vect n Nat)\n"
"leftZero = (++)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:899
#, no-wrap
msgid ""
"However, the example below can't be implemented as easily\n"
"(try id!), because Idris can't figure out on its own\n"
"that the two lengths unify.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:900
#, no-wrap
msgid ""
"rightZero' :  List (Vect n Nat)\n"
"           -> List (Vect (n + 0) Nat)\n"
"           -> List (Vect n Nat)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:909
#, no-wrap
msgid ""
"Probably for the first time we realize, just how little\n"
"Idris knows about the laws of arithmetics. Idris is able\n"
"to unify values when\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Eq.md:913
msgid "all values in a computation are known at compile time"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Eq.md:913
msgid ""
"one expression follows directly from the other due to the pattern matches "
"used in a function's implementation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:917
#, no-wrap
msgid ""
"In expression `n + 0`,  not all values are known (`n` is a variable),\n"
"and `(+)` is implemented by pattern matching on the first\n"
"argument, about which we know nothing here.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:923
#, no-wrap
msgid ""
"However, we can teach Idris. If we can proof that the two\n"
"expressions are equivalent, we can replace one expression\n"
"for the other, so that the two unify again. Here is a lemma\n"
"and its proof, that `n + 0` equals `n`, for all natural\n"
"numbers `n`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:924
#, no-wrap
msgid ""
"addZeroRight : (n : Nat) -> n + 0 = n\n"
"addZeroRight 0     = Refl\n"
"addZeroRight (S k) = cong S $ addZeroRight k\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:935
#, no-wrap
msgid ""
"Note, how the base case is trivial: Since there are no\n"
"variables left, Idris can immediately figure out that\n"
"`0 + 0 = 0`. In the recursive case, it can be instructive\n"
"to replace `cong S` with a hole and look at its type\n"
"and context to figure out how to proceed.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:940
#, no-wrap
msgid ""
"The *Prelude* exports function `replace` for substituting one\n"
"variable in a term by another, based on a proof of equality.\n"
"Make sure to inspect its type first before looking at the\n"
"example below:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:941
#, no-wrap
msgid ""
"replaceVect : Vect (n + 0) a -> Vect n a\n"
"replaceVect as = replace {p = \\k => Vect k a} (addZeroRight n) as\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:952
#, no-wrap
msgid ""
"As you can see, we *replace* a value of type `p x` with a value\n"
"of type `p y` based on a proof that `x = y`,\n"
"where `p` is a function from some type `t` to\n"
"`Type`, and `x` and `y` are values of type `t`. In our\n"
"`replaceVect` example, `t` equals `Nat`, `x` equals `n + 0`,\n"
"`y` equals `n`, and `p` equals `\\k => Vect k a`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:960
#, no-wrap
msgid ""
"Using `replace` directly is not very convenient, because Idris\n"
"can often not infer the value of `p` on its own. Indeed, we\n"
"had to give its type explicitly in `replaceVect`.\n"
"Idris therefore provides special syntax for such *rewrite rules*,\n"
"which will get desugared to calls to `replace` with all the\n"
"details filled in for us. Here is an implementation\n"
"of `replaceVect` with a rewrite rule:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:961
#, no-wrap
msgid ""
"rewriteVect : Vect (n + 0) a -> Vect n a\n"
"rewriteVect as = rewrite sym (addZeroRight n) in as\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:970
#, no-wrap
msgid ""
"One source of confusion is that *rewrite* uses proofs\n"
"of equality the other way round: Given an `y = x`\n"
"it replaces `p x` with `p y`. Hence the need to call `sym`\n"
"in our implementation above.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:971
#, no-wrap
msgid "Use Case: Reversing Vectors"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:982
#, no-wrap
msgid ""
"Rewrite rules are often required when we perform interesting\n"
"type-level computations. For instance,\n"
"we have already seen many interesting examples of functions\n"
"operating on `Vect`, which allowed us to keep track of the\n"
"exact lengths of the vectors involved, but one key\n"
"functionality has been missing from our discussions so far,\n"
"and for good reasons: Function `reverse`. Here is a possible\n"
"implementation, which is how `reverse` is implemented for\n"
"lists:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:984
#, no-wrap
msgid ""
"reverseOnto' : Vect m a -> Vect n a -> Vect (m + n) a\n"
"reverseOnto' xs []        = xs\n"
"reverseOnto' xs (x :: ys) = reverseOnto' (x :: xs) ys\n"
"\n"
"\n"
"reverseVect' : Vect n a -> Vect n a\n"
"reverseVect' = reverseOnto' []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:997
#, no-wrap
msgid ""
"As you might have guessed, this will not compile as the\n"
"length indices in the two clauses of `reverseOnto'` do\n"
"not unify.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1001
#, no-wrap
msgid ""
"The *nil* case is a case we've already seen above:\n"
"Here `n` is zero, because the second vector is empty,\n"
"so we have to convince Idris once again that `m + 0 = m`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1002
#, no-wrap
msgid ""
"reverseOnto : Vect m a -> Vect n a -> Vect (m + n) a\n"
"reverseOnto xs [] = rewrite addZeroRight m in xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1013
#, no-wrap
msgid ""
"The second case is more complex. Here, Idris fails to unify\n"
"`S (m + len)` with `m + S len`, where `len` is the length of\n"
"`ys`, the tail of the second vector. Module `Data.Nat`\n"
"provides many proofs about arithmetic operations on natural\n"
"numbers, one of which is `plusSuccRightSucc`. Here's its\n"
"type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1014
#, no-wrap
msgid ""
"Tutorial.Eq> :t plusSuccRightSucc\n"
"Data.Nat.plusSuccRightSucc :  (left : Nat)\n"
"                           -> (right : Nat)\n"
"                           -> S (left + right) = left + S right\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1032
#, no-wrap
msgid ""
"In our case, we want to replace `S (m + len)` with `m + S len`,\n"
"so we will need the version with arguments flipped. However, there\n"
"is one more obstacle: We need to invoke `plusSuccRightSucc`\n"
"with the length of `ys`, which is not given as an implicit\n"
"function argument of `reverseOnto`. We therefore need to pattern\n"
"match on `n` (the length of the second vector), in order to\n"
"bind the length of the tail to a variable. Remember, that we\n"
"are allowed to pattern match on an erased argument only if\n"
"the constructor used follows from a match on another, unerased,\n"
"argument (`ys` in this case). Here's the implementation of the\n"
"second case:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1033
#, no-wrap
msgid ""
"reverseOnto {n = S len} xs (x :: ys) =\n"
"  rewrite sym (plusSuccRightSucc m len) in reverseOnto (x :: xs) ys\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1043
#, no-wrap
msgid ""
"I know from my own experience that this can be highly confusing\n"
"at first. If you use Idris as a general purpose programming language\n"
"and not as a proof assistant, you probably will not have to use\n"
"rewrite rules too often. Still, it is important to know that they\n"
"exist, as they allow us to teach complex equivalences to Idris.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:1044
#, no-wrap
msgid "A Note on Erasure"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1055
#, no-wrap
msgid ""
"Single value data types like `Unit`, `Equal`, or `SameSchema` have\n"
"not runtime relevance, as values of these types are always identical.\n"
"We can therefore always use them as erased function arguments while\n"
"still being able to pattern match on these values.\n"
"For instance, when you look at the type of `replace`, you will see\n"
"that the equality proof is an erased argument.\n"
"This allows us to run arbitrarily complex computations to produce\n"
"such values without fear of these computations slowing down\n"
"the compiled Idris program.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:1059
msgid "Implement `plusSuccRightSucc` yourself."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:1061
msgid "Proof that `minus n n` equals zero for all natural numbers `n`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:1063
msgid "Proof that `minus n 0` equals n for all natural numbers `n`"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:1066
msgid "Proof that `n * 1 = n` and `1 * n = n` for all natural numbers `n`."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:1069
msgid "Proof that addition of natural numbers is commutative."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:1071
msgid "Implement a tail-recursive version of `map` for vectors."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Eq.md:1073
msgid "Proof the following proposition:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1074
#, no-wrap
msgid ""
"   mapAppend :  (f : a -> b)\n"
"             -> (xs : List a)\n"
"             -> (ys : List a)\n"
"             -> map f (xs ++ ys) = map f xs ++ map f ys\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Eq.md:1084
msgid ""
"Use the proof from exercise 7 to implement again a function for zipping two "
"`Table`s, this time using a rewrite rule plus `Data.HList.(++)` instead of "
"custom function `appRows`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1096
#, no-wrap
msgid ""
"The concept of *types as propositions, values as proofs* is\n"
"a very powerful tool for writing provably correct programs. We\n"
"will therefore spend some more time defining data types\n"
"for describing contracts between values, and values of these\n"
"types as proofs that the contracts hold. This will allow\n"
"us to describe necessary pre- and postconditions for our functions,\n"
"thus reducing the need to return a `Maybe` or other failure type,\n"
"because due to the restricted input, our functions can no longer\n"
"fail.\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Folds.md:1
#, no-wrap
msgid "Recursion and Folds"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:12
#, no-wrap
msgid ""
"In this chapter, we are going to have a closer look at the\n"
"computations we typically perform with *container types*:\n"
"Parameterized data types like `List`, `Maybe`, or\n"
"`Identity`, holding zero or more values of the parameter's\n"
"type. Many of these functions are recursive in nature,\n"
"so we start with a discourse about recursion in general,\n"
"and tail recursion as an important optimization technique\n"
"in particular. Most recursive functions in this part\n"
"will describe pure iterations over lists.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:17
#, no-wrap
msgid ""
"It is recursive functions, for which totality is hard\n"
"to determine, so we will next have a quick look at the\n"
"totality checker and learn, when it will refuse to\n"
"accept a function as being total and what to do about this.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:22
#, no-wrap
msgid ""
"Finally, we will start looking for common patterns in\n"
"the recursive functions from the first part and will\n"
"eventually introduce a new interface for consuming\n"
"container types: Interface `Foldable`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:23
#, no-wrap
msgid ""
"module Tutorial.Folds\n"
"\n"
"import Data.List1\n"
"import Data.Maybe\n"
"import Data.Vect\n"
"import Debug.Trace\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Folds.md:34
#, no-wrap
msgid "Recursion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:38
#, no-wrap
msgid ""
"In this section, we are going to have a closer look at\n"
"recursion in general and at tail recursion in particular.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:47
#, no-wrap
msgid ""
"Recursive functions are functions, which call themselves\n"
"to repeat a task or calculation until a certain aborting\n"
"condition (called the *base case*) holds.\n"
"Please note, that it is recursive functions, which\n"
"make it hard to verify totality: Non-recursive functions,\n"
"which are *covering* (they cover all possible cases in their\n"
"pattern matches) are automatically total if they only invoke\n"
"other total functions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:50
#, no-wrap
msgid ""
"Here is an example of a recursive function: It generates\n"
"a list of the given length filling it with identical values:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:51
#, no-wrap
msgid ""
"replicateList : Nat -> a -> List a\n"
"replicateList 0     _ = []\n"
"replicateList (S k) x = x :: replicateList k x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:63
#, no-wrap
msgid ""
"As you can see (this module has the `%default total` pragma at the top),\n"
"this function is provably total. Idris verifies, that the `Nat` argument\n"
"gets *strictly smaller* in each recursive call, and that therefore, the\n"
"function *must* eventually come to an end. Of course, we can do the\n"
"same thing for `Vect`, where we can even show that the length of the\n"
"resulting vector matches the given natural number:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:64
#, no-wrap
msgid ""
"replicateVect : (n : Nat) -> a -> Vect n a\n"
"replicateVect 0     _ = []\n"
"replicateVect (S k) x = x :: replicateVect k x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:73
#, no-wrap
msgid ""
"While we often use recursion to *create* values of data types like\n"
"`List` or `Vect`, we also use recursion, when we *consume* such values.\n"
"For instance, here is a function for calculating the length of a list:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:74
#, no-wrap
msgid ""
"len : List a -> Nat\n"
"len []        = 0\n"
"len (_ :: xs) = 1 + len xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:82
#, no-wrap
msgid ""
"Again, Idris can verify that `len` is total, as the list we pass in\n"
"the recursive case is strictly smaller than the original list argument.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:88
#, no-wrap
msgid ""
"But when is a recursive function non-total? Here is an example: The\n"
"following function creates a sequence of values until the given\n"
"generation function (`gen`) returns a `Nothing`. Note, how we use\n"
"a *state* value (of generic type `s`) and use `gen` to calculate\n"
"a value together with the next state:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:89
#, no-wrap
msgid ""
"covering\n"
"unfold : (gen : s -> Maybe (s,a)) -> s -> List a\n"
"unfold gen vs = case gen vs of\n"
"  Just (vs',va) => va :: unfold gen vs'\n"
"  Nothing       => []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:103
#, no-wrap
msgid ""
"With `unfold`, Idris can't verify that any of its arguments is\n"
"converging towards the base case. It therefore rightfully\n"
"refuses to accept that `unfold` is total. And indeed, the following\n"
"function produces an infinite list (so please, don't try to inspect\n"
"this at the REPL, as doing so will consume all your computer's\n"
"memory):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:104
#, no-wrap
msgid ""
"fiboHelper : (Nat,Nat) -> ((Nat,Nat),Nat)\n"
"fiboHelper (f0,f1) = ((f1, f0 + f1), f0)\n"
"\n"
"covering\n"
"fibonacci : List Nat\n"
"fibonacci = unfold (Just . fiboHelper) (1,1)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:117
#, no-wrap
msgid ""
"In order to safely create a (finite) sequence of Fibonacci numbers,\n"
"we need to make sure the function generating the sequence will\n"
"stop after a finite number of steps, for instance by limiting\n"
"the length of the list:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:118
#, no-wrap
msgid ""
"unfoldTot : Nat -> (gen : s -> Maybe (s,a)) -> s -> List a\n"
"unfoldTot 0     _   _  = []\n"
"unfoldTot (S k) gen vs = case gen vs of\n"
"  Just (vs',va) => va :: unfoldTot k gen vs'\n"
"  Nothing       => []\n"
"\n"
"fibonacciN : Nat -> List Nat\n"
"fibonacciN n = unfoldTot n (Just . fiboHelper) (1,1)\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:129
#, no-wrap
msgid "The Call Stack"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:133
#, no-wrap
msgid ""
"In order to demonstrate what tail recursion is about, we require\n"
"the following `main` function:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:134
#, no-wrap
msgid ""
"main : IO ()\n"
"main = printLn . len $ replicateList 10000 10\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:144
#, no-wrap
msgid ""
"If you have [Node.js](https://nodejs.org/en/) installed on your system,\n"
"you might try the following experiment. Compile and run this\n"
"module using the *Node.js* backend of Idris instead of the default\n"
"*Chez Scheme* backend and run the resulting JavaScript source file\n"
"with the Node.js binary:\n"
msgstr ""

#. type: Code fence info string
#: ../src/Tutorial/Folds.md:145 ../src/Tutorial/Folds.md:241 ../src/Tutorial/Folds.md:326 ../src/Tutorial/Folds.md:582 ../src/Tutorial/Intro.md:199 ../src/Tutorial/Intro.md:208 ../src/Tutorial/Intro.md:223 ../src/Tutorial/Prim.md:38
#, no-wrap
msgid "sh"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:145
#, no-wrap
msgid ""
"idris2 --cg node -o test.js --find-ipkg -src/Tutorial/Folds.md\n"
"node build/exec/test.js\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:154
#, no-wrap
msgid ""
"Node.js will fail with the following error message and a lengthy\n"
"stack trace: `RangeError: Maximum call stack size exceeded`.\n"
"What's going on here? How can it be that `main` fails with an\n"
"exception although it is provably total?\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:169
#, no-wrap
msgid ""
"First, remember that a function\n"
"being total means that it will eventually produce a value\n"
"of the given type in a finite amount of time, *given\n"
"enough resources like computer memory*. Here, `main` hasn't\n"
"been given enough resources as Node.js has a very small size\n"
"limit on its call stack. The *call stack* can be thought\n"
"of as a stack data structure (first in, last out), where\n"
"nested function calls are put. In case of recursive functions,\n"
"the stack size increases by one with every recursive function\n"
"call. In case of our `main` function, we create and consume\n"
"a list of length 10'000, so the call stack will hold\n"
"at least 10'000 function calls before they are being invoked\n"
"and the stack's size is reduced again. This exceeds Node.js's\n"
"stack size limit by far, hence the overflow error.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:180
#, no-wrap
msgid ""
"Now, before we look at a solution how to circumvent this issue,\n"
"please note that this is a very serious and limiting source of\n"
"bugs when using the JavaScript backends of Idris. In Idris, having no\n"
"access to control structures like `for` or `while` loops, we *always*\n"
"have to resort to recursion in order to describe iterative\n"
"computations. Luckily (or should I say \"unfortunately\", since otherwise\n"
"this issue would already have been addressed with all seriousness),\n"
"the Scheme backends don't have this issue, as their stack size\n"
"limit is much larger and they perform all kinds of optimizations\n"
"internally to prevent the call stack from overflowing.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:181
#, no-wrap
msgid "Tail Recursion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:187
#, no-wrap
msgid ""
"A recursive function is said to be *tail recursive*, if\n"
"all recursive calls occur at *tail position*: The last\n"
"function call in a (sub)expression. For instance, the following\n"
"version of `len` is tail recursive:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:188
#, no-wrap
msgid ""
"lenOnto : Nat -> List a -> Nat\n"
"lenOnto k []        = k\n"
"lenOnto k (_ :: xs) = lenOnto (k + 1) xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:197
#, no-wrap
msgid ""
"Compare this to `len` as defined above: There, the last\n"
"function call is an invocation of operator `(+)`, and\n"
"the recursive call happens in one of its arguments:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:198
#, no-wrap
msgid "len (_ :: xs) = 1 + len xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:204
#, no-wrap
msgid ""
"We can use `lenOnto` as a utility to implement a tail recursive\n"
"version of `len` without the additional `Nat` argument:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:205
#, no-wrap
msgid ""
"lenTR : List a -> Nat\n"
"lenTR = lenOnto 0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:215
#, no-wrap
msgid ""
"This is a common pattern when writing tail recursive functions:\n"
"We typically add an additional function argument for accumulating\n"
"intermediary results, which is then passed on explicitly at each\n"
"recursive call. For instance, here is a tail recursive version\n"
"of `replicateList`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:216
#, no-wrap
msgid ""
"replicateListTR : Nat -> a -> List a\n"
"replicateListTR n v = go Nil n\n"
"  where go : List a -> Nat -> List a\n"
"        go xs 0     = xs\n"
"        go xs (S k) = go (v :: xs) k\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:229
#, no-wrap
msgid ""
"The big advantage of tail recursive functions is, that they\n"
"can be easily converted to efficient, imperative loops by the Idris\n"
"compiler, and are thus *stack safe*: Recursive function calls\n"
"are *not* added to the call stack, thus avoiding the dreaded\n"
"stack overflow errors.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:230
#, no-wrap
msgid ""
"main1 : IO ()\n"
"main1 = printLn . lenTR $ replicateListTR 10000 10\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:240
#, no-wrap
msgid ""
"We can again run `main1` using the *Node.js* backend. This time,\n"
"we use slightly different syntax to execute a function other than\n"
"`main` (Remember: The dollar prefix is only there to distinghish\n"
"a terminal command from its output. It is not part of the\n"
"command you enter in a terminal sesssion.):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:241
#, no-wrap
msgid ""
"$ idris2 --cg node --exec main1 --find-ipkg src/Tutorial/Folds.md\n"
"10000\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:248
#, no-wrap
msgid ""
"As you can see, this time the computation finished without\n"
"overflowing the call stack.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:253
#, no-wrap
msgid ""
"Tail recursive functions are allowed to consist of\n"
"(possibly nested) pattern matches, with recursive\n"
"calls at tail position in several of the branches.\n"
"Here is an example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:254
#, no-wrap
msgid ""
"countTR : (a -> Bool) -> List a -> Nat\n"
"countTR p = go 0\n"
"  where go : Nat -> List a -> Nat\n"
"        go k []        = k\n"
"        go k (x :: xs) = case p x of\n"
"          True  => go (S k) xs\n"
"          False => go k xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:266
#, no-wrap
msgid ""
"Note, how each invocation of `go` is in tail position in\n"
"its branch of the case expression.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:267
#, no-wrap
msgid "Mutual Recursion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:281
#, no-wrap
msgid ""
"It is sometimes convenient to implement several related\n"
"functions, which call each other recursively. In Idris,\n"
"unlike in many other programming languages,\n"
"a function must be declared in a source file\n"
"*before* it can be called by other functions, as in general\n"
"a function's implementation must\n"
"be available during type checking (because Idris has\n"
"dependent types). There are two ways around this, which\n"
"actually result in the same internal representation in the\n"
"compiler. Our first option is to write down the functions' declarations\n"
"first with the implementations following after. Here's a\n"
"silly example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:282
#, no-wrap
msgid ""
"even : Nat -> Bool\n"
"\n"
"odd : Nat -> Bool\n"
"\n"
"even 0     = True\n"
"even (S k) = odd k\n"
"\n"
"odd 0     = False\n"
"odd (S k) = even k\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:297
#, no-wrap
msgid ""
"As you can see, function `even` is allowed to call function `odd` in\n"
"its implementation, since `odd` has already been declared (but not yet\n"
"implemented).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:302
#, no-wrap
msgid ""
"If you're like me and want to keep declarations and implementations\n"
"next to each other, you can introduce a `mutual` block, which has\n"
"the same effect. Like with other code blocks, functions in a `mutual`\n"
"block must all be indented by the same amount of whitespace:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:303
#, no-wrap
msgid ""
"mutual\n"
"  even' : Nat -> Bool\n"
"  even' 0     = True\n"
"  even' (S k) = odd' k\n"
"\n"
"  odd' : Nat -> Bool\n"
"  odd' 0     = False\n"
"  odd' (S k) = even' k\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:319
#, no-wrap
msgid ""
"Just like with single recursive functions, mutually recursive\n"
"functions can be optimized to imperative loops if all\n"
"recursive calls occur at tail position. This is the case\n"
"with functions `even` and `odd`, as can again be\n"
"verified at the *Node.js* backend:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:320
#, no-wrap
msgid ""
"main2 : IO ()\n"
"main2 =  printLn (even 100000)\n"
"      >> printLn (odd 100000)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:326
#, no-wrap
msgid ""
"$ idris2 --cg node --exec main2 --find-ipkg src/Tutorial/Folds.md\n"
"True\n"
"False\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:332
#, no-wrap
msgid "Final Remarks"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:336
#, no-wrap
msgid ""
"In this section, we learned about several important aspects\n"
"of recursion and totality checking, which are summarized here:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:339
msgid ""
"In pure functional programming, recursion is the way to implement iterative "
"procedures."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:343
msgid ""
"Recursive functions pass the totality checker, if it can verify that one of "
"the arguments is getting strictly smaller in every recursive function call."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:346
msgid ""
"Arbitrary recursion can lead to stack overflow exceptions on backends with "
"small stack size limits."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:350
msgid ""
"The JavaScript backends of Idris perform mutual tail call optimization: Tail "
"recursive functions are converted to stack safe, imperative loops."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:354
#, no-wrap
msgid ""
"Note, that not all Idris backends you will come across in the wild\n"
"will perform tail call optimization. Please check the corresponding\n"
"documentation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:372
#, no-wrap
msgid ""
"Note also, that most recursive functions in the core libraries (*prelude*\n"
"and *base*) do not yet make use of tail recursion. There is an\n"
"important reason for this: In many cases, non-tail recursive\n"
"functions are easier to use in compile-time proofs, as they\n"
"unify more naturally than their tail recursive counterparts.\n"
"Compile-time proofs are an important aspect of programming\n"
"in Idris (as we will see in later chapters), so there is a\n"
"compromise to be made between what performs well at runtime\n"
"and what works well at compile time. Eventually, the way\n"
"to go might be to provide two implementations for most\n"
"recursive functions with a *transform rule* telling the\n"
"compiler to use the optimized version at runtime whenever\n"
"programmers use the non-optimized version in their code.\n"
"Such transform rules have - for instance - already been\n"
"written for functions `pack` and `unpack` (which use\n"
"`fastPack` and `fastUnpack` at runtime; see the corresponding\n"
"rules in [the following source "
"file](https://github.com/idris-lang/Idris2/blob/main/libs/prelude/Prelude/Types.idr)).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:379
#, no-wrap
msgid ""
"In these exercises you are going to implement several\n"
"recursive functions. Make sure to use tail recursion\n"
"whenever possible and quickly verify the correct\n"
"behavior of all functions at the REPL.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Folds.md:383
msgid ""
"Implement functions `anyList` and `allList`, which return `True` if any "
"element (or all elements in case of `allList`) in a list fulfills the given "
"predicate:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:384
#, no-wrap
msgid ""
"   anyList : (a -> Bool) -> List a -> Bool\n"
"\n"
"   allList : (a -> Bool) -> List a -> Bool\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:392
msgid ""
"Implement function `findList`, which returns the first value (if any) "
"fulfilling the given predicate:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:393
#, no-wrap
msgid "   findList : (a -> Bool) -> List a -> Maybe a\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:399
msgid ""
"Implement function `collectList`, which returns the first value (if any), "
"for which the given function returns a `Just`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:400
#, no-wrap
msgid "   collectList : (a -> Maybe b) -> List a -> Maybe b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:405
#, no-wrap
msgid "   Implement `lookupList` in terms of `collectList`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:406
#, no-wrap
msgid "   lookupList : Eq a => a -> List (a,b) -> Maybe b\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:423
msgid ""
"For functions like `map` or `filter`, which must loop over a list without "
"affecting the order of elements, it is harder to write a tail recursive "
"implementation.  The safest way to do so is by using a `SnocList` (a "
"*reverse* kind of list that's built from head to tail instead of from tail "
"to head) to accumulate intermediate results. Its two constructors are `Lin` "
"and `(:<)` (called the *snoc* operator).  Module `Data.SnocList` exports two "
"tail recursive operators called *fish* and *chips* (`(<><)` and `(<>>)`) for "
"going from `SnocList` to `List` and vice versa. Have a look at the types of "
"all new data constructors and operators before continuing with the exercise."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:428
#, no-wrap
msgid ""
"   Implement a tail recursive version of `map` for `List`\n"
"   by using a `SnocList` to reassemble the mapped list. Use then\n"
"   the *chips* operator with a `Nil` argument to\n"
"   in the end convert the `SnocList` back to a `List`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:429
#, no-wrap
msgid "   mapTR : (a -> b) -> List a -> List b\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:437
msgid ""
"Implement a tail recursive version of `filter`, which only keeps those "
"values in a list, which fulfill the given predicate. Use the same technique "
"as described in exercise 4."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:438
#, no-wrap
msgid "   filterTR : (a -> Bool) -> List a -> List a\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Folds.md:445
msgid ""
"Implement a tail recursive version of `mapMaybe`, which only keeps those "
"values in a list, for which the given function argument returns a `Just`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:446
#, no-wrap
msgid "   mapMaybeTR : (a -> Maybe b) -> List a -> List b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:451
#, no-wrap
msgid "   Implement `catMaybesTR` in terms of `mapMaybeTR`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:452
#, no-wrap
msgid "   catMaybesTR : List (Maybe a) -> List a\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Folds.md:457
msgid "Implement a tail recursive version of list concatenation:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:458
#, no-wrap
msgid "   concatTR : List a -> List a -> List a\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Folds.md:464
msgid "Implement tail recursive versions of *bind* and `join` for `List`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:465
#, no-wrap
msgid ""
"   bindTR : List a -> (a -> List b) -> List b\n"
"\n"
"   joinTR : List (List a) -> List a\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Folds.md:471
#, no-wrap
msgid "A few Notes on Totality Checking"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:482
#, no-wrap
msgid ""
"The totality checker in Idris verifies, that at least one\n"
"(possibly erased!) argument in a recursive call converges towards\n"
"a base case. For instance, with natural numbers, if the base case\n"
"is zero (corresponding to data constructor `Z`), and we continue\n"
"with `k` after pattern matching on `S k`, Idris can derive from\n"
"`Nat`'s constructors, that `k` is strictly smaller than `S k`\n"
"and therefore the recursive call must converge towards a base case.\n"
"Exactly the same reasoning is used when pattern matching on a list\n"
"and continuing only with its tail in the recursive call.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:487
#, no-wrap
msgid ""
"While this works in many cases, it doesn't always go as expected.\n"
"Below, I'll show you a couple of examples where totality checking\n"
"fails, although *we* know, that the functions in question are definitely\n"
"total.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:488
#, no-wrap
msgid "Case 1: Recursion over a Primitive"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:494
#, no-wrap
msgid ""
"Idris doesn't know anything about the internal structure of\n"
"primitive data types. So the following function, although\n"
"being obviously total, will not be accepted by the totality\n"
"checker:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:495
#, no-wrap
msgid ""
"covering\n"
"replicatePrim : Bits32 -> a -> List a\n"
"replicatePrim 0 v = []\n"
"replicatePrim x v = v :: replicatePrim (x - 1) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:514
#, no-wrap
msgid ""
"Unlike with natural numbers (`Nat`), which are defined as an inductive\n"
"data type and are only converted to integer primitives during compilation,\n"
"Idris can't tell that `x - 1` is strictly smaller than `x`, and so it\n"
"fails to verify that this must converge towards the base case.\n"
"(The reason is, that `x - 1` is implemented in terms of primitive\n"
"function `prim__sub_Bits32`, which is built into the compiler and\n"
"must be implemented by each backend individually. The totality\n"
"checker knows about data types, constructors, and functions\n"
"defined in Idris, but not about (primitive) functions and foreign "
"functions\n"
"implemented at the backends. While it is theoretically possible to\n"
"also define and use laws for primitive and foreign functions, this hasn't "
"yet\n"
"been done for most of them.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:520
#, no-wrap
msgid ""
"Since non-totality is highly contagious (all functions invoking a\n"
"partial function are themselves considered to be partial by the\n"
"totality checker), there is utility function `assert_smaller`, which\n"
"we can use to convince the totality checker and still annotate our\n"
"functions with the `total` keyword:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:521
#, no-wrap
msgid ""
"replicatePrim' : Bits32 -> a -> List a\n"
"replicatePrim' 0 v = []\n"
"replicatePrim' x v = v :: replicatePrim' (assert_smaller x $ x - 1) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:532
#, no-wrap
msgid ""
"Please note, though, that whenever you use `assert_smaller` to\n"
"silence the totality checker, the burden of proving totality rests\n"
"on your shoulders. Failing to do so can lead to arbitrary and\n"
"unpredictable program behavior (which is the default with most\n"
"other programming languages).\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Folds.md:533
#, no-wrap
msgid "Ex Falso Quodlibet"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:543
#, no-wrap
msgid ""
"Below - as a demonstration - is a simple proof of `Void`.\n"
"`Void` is an *uninhabited type*: a type with no values.\n"
"*Proofing `Void`* means, that we implement a function accepted\n"
"by the totality checker, which returns a value of type `Void`,\n"
"although this is supposed to be impossible as there is no\n"
"such value. Doing so allows us to completely\n"
"disable the type system together with all the guarantees it provides.\n"
"Here's the code and its dire consequences:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:544
#, no-wrap
msgid ""
"-- In order to proof `Void`, we just loop forever, using\n"
"-- `assert_smaller` to silence the totality checker.\n"
"proofOfVoid : Bits8 -> Void\n"
"proofOfVoid n = proofOfVoid (assert_smaller n n)\n"
"\n"
"-- From a value of type `Void`, anything follows!\n"
"-- This function is safe and total, as there is no\n"
"-- value of type `Void`!\n"
"exFalsoQuodlibet : Void -> a\n"
"exFalsoQuodlibet _ impossible\n"
"\n"
"-- By passing our proof of void to `exFalsoQuodlibet`\n"
"-- (exported by the *Prelude* by the name of `void`), we\n"
"-- can coerce any value to a value of any other type.\n"
"-- This renders type checking completely useless, as\n"
"-- we can freely convert between values of different\n"
"-- types.\n"
"coerce : a -> b\n"
"coerce _ = exFalsoQuodlibet (proofOfVoid 0)\n"
"\n"
"-- Finally, we invoke `putStrLn` with a number instead\n"
"-- of a string. `coerce` allows us to do just that.\n"
"pain : IO ()\n"
"pain = putStrLn $ coerce 0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:576
#, no-wrap
msgid ""
"Please take a moment to marvel at provably total function `coerce`:\n"
"It claims to convert *any* value to a value of *any* other type.\n"
"And it is completely safe, as it only uses total functions in its\n"
"implementation. The problem is - of course - that `proofOfVoid` should\n"
"never ever have been a total function.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:581
#, no-wrap
msgid ""
"In `pain` we use `coerce` to conjure a string from an integer.\n"
"In the end, we get what we deserve: The program crashes with an error.\n"
"While things could have been much worse, it can still be quite\n"
"time consuming and annoying to localize the source of such an error.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:582
#, no-wrap
msgid ""
"$ idris2 --cg node --exec pain --find-ipkg src/Tutorial/Folds.md\n"
"ERROR: No clauses\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:590
#, no-wrap
msgid ""
"So, with a single thoughtless placement of `assert_smaller` we wrought\n"
"havoc within our pure and total codebase sacrificing totality and\n"
"type safety in one fell swoop. Therefore: Use at your own risk!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:594
#, no-wrap
msgid ""
"Note: I do not expect you to understand all the dark magic at\n"
"work in the code above. I'll explain the details in due time\n"
"in another chapter.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:602
#, no-wrap
msgid ""
"Second note: *Ex falso quodlibet*, also called\n"
"[the principle of "
"explosion](https://en.wikipedia.org/wiki/Principle_of_explosion)\n"
"is a law in classical logic: From a contradiction, any statement can be "
"proven.\n"
"In our case, the contradiction was our proof of `Void`: The claim that we "
"wrote\n"
"a total function producing such a value, although `Void` is an uninhabited "
"type.\n"
"You can verify this by inspecting `Void` at the REPL with `:doc Void`: It\n"
"has no data constructors.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:603
#, no-wrap
msgid "Case 2: Recursion via Function Calls"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:608
#, no-wrap
msgid ""
"Below is an implementation of a [*rose "
"tree*](https://en.wikipedia.org/wiki/Rose_tree).\n"
"Rose trees can represent search paths in computer algorithms,\n"
"for instance in graph theory.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:609
#, no-wrap
msgid ""
"record Tree a where\n"
"  constructor Node\n"
"  value  : a\n"
"  forest : List (Tree a)\n"
"\n"
"Forest : Type -> Type\n"
"Forest = List . Tree\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:620
#, no-wrap
msgid "We could try and compute the size of such a tree as follows:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:621
#, no-wrap
msgid ""
"covering\n"
"size : Tree a -> Nat\n"
"size (Node _ forest) = S . sum $ map size forest\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:632
#, no-wrap
msgid ""
"In the code above, the recursive call happens within `map`. *We* know that\n"
"we are using only subtrees in the recursive calls (since we know how `map`\n"
"is implemented for `List`), but Idris can't know this (teaching a totality\n"
"checker how to figure this out on its own seems to be an open research\n"
"question). So it will refuse to accept the function as being total.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:637
#, no-wrap
msgid ""
"There are two ways to handle the case above. If we don't mind writing\n"
"a bit of otherwise unneeded boilerplate code, we can use explicit "
"recursion.\n"
"In fact, since we often also work with search *forests*, this is\n"
"the preferable way here.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:638
#, no-wrap
msgid ""
"mutual\n"
"  treeSize : Tree a -> Nat\n"
"  treeSize (Node _ forest) = S $ forestSize forest\n"
"\n"
"  forestSize : Forest a -> Nat\n"
"  forestSize []        = 0\n"
"  forestSize (x :: xs) = treeSize x + forestSize xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:652
#, no-wrap
msgid ""
"In the case above, Idris can verify that we don't blow up our trees behind\n"
"its back as we are explicit about what happens in each recursive step.\n"
"This is the safe, preferable way of going about this, especially if you "
"are\n"
"new to the language and totality checking in general.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:655
#, no-wrap
msgid ""
"However, sometimes the solution presented above is just too cumbersome to\n"
"write. For instance, here is an implementation of `Show` for rose trees:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:656
#, no-wrap
msgid ""
"Show a => Show (Tree a) where\n"
"  showPrec p (Node v ts) =\n"
"    assert_total $ showCon p \"Node\" (showArg v ++ showArg ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:667
#, no-wrap
msgid ""
"In this case, we'd have to manually reimplement `Show` for lists of trees:\n"
"A tedious task - and error-prone on its own. Instead, we resort to using "
"the\n"
"mighty sledgehammer of totality checking: `assert_total`. Needless to say\n"
"that this comes with the same risks as `assert_smaller`, so be very\n"
"careful.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:673
#, no-wrap
msgid ""
"Implement the following functions in a provably total\n"
"way without \"cheating\". Note: It is not necessary to\n"
"implement these in a tail recursive way.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:682
#, no-wrap
msgid ""
"<!-- textlint-disable terminology -->\n"
"1. Implement function `depth` for rose trees. This\n"
"   should return the maximal number of `Node` constructors\n"
"   from the current node to the farthest child node.\n"
"   For instance, the current node should be at depth one,\n"
"   all its direct child nodes are at depth two, their\n"
"   immediate child nodes at depth three and so on.\n"
"<!-- textlint-enable -->\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:684
msgid "Implement interface `Eq` for rose trees."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:686
msgid "Implement interface `Functor` for rose trees."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:688
msgid "For the fun of it: Implement interface `Show` for rose trees."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:692
msgid ""
"In order not to forget how to program with dependent types, implement "
"function `treeToVect` for converting a rose tree to a vector of the correct "
"size."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:696
#, no-wrap
msgid ""
"   Hint: Make sure to follow the same recursion scheme as in\n"
"   the implementation of `treeSize`. Otherwise, this might be\n"
"   very hard to get to work.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Folds.md:697
#, no-wrap
msgid "Interface Foldable"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:707
#, no-wrap
msgid ""
"When looking back at all the exercises we solved\n"
"in the section about recursion, most tail recursive functions\n"
"on lists were of the following pattern: Iterate\n"
"over all list elements from head to tail while\n"
"passing along some state for accumulating intermediate\n"
"results. At the end of the list,\n"
"return the final state or convert it with an\n"
"additional function call.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:708
#, no-wrap
msgid "Left Folds"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:719
#, no-wrap
msgid ""
"This is functional programming, and we'd like to abstract\n"
"over such reoccurring patterns. In order to tail recursively\n"
"iterate over a list, all we need is an accumulator function\n"
"and some initial state. But what should be the type of\n"
"the accumulator? Well, it combines the current state\n"
"with the list's next element and returns an updated\n"
"state: `state -> elem -> state`. Surely, we can come\n"
"up with a higher-order function to encapsulate this\n"
"behavior:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:720
#, no-wrap
msgid ""
"leftFold : (acc : state -> el -> state) -> (st : state) -> List el -> "
"state\n"
"leftFold _   st []        = st\n"
"leftFold acc st (x :: xs) = leftFold acc (acc st x) xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:734
#, no-wrap
msgid ""
"We call this function a *left fold*, as it iterates over\n"
"the list from left to right (head to tail), collapsing (or\n"
"*folding*) the list until just a single value remains.\n"
"This new value might still be a list or other container type,\n"
"but the original list has been consumed from head to tail.\n"
"Note how `leftFold` is tail recursive, and therefore all\n"
"functions implemented in terms of `leftFold` are\n"
"tail recursive (and thus, stack safe!) as well.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:736
#, no-wrap
msgid "Here are a few examples:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:737
#, no-wrap
msgid ""
"sumLF : Num a => List a -> a\n"
"sumLF = leftFold (+) 0\n"
"\n"
"reverseLF : List a -> List a\n"
"reverseLF = leftFold (flip (::)) Nil\n"
"\n"
"-- this is more natural than `reverseLF`!\n"
"toSnocListLF : List a -> SnocList a\n"
"toSnocListLF = leftFold (:<) Lin\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:749
#, no-wrap
msgid "Right Folds"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:760
#, no-wrap
msgid ""
"The example functions we implemented in terms of `leftFold` had\n"
"to always completely traverse the whole list, as every single\n"
"element was required to compute the result. This is not always\n"
"necessary, however. For instance, if you look at `findList` from\n"
"the exercises, we could abort iterating over the list as soon\n"
"as our search was successful. It is *not* possible to implement\n"
"this more efficient behavior in terms of `leftFold`: There,\n"
"the result will only be returned when our pattern match reaches\n"
"the `Nil` case.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:765
#, no-wrap
msgid ""
"Interestingly, there is another, non-tail recursive fold, which\n"
"reflects the list structure more naturally, we can use for\n"
"breaking out early from an iteration. We call this a\n"
"*right fold*. Here is its implementation:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:766
#, no-wrap
msgid ""
"rightFold : (acc : el -> state -> state) -> state -> List el -> state\n"
"rightFold acc st []        = st\n"
"rightFold acc st (x :: xs) = acc x (rightFold acc st xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:775
#, no-wrap
msgid ""
"Now, it might not immediately be obvious how this differs from `leftFold`.\n"
"In order to see this, we will have to talk about lazy evaluation\n"
"first.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Folds.md:776
#, no-wrap
msgid "Lazy Evaluation in Idris"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:784
#, no-wrap
msgid ""
"For some computations, it is not necessary to evaluate all function\n"
"arguments in order to return a result. For instance, consider\n"
"boolean operator `(&&)`: If the first argument evaluates to `False`,\n"
"we already know that the result is `False` without even looking at\n"
"the second argument. In such a case, we don't want to unnecessarily "
"evaluate\n"
"the second argument, as this might include a lengthy computation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:786
#, no-wrap
msgid "Consider the following REPL session:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:787
#, no-wrap
msgid ""
"Tutorial.Folds> False && (length [1..10000000000] > 100)\n"
"False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:797
#, no-wrap
msgid ""
"If the second argument were evaluated, this computation would most\n"
"certainly blow up your computer's memory, or at least take a very long\n"
"time to run to completion. However, in this case, the result `False` is\n"
"printed immediately. If you look at the type of `(&&)`, you'll see\n"
"the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:798
#, no-wrap
msgid ""
"Tutorial.Folds> :t (&&)\n"
"Prelude.&& : Bool -> Lazy Bool -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:816
#, no-wrap
msgid ""
"As you can see, the second argument is wrapped in a `Lazy` type\n"
"constructor. This is a built-in type, and the details are handled\n"
"by Idris automatically most of the time. For instance, when passing\n"
"arguments to `(&&)`, we don't have to manually wrap the values in\n"
"some data constructor.\n"
"A lazy function argument will only be evaluated at the moment it\n"
"is *required* in the function's implementation, for instance,\n"
"because it is being pattern matched on, or it is being passed\n"
"as a strict argument to another function. In the implementation\n"
"of `(&&)`, the pattern match happens\n"
"on the first argument, so the second will only be evaluated if\n"
"the first argument is `True` and the second is returned as the function's\n"
"(strict) result.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:821
#, no-wrap
msgid ""
"There are two utility functions for working with lazy evaluation:\n"
"Function `delay` wraps a value in the `Lazy` data type. Note, that\n"
"the argument of `delay` is strict, so the following might take\n"
"several seconds to print its result:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:822
#, no-wrap
msgid ""
"Tutorial.Folds> False && (delay $ length [1..10000] > 100)\n"
"False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:829
#, no-wrap
msgid ""
"In addition, there is function `force`, which forces evaluation\n"
"of a `Lazy` value.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Folds.md:830
#, no-wrap
msgid "Lazy Evaluation and Right Folds"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:838
#, no-wrap
msgid ""
"We will now learn how to make use of `rightFold` and lazy evaluation\n"
"to implement folds, which can break out from iteration early.\n"
"Note, that in the implementation of `rightFold` the result of\n"
"folding over the remainder of the list is passed as an argument\n"
"to the accumulator (instead of the result of invoking the accumulator\n"
"being used in the recursive call):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:839
#, no-wrap
msgid "rightFold acc st (x :: xs) = acc x (rightFold acc st xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:846
#, no-wrap
msgid ""
"If the second argument of `acc` were lazily evaluated, it would be "
"possible\n"
"to abort the computation of `acc`'s result without having to iterate\n"
"till the end of the list:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:847
#, no-wrap
msgid ""
"foldHead : List a -> Maybe a\n"
"foldHead = force . rightFold first Nothing\n"
"  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)\n"
"        first v _ = Just v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:858
#, no-wrap
msgid ""
"Note, how Idris takes care of the bookkeeping of laziness most of the "
"time. (It\n"
"doesn't handle the curried invocation of `rightFold` correctly, though, so "
"we\n"
"either must pass on the list argument of `foldHead` explicitly, or compose\n"
"the curried function with `force` to get the types right.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:865
#, no-wrap
msgid ""
"In order to verify that this works correctly, we need a debugging utility\n"
"called `trace` from module `Debug.Trace`. This \"function\" allows us to\n"
"print debugging messages to the console at certain points in our pure\n"
"code. Please note, that this is for debugging purposes only and should\n"
"never be left lying around in production code, as, strictly speaking,\n"
"printing stuff to the console breaks referential transparency.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:868
#, no-wrap
msgid ""
"Here is an adjusted version of `foldHead`, which prints \"folded\" to\n"
"standard output every time utility function `first` is being invoked:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:869
#, no-wrap
msgid ""
"foldHeadTraced : List a -> Maybe a\n"
"foldHeadTraced = force . rightFold first Nothing\n"
"  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)\n"
"        first v _ = trace \"folded\" (Just v)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:879
#, no-wrap
msgid ""
"In order to test this at the REPL, we need to know that `trace` uses "
"`unsafePerformIO`\n"
"internally and therefore will not reduce during evaluation. We have to\n"
"resort to the `:exec` command to see this in action at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:880
#, no-wrap
msgid ""
"Tutorial.Folds> :exec printLn $ foldHeadTraced [1..10]\n"
"folded\n"
"Just 1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:888
#, no-wrap
msgid ""
"As you can see, although the list holds ten elements, `first` is only "
"called\n"
"once resulting in a considerable increase of efficiency.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:891
#, no-wrap
msgid ""
"Let's see what happens, if we change the implementation of `first` to\n"
"use strict evaluation:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:892
#, no-wrap
msgid ""
"foldHeadTracedStrict : List a -> Maybe a\n"
"foldHeadTracedStrict = rightFold first Nothing\n"
"  where first : a -> Maybe a -> Maybe a\n"
"        first v _ = trace \"folded\" (Just v)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:903
#, no-wrap
msgid ""
"Although we don't use the second argument in the implementation of "
"`first`,\n"
"it is still being evaluated before evaluating the body of `first`, because\n"
"Idris - unlike Haskell! - defaults to use strict semantics. Here's how "
"this\n"
"behaves at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:904
#, no-wrap
msgid ""
"Tutorial.Folds> :exec printLn $ foldHeadTracedStrict [1..10]\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"Just 1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:925
#, no-wrap
msgid ""
"While this technique can sometimes lead to very elegant code, always\n"
"remember that `rightFold` is not stack safe in the general case. So,\n"
"unless your accumulator is not guaranteed to return a result after\n"
"not too many iterations, consider implementing your function\n"
"tail recursively with an explicit pattern match. Your code will be\n"
"slightly more verbose, but with the guaranteed benefit of stack safety.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:926
#, no-wrap
msgid "Folds and Monoids"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:934
#, no-wrap
msgid ""
"Left and right folds share a common pattern: In both cases, we start\n"
"with an initial *state* value and use an accumulator function for\n"
"combining the current state with the current element. This principle\n"
"of *combining values* after starting from an *initial value* lies\n"
"at the heart of an interface we've already learned about: `Monoid`.\n"
"It therefore makes sense to fold a list over a monoid:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:935
#, no-wrap
msgid ""
"foldMapList : Monoid m => (a -> m) -> List a -> m\n"
"foldMapList f = leftFold (\\vm,va => vm <+> f va) neutral\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:946
#, no-wrap
msgid ""
"Note how, with `foldMapList`, we no longer need to pass an accumulator\n"
"function. All we need is a conversion from the element type to\n"
"a type with an implementation of `Monoid`. As we have already seen\n"
"in the chapter about [interfaces](Interfaces.md), there are *many*\n"
"monoids in functional programming, and therefore, `foldMapList` is\n"
"an incredibly useful function.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:950
#, no-wrap
msgid ""
"We could make this even shorter: If the elements in our list already\n"
"are of a type with a monoid implementation, we don't even need a\n"
"conversion function to collapse the list:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:951
#, no-wrap
msgid ""
"concatList : Monoid m => List m -> m\n"
"concatList = foldMapList id\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:956
#, no-wrap
msgid "Stop Using `List` for Everything"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:971
#, no-wrap
msgid ""
"And here we are, finally, looking at a large pile of utility functions\n"
"all dealing in some way with the concept of collapsing (or folding)\n"
"a list of values into a single result. But all of these folding functions\n"
"are just as useful when working with vectors, with non-empty lists, with\n"
"rose trees, even with single-value containers like `Maybe`, `Either e`,\n"
"or `Identity`. Heck, for the sake of completeness, they are even useful\n"
"when working with zero-value containers like `Control.Applicative.Const "
"e`!\n"
"And since there are so many of these functions, we'd better look out for\n"
"an essential set of them in terms of which we can implement all\n"
"the others, and wrap up the whole bunch in an interface. This interface\n"
"is called `Foldable`, and is available from the `Prelude`. When you\n"
"look at its definition in the REPL (`:doc Foldable`), you'll see that\n"
"it consists of six essential functions:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`foldr`, for folds from the right"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`foldl`, for folds from the left"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`null`, for testing if the container is empty or not"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`foldlM`, for effectful folds in a monad"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`toList`, for converting the container to a list of values"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`foldMap`, for folding over a monoid"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:987
#, no-wrap
msgid ""
"For a minimal implementation of `Foldable`, it is sufficient to only\n"
"implement `foldr`. However, consider implementing all six functions\n"
"manually, because folds over container types are often performance\n"
"critical operations, and each of them should be optimized accordingly.\n"
"For instance, implementing `toList` in terms of `foldr` for `List`\n"
"just makes no sense, as this is a non-tail recursive function\n"
"running in linear time complexity, while a hand-written implementation\n"
"can just return its argument without any modifications.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:993
#, no-wrap
msgid ""
"In these exercises, you are going to implement `Foldable`\n"
"for different data types. Make sure to try and manually\n"
"implement all six functions of the interface.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Folds.md:995
msgid "Implement `Foldable` for `Crud i`:"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:1005
msgid "Implement `Foldable` for `Response e i`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1006 ../src/Tutorial/Functor.md:429 ../src/Tutorial/Traverse.md:295
#, no-wrap
msgid ""
"   data Response : (e, i, a : Type) -> Type where\n"
"     Created : (id : i) -> (value : a) -> Response e i a\n"
"     Updated : (id : i) -> (value : a) -> Response e i a\n"
"     Found   : (values : List a) -> Response e i a\n"
"     Deleted : (id : i) -> Response e i a\n"
"     Error   : (err : e) -> Response e i a\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:1018
msgid ""
"Implement `Foldable` for `List01`. Use tail recursion in the implementations "
"of `toList`, `foldMap`, and `foldl`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/IO.md:753 ../src/Tutorial/Traverse.md:267
#, no-wrap
msgid ""
"   data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"     Nil  : List01 False a\n"
"     (::) : a -> List01 False a -> List01 ne a\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:1030
msgid ""
"Implement `Foldable` for `Tree`. There is no need to use tail recursion in "
"your implementations, but your functions must be accepted by the totality "
"checker, and you are not allowed to cheat by using `assert_smaller` or "
"`assert_total`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1034
#, no-wrap
msgid ""
"   Hint: You can test the correct behavior of your implementations\n"
"   by running the same folds on the result of `treeToVect` and\n"
"   verify that the outcome is the same.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:1039
msgid ""
"Like `Functor` and `Applicative`, `Foldable` composes: The product and "
"composition of two foldable container types are again foldable container "
"types. Proof this by implementing `Foldable` for `Comp` and `Product`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1040 ../src/Tutorial/Traverse.md:308
#, no-wrap
msgid ""
"   record Comp (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkComp\n"
"     unComp  : f (g a)\n"
"\n"
"   record Product (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkProduct\n"
"     fst : f a\n"
"     snd : g a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1058
#, no-wrap
msgid ""
"We learned a lot about recursion, totality checking, and folds\n"
"in this chapter, all of which are important concepts in pure\n"
"functional programming in general. Wrapping one's head\n"
"around recursion takes time and experience. Therefore - as\n"
"usual - try to solve as many exercises as you can.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1062
#, no-wrap
msgid ""
"In the next chapter, we are taking the concept of iterating\n"
"over container types one step further and look at\n"
"effectful data traversals.\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Functions1.md:1
#, no-wrap
msgid "Functions Part 1"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:12
#, no-wrap
msgid ""
"Idris is a *functional* programming language. This means,\n"
"that functions are its main form of abstraction (unlike for\n"
"instance in an object oriented language like Java, where\n"
"*objects* and *classes* are the main form of abstraction). It also\n"
"means that we expect Idris to make it very easy for\n"
"us to compose and combine functions to create new\n"
"functions. In fact, in Idris functions are *first class*:\n"
"Functions can take other functions as arguments and\n"
"can return functions as their results.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:16
#, no-wrap
msgid ""
"We already learned about the basic shape of top level\n"
"function declarations in Idris in the [introduction](Intro.md),\n"
"so we will continue from what we learned there.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:17
#, no-wrap
msgid "module Tutorial.Functions1\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:21
#, no-wrap
msgid "Functions with more than one Argument"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:28
#, no-wrap
msgid ""
"Let's implement a function, which checks if its three\n"
"`Integer` arguments form a\n"
"[Pythagorean triple](https://en.wikipedia.org/wiki/Pythagorean_triple).\n"
"We get to use a new operator for this: `==`, the equality\n"
"operator.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:29
#, no-wrap
msgid ""
"isTriple : Integer -> Integer -> Integer -> Bool\n"
"isTriple x y z = x * x + y * y == z * z\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:36
#, no-wrap
msgid ""
"Let's give this a spin at the REPL before we talk a bit\n"
"about the types:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:37
#, no-wrap
msgid ""
"Tutorial.Functions1> isTriple 1 2 3\n"
"False\n"
"Tutorial.Functions1> isTriple 3 4 5\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:49
#, no-wrap
msgid ""
"As can be seen from this example, the type of a function\n"
"of several arguments consists just of a sequence\n"
"of argument types (also called *input types*)\n"
"chained by function arrows (`->`), which\n"
"is terminated by an output type (`Bool` in this case).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:61
#, no-wrap
msgid ""
"The implementation looks a bit like a mathematical equation:\n"
"We list the arguments on the left hand side of `=` and describe the\n"
"computation(s) to perform with them on the right hand\n"
"side. Function implementations in functional programming\n"
"languages often have this more mathematical look compared\n"
"to implementations in imperative  languages, which often\n"
"describe not *what* to compute, but *how* to\n"
"compute it by describing an algorithm as a sequence of\n"
"imperative statements. We will later see that this\n"
"imperative style is also available in Idris, but whenever\n"
"possible we prefer the declarative style.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:68
#, no-wrap
msgid ""
"As can be seen in the REPL example, functions can be invoked\n"
"by passing the arguments separated by whitespace. No parentheses\n"
"are necessary unless one of the expressions we pass as the\n"
"function's arguments contains itself additional whitespace.\n"
"This comes in very handy when we apply functions\n"
"only partially (see later in this chapter).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:74
#, no-wrap
msgid ""
"Note that, unlike `Integer` or `Bits8`, `Bool` is not a primitive\n"
"data type built into the Idris language but just a custom\n"
"data type that you could have written yourself. We will\n"
"learn more about declaring new data types in the\n"
"next chapter.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:75
#, no-wrap
msgid "Function Composition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:79
#, no-wrap
msgid ""
"Functions can be combined in several ways, the most direct\n"
"probably being the dot operator:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:80
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
"\n"
"times2 : Integer -> Integer\n"
"times2 n = 2 * n\n"
"\n"
"squareTimes2 : Integer -> Integer\n"
"squareTimes2 = times2 . square\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:92
#, no-wrap
msgid "Give this a try at the REPL! Does it do what you'd expect?\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:95
#, no-wrap
msgid ""
"We could have implemented `squareTimes2` without using\n"
"the dot operator as follows:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:96
#, no-wrap
msgid ""
"squareTimes2' : Integer -> Integer\n"
"squareTimes2' n = times2 (square n)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:105
#, no-wrap
msgid ""
"It is important to note, that functions chained by the dot\n"
"operator are invoked from right to left: `times2 . square`\n"
"is the same as `\\n => times2 (square n)` and not\n"
"`\\n => square (times2 n)`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:108
#, no-wrap
msgid ""
"We can conveniently chain several functions using the\n"
"dot operator to write more complex functions:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:109
#, no-wrap
msgid ""
"dotChain : Integer -> String\n"
"dotChain = reverse . show . square . square . times2 . times2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:119
#, no-wrap
msgid ""
"This will first multiply the argument by four, then square\n"
"it twice before converting it to a string (`show`) and\n"
"reversing the resulting `String` (functions `show` and\n"
"`reverse` are part of the Idris *Prelude* and as such are\n"
"available in every Idris program).\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:120
#, no-wrap
msgid "Higher-order Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:126
#, no-wrap
msgid ""
"Functions can take other functions as arguments. This is\n"
"an incredibly powerful concept and we can go crazy with\n"
"this very easily. But for sanity's sake, we'll start\n"
"slowly:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:127
#, no-wrap
msgid ""
"isEven : Integer -> Bool\n"
"isEven n = mod n 2 == 0\n"
"\n"
"testSquare : (Integer -> Bool) -> Integer -> Bool\n"
"testSquare fun n = fun (square n)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:142
#, no-wrap
msgid ""
"First `isEven` uses the `mod` function to check, whether\n"
"an integer is divisible by two. But the interesting function\n"
"is `testSquare`. It takes two arguments: The first argument\n"
"is of type *function from `Integer` to `Bool`*, and the second\n"
"of type `Integer`. This second argument is squared before\n"
"being passed to the first argument. Again, give this a go\n"
"at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:143
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare isEven 12\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:154
#, no-wrap
msgid ""
"Take your time to understand what's going on here. We pass\n"
"function `isEven` as an argument to `testSquare`. The\n"
"second argument is an integer, which will first be squared\n"
"and then passed to `isEven`. While this is not very interesting,\n"
"we will see lots of use cases for passing functions as\n"
"arguments to other functions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:157
#, no-wrap
msgid ""
"I said above, we could go crazy pretty easily.\n"
"Consider for instance the following example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:158
#, no-wrap
msgid ""
"twice : (Integer -> Integer) -> Integer -> Integer\n"
"twice f n = f (f n)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:164 ../src/Tutorial/Functions1.md:227 ../src/Tutorial/Interfaces.md:504 ../src/Tutorial/Predicates.md:461 ../src/Tutorial/Prim.md:646
#, no-wrap
msgid "And at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:165
#, no-wrap
msgid ""
"Tutorial.Functions1> twice square 2\n"
"16\n"
"Tutorial.Functions1> (twice . twice) square 2\n"
"65536\n"
"Tutorial.Functions1> (twice . twice . twice . twice) square 2\n"
"*** huge number ***\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:177
#, no-wrap
msgid ""
"You might be surprised about this behavior, so we'll try\n"
"and break it down. The following two expressions are identical\n"
"in their behavior:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:178
#, no-wrap
msgid ""
"expr1 : Integer -> Integer\n"
"expr1 = (twice . twice . twice . twice) square\n"
"\n"
"expr2 : Integer -> Integer\n"
"expr2 = twice (twice (twice (twice square)))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:194
#, no-wrap
msgid ""
"So, `square` raises its argument to the 2nd power,\n"
"`twice square` raises it to its 4th power (by invoking\n"
"`square` twice in succession),\n"
"`twice (twice square)` raises it to its 16th power\n"
"(by invoking `twice square` twice in succession),\n"
"and so on, until `twice (twice (twice (twice square)))`\n"
"raises it to its 65536th power resulting in an impressively\n"
"huge result.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:195
#, no-wrap
msgid "Currying"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:201
#, no-wrap
msgid ""
"Once we start using higher-order functions, the concept\n"
"of partial function application (also called *currying*\n"
"after mathematician and logician Haskell Curry) becomes\n"
"very important.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:203
#, no-wrap
msgid "Load this file in a REPL session and try the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:204
#, no-wrap
msgid ""
"Tutorial.Functions1> :t testSquare isEven\n"
"testSquare isEven : Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1\n"
"isTriple 1 : Integer -> Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1 2\n"
"isTriple 1 2 : Integer -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:220
#, no-wrap
msgid ""
"Note, how in Idris we can partially apply a function\n"
"with more than one argument and as a result get a new function\n"
"back. For instance, `isTriple 1` applies argument `1` to function\n"
"`isTriple` and as a result returns a new function of\n"
"type `Integer -> Integer -> Bool`. We can even\n"
"use the result of such a partially applied function in\n"
"a new top level definition:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:221
#, no-wrap
msgid ""
"partialExample : Integer -> Bool\n"
"partialExample = isTriple 3 4\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:228
#, no-wrap
msgid ""
"Tutorial.Functions1> partialExample 5\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:236
#, no-wrap
msgid ""
"We already used partial function application in our `twice`\n"
"examples above to get some impressive results with very\n"
"little code.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:237
#, no-wrap
msgid "Anonymous Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:245
#, no-wrap
msgid ""
"Sometimes we'd like to pass a small custom function to\n"
"a higher-order function without bothering to write a\n"
"top level definition. For instance, in the following example,\n"
"function `someTest` is very specific and probably not\n"
"very useful in general, but we'd still like to pass it\n"
"to higher-order function `testSquare`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:246
#, no-wrap
msgid ""
"someTest : Integer -> Bool\n"
"someTest n = n >= 3 || n <= 10\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:252
#, no-wrap
msgid "Here's, how to pass it to `testSquare`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:253
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare someTest 100\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:260
#, no-wrap
msgid ""
"Instead of defining and using `someTest`, we can use an\n"
"anonymous function:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:261
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (\\n => n >= 3 || n <= 10) 100\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:277
#, no-wrap
msgid ""
"Anonymous functions are sometimes also called *lambdas* (from\n"
"[lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus)),\n"
"and the backslash is chosen since it resembles the Greek\n"
"letter *lambda*. The `\\n =>` syntax introduces a new anonymous\n"
"function of one argument called `n`, the implementation of\n"
"which is on the right hand side of the function arrow.\n"
"Like other top level functions, lambdas can have more\n"
"than one arguments, separated by commas: `\\x,y => x * x + y`.\n"
"When we pass lambdas as arguments to higher-order functions,\n"
"they typically need to be wrapped in parentheses or separated\n"
"by the dollar operator `($)` (see the next section about this).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:280
#, no-wrap
msgid ""
"Note that, in a lambda, arguments are not annotated with types,\n"
"so Idris has to be able to infer them from the current context.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:281
#, no-wrap
msgid "Operators"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:288
#, no-wrap
msgid ""
"In Idris, infix operators like `.`, `*` or `+` are not built into\n"
"the language, but are just regular Idris function with\n"
"some special support for using them in infix notation.\n"
"When we don't use operators in infix notation, we have\n"
"to wrap them in parentheses.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:291
#, no-wrap
msgid ""
"As an example, let us define a custom operator for sequencing\n"
"functions of type `Bits8 -> Bits8`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:292
#, no-wrap
msgid ""
"infixr 4 >>>\n"
"\n"
"(>>>) : (Bits8 -> Bits8) -> (Bits8 -> Bits8) -> Bits8 -> Bits8\n"
"f1 >>> f2 = f2 . f1\n"
"\n"
"foo : Bits8 -> Bits8\n"
"foo n = 2 * n + 3\n"
"\n"
"test : Bits8 -> Bits8\n"
"test = foo >>> foo >>> foo >>> foo\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:311
#, no-wrap
msgid ""
"In addition to declaring and defining the operator\n"
"itself, we also have to specify its fixity: `infixr 4 >>>` means,\n"
"that `(>>>)` associates to the right (meaning, that\n"
"`f >>> g >>> h` is to be interpreted as `f >>> (g >>> h)`)\n"
"with a priority of `4`. You can also have a look at the fixity\n"
"of operators exported by the *Prelude* in the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:312
#, no-wrap
msgid ""
"Tutorial.Functions1> :doc (.)\n"
"Prelude.. : (b -> c) -> (a -> b) -> a -> c\n"
"  Function composition.\n"
"  Totality: total\n"
"  Fixity Declaration: infixr operator, level 9\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:325
#, no-wrap
msgid ""
"When you mix infix operators in an expression, those with\n"
"a higher priority bind more tightly. For instance, `(+)`\n"
"is left associated with a priority of 8, while `(*)`\n"
"is left associated with a priority of 9. Hence,\n"
"`a * b + c` is the same as `(a * b) + c` instead of `a * (b + c)`.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions1.md:326
#, no-wrap
msgid "Operator Sections"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:332
#, no-wrap
msgid ""
"Operators can be partially applied just like regular\n"
"functions. In this case, the whole expression has to\n"
"be wrapped in parentheses and is called an *operator\n"
"section*. Here are two examples:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:333
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (< 10) 5\n"
"False\n"
"Tutorial.Functions1> testSquare (10 <) 5\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:344
#, no-wrap
msgid ""
"As you can see, there is a difference between `(< 10)`\n"
"and `(10 <)`. The first tests, whether its argument is\n"
"less than 10, the second, whether 10 is less than its\n"
"argument.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:348
#, no-wrap
msgid ""
"One exception where operator sections will not work is\n"
"with the *minus* operator `(-)`. Here is an example to\n"
"demonstrate this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:349
#, no-wrap
msgid ""
"applyToTen : (Integer -> Integer) -> Integer\n"
"applyToTen f = f 10\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:357
#, no-wrap
msgid ""
"This is just a higher-order function applying the number ten\n"
"to its function argument. This works very well in the following\n"
"example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:358
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToThen (* 2)\n"
"20\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:365
#, no-wrap
msgid ""
"However, if we want to subtract five from ten, the following\n"
"will fail:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:366
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (- 5)\n"
"Error: Can't find an implementation for Num (Integer -> Integer).\n"
"\n"
"(Interactive):1:12--1:17\n"
" 1 | applyToTen (- 5)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:377
#, no-wrap
msgid ""
"The problem here is, that Idris treats `- 5` as an integer literal\n"
"instead of an operator section. In this special case, we therefore\n"
"have to use an anonymous function instead:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:378
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (\\x => x - 5)\n"
"5\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions1.md:383
#, no-wrap
msgid "Infix Notation for Non-Operators"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:390
#, no-wrap
msgid ""
"In Idris, it is possible to use infix notation for\n"
"regular binary functions, by wrapping them in backticks.\n"
"It is even possible to define a precedence (fixity) for\n"
"these and use them in operator sections, just like regular\n"
"operators:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:391
#, no-wrap
msgid ""
"infixl 8 `plus`\n"
"\n"
"infixl 9 `mult`\n"
"\n"
"plus : Integer -> Integer -> Integer\n"
"plus = (+)\n"
"\n"
"mult : Integer -> Integer -> Integer\n"
"mult = (*)\n"
"\n"
"arithTest : Integer\n"
"arithTest = 5 `plus` 10 `mult` 12\n"
"\n"
"arithTest' : Integer\n"
"arithTest' = 5 + 10 * 12\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions1.md:409
#, no-wrap
msgid "Operators exported by the *Prelude*"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:419
#, no-wrap
msgid ""
"Here is a list of important operators exported by the *Prelude*.\n"
"Most of these are *constrained*, that is they work only\n"
"for types implementing a certain *interface*. Don't worry\n"
"about this right now. We will learn about interfaces in due\n"
"time, and the operators behave as they intuitively should.\n"
"For instance, addition and multiplication work for all\n"
"numeric types, comparison operators work for almost all\n"
"types in the *Prelude* with the exception of functions.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(.)`: Function composition"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(+)`: Addition"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(*)`: Multiplication"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(-)`: Subtraction"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(/)`: Division"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(==)` : True, if two values are equal"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(/=)` : True, if two values are not equal"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(<=)`, `(>=)`, `(<)`, and `(>)` : Comparison operators"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`($)`: Function application"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:440
#, no-wrap
msgid ""
"The most special of the above is the last one. It has a\n"
"priority of 0, so all other operators bind more tightly.\n"
"In addition, function application binds more tightly, so\n"
"this can be used to reduce the number of parentheses\n"
"required. For instance, instead of writing\n"
"`isTriple 3 4 (2 + 3 * 1)` we can write\n"
"`isTriple 3 4 $ 2 + 3 * 1`,\n"
"which is exactly the same. Sometimes, this helps readability,\n"
"sometimes, it doesn't. The important thing to remember is\n"
"that `fun $ x y` is just the same as `fun (x y)`.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions1.md:441 ../src/Tutorial/Functions2.md:339
#, no-wrap
msgid "Exercises"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions1.md:450
msgid ""
"Reimplement functions `testSquare` and `twice` by using the dot operator and "
"dropping the second arguments (have a look at the implementation of "
"`squareTimes2` to get an idea where this should lead you). This highly "
"concise way of writing function implementations is sometimes called "
"*point-free style* and is often the preferred way of writing small utility "
"functions."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions1.md:453
msgid ""
"Declare and implement function `isOdd` by combining functions `isEven` from "
"above and `not` (from the Idris *Prelude*). Use point-free style."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions1.md:456
msgid ""
"Declare and implement function `isSquareOf`, which checks whether its first "
"`Integer` argument is the square of the second argument."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions1.md:460
msgid ""
"Declare and implement function `isSmall`, which checks whether its `Integer` "
"argument is less than or equal to 100. Use one of the comparison operators "
"`<=` or `>=` in your implementation."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions1.md:465
msgid ""
"Declare and implement function `absIsSmall`, which checks whether the "
"absolute value of its `Integer` argument is less than or equal to 100.  Use "
"functions `isSmall` and `abs` (from the Idris *Prelude*) in your "
"implementation, which should be in point-free style."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Functions1.md:471
msgid ""
"In this slightly extended exercise we are going to implement some utilities "
"for working with `Integer` predicates (functions from `Integer` to "
"`Bool`). Implement the following higher-order functions (use boolean "
"operators `&&`, `||`, and function `not` in your implementations):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:472
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   and : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   or : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   negate : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:487
#, no-wrap
msgid ""
"   After solving this exercise, give it a go in the REPL. In the\n"
"   example below, we use binary function `and` in infix notation\n"
"   by wrapping it in backticks. This is just a syntactic convenience\n"
"   to make certain function applications more readable:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:488
#, no-wrap
msgid ""
"   Tutorial.Functions1> negate (isSmall `and` isOdd) 73\n"
"   False\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Functions1.md:500
msgid ""
"As explained above, Idris allows us to define our own infix operators.  Even "
"better, Idris supports *overloading* of function names, that is, two "
"functions or operators can have the same name, but different types and "
"implementations.  Idris will make use of the types to distinguish between "
"equally named operators and functions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:504
#, no-wrap
msgid ""
"   This allows us, to reimplement functions `and`, `or`, and `negate`\n"
"   from Exercise 6 by using the existing operator and function\n"
"   names from boolean algebra:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:505
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   (&&) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"   x && y = and x y\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   (||) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   not : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:518
#, no-wrap
msgid "   Implement the other two functions and test them at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:519
#, no-wrap
msgid ""
"   Tutorial.Functions1> not (isSmall && isOdd) 73\n"
"   False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:527
#, no-wrap
msgid "What we learned in this chapter:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:530
#, no-wrap
msgid ""
"* A function in Idris can take an arbitrary number of arguments,\n"
"separated by `->` in the function's type.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:534
#, no-wrap
msgid ""
"* Functions can be combined\n"
"sequentially using the dot operator, which leads to highly\n"
"concise code.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:539
#, no-wrap
msgid ""
"* Functions can be partially applied by passing them fewer\n"
"arguments than they expect. The result is a new function\n"
"expecting the remaining arguments. This technique is called\n"
"*currying*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:543
#, no-wrap
msgid ""
"* Functions can be passed as arguments to other functions, which\n"
"allows us to easily combine small coding units to create\n"
"more complex behavior.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:547
#, no-wrap
msgid ""
"* We can pass anonymous functions (*lambdas*) to higher-order\n"
"functions, if writing a corresponding top level\n"
"function would be too cumbersome.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:551
#, no-wrap
msgid ""
"* Idris allows us to define our own infix operators. These\n"
"have to be written in parentheses unless they are being used\n"
"in infix notation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:556
#, no-wrap
msgid ""
"* Infix operators can also be partially applied. These *operator sections*\n"
"have to be wrapped in parentheses, and the position of the\n"
"argument determines, whether it is used as the operator's first\n"
"or second argument.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:560
#, no-wrap
msgid ""
"* Idris supports name overloading: Functions can have the same\n"
"names but different implementations. Idris will decide, which function\n"
"to used based to the types involved.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:567
#, no-wrap
msgid ""
"Please note, that function and operator names in a module\n"
"must be unique. In order to define two functions with the same\n"
"name, they have to be declared in distinct modules. If Idris\n"
"is not able to decide, which of the two functions to use, we\n"
"can help name resolution by prefixing a function with\n"
"(a part of) its *namespace*:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:568
#, no-wrap
msgid ""
"Tutorial.Functions1> :t Prelude.not\n"
"Prelude.not : Bool -> Bool\n"
"Tutorial.Functions1> :t Functions1.not\n"
"Tutorial.Functions1.not : (Integer -> Bool) -> (Integer -> Bool) -> Integer "
"-> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:581
#, no-wrap
msgid ""
"In the [next section](DataTypes.md), we will learn how to define\n"
"our own data types and how to construct and deconstruct\n"
"values of these new types. We will also learn about\n"
"generic types and functions.\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Functions2.md:1
#, no-wrap
msgid "Functions Part 2"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:9
#, no-wrap
msgid ""
"So far, we learned about the core features of the Idris\n"
"language, which it has in common with several other\n"
"pure, strongly typed programming languages like Haskell:\n"
"(Higher order) Functions, algebraic data types, pattern matching,\n"
"parametric polymorphism (generic types and functions), and\n"
"ad hoc polymorphism (interfaces and constrained functions).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:15
#, no-wrap
msgid ""
"In this chapter, we start to dissect Idris functions and their types\n"
"for real. We learn about implicit arguments, named arguments, as well\n"
"as erasure and quantities. But first, we'll look at `let` bindings\n"
"and `where` blocks, which help us implement functions too complex\n"
"to fit on a single line of code. Let's get started!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:16
#, no-wrap
msgid ""
"module Tutorial.Functions2\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions2.md:22
#, no-wrap
msgid "Let Bindings and Local Definitions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:31
#, no-wrap
msgid ""
"The functions we looked at so far were simple enough\n"
"to be implemented directly via pattern matching\n"
"without the need of additional auxiliary functions or\n"
"variables. This is not always the case, and there are two\n"
"important language constructs for introducing and reusing\n"
"new local variables and functions. We'll look at these\n"
"in two case studies.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:32
#, no-wrap
msgid "Use Case 1: Arithmetic Mean and Standard Deviation"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:37
#, no-wrap
msgid ""
"In this example, we'd like to calculate the arithmetic\n"
"mean and the standard deviation of a list of floating point values.\n"
"There are several things we need to consider.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:41
#, no-wrap
msgid ""
"First, we need a function for calculating the sum of\n"
"a list of numeric values. The *Prelude* exports function\n"
"`sum` for this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:42
#, no-wrap
msgid ""
"Main> :t sum\n"
"Prelude.sum : Num a => Foldable t => t a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:51
#, no-wrap
msgid ""
"This is - of course - similar to `sumList` from Exercise 10\n"
"of the [last section](Interfaces.md), but generalized to all\n"
"container types with a `Foldable` implementation. We will\n"
"learn about interface `Foldable` in a later section.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:62
#, no-wrap
msgid ""
"In order to also calculate the variance,\n"
"we need to convert every value in the list to\n"
"a new value, as we have to subtract the mean\n"
"from every value in the list and square the\n"
"result. In the previous section's exercises, we\n"
"defined function `mapList` for this. The *Prelude* - of course -\n"
"already exports a similar function called `map`,\n"
"which is again more general\n"
"and works also like our `mapMaybe` for `Maybe`\n"
"and `mapEither` for `Either e`. Here's its type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:63
#, no-wrap
msgid ""
"Main> :t map\n"
"Prelude.map : Functor f => (a -> b) -> f a -> f b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:70
#, no-wrap
msgid ""
"Interface `Functor` is another one we'll talk about\n"
"in a later section.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:73
#, no-wrap
msgid ""
"Finally, we need a way to calculate the length of\n"
"a list of values. We use function `length` for this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:74
#, no-wrap
msgid ""
"Main> :t List.length\n"
"Prelude.List.length : List a -> Nat\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:87
#, no-wrap
msgid ""
"Here, `Nat` is the type of natural numbers\n"
"(unbounded, unsigned integers). `Nat` is actually not a primitive data\n"
"type but a sum type defined in the *Prelude* with\n"
"data constructors `Z : Nat` (for zero)\n"
"and `S : Nat -> Nat` (for successor). It might seem highly inefficient\n"
"to define natural numbers this way, but the Idris compiler\n"
"treats these and several other *number-like* types specially, and\n"
"replaces them with primitive integers during code generation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:93
#, no-wrap
msgid ""
"We are now ready to give the implementation of `mean` a go.\n"
"Since this is Idris, and we care about clear semantics, we will\n"
"quickly define a custom record type instead of just returning\n"
"a tuple of `Double`s. This makes it clearer, which floating\n"
"point number corresponds to which statistic entity:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:94
#, no-wrap
msgid ""
"square : Double -> Double\n"
"square n = n * n\n"
"\n"
"record Stats where\n"
"  constructor MkStats\n"
"  mean      : Double\n"
"  variance  : Double\n"
"  deviation : Double\n"
"\n"
"stats : List Double -> Stats\n"
"stats xs =\n"
"  let len      := cast (length xs)\n"
"      mean     := sum xs / len\n"
"      variance := sum (map (\\x => square (x - mean)) xs) / len\n"
"   in MkStats mean variance (sqrt variance)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:113
#, no-wrap
msgid "As usual, we first try this at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:114
#, no-wrap
msgid ""
"Tutorial.Functions2> stats [2,4,4,4,5,5,7,9]\n"
"MkStats 5.0 4.0 2.0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:133
#, no-wrap
msgid ""
"Seems to work, so let's digest this step by step.\n"
"We introduce several new local variables\n"
"(`len`, `mean`, and `variance`),\n"
"which all will be used more than once in the remainder\n"
"of the implementation. To do so, we use a `let` binding. This\n"
"consists of the `let` keyword, followed by one or more\n"
"variable assignments, followed by the final expression,\n"
"which has to be prefixed by `in`. Note, that whitespace\n"
"is significant again: We need to properly align the three\n"
"variable names. Go ahead, and try out what happens if\n"
"you remove a space in front of `mean` or `variance`.\n"
"Note also, that the alignment of assignment operators\n"
"`:=` is optional. I do this, since I thinks it helps\n"
"readability.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:149
#, no-wrap
msgid ""
"Let's also quickly look at the different variables\n"
"and their types. `len` is the length of the list\n"
"cast to a `Double`, since this is what's needed\n"
"later on, where we divide other values of type `Double`\n"
"by the length. Idris is very strict about this: We are\n"
"not allowed to mix up numeric types without explicit\n"
"casts. Please note, that in this case Idris is able\n"
"to *infer* the type of `len` from the surrounding\n"
"context. `mean` is straight forward: We `sum` up the\n"
"values stored in the list and divide by the list's\n"
"length. `variance` is the most involved of the\n"
"three: We map each item in the list to a new value\n"
"using an anonymous function to subtract the mean\n"
"and square the result. We then sum up the new terms\n"
"and divide again by the number of values.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:150
#, no-wrap
msgid "Use Case 2: Simulating a Simple Web Server"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:156
#, no-wrap
msgid ""
"In the second use case, we are going to write a slightly\n"
"larger application. This should give you an idea about how to\n"
"design data types and functions around some business\n"
"logic you'd like to implement.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:161
#, no-wrap
msgid ""
"Assume we run a music streaming web server, where users\n"
"can buy whole albums and listen to them online. We'd\n"
"like to simulate a user connecting to the server and\n"
"getting access to one of the albums they bought.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:163
#, no-wrap
msgid "We first define a bunch of record types:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:164
#, no-wrap
msgid ""
"record Artist where\n"
"  constructor MkArtist\n"
"  name : String\n"
"\n"
"record Album where\n"
"  constructor MkAlbum\n"
"  name   : String\n"
"  artist : Artist\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : String\n"
"  email    : Email\n"
"  password : Password\n"
"  albums   : List Album\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:202
#, no-wrap
msgid ""
"Most of these should be self-explanatory. Note, however, that\n"
"in several cases (`Email`, `Artist`, `Password`) we wrap a\n"
"single value in a new record type. Of course, we *could* have\n"
"used the unwrapped `String` type instead, but we'd have ended\n"
"up with many `String` fields, which can be hard to disambiguate.\n"
"In order not to confuse an email string with a password string,\n"
"it can therefore be helpful to wrap both of them in a new\n"
"record type to drastically increase type safety at the cost\n"
"of having to reimplement some interfaces.\n"
"Utility function `on` from the *Prelude* is very useful for this. Don't\n"
"forget to inspect its type at the REPL, and try to understand what's\n"
"going on here.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:203
#, no-wrap
msgid ""
"Eq Artist where (==) = (==) `on` name\n"
"\n"
"Eq Email where (==) = (==) `on` value\n"
"\n"
"Eq Password where (==) = (==) `on` value\n"
"\n"
"Eq Album where (==) = (==) `on` \\a => (a.name, a.artist)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:216
#, no-wrap
msgid ""
"In case of `Album`, we wrap the two fields of the record in\n"
"a `Pair`, which already comes with an implementation of `Eq`.\n"
"This allows us to again use function `on`, which is very convenient.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:219
#, no-wrap
msgid ""
"Next, we have to define the data types representing\n"
"server requests and responses:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:220
#, no-wrap
msgid ""
"record Credentials where\n"
"  constructor MkCredentials\n"
"  email    : Email\n"
"  password : Password\n"
"\n"
"record Request where\n"
"  constructor MkRequest\n"
"  credentials : Credentials\n"
"  album       : Album\n"
"\n"
"data Response : Type where\n"
"  UnknownUser     : Email -> Response\n"
"  InvalidPassword : Response\n"
"  AccessDenied    : Email -> Album -> Response\n"
"  Success         : Album -> Response\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:243
#, no-wrap
msgid ""
"For server responses, we use a custom sum type encoding\n"
"the possible outcomes of a client request. In practice,\n"
"the `Success` case would return some kind of connection\n"
"to start the actual album stream, but we just\n"
"wrap up the album we found to simulate this behavior.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:248
#, no-wrap
msgid ""
"We can now go ahead and simulate the handling of\n"
"a request at the server. To emulate our user data base,\n"
"a simple list of users will do. Here's the type of the\n"
"function we'd like to implement:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:249
#, no-wrap
msgid ""
"DB : Type\n"
"DB = List User\n"
"\n"
"handleRequest : DB -> Request -> Response\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:265
#, no-wrap
msgid ""
"Note, how we defined a short alias for `List User` called `DB`.\n"
"This is often useful to make lengthy type signatures more readable\n"
"and communicate the meaning of a type in the given context. However,\n"
"this will *not* introduce a new type, nor will it\n"
"increase type safety: `DB` is *identical* to `List User`, and as\n"
"such, a value of type `DB` can be used wherever a `List User` is\n"
"expected and vice versa. In more complex programs it is therefore\n"
"usually preferable to define new types by wrapping values in\n"
"single-field records.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:274
#, no-wrap
msgid ""
"The implementation will proceed as follows: It will first\n"
"try and lookup a `User` by is email address in the data\n"
"base. If this is successful, it will compare the provided password\n"
"with the user's actual password. If the two match, it will\n"
"lookup the requested album in the user's list of albums.\n"
"If all of these steps succeed, the result will be an `Album`\n"
"wrapped in a `Success`. If any of the steps fails, the\n"
"result will describe exactly what went wrong.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:276
#, no-wrap
msgid "Here's a possible implementation:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:277
#, no-wrap
msgid ""
"handleRequest db (MkRequest (MkCredentials email pw) album) =\n"
"  case lookupUser db of\n"
"    Just (MkUser _ _ password albums)  =>\n"
"      if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"    Nothing => UnknownUser email\n"
"\n"
"  where lookupUser : List User -> Maybe User\n"
"        lookupUser []        = Nothing\n"
"        lookupUser (x :: xs) =\n"
"          if x.email == email then Just x else lookupUser xs\n"
"\n"
"        lookupAlbum : List Album -> Response\n"
"        lookupAlbum []        = AccessDenied email album\n"
"        lookupAlbum (x :: xs) =\n"
"          if x == album then Success album else lookupAlbum xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:305
#, no-wrap
msgid ""
"I'd like to point out several things in this example. First,\n"
"note how we can extract values from nested records in a\n"
"single pattern match.\n"
"Second, we defined two *local* functions in a `where` block: `lookupUser`,\n"
"and `lookupAlbum`. Both of these have access to all variables\n"
"in the surrounding scope. For instance, `lookupUser` uses the\n"
"`album` variable from the pattern match in the implementation's\n"
"first line. Likewise, `lookupAlbum` makes use of the `album`\n"
"variable.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:310
#, no-wrap
msgid ""
"A `where` block introduces new local definitions, accessible\n"
"only from the surrounding scope and from other functions\n"
"defined later in the same `where` block. These need to\n"
"be explicitly typed and indented by the same amount of whitespace.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:318
#, no-wrap
msgid ""
"Local definitions can also be introduce *before* a function's\n"
"implementation by using the `let` keyword. This usage\n"
"of `let` is not to be confused with *let bindings* described\n"
"above, which are used to bind and reuse the results of intermediate\n"
"computations. Below is how we could have implemented `handleRequest` with\n"
"local definitions introduced by the `let` keyword. Again,\n"
"all definitions have to be properly typed and indented:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:319
#, no-wrap
msgid ""
"handleRequest' : DB -> Request -> Response\n"
"handleRequest' db (MkRequest (MkCredentials email pw) album) =\n"
"  let lookupUser : List User -> Maybe User\n"
"      lookupUser []        = Nothing\n"
"      lookupUser (x :: xs) =\n"
"        if x.email == email then Just x else lookupUser xs\n"
"\n"
"      lookupAlbum : List Album -> Response\n"
"      lookupAlbum []        = AccessDenied email album\n"
"      lookupAlbum (x :: xs) =\n"
"        if x == album then Success album else lookupAlbum xs\n"
"\n"
"   in case lookupUser db of\n"
"        Just (MkUser _ _ password albums)  =>\n"
"          if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"        Nothing => UnknownUser email\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:345
#, no-wrap
msgid ""
"The exercises in this section are supposed to increase\n"
"you experience in writing purely functional code. In some\n"
"cases it might be useful to use `let` expressions or\n"
"`where` blocks, but this will not always be required.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:350
#, no-wrap
msgid ""
"Exercise 3 is again of utmost importance. `traverseList`\n"
"is a specialized version of the more general `traverse`,\n"
"one of the most powerful and versatile functions\n"
"available in the *Prelude* (check out its type!).\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions2.md:355
msgid ""
"Module `Data.List` in *base* exports functions `find` and `elem`.  Inspect "
"their types and use these in the implementation of `handleRequest`. This "
"should allow you to completely get rid of the `where` block."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions2.md:365
msgid ""
"Define an enumeration type listing the four "
"[nucleobases](https://en.wikipedia.org/wiki/Nucleobase)  occurring in DNA "
"strands. Define also a type alias `DNA` for lists of nucleobases.  Declare "
"and implement function `readBase` for converting a single character (type "
"`Char`) to a nucleobase.  You can use character literals in your "
"implementation like so: `'A'`, `'a'`. Note, that this function might fail, "
"so adjust the result type accordingly."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions2.md:371
msgid ""
"Implement the following function, which tries to convert all values in a "
"list with a function, which might fail. The result should be a `Just` "
"holding the list of converted values in unmodified order, if and only if "
"every single conversion was successful."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:372
#, no-wrap
msgid "   traverseList : (a -> Maybe b) -> List a -> Maybe (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:378
#, no-wrap
msgid ""
"   You can verify, that the function behaves correctly with\n"
"   the following test: `traverseList Just [1,2,3] = Just [1,2,3]`.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions2.md:382
msgid ""
"Implement function `readDNA : String -> Maybe DNA` using the functions and "
"types defined in exercises 2 and 3.  You will also need function `unpack` "
"from the *Prelude*."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions2.md:385
msgid ""
"Implement function `complement : DNA -> DNA` to calculate the complement of "
"a strand of DNA."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions2.md:386
#, no-wrap
msgid "The Truth about Function Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:390
#, no-wrap
msgid ""
"So far, when we defined a top level function, it looked something\n"
"like the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:391
#, no-wrap
msgid ""
"zipEitherWith : (a -> b -> c) -> Either e a -> Either e b -> Either e c\n"
"zipEitherWith f (Right va) (Right vb) = Right (f va vb)\n"
"zipEitherWith f (Left e)   _          = Left e\n"
"zipEitherWith f _          (Left e)   = Left e\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:401
#, no-wrap
msgid ""
"Function `zipEitherWith` is a generic higher-order function combining the\n"
"values stored in two `Either`s via a binary function. If either\n"
"of the `Either` arguments is a `Left`, the result is also a `Left`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:407
#, no-wrap
msgid ""
"This is a *generic function* with *type parameters* `a`, `b`, `c`, and "
"`e`.\n"
"However, there is a more verbose type for `zipEitherWith`, which is\n"
"visible in the REPL when entering `:ti zipEitherWith` (the `i` here\n"
"tells Idris to include `implicit` arguments). You will get a type\n"
"similar to this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:408
#, no-wrap
msgid ""
"zipEitherWith' :  {0 a : Type}\n"
"               -> {0 b : Type}\n"
"               -> {0 c : Type}\n"
"               -> {0 e : Type}\n"
"               -> (a -> b -> c)\n"
"               -> Either e a\n"
"               -> Either e b\n"
"               -> Either e c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:421
#, no-wrap
msgid ""
"In order to understand what's going on here, we will have to talk about\n"
"named arguments, implicit arguments, and quantities.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:422
#, no-wrap
msgid "Named Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:425
#, no-wrap
msgid "In a function type, we can give each argument a name. Like so:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:426
#, no-wrap
msgid ""
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:439
#, no-wrap
msgid ""
"Here, the first argument is given name `deflt`, the second `ma`. These\n"
"names can be reused in a function's implementation, as was done for "
"`deflt`,\n"
"but this is not mandatory: We are free to use different names in the\n"
"implementation. There are several reasons, why we'd choose to name our\n"
"arguments: It can serve as documentation, but it also\n"
"allows us to pass the arguments to a function in arbitrary order\n"
"when using the following syntax:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:440
#, no-wrap
msgid ""
"extractBool : Maybe Bool -> Bool\n"
"extractBool v = fromMaybe { ma = v, deflt = False }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:446
#, no-wrap
msgid "Or even :\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:447
#, no-wrap
msgid ""
"extractBool2 : Maybe Bool -> Bool\n"
"extractBool2 = fromMaybe { deflt = False }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:454
#, no-wrap
msgid ""
"The arguments in a record's constructor are automatically named\n"
"in accordance with the field names:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:455
#, no-wrap
msgid ""
"record Dragon where\n"
"  constructor MkDragon\n"
"  name      : String\n"
"  strength  : Nat\n"
"  hitPoints : Int16\n"
"\n"
"gorgar : Dragon\n"
"gorgar = MkDragon { strength = 150, name = \"Gorgar\", hitPoints = 10000 }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:471
#, no-wrap
msgid ""
"For the use cases described above, named arguments are merely a\n"
"convenience and completely optional. However, Idris is a *dependently "
"typed*\n"
"programming language: Types can be calculated from and depend on\n"
"values. For instance, the *result type* of a function can *depend* on\n"
"the *value* of one of its arguments. Here's a contrived example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:472
#, no-wrap
msgid ""
"IntOrString : Bool -> Type\n"
"IntOrString True  = Integer\n"
"IntOrString False = String\n"
"\n"
"intOrString : (v : Bool) -> IntOrString v\n"
"intOrString False = \"I'm a String\"\n"
"intOrString True  = 1000\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:489
#, no-wrap
msgid ""
"If you see such a thing for the first time, it can be hard to understand\n"
"what's going on here. First, function `IntOrString` computes a `Type`\n"
"from a `Bool` value: If the argument is `True`, it returns type `Integer`,\n"
"if the argument is `False` it returns `String`. We use this to\n"
"calculate the return type of function `intOrString` based on its\n"
"boolean argument `v`: If `v` is `True`, the return type is (in accordance\n"
"with `IntOrString True = Integer`) `Integer`, otherwise it is `String`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:493
#, no-wrap
msgid ""
"Note, how in the type signature of `intOrString`, we *must* give the\n"
"argument of type `Bool` a name (`v`) in order to reference it in\n"
"the result type `IntOrString v`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:500
#, no-wrap
msgid ""
"You might wonder at this moment, why this is useful and why we would\n"
"ever want to define a function with such a strange type. We will see\n"
"lots of very useful examples in due time! For now, suffice to say that\n"
"in order to express dependent function types, we need to name\n"
"at least some of the function's arguments and refer to them by name\n"
"in the types of other arguments.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:501
#, no-wrap
msgid "Implicit Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:509
#, no-wrap
msgid ""
"Implicit arguments are arguments, the values of which the compiler\n"
"should infer and fill in for us automatically. For instance, in\n"
"the following function signature, we expect the compiler to\n"
"infer the value of type parameter `a` automatically from the\n"
"types of the other arguments (ignore the 0 quantity for the moment;\n"
"I'll explain it in the next subsection):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:510
#, no-wrap
msgid ""
"maybeToEither : {0 a : Type} -> Maybe a -> Either String a\n"
"maybeToEither Nothing  = Left \"Nope\"\n"
"maybeToEither (Just x) = Right x\n"
"\n"
"-- Please remember, that the above is\n"
"-- equivalent to the following:\n"
"maybeToEither' : Maybe a -> Either String a\n"
"maybeToEither' Nothing  = Left \"Nope\"\n"
"maybeToEither' (Just x) = Right x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:527
#, no-wrap
msgid ""
"As you can see, implicit arguments are wrapped in curly braces,\n"
"unlike explicit named arguments, which are wrapped in parentheses.\n"
"Inferring the value of an implicit argument is not always possible.\n"
"For instance, if we enter the following\n"
"at the REPL, Idris will fail with an error:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:528
#, no-wrap
msgid ""
"Tutorial.Functions2> show (maybeToEither Nothing)\n"
"Error: Can't find an implementation for Show (Either String ?a).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:540
#, no-wrap
msgid ""
"Idris is unable to find an implementation of `Show (Either String a)`\n"
"without knowing what `a` actually is.\n"
"Note the question mark in front of the\n"
"type parameter: `?a`.\n"
"If this happens, there are several ways to help the type checker.\n"
"We could, for instance, pass a value for the implicit argument\n"
"explicitly. Here's the syntax to do this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:541
#, no-wrap
msgid ""
"Tutorial.Functions2> show (maybeToEither {a = Int8} Nothing)\n"
"\"Left \"Nope\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:549
#, no-wrap
msgid ""
"As you can see, we use the same syntax\n"
"as shown above for explicit named arguments and the\n"
"two forms of argument passing can be mixed.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:552
#, no-wrap
msgid ""
"We could also specify the type of the whole expression using\n"
"utility function `the` from the *Prelude*:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:553
#, no-wrap
msgid ""
"Tutorial.Functions2> show (the (Either String Int8) (maybeToEither "
"Nothing))\n"
"\"Left \"Nope\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:559
#, no-wrap
msgid "It is instructive to have a look at the type of `the`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:560
#, no-wrap
msgid ""
"Tutorial.Functions2> :ti the\n"
"Prelude.the : (0 a : Type) -> a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:566
#, no-wrap
msgid "Compare this with the identity function `id`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:567
#, no-wrap
msgid ""
"Tutorial.Functions2> :ti id\n"
"Prelude.id : {0 a : Type} -> a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:581
#, no-wrap
msgid ""
"The only difference between the two: In case of `the`,\n"
"the type parameter `a` is an *explicit* argument, while\n"
"in case of `id`, it is an *implicit* argument. Although\n"
"the two functions have almost identical types (and implementations!),\n"
"they serve quite different purposes: `the` is used to help\n"
"type inference, while `id` is used whenever we'd like\n"
"to return an argument without modifying it at all (which,\n"
"in the presence of higher-order functions,\n"
"happens surprisingly often).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:585
#, no-wrap
msgid ""
"Both ways to improve type inference shown above\n"
"are used quite often, and must be understood by Idris\n"
"programmers.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:586
#, no-wrap
msgid "Multiplicities"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:593
#, no-wrap
msgid ""
"Finally, we need to talk about the zero multiplicity, which appeared\n"
"in several of the type signatures in this section. Idris 2, unlike\n"
"its predecessor Idris 1, is based on a core language called\n"
"*quantitative type theory* (QTT): Every variable in Idris 2 is\n"
"associated with one of three possible multiplicities:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
msgid "`0`, meaning that the variable is *erased* at runtime."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
msgid "`1`, meaning that the variable is used *exactly once* at runtime."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:598
#, no-wrap
msgid ""
"* *Unrestricted* (the default), meaning that the variable is used\n"
"   an arbitrary number of times at runtime.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:604
#, no-wrap
msgid ""
"We will not talk about the most complex of the three, multiplicity `1`, "
"here.\n"
"We are, however, often interested in multiplicity `0`: A variable with\n"
"multiplicity `0` is only relevant at *compile time*. It will not make\n"
"any appearance at runtime, and the computation of such a variable will\n"
"never affect a program's runtime performance.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:609
#, no-wrap
msgid ""
"In the type signature of `maybeToEither` we see that type\n"
"parameter `a` has multiplicity `0`, and will therefore be erased and\n"
"is only relevant at compile time, while the `Maybe a` argument\n"
"has *unrestricted* multiplicity.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:613
#, no-wrap
msgid ""
"It is also possible to annotate explicit arguments with multiplicities,\n"
"in which case the argument must again be put in parentheses. For an "
"example,\n"
"look again at the type signature of `the`.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:614
#, no-wrap
msgid "Underscores"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:623
#, no-wrap
msgid ""
"It is often desirable, to only write as little code as necessary\n"
"and let Idris figure out the rest.\n"
"We have already learned about one such occasion: Catch-all patterns.\n"
"If a variable in a pattern match is not used on the right hand side,\n"
"we can't just drop it, as this would make it impossible for\n"
"Idris, which of several arguments we were planning to drop,\n"
"but we can use an underscore as a placeholder instead:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:624
#, no-wrap
msgid ""
"isRight : Either a b -> Bool\n"
"isRight (Right _) = True\n"
"isRight _         = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:633
#, no-wrap
msgid ""
"But when we look at the type signature of `isRight`, we will note\n"
"that type parameters `a` and `b` are also only used once, and\n"
"are therefore of no importance. Let's get rid of them:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:634
#, no-wrap
msgid ""
"isRight' : Either _ _ -> Bool\n"
"isRight' (Right _) = True\n"
"isRight' _         = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:645
#, no-wrap
msgid ""
"In the detailed type signature of `zipEitherWith`, it should\n"
"be obvious for Idris that the implicit arguments are of type `Type`.\n"
"After all, all of them are later on applied to the `Either` type\n"
"constructor, which is of type `Type -> Type -> Type`. Let's get rid\n"
"of them:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:646
#, no-wrap
msgid ""
"zipEitherWith'' :  {0 a : _}\n"
"                -> {0 b : _}\n"
"                -> {0 c : _}\n"
"                -> {0 e : _}\n"
"                -> (a -> b -> c)\n"
"                -> Either e a\n"
"                -> Either e b\n"
"                -> Either e c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:658
#, no-wrap
msgid "Consider the following contrived example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:659
#, no-wrap
msgid ""
"foo : Integer -> String\n"
"foo n = show (the (Either String Integer) (Right n))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:669
#, no-wrap
msgid ""
"Since we wrap an `Integer` in a `Right`, it is obvious\n"
"that the second argument in `Either String Integer` is\n"
"`Integer`. Only the `String` argument can't be inferred\n"
"by Idris. Even better, the `Either` itself is obvious!\n"
"Let's get rid of the unnecessary noise:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:670
#, no-wrap
msgid ""
"foo' : Integer -> String\n"
"foo' n = show (the (_ String _) (Right n))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:680
#, no-wrap
msgid ""
"Please note, that using underscores as in `foo'` is\n"
"not always desirable, as it can quite drastically\n"
"obfuscate the written code. Always use a syntactic\n"
"convenience to make code more readable, and not to\n"
"show people how clever you are.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions2.md:681
#, no-wrap
msgid "Programming with Holes"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:696
#, no-wrap
msgid ""
"Solved all the exercises so far? Got angry at the type checker\n"
"for always complaining and never being really helpful? It's time\n"
"to change that. Idris comes with several highly useful interactive\n"
"editing features. Sometimes, the compiler is able to implement\n"
"complete functions for us (if the types are specific enough). Even\n"
"if that's not possible, there's an incredibly useful and important\n"
"feature, which can help us when the types are getting too complicated: "
"Holes.\n"
"Holes are variables, the names of which are prefixed with a question mark.\n"
"We can use them as placeholders whenever we plan to implement a piece\n"
"of functionality at a later time. In addition, their types and the types\n"
"and quantities of all other variables in scope can be inspected\n"
"at the REPL (or in your editor, if you setup the necessary plugin).\n"
"Let's see them holes in action.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:704
#, no-wrap
msgid ""
"Remember the `traverseList` example from an Exercise earlier in\n"
"this section? If this was your first encounter with applicative list\n"
"traversals, this might have been a nasty bit of work. Well, let's just\n"
"make it a wee bit harder still. We'd like to implement the same\n"
"piece of functionality for functions returning `Either e`, where\n"
"`e` is a type with a `Semigroup` implementation, and we'd like\n"
"to accumulate the values in all `Left`s we meet along the way.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:706
#, no-wrap
msgid "Here's the type of the function:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:707
#, no-wrap
msgid ""
"traverseEither :  Semigroup e\n"
"               => (a -> Either e b)\n"
"               -> List a\n"
"               -> Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:718
#, no-wrap
msgid ""
"Now, in order to follow along, you might want to start your own\n"
"Idris source file, load it into a REPL session and adjust the\n"
"code as described here. The first thing we'll do, is write a\n"
"skeleton implementation with a hole on the right hand side:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:719
#, no-wrap
msgid "traverseEither fun as = ?impl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:725
#, no-wrap
msgid ""
"When you now go to the REPL and reload the file using command `:r`,\n"
"you can enter `:m` to list all the *metavariables*:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:726
#, no-wrap
msgid ""
"Tutorial.Functions2> :m\n"
"1 hole:\n"
"  Tutorial.Functions2.impl : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:734
#, no-wrap
msgid ""
"Next, we'd like to display the hole's type (including all variables in the\n"
"surrounding context plus their types):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:735
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   as : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:750
#, no-wrap
msgid ""
"So, we have some erased type parameters (`a`, `b`, and `e`), a value\n"
"of type `List a` called `as`, and a function from `a` to\n"
"`Either e b` called `fun`. Our goal is to come up with a value\n"
"of type `Either a (List b)`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:754
#, no-wrap
msgid ""
"We *could* just return a `Right []`, but that only make sense\n"
"if our input list is indeed the empty list. We therefore should\n"
"start with a pattern match on the list:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:755
#, no-wrap
msgid ""
"traverseEither fun []        = ?impl_0\n"
"traverseEither fun (x :: xs) = ?impl_1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:762
#, no-wrap
msgid ""
"The result is two holes, which must be given distinct names. When inspecting "
"`impl_0`,\n"
"we get the following result:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:763
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_0\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_0 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:779
#, no-wrap
msgid ""
"Now, this is an interesting situation. We are supposed to come up with a "
"value\n"
"of type `Either e (List b)` with nothing to work with. We know nothing\n"
"about `a`, so we can't provide an argument with which to invoke `fun`.\n"
"Likewise, we know nothing about `e` or `b` either, so we can't produce\n"
"any values of these either. The *only* option we have is to replace "
"`impl_0`\n"
"with an empty list wrapped in a `Right`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:780
#, no-wrap
msgid "traverseEither fun []        = Right []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:786
#, no-wrap
msgid ""
"The non-empty case is of course slightly more involved. Here's the context\n"
"of `?impl_1`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:787
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_1\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   x : a\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_1 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:810
#, no-wrap
msgid ""
"Since `x` is of type `a`, we can either use it as an argument\n"
"to `fun` or drop and ignore it. `xs`, on the other hand, is\n"
"the remainder of the list of type `List a`. We could again\n"
"drop it or process it further by invoking `traverseEither`\n"
"recursively. Since the goal is to try and convert *all* values,\n"
"we should drop neither. Since in case of two `Left`s we\n"
"are supposed to accumulate the values, we eventually need to\n"
"run both computations anyway (invoking `fun`, and recursively\n"
"calling `traverseEither`). We therefore can do both at the\n"
"same time and analyze the results in a single pattern match\n"
"by wrapping both in a `Pair`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:811
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"   p => ?impl_2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:818
#, no-wrap
msgid "Once again, we inspect the context:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:819
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_2\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   p : (Either e b, Either e (List b))\n"
"------------------------------\n"
"impl_2 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:834
#, no-wrap
msgid ""
"We'll definitely need to pattern match on pair `p` next\n"
"to figure out, which of the two computations succeeded:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:835
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => ?impl_6\n"
"    (Left y, Right _)  => ?impl_7\n"
"    (Right _, Left z)  => ?impl_8\n"
"    (Right y, Right z) => ?impl_9\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:847
#, no-wrap
msgid ""
"At this point we might have forgotten what we actually\n"
"wanted to do (at least to me, this happens annoyingly often),\n"
"so we'll just quickly check what our goal is:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:848
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_6\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   y : e\n"
"   z : e\n"
"------------------------------\n"
"impl_6 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:868
#, no-wrap
msgid ""
"So, we are still looking for a value of type `Either e (List b)`, and\n"
"we have two values of type `e` in scope. According to the spec we\n"
"want to accumulate these using `e`s `Semigroup` implementation.\n"
"We can proceed for the other cases in a similar manner, remembering\n"
"that we should return a `Right`, if and only if all conversions\n"
"where successful:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:869
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => Left (y <+> z)\n"
"    (Left y, Right _)  => Left y\n"
"    (Right _, Left z)  => Left z\n"
"    (Right y, Right z) => Right (y :: z)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:879
#, no-wrap
msgid "To reap the fruits of our labour, let's show off with a small example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:880
#, no-wrap
msgid ""
"data Nucleobase = Adenine | Cytosine | Guanine | Thymine\n"
"\n"
"readNucleobase : Char -> Either (List String) Nucleobase\n"
"readNucleobase 'A' = Right Adenine\n"
"readNucleobase 'C' = Right Cytosine\n"
"readNucleobase 'G' = Right Guanine\n"
"readNucleobase 'T' = Right Thymine\n"
"readNucleobase c   = Left [\"Unknown nucleobase: \" ++ show c]\n"
"\n"
"DNA : Type\n"
"DNA = List Nucleobase\n"
"\n"
"readDNA : String -> Either (List String) DNA\n"
"readDNA = traverseEither readNucleobase . unpack\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:898
#, no-wrap
msgid "Let's try this at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:899
#, no-wrap
msgid ""
"Tutorial.Functions2> readDNA \"CGTTA\"\n"
"Right [Cytosine, Guanine, Thymine, Thymine, Adenine]\n"
"Tutorial.Functions2> readDNA \"CGFTAQ\"\n"
"Left [\"Unknown nucleobase: 'F'\", \"Unknown nucleobase: 'Q'\"]\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:906
#, no-wrap
msgid "Interactive Editing"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:916
#, no-wrap
msgid ""
"There are plugins available for several editors and\n"
"programming environments, which facilitate interacting\n"
"with the Idris compiler when implementing your functions.\n"
"One editor, which is well supported in the Idris\n"
"community, is Neovim. Since I am a Neovim user myself,\n"
"I added some examples of what's possible to the\n"
"[appendix](../Appendices/Neovim.md). Now would be a good\n"
"time to start using the utilities discussed there.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:923
#, no-wrap
msgid ""
"If you use a different editor, probably with less support\n"
"for the Idris programming language, you should at the very\n"
"least have a REPL session open all the time, where the\n"
"source file you are currently working on is loaded. This\n"
"allows you to introduce new metavariables and inspect their\n"
"types and context as you develop your code.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:929
#, no-wrap
msgid ""
"We again covered a lot of ground in this section. I can't stress enough that "
"you\n"
"should get yourselves accustomed to programming with holes and let the\n"
"type checker help you figure out what to do next.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:932
#, no-wrap
msgid ""
"* When in need of local utility functions, consider defining them\n"
"as local definitions in a *where block*.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:934
msgid "Use *let expressions* to define and reuse local variables."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:938
#, no-wrap
msgid ""
"* Function arguments can be given a name, which can serve as "
"documentation,\n"
"can be used to pass arguments in any order, and is used to refer to\n"
"them in dependent types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:942
#, no-wrap
msgid ""
"* Implicit arguments are wrapped in curly braces. The compiler is\n"
"supposed to infer them from the context. If that's not possible,\n"
"they can be passed explicitly as other named arguments.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:945
#, no-wrap
msgid ""
"* Whenever possible, Idris adds implicit erased arguments for all\n"
"type parameters automatically.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:948
#, no-wrap
msgid ""
"* Quantities allow us to track how often a function argument is\n"
"used. Quantity 0 means, the argument is erased at runtime.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:953
#, no-wrap
msgid ""
"* Use *holes* as placeholders for pieces of code you plan to fill\n"
"in at a later time. Use the REPL (or your editor) to inspect\n"
"the types of holes together with the names, types, and quantities of all\n"
"variables in their context.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:962
#, no-wrap
msgid ""
"In the [next chapter](Dependent.md)\n"
"we'll start using dependent types to help us write provably correct code.\n"
"Having a good understanding of how to read\n"
"Idris' type signatures will be of paramount importance there. Whenever\n"
"you feel lost, add one or more holes and inspect their context to decide "
"what to\n"
"do next.\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Functor.md:1
#, no-wrap
msgid "Functor and Friends"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:6
#, no-wrap
msgid ""
"Programming, like mathematics, is about abstraction. We\n"
"try to model parts of the real world, reusing recurring\n"
"patterns by abstracting over them.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:17
#, no-wrap
msgid ""
"In this chapter, we will learn about several related interfaces,\n"
"which are all about abstraction and therefore can be hard to\n"
"understand at the beginning. Especially figuring out\n"
"*why* they are useful and *when* to use them will take\n"
"time and experience. This chapter therefore comes\n"
"with tons of exercises, most of which can be solved\n"
"with only a few short lines of code. Don't skip them.\n"
"Come back to them several times until these things start\n"
"feeling natural to you. You will then realize that their\n"
"initial complexity has vanished.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:18
#, no-wrap
msgid ""
"module Tutorial.Functor\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functor.md:28
#, no-wrap
msgid "Functor"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:42
#, no-wrap
msgid ""
"What do type constructors like `List`, `List1`, `Maybe`, or\n"
"`IO` have in common? First, all of them are of type\n"
"`Type -> Type`. Second, they all put values of a given type\n"
"in a certain *context*. With `List`,\n"
"the *context* is *non-determinism*: We know there to\n"
"be zero or more values, but we don't know the exact number\n"
"until we start taking the list apart by pattern matching\n"
"on it. Likewise for `List1`, though we know for sure that\n"
"there is at least one value. For `Maybe`, we are still not\n"
"sure about how many values there are, but the possibilities\n"
"are much smaller: Zero or one. With `IO`, the context is a different one:\n"
"Arbitrary side effects.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:49
#, no-wrap
msgid ""
"Although the type constructors discussed above are quite\n"
"different in how they behave and when they are useful,\n"
"there are certain operations that keep coming up\n"
"when working with them. The first such operation\n"
"is *mapping a pure function over the data type, without\n"
"affecting its underlying structure*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:53
#, no-wrap
msgid ""
"For instance, given a list of numbers, we'd like to multiply\n"
"each number by two, without changing their order or removing\n"
"any values:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:54
#, no-wrap
msgid ""
"multBy2List : Num a => List a -> List a\n"
"multBy2List []        = []\n"
"multBy2List (x :: xs) = 2 * x :: multBy2List xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:62
#, no-wrap
msgid ""
"But we might just as well convert every string in a\n"
"list of strings to upper case characters:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:63
#, no-wrap
msgid ""
"toUpperList : List String -> List String\n"
"toUpperList []        = []\n"
"toUpperList (x :: xs) = toUpper x :: toUpperList xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:72
#, no-wrap
msgid ""
"Sometimes, the type of the stored value changes. In the\n"
"next example, we calculate the lengths of the strings stored\n"
"in a list:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:73
#, no-wrap
msgid ""
"toLengthList : List String -> List Nat\n"
"toLengthList []        = []\n"
"toLengthList (x :: xs) = length x :: toLengthList xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:83
#, no-wrap
msgid ""
"I'd like you to appreciate, just how boring these functions are. They\n"
"are almost identical, with the only interesting part being\n"
"the function we apply to each element. Surely, there must be a\n"
"pattern to abstract over:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:84
#, no-wrap
msgid ""
"mapList : (a -> b) -> List a -> List b\n"
"mapList f []        = []\n"
"mapList f (x :: xs) = f x :: mapList f xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:94
#, no-wrap
msgid ""
"This is often the first step of abstraction in functional\n"
"programming: Write a (possibly generic) higher-order function.\n"
"We can now concisely implement all examples shown above in\n"
"terms of `mapList`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:95
#, no-wrap
msgid ""
"multBy2List' : Num a => List a -> List a\n"
"multBy2List' = mapList (2 *)\n"
"\n"
"toUpperList' : List String -> List String\n"
"toUpperList' = mapList toUpper\n"
"\n"
"toLengthList' : List String -> List Nat\n"
"toLengthList' = mapList length\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:110
#, no-wrap
msgid ""
"But surely we'd like to do the same kind of thing with\n"
"`List1` and `Maybe`! After all, they are just container\n"
"types like `List`, the only difference being some detail\n"
"about the number of values they can or can't hold:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:111
#, no-wrap
msgid ""
"mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"mapMaybe f Nothing  = Nothing\n"
"mapMaybe f (Just v) = Just (f v)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:125
#, no-wrap
msgid ""
"Even with `IO`, we'd like to be able to map pure functions\n"
"over effectful computations. The implementation is\n"
"a bit more involved, due to the nested layers of\n"
"data constructors, but if in doubt, the types will surely\n"
"guide us. Note, however, that `IO` is not publicly exported,\n"
"so its data constructor is unavailable to us. We can use\n"
"functions `toPrim` and `fromPrim`, however, for converting\n"
"`IO` from and to `PrimIO`, which we can freely dissect:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:126
#, no-wrap
msgid ""
"mapIO : (a -> b) -> IO a -> IO b\n"
"mapIO f io = fromPrim $ mapPrimIO (toPrim io)\n"
"  where mapPrimIO : PrimIO a -> PrimIO b\n"
"        mapPrimIO prim w =\n"
"          let MkIORes va w2 = prim w\n"
"           in MkIORes (f va) w2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:138
#, no-wrap
msgid ""
"From the concept of *mapping a pure function over\n"
"values in a context* follow some derived functions, which are\n"
"often useful. Here are some of them for `IO`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:139
#, no-wrap
msgid ""
"mapConstIO : b -> IO a -> IO b\n"
"mapConstIO = mapIO . const\n"
"\n"
"forgetIO : IO a -> IO ()\n"
"forgetIO = mapConstIO ()\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:151
#, no-wrap
msgid ""
"Of course, we'd want to implement `mapConst` and `forget` as well\n"
"for `List`, `List1`, and `Maybe` (and dozens of other type\n"
"constructors with some kind of mapping function), and they'd\n"
"all look the same and be equally boring.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:161
#, no-wrap
msgid ""
"When we come upon a recurring class of functions with\n"
"several useful derived functions, we should consider defining\n"
"an interface. But how should we go about this here?\n"
"When you look at the types of `mapList`, `mapMaybe`, and `mapIO`,\n"
"you'll see that it's the `List`, `List1`, and `IO` types we\n"
"need to get rid of. These are not of type `Type` but of type\n"
"`Type -> Type`. Luckily, there is nothing preventing us\n"
"from parametrizing an interface over something else than\n"
"a `Type`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:166
#, no-wrap
msgid ""
"The interface we are looking for is called `Functor`.\n"
"Here is its definition and an example implementation (I appended\n"
"a tick at the end of the names for them not to overlap with\n"
"the interface and functions exported by the *Prelude*):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:167
#, no-wrap
msgid ""
"interface Functor' (0 f : Type -> Type) where\n"
"  map' : (a -> b) -> f a -> f b\n"
"\n"
"implementation Functor' Maybe where\n"
"  map' _ Nothing  = Nothing\n"
"  map' f (Just v) = Just $ f v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:179
#, no-wrap
msgid ""
"Note, that we had to give the type of parameter `f` explicitly,\n"
"and in that case it needs to be annotated with quantity zero if\n"
"you want it to be erased at runtime (which you almost always want).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:186
#, no-wrap
msgid ""
"Now, reading type signatures consisting only of type parameters\n"
"like the one of `map'` can take some time to get used to, especially\n"
"when some type parameters are applied to other parameters as in\n"
"`f a`. It can be very helpful to inspect these signatures together\n"
"with all implicit arguments at the REPL (I formatted the output to\n"
"make it more readable):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:187
#, no-wrap
msgid ""
"Tutorial.Functor> :ti map'\n"
"Tutorial.Functor.map' :  {0 b : Type}\n"
"                      -> {0 a : Type}\n"
"                      -> {0 f : Type -> Type}\n"
"                      -> Functor' f\n"
"                      => (a -> b)\n"
"                      -> f a\n"
"                      -> f b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:200
#, no-wrap
msgid ""
"It can also be helpful to replace type parameter `f` with a concrete\n"
"value of the same type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:201
#, no-wrap
msgid ""
"Tutorial.Functor> :t map' {f = Maybe}\n"
"map' : (?a -> ?b) -> Maybe ?a -> Maybe ?b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:209
#, no-wrap
msgid ""
"Remember, being able to interpret type signatures is paramount to\n"
"understanding what's going on in an Idris declaration. You *must*\n"
"practice this and make use of the tools and utilities given to you.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:210
#, no-wrap
msgid "Derived Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:215
#, no-wrap
msgid ""
"There are several functions and operators directly derivable from "
"interface\n"
"`Functor`. Eventually, you should know and remember all of them as\n"
"they are highly useful. Here they are together with their types:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:216
#, no-wrap
msgid ""
"Tutorial.Functor> :t (<$>)\n"
"Prelude.<$> : Functor f => (a -> b) -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t (<&>)\n"
"Prelude.<&> : Functor f => f a -> (a -> b) -> f b\n"
"\n"
"Tutorial.Functor> :t ($>)\n"
"Prelude.$> : Functor f => f a -> b -> f b\n"
"\n"
"Tutorial.Functor> :t (<$)\n"
"Prelude.<$ : Functor f => b -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t ignore\n"
"Prelude.ignore : Functor f => f a -> f ()\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:235
#, no-wrap
msgid ""
"`(<$>)` is an operator alias for `map` and allows you to sometimes\n"
"drop some parentheses. For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:236
#, no-wrap
msgid ""
"tailShowReversNoOp : Show a => List1 a -> List String\n"
"tailShowReversNoOp xs = map (reverse . show) (tail xs)\n"
"\n"
"tailShowReverse : Show a => List1 a -> List String\n"
"tailShowReverse xs = reverse . show <$> tail xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:249
#, no-wrap
msgid ""
"`(<&>)` is an alias for `(<$>)` with the arguments flipped.\n"
"The other three (`ignore`, `($>)`, and `(<$)`) are all used\n"
"to replace the values in a context with a constant. They are often useful\n"
"when you don't care about the values themselves but\n"
"want to keep the underlying structure.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:250
#, no-wrap
msgid "Functors with more than one Type Parameter"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:259
#, no-wrap
msgid ""
"The type constructors we looked at so far were all\n"
"of type `Type -> Type`. However, we can also implement `Functor`\n"
"for other type constructors. The only prerequisite is that\n"
"the type parameter we'd like to change with function `map` must\n"
"be the last in the argument list. For instance, here is the\n"
"`Functor` implementation for `Either e` (note, that `Either e`\n"
"has of course type `Type -> Type` as required):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:260
#, no-wrap
msgid ""
"implementation Functor' (Either e) where\n"
"  map' _ (Left ve)  = Left ve\n"
"  map' f (Right va) = Right $ f va\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:269
#, no-wrap
msgid ""
"Here is another example, this time for a type constructor of\n"
"type `Bool -> Type -> Type` (you might remember this from\n"
"the exercises in the [last chapter](IO.md)):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:270
#, no-wrap
msgid ""
"data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"  Nil  : List01 False a\n"
"  (::) : a -> List01 False a -> List01 ne a\n"
"\n"
"implementation Functor (List01 ne) where\n"
"  map _ []        = []\n"
"  map f (x :: xs) = f x :: map f xs\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:280
#, no-wrap
msgid "Functor Composition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:284
#, no-wrap
msgid ""
"The nice thing about functors is how they can be paired and\n"
"nested with other functors and the results are functors again:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:285
#, no-wrap
msgid ""
"record Product (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkProduct\n"
"  fst : f a\n"
"  snd : g a\n"
"\n"
"implementation Functor f => Functor g => Functor (Product f g) where\n"
"  map f (MkProduct l r) = MkProduct (map f l) (map f r)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:297
#, no-wrap
msgid ""
"The above allows us to conveniently map over a pair of functors. Note,\n"
"however, that Idris needs some help with inferring the types involved:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:298
#, no-wrap
msgid ""
"toPair : Product f g a -> (f a, g a)\n"
"toPair (MkProduct fst snd) = (fst, snd)\n"
"\n"
"fromPair : (f a, g a) -> Product f g a\n"
"fromPair (x,y) = MkProduct x y\n"
"\n"
"productExample :  Show a\n"
"               => (Either e a, List a)\n"
"               -> (Either e String, List String)\n"
"productExample = toPair . map show . fromPair {f = Either e, g = List}\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:313
#, no-wrap
msgid ""
"More often, we'd like to map over several layers of nested functors\n"
"at once. Here's how to do this with an example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:314
#, no-wrap
msgid ""
"record Comp (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkComp\n"
"  unComp  : f (g a)\n"
"\n"
"implementation Functor f => Functor g => Functor (Comp f g) where\n"
"  map f (MkComp v) = MkComp $ map f <$> v\n"
"\n"
"compExample :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample = unComp . map show . MkComp {f = List, g = Either e}\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Functor.md:326
#, no-wrap
msgid "Named Implementations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:334
#, no-wrap
msgid ""
"Sometimes, there are more ways to implement an interface for\n"
"a given type. For instance, for numeric types we can have\n"
"a `Monoid` representing addition and one representing multiplication.\n"
"Likewise, for nested functors, `map` can be interpreted as a mapping\n"
"over only the first layer of values, or a mapping over several layers\n"
"of values.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:339
#, no-wrap
msgid ""
"One way to go about this is to define single-field wrappers as\n"
"shown with data type `Comp` above. However, Idris also allows us\n"
"to define additional interface implementations, which must then\n"
"be given a name. For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:340
#, no-wrap
msgid ""
"[Compose'] Functor f => Functor g => Functor (f . g) where\n"
"  map f = (map . map) f\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:350
#, no-wrap
msgid ""
"Note, that this defines a new implementation of `Functor`, which will\n"
"*not* be considered during implicit resolution in order\n"
"to avoid ambiguities. However,\n"
"it is possible to explicitly choose to use this implementation\n"
"by passing it as an explicit argument to `map`, prefixed with an `@`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:351
#, no-wrap
msgid ""
"compExample2 :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample2 = map @{Compose} show\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:358
#, no-wrap
msgid ""
"In the example above, we used `Compose` instead of `Compose'`, since\n"
"the former is already exported by the *Prelude*.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:359
#, no-wrap
msgid "Functor Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:365
#, no-wrap
msgid ""
"Implementations of `Functor` are supposed to adhere to certain laws,\n"
"just like implementations of `Eq` or `Ord`. Again, these laws are\n"
"not verified by Idris, although it would be possible (and\n"
"often cumbersome) to do so.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:370
#, no-wrap
msgid ""
"1. `map id = id`: Mapping the identity function over a functor\n"
"    must not have any visible effect such as changing a container's\n"
"    structure or affecting the side effects perfomed when\n"
"    running an `IO` action.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:373
msgid ""
"`map (f . g) = map f . map g`: Sequencing two mappings must be identical to "
"a single mapping using the composition of the two functions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:380
#, no-wrap
msgid ""
"Both of these laws request, that `map` is preserving the *structure*\n"
"of values. This is easier to understand with container types like\n"
"`List`, `Maybe`, or `Either e`, where `map` is not allowed to\n"
"add or remove any wrapped value, nor - in case of `List` -\n"
"change their order. With `IO`, this can best be described as `map`\n"
"not performing additional side effects.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:385
msgid ""
"Write your own implementations of `Functor'` for `Maybe`, `List`, `List1`, "
"`Vect n`, `Either e`, and `Pair a`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:388
msgid ""
"Write a named implementation of `Functor` for pairs of functors (similar to "
"the one implemented for `Product`)."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:391
msgid ""
"Implement `Functor` for data type `Identity` (which is available from "
"`Control.Monad.Identity` in *base*):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:392
#, no-wrap
msgid ""
"   record Identity a where\n"
"     constructor Id\n"
"     value : a\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:404
msgid ""
"Here is a curious one: Implement `Functor` for `Const e` (which is also "
"available from `Control.Applicative.Const` in *base*). You might be confused "
"about the fact that the second type parameter has absolutely no relevance at "
"runtime, as there is no value of that type. Such types are sometimes called "
"*phantom types*. They can be quite useful for tagging values with additional "
"typing information."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:407
#, no-wrap
msgid ""
"   Don't let the above confuse you: There is only one possible "
"implementation.\n"
"   As usual, use holes and let the compiler guide you if you get lost.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:408
#, no-wrap
msgid ""
"   record Const (e,a : Type) where\n"
"     constructor MkConst\n"
"     value : e\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:416
msgid ""
"Here is a sum type for describing CRUD operations (Create, Read, Update, and "
"Delete) in a data store:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:426
#, no-wrap
msgid "   Implement `Functor` for `Crud i`.\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:428
msgid "Here is a sum type for describing responses from a data server:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:439
#, no-wrap
msgid "   Implement `Functor` for `Repsonse e i`.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Functor.md:441
msgid "Implement `Functor` for `Validated e`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:442
#, no-wrap
msgid ""
"   data Validated : (e,a : Type) -> Type where\n"
"     Invalid : (err : e) -> Validated e a\n"
"     Valid   : (val : a) -> Validated e a\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functor.md:448
#, no-wrap
msgid "Applicative"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:453
#, no-wrap
msgid ""
"While `Functor` allows us to map a pure, unary function\n"
"over a value in a context, it doesn't allow us to combine\n"
"n such values under an n-ary function.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:455
#, no-wrap
msgid "For instance, consider the following functions:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:456
#, no-wrap
msgid ""
"liftMaybe2 : (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\n"
"liftMaybe2 f (Just va) (Just vb) = Just $ f va vb\n"
"liftMaybe2 _ _         _         = Nothing\n"
"\n"
"liftVect2 : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"liftVect2 _ []        []        = []\n"
"liftVect2 f (x :: xs) (y :: ys) = f x y :: liftVect2 f xs ys\n"
"\n"
"liftIO2 : (a -> b -> c) -> IO a -> IO b -> IO c\n"
"liftIO2 f ioa iob = fromPrim $ go (toPrim ioa) (toPrim iob)\n"
"  where go : PrimIO a -> PrimIO b -> PrimIO c\n"
"        go pa pb w =\n"
"          let MkIORes va w2 = pa w\n"
"              MkIORes vb w3 = pb w2\n"
"           in MkIORes (f va vb) w3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:478
#, no-wrap
msgid ""
"This behavior is not covered by `Functor`, yet it is a very\n"
"common thing to do. For instance, we might want to read two numbers\n"
"from standard input (both operations might fail), calculating the\n"
"product of the two. Here's the code:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:479
#, no-wrap
msgid ""
"multNumbers : Num a => Neg a => IO (Maybe a)\n"
"multNumbers = do\n"
"  s1 <- getLine\n"
"  s2 <- getLine\n"
"  pure $ liftMaybe2 (*) (parseInteger s1) (parseInteger s2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:490
#, no-wrap
msgid ""
"And it won't stop here. We might just as well want to have\n"
"`liftMaybe3` for ternary functions and three `Maybe` arguments\n"
"and so on, for arbitrary numbers of arguments.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:493
#, no-wrap
msgid ""
"But there is more: We'd also like to lift pure values into\n"
"the context in question. With this, we could do the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:494
#, no-wrap
msgid ""
"liftMaybe3 : (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe "
"d\n"
"liftMaybe3 f (Just va) (Just vb) (Just vc) = Just $ f va vb vc\n"
"liftMaybe3 _ _         _         _         = Nothing\n"
"\n"
"pureMaybe : a -> Maybe a\n"
"pureMaybe = Just\n"
"\n"
"multAdd100 : Num a => Neg a => String -> String -> Maybe a\n"
"multAdd100 s t = liftMaybe3 calc (parseInteger s) (parseInteger t) (pure "
"100)\n"
"  where calc : a -> a -> a -> a\n"
"        calc x y z = x * y + z\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:511
#, no-wrap
msgid ""
"As you'll of course already know, I am now going to present a new\n"
"interface to encapsulate this behavior. It's called `Applicative`.\n"
"Here is its definition and an example implementation:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:512
#, no-wrap
msgid ""
"interface Functor' f => Applicative' f where\n"
"  app   : f (a -> b) -> f a -> f b\n"
"  pure' : a -> f a\n"
"\n"
"implementation Applicative' Maybe where\n"
"  app (Just fun) (Just val) = Just $ fun val\n"
"  app _          _          = Nothing\n"
"\n"
"  pure' = Just\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:527
#, no-wrap
msgid ""
"Interface `Applicative` is of course already exported by the *Prelude*.\n"
"There, function `app` is an operator sometimes called *app* or *apply*:\n"
"`(<*>)`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:530
#, no-wrap
msgid ""
"You may wonder, how functions like `liftMaybe2` or `liftIO3` are related\n"
"to operator *apply*. Let me demonstrate this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:531
#, no-wrap
msgid ""
"liftA2 : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2 fun fa fb = pure fun <*> fa <*> fb\n"
"\n"
"liftA3 : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3 fun fa fb fc = pure fun <*> fa <*> fb <*> fc\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:544
#, no-wrap
msgid ""
"It is really important for you to understand what's going on here, so "
"let's\n"
"break these down. If we specialize `liftA2` to use `Maybe` for `f`,\n"
"`pure fun` is of type `Maybe (a -> b -> c)`. Likewise, `pure fun <*> fa`\n"
"is of type `Maybe (b -> c)`, as `(<*>)` will apply the value stored\n"
"in `fa` to the function stored in `pure fun` (currying!).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:550
#, no-wrap
msgid ""
"You'll often see such chains of applications of *apply*, the number\n"
"of *applies* corresponding to the arity of the function we lift.\n"
"You'll sometimes also see the following, which allows us to drop\n"
"the initial call to `pure`, and use the operator version of `map`\n"
"instead:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:551
#, no-wrap
msgid ""
"liftA2' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2' fun fa fb = fun <$> fa <*> fb\n"
"\n"
"liftA3' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3' fun fa fb fc = fun <$> fa <*> fb <*> fc\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:564
#, no-wrap
msgid ""
"So, interface `Applicative` allows us to lift values (and functions!)\n"
"into computational contexts and apply them to values in the same\n"
"contexts. Before we will see an extended example why this is\n"
"useful, I'll quickly introduce some syntactic sugar for working\n"
"with applicative functors.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:565
#, no-wrap
msgid "Idiom Brackets"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:571
#, no-wrap
msgid ""
"The programming style used for implementing `liftA2'` and `liftA3'`\n"
"is also referred to as *applicative style* and is used a lot\n"
"in Haskell for combining several effectful computations\n"
"with a single pure function.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:575
#, no-wrap
msgid ""
"In Idris, there is an alternative to using such chains of\n"
"operator applications: Idiom brackets. Here's another\n"
"reimplementation of `liftA2` and `liftA3`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:576
#, no-wrap
msgid ""
"liftA2'' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2'' fun fa fb = [| fun fa fb |]\n"
"\n"
"liftA3'' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3'' fun fa fb fc = [| fun fa fb fc |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:590
#, no-wrap
msgid ""
"The above implementations will be desugared to the one given\n"
"for `liftA2` and `liftA3`, again *before disambiguating,\n"
"type checking, and filling in of implicit values*. Like with the\n"
"*bind* operator, we can therefore write custom implementations\n"
"for `pure` and `(<*>)`, and Idris will use these if it\n"
"can disambiguate between the overloaded function names.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:591
#, no-wrap
msgid "Use Case: CSV Reader"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:604
#, no-wrap
msgid ""
"In order to understand the power and versatility that comes\n"
"with applicative functors, we will look at a slightly\n"
"extended example. We are going to write some utilities\n"
"for parsing and decoding content from CSV files. These\n"
"are files where each line holds a list of values separated\n"
"by commas (or some other delimiter). Typically, they are\n"
"used to store tabular data, for instance from spread sheet\n"
"applications. What we would like to do is convert\n"
"lines in a CSV file and store the result in custom\n"
"records, where each record field corresponds to a column\n"
"in the table.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:609
#, no-wrap
msgid ""
"For instance, here is a simple example\n"
"file, containing tabular user information from a web\n"
"store: First name, last name, age (optional), email address,\n"
"gender, and password.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:610
#, no-wrap
msgid ""
"Jon,Doe,42,jon@doe.ch,m,weijr332sdk\n"
"Jane,Doe,,jane@doe.ch,f,aa433sd112\n"
"Stefan,Hoeck,,nope@goaway.ch,m,password123\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:621
#, no-wrap
msgid ""
"And here are the Idris data types necessary to hold\n"
"this information at runtime. We use again custom\n"
"string wrappers for increased type safety and\n"
"because it will allow us to define for each data type\n"
"what we consider to be valid input:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:622
#, no-wrap
msgid ""
"data Gender = Male | Female | Other\n"
"\n"
"record Name where\n"
"  constructor MkName\n"
"  value : String\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  firstName : Name\n"
"  lastName  : Name\n"
"  age       : Maybe Nat\n"
"  email     : Email\n"
"  gender    : Gender\n"
"  password  : Password\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:650
#, no-wrap
msgid ""
"We start by defining an interface for reading fields\n"
"in a CSV file and writing implementations for\n"
"the data types we'd like to read:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:651
#, no-wrap
msgid ""
"interface CSVField a where\n"
"  read : String -> Maybe a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:659
#, no-wrap
msgid ""
"Below are implementations for `Gender` and `Bool`. I decided\n"
"to in these cases encode each value with a single lower\n"
"case character:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:660
#, no-wrap
msgid ""
"CSVField Gender where\n"
"  read \"m\" = Just Male\n"
"  read \"f\" = Just Female\n"
"  read \"o\" = Just Other\n"
"  read _   = Nothing\n"
"\n"
"CSVField Bool where\n"
"  read \"t\" = Just True\n"
"  read \"f\" = Just False\n"
"  read _   = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:675
#, no-wrap
msgid ""
"For numeric types, we can use the parsing functions\n"
"from `Data.String`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:676
#, no-wrap
msgid ""
"CSVField Nat where\n"
"  read = parsePositive\n"
"\n"
"CSVField Integer where\n"
"  read = parseInteger\n"
"\n"
"CSVField Double where\n"
"  read = parseDouble\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:692
#, no-wrap
msgid ""
"For optional values, the stored type must itself\n"
"come with an instance of `CSVField`. We can then treat\n"
"the empty string `\"\"` as `Nothing`, while a non-empty\n"
"string will be passed to the encapsulated type's field reader.\n"
"(Remember that `(<$>)` is an alias for `map`.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:693
#, no-wrap
msgid ""
"CSVField a => CSVField (Maybe a) where\n"
"  read \"\" = Just Nothing\n"
"  read s  = Just <$> read s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:703
#, no-wrap
msgid ""
"Finally, for our string wrappers, we need to decide what\n"
"we consider to be valid values. For simplicity, I decided\n"
"to limit the length of allowed strings and the set of\n"
"valid characters.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:704
#, no-wrap
msgid ""
"readIf : (String -> Bool) -> (String -> a) -> String -> Maybe a\n"
"readIf p mk s = if p s then Just (mk s) else Nothing\n"
"\n"
"isValidName : String -> Bool\n"
"isValidName s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isAlpha (unpack s)\n"
"\n"
"CSVField Name where\n"
"  read = readIf isValidName MkName\n"
"\n"
"isEmailChar : Char -> Bool\n"
"isEmailChar '.' = True\n"
"isEmailChar '@' = True\n"
"isEmailChar c   = isAlphaNum c\n"
"\n"
"isValidEmail : String -> Bool\n"
"isValidEmail s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isEmailChar (unpack s)\n"
"\n"
"CSVField Email where\n"
"  read = readIf isValidEmail MkEmail\n"
"\n"
"isPasswordChar : Char -> Bool\n"
"isPasswordChar ' ' = True\n"
"isPasswordChar c   = not (isControl c) && not (isSpace c)\n"
"\n"
"isValidPassword : String -> Bool\n"
"isValidPassword s =\n"
"  let len = length s\n"
"   in 8 < len && len <= 100 && all isPasswordChar (unpack s)\n"
"\n"
"CSVField Password where\n"
"  read = readIf isValidPassword MkPassword\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:745
#, no-wrap
msgid ""
"In a later chapter, we will learn about refinement types and\n"
"how to store an erased proof of validity together with\n"
"a validated value.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:749
#, no-wrap
msgid ""
"We can now start to decode whole lines in a CSV file.\n"
"In order to do so, we first introduce a custom error\n"
"type encapsulating how things can go wrong:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:750
#, no-wrap
msgid ""
"data CSVError : Type where\n"
"  FieldError           : (line, column : Nat) -> (str : String) -> "
"CSVError\n"
"  UnexpectedEndOfInput : (line, column : Nat) -> CSVError\n"
"  ExpectedEndOfInput   : (line, column : Nat) -> CSVError\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:760
#, no-wrap
msgid ""
"We can now use `CSVField` to read a single field at a given\n"
"line and position in a CSV file, and return a `FieldError` in case\n"
"of a failure.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:761
#, no-wrap
msgid ""
"readField : CSVField a => (line, column : Nat) -> String -> Either CSVError "
"a\n"
"readField line col str =\n"
"  maybe (Left $ FieldError line col str) Right (read str)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:772
#, no-wrap
msgid ""
"If we know in advance the number of fields we need to read,\n"
"we can try and convert a list of strings to a `Vect` of\n"
"the given length. This facilitates reading record values of\n"
"a known number of fields, as we get the correct number\n"
"of string variables when pattern matching on the vector:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:773
#, no-wrap
msgid ""
"toVect : (n : Nat) -> (line, col : Nat) -> List a -> Either CSVError (Vect n "
"a)\n"
"toVect 0     line _   []        = Right []\n"
"toVect 0     line col _         = Left (ExpectedEndOfInput line col)\n"
"toVect (S k) line col []        = Left (UnexpectedEndOfInput line col)\n"
"toVect (S k) line col (x :: xs) = (x ::) <$> toVect k line (S col) xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:783
#, no-wrap
msgid ""
"Finally, we can implement function `readUser` to try and convert\n"
"a single line in a CSV-file to a value of type `User`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:784
#, no-wrap
msgid ""
"readUser' : (line : Nat) -> List String -> Either CSVError User\n"
"readUser' line ss = do\n"
"  [fn,ln,a,em,g,pw] <- toVect 6 line 0 ss\n"
"  [| MkUser (readField line 1 fn)\n"
"            (readField line 2 ln)\n"
"            (readField line 3 a)\n"
"            (readField line 4 em)\n"
"            (readField line 5 g)\n"
"            (readField line 6 pw) |]\n"
"\n"
"readUser : (line : Nat) -> String -> Either CSVError User\n"
"readUser line = readUser' line . forget . split (',' ==)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:800 ../src/Tutorial/Traverse.md:122
#, no-wrap
msgid "Let's give this a go at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:801
#, no-wrap
msgid ""
"Tutorial.Functor> readUser 1 \"Joe,Foo,46,j@f.ch,m,pw1234567\"\n"
"Right (MkUser (MkName \"Joe\") (MkName \"Foo\")\n"
"  (Just 46) (MkEmail \"j@f.ch\") Male (MkPassword \"pw1234567\"))\n"
"Tutorial.Functor> readUser 7 \"Joe,Foo,46,j@f.ch,m,shortPW\"\n"
"Left (FieldError 7 6 \"shortPW\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:816
#, no-wrap
msgid ""
"Note, how in the implementation of `readUser'` we used\n"
"an idiom bracket to map a function of six arguments (`MkUser`)\n"
"over six values of type `Either CSVError`. This will automatically\n"
"succeed, if and only if all of the parsings have\n"
"succeeded. It would have been notoriously cumbersome resulting\n"
"in much less readable code to implement\n"
"`readUser'` with a succession of six nested pattern matches.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:819
#, no-wrap
msgid ""
"However, the idiom bracket above looks still quite repetitive.\n"
"Surely, we can do better?\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Functor.md:820
#, no-wrap
msgid "A Case for Heterogeneous Lists"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:827
#, no-wrap
msgid ""
"It is time to learn about a family of types, which can\n"
"be used as a generic representation for record types, and\n"
"which will allow us to represent and read rows in\n"
"heterogeneous tables with a minimal amount of code: Heterogeneous\n"
"lists.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:828
#, no-wrap
msgid ""
"namespace HList\n"
"  public export\n"
"  data HList : (ts : List Type) -> Type where\n"
"    Nil  : HList Nil\n"
"    (::) : (v : t) -> (vs : HList ts) -> HList (t :: ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:841
#, no-wrap
msgid ""
"A heterogeneous list is a list type indexed over a *list of types*.\n"
"This allows us to at each position store a value of the\n"
"type at the same position in the list index. For instance,\n"
"here is a variant, which stores three values of types\n"
"`Bool`, `Nat`, and `Maybe String` (in that order):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:842
#, no-wrap
msgid ""
"hlist1 : HList [Bool, Nat, Maybe String]\n"
"hlist1 = [True, 12, Nothing]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:854
#, no-wrap
msgid ""
"You could argue that heterogeneous lists are just tuples\n"
"storing values of the given types. That's right, of course,\n"
"however, as you'll learn the hard way in the exercises,\n"
"we can use the list index to perform compile-time computations\n"
"on `HList`, for instance when concatenating two such lists\n"
"to keep track of the types stored in the result at the\n"
"same time.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:859
#, no-wrap
msgid ""
"But first, we'll make use of `HList` as a means to\n"
"concisely parse CSV-lines. In order to do that, we\n"
"need to introduce a new interface for types corresponding\n"
"to whole lines in a CSV-file:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:860
#, no-wrap
msgid ""
"interface CSVLine a where\n"
"  decodeAt : (line, col : Nat) -> List String -> Either CSVError a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:871
#, no-wrap
msgid ""
"We'll now write two implementations of `CSVLine` for `HList`:\n"
"One for the `Nil` case, which will succeed if and only if\n"
"the current list of strings is empty. The other for the *cons*\n"
"case, which will try and read a single field from the head\n"
"of the list and the remainder from its tail. We use\n"
"again an idiom bracket to concatenate the results:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:872
#, no-wrap
msgid ""
"CSVLine (HList []) where\n"
"  decodeAt _ _ [] = Right Nil\n"
"  decodeAt l c _  = Left (ExpectedEndOfInput l c)\n"
"\n"
"CSVField t => CSVLine (HList ts) => CSVLine (HList (t :: ts)) where\n"
"  decodeAt l c []        = Left (UnexpectedEndOfInput l c)\n"
"  decodeAt l c (s :: ss) = [| readField l c s :: decodeAt l (S c) ss |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:887
#, no-wrap
msgid ""
"And that's it! All we need to add is two utility function\n"
"for decoding whole lines before they have been split into\n"
"tokens, one of which is specialized to `HList` and takes an\n"
"erased list of types as argument to make it more convenient to\n"
"use at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:888
#, no-wrap
msgid ""
"decode : CSVLine a => (line : Nat) -> String -> Either CSVError a\n"
"decode line = decodeAt line 1 . forget . split (',' ==)\n"
"\n"
"hdecode :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => (line : Nat)\n"
"        -> String\n"
"        -> Either CSVError (HList ts)\n"
"hdecode _ = decode\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:902
#, no-wrap
msgid ""
"It's time to reap the fruits of our labour and give this a go at\n"
"the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:903
#, no-wrap
msgid ""
"Tutorial.Functor> hdecode [Bool,Nat,Double] 1 \"f,100,12.123\"\n"
"Right [False, 100, 12.123]\n"
"Tutorial.Functor> hdecode [Name,Name,Gender] 3 \"Idris,,f\"\n"
"Left (FieldError 3 2 \"\")\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:910
#, no-wrap
msgid "Applicative Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:914
#, no-wrap
msgid ""
"Again, `Applicative` implementations must follow certain\n"
"laws. Here they are:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:917
msgid ""
"`pure id <*> fa = fa`: Lifting and applying the identity function has no "
"visible effect."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:922
msgid ""
"`[| f . g |] <*> v = f <*> (g <*> v)`: I must not matter, whether we compose "
"our functions first and then apply them, or whether we apply our functions "
"first and then compose them."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:925
#, no-wrap
msgid ""
"  The above might be hard to understand, so here\n"
"  they are again with explicit types and implementations:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:926
#, no-wrap
msgid ""
"  compL : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compL f g v = [| f . g |] <*> v\n"
"\n"
"  compR : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compR f g v = f <*> (g <*> v)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:936
#, no-wrap
msgid ""
"  The second applicative law states, that the two implementations\n"
"  `compL` and `compR` should behave identically.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:939
msgid ""
"`pure f <*> pure x = pure (f x)`. This is also called the *homomorphism* "
"law. It should be pretty self-explaining."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:942
msgid "`f <*> pure v = pure ($ v) <*> f`. This is called the law of *interchange*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:944
#, no-wrap
msgid "  This should again be explained with a concrete example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:945
#, no-wrap
msgid ""
"  interL : Maybe (a -> b) -> a -> Maybe b\n"
"  interL f v = f <*> pure v\n"
"\n"
"  interR : Maybe (a -> b) -> a -> Maybe b\n"
"  interR f v = pure ($ v) <*> f\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:957
#, no-wrap
msgid ""
"  Note, that `($ v)` has type `(a -> b) -> b`, so this\n"
"  is a function type being applied to `f`, which has\n"
"  a function of type `a -> b` wrapped in a `Maybe`\n"
"  context.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:961
#, no-wrap
msgid ""
"  The law of interchange states that it must not matter\n"
"  whether we apply a pure value from the left or\n"
"  right of the *apply* operator.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:965
msgid "Implement `Applicative'` for `Either e` and `Identity`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:970
msgid ""
"Implement `Applicative'` for `Vect n`. Note: In order to implement `pure`, "
"the length must be known at runtime.  This can be done by passing it as an "
"unerased implicit to the interface implementation:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:971
#, no-wrap
msgid "   implementation {n : _} -> Applicative' (Vect n) where\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:977
msgid ""
"Implement `Applicative'` for `Pair e`, with `e` having a `Monoid` "
"constraint."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:980
msgid ""
"Implement `Applicative` for `Const e`, with `e` having a `Monoid` "
"constraint."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:985
msgid ""
"Implement `Applicative` for `Validated e`, with `e` having a `Semigroup` "
"constraint. This will allow us to use `(<+>)` to accumulate errors in case "
"of two `Invalid` values in the implementation of *apply*."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:990
msgid ""
"Add an additional data constructor of type `CSVError -> CSVError -> "
"CSVError` to `CSVError` and use this to implement `Semigroup` for "
"`CSVError`."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Functor.md:994
msgid ""
"Refactor our CSV-parsers and all related functions so that they return "
"`Validated` instead of `Either`. This will only work, if you solved exercise "
"6."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1000
#, no-wrap
msgid ""
"   Two things to note: You will have to adjust very little of\n"
"   the existing code, as we can still use applicative syntax\n"
"   with `Validated`. Also, with this change, we enhanced our CSV-parsers\n"
"   with the ability of error accumulation. Here are some examples\n"
"   from a REPL session:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1001
#, no-wrap
msgid ""
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"t,12,f\"\n"
"   Valid [True, 12, Female]\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,f\"\n"
"   Invalid (App (FieldError 1 1 \"o\") (FieldError 1 2 \"-12\"))\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,foo\"\n"
"   Invalid (App (FieldError 1 1 \"o\")\n"
"     (App (FieldError 1 2 \"-12\") (FieldError 1 3 \"foo\")))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1015
#, no-wrap
msgid ""
"   Behold the power of applicative functors and heterogeneous lists: With\n"
"   only a few lines of code we wrote a pure, type-safe, and total\n"
"   parser with error accumulation for lines in CSV-files, which is\n"
"   very convenient to use at the same time!\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Functor.md:1018
msgid ""
"Since we introduced heterogeneous lists in this chapter, it would be a pity "
"not to experiment with them a little."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1027
#, no-wrap
msgid ""
"   This exercise is meant to sharpen your skills in type wizardry.\n"
"   It therefore comes with very few hints. Try to decide yourself\n"
"   what behavior you'd expect from a given function, how to express\n"
"   this in the types, and how to implement it afterwards.\n"
"   If your types are correct and precise enough, the implementations\n"
"   will almost come for free. Don't give up too early if you get stuck.\n"
"   Only if you truly run out of ideas should you have a glance\n"
"   at the solutions (and then, only at the types at first!)\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Functor.md:1029
msgid "Implement `head` for `HList`."
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Functor.md:1031
msgid "Implement `tail` for `HList`."
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Functor.md:1033
msgid "Implement `(++)` for `HList`."
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/Functor.md:1037
msgid ""
"Implement `index` for `HList`. This might be harder than the other three.  "
"Go back and look how we implemented `indexList` in an [earlier "
"exercise](Dependent.md) and start from there."
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/Functor.md:1043
msgid ""
"Package *contrib*, which is part of the Idris project, provides "
"`Data.HVect.HVect`, a data type for heterogeneous vectors. The only "
"difference to our own `HList` is, that `HVect` is indexed over a vector of "
"types instead of a list of types. This makes it easier to express certain "
"operations at the type level."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1046
#, no-wrap
msgid ""
"      Write your own implementation of `HVect` together with functions\n"
"      `head`, `tail`, `(++)`, and `index`.\n"
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/Functor.md:1050
msgid ""
"For a real challenge, try implementing a function for transposing a `Vect m "
"(HVect ts)`. You'll first have to be creative about how to even express this "
"in the types."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1057
#, no-wrap
msgid ""
"      Note: In order to implement this, you'll need to pattern match\n"
"      on an erased argument in at least one case to help Idris with\n"
"      type inference. Pattern matching on erased arguments is forbidden\n"
"      (they are erased after all, so we can't inspect them at runtime),\n"
"      *unless* the structure of the value being matched on can be derived\n"
"      from another, un-erased argument.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1061
#, no-wrap
msgid ""
"      Also, don't worry if you get stuck on this one. It took me several\n"
"      tries to figure it out. But I enjoyed the experience, so I just "
"*had*\n"
"      to include it here. :-)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1065
#, no-wrap
msgid ""
"      Note, however, that such a function might be useful when working "
"with\n"
"      CSV-files, as it allows us to convert a table represented as\n"
"      rows (a vector of tuples) to one represented as columns (a tuple of "
"vectors).\n"
msgstr ""

#. type: Bullet: '9. '
#: ../src/Tutorial/Functor.md:1069
msgid ""
"Show, that the composition of two applicative functors is again an "
"applicative functor by implementing `Applicative` for `Comp f g`."
msgstr ""

#. type: Bullet: '10. '
#: ../src/Tutorial/Functor.md:1073
msgid ""
"Show, that the product of two applicative functors is again an applicative "
"functor by implementing `Applicative` for `Prod f g`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functor.md:1074
#, no-wrap
msgid "Monad"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1081
#, no-wrap
msgid ""
"Finally, `Monad`. A lot of ink has been spilled about this one.\n"
"However, after what we already saw in the [chapter about `IO`](IO.md),\n"
"there is not much left to discuss here. `Monad` extends\n"
"`Applicative` and adds two new related functions: The *bind*\n"
"operator (`(>>=)`) and function `join`. Here is its definition:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1082
#, no-wrap
msgid ""
"interface Applicative' m => Monad' m where\n"
"  bind  : m a -> (a -> m b) -> m b\n"
"  join' : m (m a) -> m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1091
#, no-wrap
msgid ""
"Implementers of `Monad` are free to choose to either implement\n"
"`(>>=)` or `join` or both. You will show in an exercise, how\n"
"`join` can be implemented in terms of *bind* and vice versa.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1099
#, no-wrap
msgid ""
"The big difference between `Monad` and `Applicative` is, that the\n"
"former allows a computation to depend on the result of an\n"
"earlier computation. For instance, we could decide based on\n"
"a string read from standard input whether to delete a file\n"
"or play a song. The result of the first `IO` action\n"
"(reading some user input) will affect, which `IO` action to run next.\n"
"This is not possible with the *apply* operator:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1100
#, no-wrap
msgid "(<*>) : IO (a -> b) -> IO a -> IO b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1115
#, no-wrap
msgid ""
"The two `IO` actions have already been decided on when they\n"
"are being passed as arguments to `(<*>)`. The result of the first\n"
"cannot - in the general case - affect which computation to\n"
"run in the second. (Actually, with `IO` this would theoretically be\n"
"possible via side effects: The first action could write some\n"
"command to a file or overwrite some mutable state, and the\n"
"second action could read from that file or state, thus\n"
"deciding on the next thing to do. But this is a speciality\n"
"of `IO`, not of applicative functors in general. If the functor in\n"
"question was `Maybe`, `List`, or `Vector`, no such thing\n"
"would be possible.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1121
#, no-wrap
msgid ""
"Let's demonstrate the difference with an example. Assume\n"
"we'd like to enhance our CSV-reader with the ability to\n"
"decode a line of tokens to a sum type. For instance,\n"
"we'd like to decode CRUD requests from the lines of a\n"
"CSV-file:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1122
#, no-wrap
msgid ""
"data Crud : (i : Type) -> (a : Type) -> Type where\n"
"  Create : (value : a) -> Crud i a\n"
"  Update : (id : i) -> (value : a) -> Crud i a\n"
"  Read   : (id : i) -> Crud i a\n"
"  Delete : (id : i) -> Crud i a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1134
#, no-wrap
msgid ""
"We need a way to on each line decide, which data constructor\n"
"to choose for our decoding. One way to do this is to\n"
"put the name of the data constructor (or some other\n"
"tag of identification) in the first column of the CSV-file:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1135
#, no-wrap
msgid ""
"hlift : (a -> b) -> HList [a] -> b\n"
"hlift f [x] = f x\n"
"\n"
"hlift2 : (a -> b -> c) -> HList [a,b] -> c\n"
"hlift2 f [x,y] = f x y\n"
"\n"
"decodeCRUD :  CSVField i\n"
"           => CSVField a\n"
"           => (line : Nat)\n"
"           -> (s    : String)\n"
"           -> Either CSVError (Crud i a)\n"
"decodeCRUD l s =\n"
"  let h ::: t = split (',' ==) s\n"
"   in do\n"
"     MkName n <- readField l 1 h\n"
"     case n of\n"
"       \"Create\" => hlift  Create  <$> decodeAt l 2 t\n"
"       \"Update\" => hlift2 Update  <$> decodeAt l 2 t\n"
"       \"Read\"   => hlift  Read    <$> decodeAt l 2 t\n"
"       \"Delete\" => hlift  Delete  <$> decodeAt l 2 t\n"
"       _        => Left (FieldError l 1 n)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1164
#, no-wrap
msgid ""
"I added two utility function for helping with type inference\n"
"and to get slightly nicer syntax. The important thing to note\n"
"is, how we pattern match on the result of the first\n"
"parsing function to decide on the data constructor\n"
"and thus the next parsing function to use.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1166
#, no-wrap
msgid "Here's how this works at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1167
#, no-wrap
msgid ""
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Create,jon@doe.ch\"\n"
"Right (Create (MkEmail \"jon@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 "
"\"Update,12,jane@doe.ch\"\n"
"Right (Update 12 (MkEmail \"jane@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Delete,jon@doe.ch\"\n"
"Left (FieldError 1 2 \"jon@doe.ch\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1184
#, no-wrap
msgid ""
"To conclude, `Monad`, unlike `Applicative`, allows us to\n"
"chain computations sequentially, where intermediary\n"
"results can affect the behavior of later computations.\n"
"So, if you have n unrelated effectful computations and want\n"
"to combine them under a pure, n-ary function, `Applicative`\n"
"will be sufficient. If, however, you want to decide\n"
"based on the result of an effectful computation what\n"
"computation to run next, you need a `Monad`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1190
#, no-wrap
msgid ""
"Note, however, that `Monad` has one important drawback\n"
"compared to `Applicative`: In general, monads don't compose.\n"
"For instance, there is no `Monad` instance for `Either e . IO`.\n"
"We will later learn about monad transformers, which can\n"
"be composed with other monads.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:1191
#, no-wrap
msgid "Monad Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1194
#, no-wrap
msgid "Without further ado, here are the laws for `Monad`:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1198
msgid ""
"`ma >>= pure = ma` and `pure v >>= f = f v`.  These are monad's identity "
"laws. Here they are as concrete examples:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1199
#, no-wrap
msgid ""
"  id1L : Maybe a -> Maybe a\n"
"  id1L ma = ma >>= pure\n"
"\n"
"  id2L : a -> (a -> Maybe b) -> Maybe b\n"
"  id2L v f = pure v >>= f\n"
"\n"
"  id2R : a -> (a -> Maybe b) -> Maybe b\n"
"  id2R v f = f v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1212
#, no-wrap
msgid ""
"  These two laws state that `pure` should behave\n"
"  neutrally w.r.t. *bind*.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1218
msgid ""
"`(m >>= f) >>= g = m >>= (f >=> g)`.  This is the law of associativity for "
"monad.  You might not have seen the second operator `(>=>)`.  It can be used "
"to sequence effectful computations and has the following type:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1219
#, no-wrap
msgid ""
"  Tutorial.Functor> :t (>=>)\n"
"  Prelude.>=> : Monad m => (a -> m b) -> (b -> m c) -> a -> m c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1229
#, no-wrap
msgid ""
"The above are the *official* monad laws. However, we need to\n"
"consider a third one, given that in Idris (and Haskell)\n"
"`Monad` extends `Applicative`: As `(<*>)` can be implemented\n"
"in terms of `(>>=)`, the actual implementation of `(<*>)`\n"
"must behave the same as the implementation in terms of `(>>=)`:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1231
msgid "`mf <*> ma = mf >>= (\\fun => map (fun $) ma)`."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:1237
msgid ""
"`Applicative` extends `Functor`, because every `Applicative` is also a "
"`Functor`. Proof this by implementing `map` in terms of `pure` and `(<*>)`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:1241
msgid ""
"`Monad` extends `Applicative`, because every `Monad` is also an "
"`Applicative`. Proof this by implementing `(<*>)` in terms of `(>>=)` and "
"`pure`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:1244
msgid ""
"Implement `(>>=)` in terms of `join` and other functions in the `Monad` "
"hierarchy."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:1247
msgid ""
"Implement `join` in terms of `(>>=)` and other functions in the `Monad` "
"hierarchy."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:1250
msgid "There is no lawful `Monad` implementation for `Validated e`.  Why?"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:1256
msgid ""
"In this slightly extended exercise, we are going to simulate CRUD operations "
"on a data store. We will use a mutable reference (imported from `Data.IORef` "
"from the *base* library)  holding a list of `User`s paired with a unique ID "
"of type `Nat` as our user data base:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1257
#, no-wrap
msgid ""
"   DB : Type\n"
"   DB = IORef (List (Nat,User))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1267
#, no-wrap
msgid ""
"   Most operations on a database come with a risk of failure:\n"
"   When we try to update or delete a user, the entry in question\n"
"   might no longer be there. When we add a new user, a user\n"
"   with the given email address might already exist. Here is\n"
"   a custom error type to deal with this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1268
#, no-wrap
msgid ""
"   data DBError : Type where\n"
"     UserExists        : Email -> Nat -> DBError\n"
"     UserNotFound      : Nat -> DBError\n"
"     SizeLimitExceeded : DBError\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1277
#, no-wrap
msgid ""
"   In general, our functions will therefore have a\n"
"   type similar to the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1278
#, no-wrap
msgid "   someDBProg : arg1 -> arg2 -> DB -> IO (Either DBError a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1284
#, no-wrap
msgid ""
"   We'd like to abstract over this, by introducing a new wrapper\n"
"   type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1285
#, no-wrap
msgid ""
"   record Prog a where\n"
"     constructor MkProg\n"
"     runProg : DB -> IO (Either DBError a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1294
#, no-wrap
msgid ""
"   We are now ready to write us some utility functions. Make sure\n"
"   to follow the following business rules when implementing the\n"
"   functions below:\n"
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1297
msgid ""
"Email addresses in the DB must be unique. (Consider implementing `Eq Email` "
"to verify this)."
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1299
msgid "The size limit of 1000 entries must not be exceeded."
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1303
msgid ""
"Operations trying to lookup a user by their ID must fail with `UserNotFound` "
"in case no entry was found in the DB."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1308
#, no-wrap
msgid ""
"   You'll need the following functions from `Data.IORef` when working\n"
"   with mutable references: `newIORef`, `readIORef`, and `writeIORef`.\n"
"   In addition, functions `Data.List.lookup` and `Data.List.find` might\n"
"   be useful to implement some of the functions below.\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Functor.md:1310
msgid "Implement interfaces `Functor`, `Applicative`, and `Monad` for `Prog`."
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Functor.md:1312
msgid "Implement interface `HasIO` for `Prog`."
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Functor.md:1314
msgid "Implement the following utility functions:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1317
#, no-wrap
msgid ""
"      ```idris\n"
"      throw : DBError -> Prog a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1319
#, no-wrap
msgid "      getUsers : Prog (List (Nat,User))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1322
#, no-wrap
msgid ""
"      -- check the size limit!\n"
"      putUsers : List (Nat,User) -> Prog ()\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1326
#, no-wrap
msgid ""
"      -- implement this in terms of `getUsers` and `putUsers`\n"
"      modifyDB : (List (Nat,User) -> List (Nat,User)) -> Prog ()\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/Functor.md:1330
msgid ""
"Implement function `lookupUser`. This should fail with an appropriate error, "
"if a user with the given ID cannot be found."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1334
#, no-wrap
msgid ""
"      ```idris\n"
"      lookupUser : (id : Nat) -> Prog User\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/Functor.md:1339
msgid ""
"Implement function `deleteUser`. This should fail with an appropriate error, "
"if a user with the given ID cannot be found. Make use of `lookupUser` in "
"your implementation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1343
#, no-wrap
msgid ""
"      ```idris\n"
"      deleteUser : (id : Nat) -> Prog ()\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/Functor.md:1349
msgid ""
"Implement function `addUser`. This should fail, if a user with the given "
"`Email` already exists, or if the data banks size limit of 1000 entries is "
"exceeded.  In addition, this should create and return a unique ID for the "
"new user entry."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1353
#, no-wrap
msgid ""
"      ```idris\n"
"      addUser : (new : User) -> Prog Nat\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   7. '
#: ../src/Tutorial/Functor.md:1358
msgid ""
"Implement function `updateUser`. This should fail, if the user in question "
"cannot be found or a user with the updated user's `Email` already exists.  "
"The returned value should be the updated user."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1362
#, no-wrap
msgid ""
"      ```idris\n"
"      updateUser : (id : Nat) -> (mod : User -> User) -> Prog User\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   8. '
#: ../src/Tutorial/Functor.md:1366
msgid ""
"Data type `Prog` is actually too specific. We could just as well abstract "
"over the error type and the `DB` environment:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1372
#, no-wrap
msgid ""
"      ```idris\n"
"      record Prog' env err a where\n"
"        constructor MkProg'\n"
"        runProg' : env -> IO (Either err a)\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1378
#, no-wrap
msgid ""
"      Verify, that all interface implementations you wrote\n"
"      for `Prog` can be used verbatim to implement the same\n"
"      interfaces for `Prog' env err`. The same goes for\n"
"      `throw` with only a slight adjustment in the function's\n"
"      type.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functor.md:1379
#, no-wrap
msgid "Background and further Reading"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1388
#, no-wrap
msgid ""
"Concepts like *functor* and *monad* have their origin in *category "
"theory*,\n"
"a branch of mathematics. That is also where their laws come from.\n"
"Category theory was found to have applications in\n"
"programming language theory, especially functional programming.\n"
"It is a highly abstract topic, but there is a pretty accessible\n"
"introduction for programmers, written by\n"
"[Bartosz "
"Milewski](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1394
#, no-wrap
msgid ""
"The usefulness of applicative functors as a middle ground between\n"
"functor and monad was discovered several years after monads had\n"
"already been in use in Haskell. They where introduced in the\n"
"article [*Applicative Programming with "
"Effects*](https://www.staff.city.ac.uk/~ross/papers/Applicative.html),\n"
"which is freely available online and a highly recommended read.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1401
msgid ""
"Interfaces `Functor`, `Applicative`, and `Monad` abstract over programming "
"patterns that come up when working with type constructors of type `Type -> "
"Type`. Such data types are also referred to as *values in a context*, or "
"*effectful computations*."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1404
msgid ""
"`Functor` allows us to *map* over values in a context without affecting the "
"context's underlying structure."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1407
msgid ""
"`Applicative` allows us to apply n-ary functions to n effectful computations "
"and to lift pure values into a context."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1411
msgid ""
"`Monad` allows us to chain effectful computations, where the intermediary "
"results can affect, which computation to run further down the chain."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1415
msgid ""
"Unlike `Monad`, `Functor` and `Applicative` compose: The product and "
"composition of two functors or applicatives are again functors or "
"applicatives, respectively."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1419
msgid ""
"Idris provides syntactic sugar for working with some of the interfaces "
"presented here: Idiom brackets for `Applicative`, *do blocks* and the bang "
"operator for `Monad`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:1420 ../src/Tutorial/Intro.md:430
#, no-wrap
msgid "What's next?"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1425
#, no-wrap
msgid ""
"In the [next chapter](Folds.md) we get to learn more about\n"
"recursion, totality checking, and an interface for\n"
"collapsing container types: `Foldable`.\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Interfaces.md:1
#, no-wrap
msgid "Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:9
#, no-wrap
msgid ""
"Function overloading - the definition of functions\n"
"with the same name but different implementations - is a concept\n"
"found in many programming languages. Idris natively supports overloading\n"
"of functions: Two functions with the same name can be defined in\n"
"different modules or namespaces, and Idris will try to disambiguate\n"
"between these based on the types involved. Here is an example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:10
#, no-wrap
msgid ""
"module Tutorial.Interfaces\n"
"\n"
"%default total\n"
"\n"
"namespace Bool\n"
"  export\n"
"  size : Bool -> Integer\n"
"  size True  = 1\n"
"  size False = 0\n"
"\n"
"namespace Integer\n"
"  export\n"
"  size : Integer -> Integer\n"
"  size = id\n"
"\n"
"namespace List\n"
"  export\n"
"  size : List a -> Integer\n"
"  size = cast . length\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:35
#, no-wrap
msgid ""
"Here, we defined three different functions\n"
"called `size`, each in its own namespace. We can disambiguate between\n"
"these by prefixing them with their namespace:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:36
#, no-wrap
msgid ""
"Tutorial.Interfaces> :t Bool.size\n"
"Tutorial.Interfaces.Bool.size : Bool -> Integer\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:42
#, no-wrap
msgid "However, this is usually not necessary:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:43
#, no-wrap
msgid ""
"mean : List Integer -> Integer\n"
"mean xs = sum xs `div` size xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:51
#, no-wrap
msgid ""
"As you can see, Idris can disambiguate between the different\n"
"`size` functions, since `xs` is of type `List Integer`, which\n"
"unifies only with `List a`, the argument type of `List.size`.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:52
#, no-wrap
msgid "Interface Basics"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:57
#, no-wrap
msgid ""
"While function overloading as described above\n"
"works well, there are use cases, where\n"
"this form of overloaded functions leads to a lot of code duplication.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:61
#, no-wrap
msgid ""
"As an example, consider a function `cmp` (short for *compare*, which is\n"
"already exported by the *Prelude*), for describing an ordering\n"
"for the values of type `String`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:62
#, no-wrap
msgid "cmp : String -> String -> Ordering\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:70
#, no-wrap
msgid ""
"We'd also like to have similar functions for many other data types.\n"
"Function overloading allows us to do just that, but `cmp` is not an\n"
"isolated piece of functionality. From it, we can derive functions\n"
"like `greaterThan'`, `lessThan'`, `minimum'`, `maximum'`, and many others:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:71
#, no-wrap
msgid ""
"lessThan' : String -> String -> Bool\n"
"lessThan' s1 s2 = LT == cmp s1 s2\n"
"\n"
"greaterThan' : String -> String -> Bool\n"
"greaterThan' s1 s2 = GT == cmp s1 s2\n"
"\n"
"minimum' : String -> String -> String\n"
"minimum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum' : String -> String -> String\n"
"maximum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:94
#, no-wrap
msgid ""
"We'd need to implement all of these again for the other types with a `cmp`\n"
"function, and most if not all of these implementations would be identical\n"
"to the ones written above. That's a lot of code repetition.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:99
#, no-wrap
msgid ""
"One way to solve this is to use higher-order functions.\n"
"For instance, we could define function `minimumBy`, which takes\n"
"a comparison function as its first argument and returns the smaller\n"
"of the two remaining arguments:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:100
#, no-wrap
msgid ""
"minimumBy : (a -> a -> Ordering) -> a -> a -> a\n"
"minimumBy f a1 a2 =\n"
"  case f a1 a2 of\n"
"    LT => a1\n"
"    _  => a2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:114
#, no-wrap
msgid ""
"This solution is another proof of how higher-order functions\n"
"allow us to reduce code duplication. However, the need to explicitly\n"
"pass around the comparison function all the time\n"
"can get tedious as well.\n"
"It would be nice, if we could teach Idris to come up with\n"
"such a function on its own.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:116
#, no-wrap
msgid "Interfaces solve exactly this issue. Here's an example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:117
#, no-wrap
msgid ""
"interface Comp a where\n"
"  comp : a -> a -> Ordering\n"
"\n"
"implementation Comp Bits8 where\n"
"  comp = compare\n"
"\n"
"implementation Comp Bits16 where\n"
"  comp = compare\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:133
#, no-wrap
msgid ""
"The code above defines *interface* `Comp` providing\n"
"function `comp` for calculating the\n"
"ordering for two values of a type `a`, followed by two *implementations*\n"
"of this interface for types `Bits8` and `Bits16`. Note, that the\n"
"`implementation` keyword is optional.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:137
#, no-wrap
msgid ""
"The `comp` implementations for `Bits8` and `Bits16` both use\n"
"function `compare`, which is part of a similar interface\n"
"from the *Prelude* called `Ord`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:139
#, no-wrap
msgid "The next step is to look at the type of `comp` at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:140
#, no-wrap
msgid ""
"Tutorial.Interfaces> :t comp\n"
"Tutorial.Interfaces.comp : Comp a => a -> a -> Ordering\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:154
#, no-wrap
msgid ""
"The interesting part in the type signature of `comp` is\n"
"the initial `Comp a =>` argument. Here, `Comp` is a *constraint* on\n"
"type parameter `a`. This signature can be read as:\n"
"\"For any type `a`, given an implementation\n"
"of interface `Comp` for `a`, we can compare two values\n"
"of type `a` and return an `Ordering` for these.\"\n"
"Whenever we invoke `comp`, we expect Idris to come up with a\n"
"value of type `Comp a` on its own, hence the new `=>` arrow.\n"
"If Idris fails to do so, it will answer with a type error.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:158
#, no-wrap
msgid ""
"We can now use `comp` in the implementations of related functions.\n"
"All we have to do is to also prefix these derived functions\n"
"with a `Comp` constraint:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:159
#, no-wrap
msgid ""
"lessThan : Comp a => a -> a -> Bool\n"
"lessThan s1 s2 = LT == comp s1 s2\n"
"\n"
"greaterThan : Comp a => a -> a -> Bool\n"
"greaterThan s1 s2 = GT == comp s1 s2\n"
"\n"
"minimum : Comp a => a -> a -> a\n"
"minimum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum : Comp a => a -> a -> a\n"
"maximum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:185
#, no-wrap
msgid ""
"Note, how the definition of `minimum` is almost identical\n"
"to `minimumBy`. The only difference being that in case of\n"
"`minimumBy` we had to pass the comparison function as an\n"
"explicit argument, while for `minimum` it is provided as\n"
"part of the `Comp` implementation, which is passed around\n"
"by Idris for us.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:188
#, no-wrap
msgid ""
"Thus, we have defined all these utility functions once and for\n"
"all for every type with an implementation of interface `Comp`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:195
#, no-wrap
msgid ""
"1. Implement function `anyLarger`, which should return `True`,\n"
"if and only if a list of values contains at least one element larger\n"
"than a given reference value. Use interface `Comp` in your\n"
"implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:200
#, no-wrap
msgid ""
"2. Implement function `allLarger`, which should return `True`,\n"
"if and only if a list of values contains *only* elements larger\n"
"than a given reference value. Note, that this is trivially true\n"
"for the empty list. Use interface `Comp` in your implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:206
#, no-wrap
msgid ""
"3. Implement function `maxElem`, which tries to extract the\n"
"largest element from a list of values with a `Comp` implementation.\n"
"Likewise for `minElem`, which tries to extract the smallest element.\n"
"Note, that the possibility of the list being empty must be considered\n"
"when deciding on the output type.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:210
#, no-wrap
msgid ""
"4. Define an interface `Concat` for values like lists or\n"
"strings, which can be concatenated. Provide implementations\n"
"for lists and strings.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:215
#, no-wrap
msgid ""
"5. Implement function `concatList` for concatenating the\n"
"values in a list holding values with a `Concat` implementation.\n"
"Make sure to reflect the possibility of the list being empty in your\n"
"output type.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:216
#, no-wrap
msgid "More about Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:224
#, no-wrap
msgid ""
"In the last section, we learned about the very basics\n"
"of interfaces: Why they are useful and how to define and\n"
"implement them.\n"
"In this section, we will learn about some slightly\n"
"advanced concepts: Extending interfaces, interfaces with\n"
"constraints, and default implementations.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:225
#, no-wrap
msgid "Extending Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:233
#, no-wrap
msgid ""
"Some interfaces form a kind of hierarchy. For instance, for\n"
"the `Concat` interface used in exercise 4, there might\n"
"be a child interface called `Empty`, for those types,\n"
"which have a neutral element with relation to concatenation.\n"
"In such a case, we make an implementation of `Concat` a\n"
"prerequisite for implementing `Empty`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:234
#, no-wrap
msgid ""
"interface Concat a where\n"
"  concat : a -> a -> a\n"
"\n"
"implementation Concat String where\n"
"  concat = (++)\n"
"\n"
"interface Concat a => Empty a where\n"
"  empty : a\n"
"\n"
"implementation Empty String where\n"
"  empty = \"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:254
#, no-wrap
msgid ""
"`Concat a => Empty a` should be read as: \"An implementation\n"
"of `Concat` for type `a` is a *prerequisite* for there being\n"
"an implementation of `Empty` for `a`.\"\n"
"But this also means that, whenever we have an implementation\n"
"of interface `Empty`, we *must* also have an implementation of `Concat`\n"
"and can invoke the corresponding functions:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:255
#, no-wrap
msgid ""
"concatListE : Empty a => List a -> a\n"
"concatListE []        = empty\n"
"concatListE (x :: xs) = concat x (concatListE xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:264
#, no-wrap
msgid ""
"Note, how in the type of `concatListE` we only used an `Empty`\n"
"constraint, and how in the implementation we were still able\n"
"to invoke both `empty` and `concat`.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:265
#, no-wrap
msgid "Constrained Implementations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:273
#, no-wrap
msgid ""
"Sometimes, it is only possible to implement an interface\n"
"for a generic type, if its type parameters implement\n"
"this interface as well. For instance, implementing interface `Comp`\n"
"for `Maybe a` makes sense only if type `a` itself implements\n"
"`Comp`. We can constrain interface implementations with\n"
"the same syntax we use for constrained functions:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:274
#, no-wrap
msgid ""
"implementation Comp a => Comp (Maybe a) where\n"
"  comp Nothing  Nothing  = EQ\n"
"  comp (Just _) Nothing  = GT\n"
"  comp Nothing  (Just _) = LT\n"
"  comp (Just x) (Just y) = comp x y\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:292
#, no-wrap
msgid ""
"This is not the same as extending an interface, although\n"
"the syntax looks very similar. Here, the constraint lies\n"
"on a *type parameter* instead of the full type.\n"
"The last line in the implementation of `Comp (Maybe a)`\n"
"compares the values stored in the two `Just`s. This is\n"
"only possible, if there is a `Comp` implementation for\n"
"these values as well. Go ahead, and remove the `Comp a`\n"
"constraint from the above implementation. Learning to\n"
"read and understand Idris' type errors is important\n"
"for fixing them.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:295
#, no-wrap
msgid ""
"The good thing is, that Idris will solve all these\n"
"constraints for us:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:296
#, no-wrap
msgid ""
"maxTest : Maybe Bits8 -> Ordering\n"
"maxTest = comp (Just 12)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:305
#, no-wrap
msgid ""
"Here, Idris tries to find an implementation for `Comp (Maybe Bits8)`.\n"
"In order to do so, it needs an implementation for `Comp Bits8`.\n"
"Go ahead, and replace `Bits8` in the type of `maxTest` with `Bits64`,\n"
"and have a look at the error message Idris produces.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:306
#, no-wrap
msgid "Default Implementations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:320
#, no-wrap
msgid ""
"Sometimes, we'd like to pack several related functions\n"
"in an interface to allow programmers to implement each\n"
"in the most efficient way, although they *could* be\n"
"implemented in terms of each other. For instance,\n"
"consider an interface `Equals` for comparing two\n"
"values for equality, with functions `eq` returning\n"
"`True` if two values are equal and `neq` returning\n"
"`True` if they are not. Surely, we can implement `neq`\n"
"in terms of `eq`, so most of the time when implementing\n"
"`Equals`, we will only implement the latter.\n"
"In this case, we can give an implementation for `neq`\n"
"already in the definition of `Equals`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:321
#, no-wrap
msgid ""
"interface Equals a where\n"
"  eq : a -> a -> Bool\n"
"\n"
"  neq : a -> a -> Bool\n"
"  neq a1 a2 = not (eq a1 a2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:332
#, no-wrap
msgid ""
"If in an implementation of `Equals` we only implement `eq`,\n"
"Idris will use the default implementation for `neq` as\n"
"shown above:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:333
#, no-wrap
msgid ""
"Equals String where\n"
"  eq = (==)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:340
#, no-wrap
msgid ""
"If on the other hand we'd like to provide explicit implementations\n"
"for both functions, we can do so as well:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:341
#, no-wrap
msgid ""
"Equals Bool where\n"
"  eq True True   = True\n"
"  eq False False = True\n"
"  eq _ _         = False\n"
"\n"
"  neq True  False = True\n"
"  neq False True  = True\n"
"  neq _ _         = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:358
#, no-wrap
msgid ""
"1. Implement interfaces `Equals`, `Comp`, `Concat`, and\n"
"  `Empty` for pairs, constraining your implementations as necessary.\n"
"  (Note, that multiple constraints can be given sequentially like\n"
"  other function arguments: `Comp a => Comp b => Comp (a,b)`.)\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Interfaces.md:361
msgid ""
"Below is an implementation of a binary tree. Implement interfaces `Equals` "
"and `Concat` for this type."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:362
#, no-wrap
msgid ""
"   data Tree : Type -> Type where\n"
"     Leaf : a -> Tree a\n"
"     Node : Tree a -> Tree a -> Tree a\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:368
#, no-wrap
msgid "Interfaces in the *Prelude*"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:374
#, no-wrap
msgid ""
"The Idris *Prelude* provides several interfaces plus implementations\n"
"that are useful in almost every non-trivial program. I'll introduce\n"
"the basic ones here. The more advanced ones will be discussed in later\n"
"chapters.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:378
#, no-wrap
msgid ""
"Most of these interfaces come with associated mathematical laws,\n"
"and implementations are assumed to adhere to these laws. These\n"
"laws will be given here as well.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:379
#, no-wrap
msgid "`Eq`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:389
#, no-wrap
msgid ""
"Probably the most often used interface, `Eq` corresponds to\n"
"interface `Equals` we used above as an example. Instead of\n"
"`eq` and `neq`, `Eq` provides two operators `(==)` and `(/=)`\n"
"for comparing two values of the same type for being equal\n"
"or not. Most of the data types defined in the *Prelude* come\n"
"with an implementation of `Eq`, and whenever programmers define\n"
"their own data types, `Eq` is typically one of the first\n"
"interfaces they implement.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:390
#, no-wrap
msgid "`Eq` Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:393
#, no-wrap
msgid "We expect the following laws to hold for all implementations of `Eq`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:396
#, no-wrap
msgid ""
"* `(==)` is *reflexive*: `x == x = True` for all `x`. This means, that\n"
"every value is equal to itself.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:399
#, no-wrap
msgid ""
"* `(==)` is *symmetric*: `x == y = y == x` for all `x` and `y`.\n"
"This means, that the order of arguments passed to `(==)` does not matter.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:402
#, no-wrap
msgid ""
"* `(==)` is *transitive*: From `x == y = True` and `y == z = True` follows\n"
"`x == z = True`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:405
#, no-wrap
msgid ""
"* `(/=)` is the negation of `(==)`: `x == y = not (x /= y)`\n"
"for all `x` and `y`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:410
#, no-wrap
msgid ""
"In theory, Idris has the power to verify these laws at compile time\n"
"for many non-primitive types. However, out of pragmatism this is not\n"
"required when implementing `Eq`, since writing such proofs can be\n"
"quite involved.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:411
#, no-wrap
msgid "`Ord`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:419
#, no-wrap
msgid ""
"The pendant to `Comp` in the *Prelude* is interface `Ord`. In addition\n"
"to `compare`, which is identical to our own `comp` it provides comparison\n"
"operators `(>=)`, `(>)`, `(<=)`, and `(<)`, as well as utility functions\n"
"`max` and `min`. Unlike `Comp`, `Ord` extends `Eq`,\n"
"so whenever there is an `Ord` constraint, we also have access to operators\n"
"`(==)` and `(/=)` and related functions.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:420
#, no-wrap
msgid "`Ord` Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:423
#, no-wrap
msgid "We expect the following laws to hold for all implementations of `Ord`:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:433
msgid "`(<=)` is *reflexive* and *transitive*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:433
#, no-wrap
msgid ""
"* `(<=)` is *antisymmetric*: From `x <= y = True` and `y <= x = True`\n"
"follows `x == y = True`.\n"
"* `x <= y = y >= x`.\n"
"* `x < y = not (y <= x)`\n"
"* `x > y = not (y >= x)`\n"
"* `compare x y = EQ` => `x == y = True`\n"
"* `compare x y == GT = x > y`\n"
"* `compare x y == LT = x < y`\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:434
#, no-wrap
msgid "`Semigroup` and `Monoid`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:439
#, no-wrap
msgid ""
"`Semigroup` is the pendant to our example interface `Concat`,\n"
"with operator `(<+>)` (also called *append*) corresponding\n"
"to function `concat`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:442
#, no-wrap
msgid ""
"Likewise, `Monoid` corresponds to `Empty`,\n"
"with `neutral` corresponding to `empty`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:449
#, no-wrap
msgid ""
"These are incredibly important interfaces, which can be used\n"
"to combine two or more values of a data type into a single\n"
"value of the same type. Examples include but are not limited\n"
"to addition or multiplication\n"
"of numeric types, concatenation of sequences of data, or\n"
"sequencing of computations.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:455
#, no-wrap
msgid ""
"As an example, consider a data type for representing\n"
"distances in a geometric application. We could just use `Double`\n"
"for this, but that's not very type safe. It would be better\n"
"to use a single field record wrapping values type `Double`,\n"
"to give such values clear semantics:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:456
#, no-wrap
msgid ""
"record Distance where\n"
"  constructor MkDistance\n"
"  meters : Double\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:465
#, no-wrap
msgid ""
"There is a natural way for combining two distances: We sum up\n"
"the values they hold. This immediately leads to an implementation\n"
"of `Semigroup`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:466
#, no-wrap
msgid ""
"Semigroup Distance where\n"
"  x <+> y = MkDistance $ x.meters + y.meters\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:474
#, no-wrap
msgid ""
"It is also immediately clear, that zero is the neutral element of this\n"
"operation: Adding zero to any value does not affect the value at all.\n"
"This allows us to implement `Monoid` as well:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:475
#, no-wrap
msgid ""
"Monoid Distance where\n"
"  neutral = MkDistance 0\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:480
#, no-wrap
msgid "`Semigroup` and `Monoid` Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:484
#, no-wrap
msgid ""
"We expect the following laws to hold for all implementations of "
"`Semigroup`\n"
"and `Monoid`:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:489
msgid ""
"`(<+>)` is *associative*: `x <+> (y <+> z) = (x <+> y) <+> z`, for all "
"values `x`, `y`, and `z`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:489
msgid ""
"`neutral` is the *neutral element* with relation to `(<+>)`: `neutral <+> x "
"= x <+> neutral = x`, for all `x`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:490
#, no-wrap
msgid "`Show`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:497
#, no-wrap
msgid ""
"The `Show` interface is mainly used for debugging purposes, and is\n"
"supposed to display values of a given type as a string, typically closely\n"
"resembling the Idris code used to create the value. This includes the\n"
"proper wrapping of arguments in parentheses where necessary. For instance,\n"
"experiment with the output of the following function at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:498
#, no-wrap
msgid ""
"showExample : Maybe (Either String (List (Maybe Integer))) -> String\n"
"showExample = show\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:505
#, no-wrap
msgid ""
"Tutorial.Interfaces> showExample (Just (Right [Just 12, Nothing]))\n"
"\"Just (Right [Just 12, Nothing])\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:511
#, no-wrap
msgid "We will learn how to implement instances of `Show` in an exercise.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:512
#, no-wrap
msgid "Overloaded Literals"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:524
#, no-wrap
msgid ""
"Literal values in Idris, such as integer literals (`12001`), string\n"
"literals (`\"foo bar\"`), floating point literals (`12.112`), and\n"
"character literals  (`'$'`) can be overloaded. This means, that we\n"
"can create values of types other than `String` from just a string\n"
"literal. The exact workings of this has to wait for another section,\n"
"but for many common cases, it is sufficient for a value to implement\n"
"interfaces `FromString` (for using string literals), `FromChar` (for using\n"
"character literals), or `FromDouble` (for using floating point literals).\n"
"The case of integer literals is special, and will be discussed in the next\n"
"section.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:531
#, no-wrap
msgid ""
"Here is an example of using `FromString`. Assume, we write an application\n"
"where users can identify themselves with a username and password. Both\n"
"consist of strings of characters, so it is pretty easy to confuse and mix\n"
"up the two things, although they clearly have very different semantics.\n"
"In these cases, it is advisable to come up with new types for the two,\n"
"especially since getting these things wrong is a security concern.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:533
#, no-wrap
msgid "Here are three example record types to do this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:534
#, no-wrap
msgid ""
"record UserName where\n"
"  constructor MkUserName\n"
"  name : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : UserName\n"
"  password : Password\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:551
#, no-wrap
msgid ""
"In order to create a value of type `User`, even for testing, we'd have\n"
"to wrap all strings using the given constructors:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:552
#, no-wrap
msgid ""
"hock : User\n"
"hock = MkUser (MkUserName \"hock\") (MkPassword \"not telling\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:560
#, no-wrap
msgid ""
"This is rather cumbersome, and some people might think this to be too high\n"
"a price to pay just for an increase in type safety (I'd tend to disagree).\n"
"Luckily, we can get the convenience of string literals back very easily:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:561
#, no-wrap
msgid ""
"FromString UserName where\n"
"  fromString = MkUserName\n"
"\n"
"FromString Password where\n"
"  fromString = MkPassword\n"
"\n"
"hock2 : User\n"
"hock2 = MkUser \"hock\" \"not telling\"\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:572
#, no-wrap
msgid "Numeric Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:577
#, no-wrap
msgid ""
"The *Prelude* also exports several interfaces providing the usual "
"arithmetic\n"
"operations. Below is a comprehensive list of the interfaces and the\n"
"functions each provides:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:582
#, no-wrap
msgid ""
"* `Num`\n"
"  * `(+)` : Addition\n"
"  * `(*)` : Multiplication\n"
"  * `fromInteger` : Overloaded integer literals\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:586
#, no-wrap
msgid ""
"* `Neg`\n"
"  * `negate` : Negation\n"
"  * `(-)` : Subtraction\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:590
#, no-wrap
msgid ""
"* `Integral`\n"
"  * `div` : Integer division\n"
"  * `mod` : Modulo operation\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:594
#, no-wrap
msgid ""
"* `Fractional`\n"
"  * `(/)` : Division\n"
"  * `recip` : Calculates the reciprocal of a value\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:599
#, no-wrap
msgid ""
"As you can see: We need to implement interface `Num` to\n"
"use integer literals for a given type. In order to use\n"
"negative integer literals like `-12`, we also have to\n"
"implement interface `Neg`.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:600
#, no-wrap
msgid "`Cast`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:607
#, no-wrap
msgid ""
"The last interface we will quickly discuss in this section is `Cast`. It\n"
"is used to convert values of one type to values of another via\n"
"function `cast`. `Cast` is special, since it is parameterized\n"
"over *two* type parameters unlike the other interfaces we looked\n"
"at so far, with only one type parameter.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:614
#, no-wrap
msgid ""
"So far, `Cast` is mainly used for interconversion\n"
"between primitive types in the standard libraries,\n"
"especially numeric types. When you look\n"
"at the implementations exported from the *Prelude* (for instance,\n"
"by invoking `:doc Cast` at the REPL), you'll see that there are\n"
"dozens of implementations for most pairings of primitive types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:623
#, no-wrap
msgid ""
"Although `Cast` would also be useful for other conversions (for\n"
"going from `Maybe` to `List` or for going from `Either e` to `Maybe`,\n"
"for instance), the *Prelude* and\n"
"*base* seem not to introduce these consistently. For instance,\n"
"there are `Cast` implementations from going from `SnocList` to\n"
"`List` and vice versa, but not for going from `Vect n` to `List`,\n"
"or for going from `List1` to `List`, although these would\n"
"be just as feasible.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:629
#, no-wrap
msgid ""
"These exercises are meant to make you comfortable with\n"
"implementing interfaces for your own data types, as you\n"
"will have to do so regularly when writing Idris code.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:635
#, no-wrap
msgid ""
"While it is immediately clear why interfaces like\n"
"`Eq`, `Ord`, or `Num` are useful, the usability of\n"
"`Semigroup` and `Monoid` may be harder to appreciate at first.\n"
"Therefore, there are several exercises where you'll implement\n"
"different instances for these.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Interfaces.md:639
msgid ""
"Define a record type `Complex` for complex numbers, by pairing two values of "
"type `Double`.  Implement interfaces `Eq`, `Num`, `Neg`, and `Fractional` "
"for `Complex`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Interfaces.md:643
msgid ""
"Implement interface `Show` for `Complex`. Have a look at data type `Prec` "
"and function `showPrec` and how these are used in the *Prelude* to implement "
"instances for `Either` and `Maybe`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:647
#, no-wrap
msgid ""
"   Verify the correct behavior of your implementation by wrapping\n"
"   a value of type `Complex` in a `Just` and `show` the result at\n"
"   the REPL.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Interfaces.md:649
msgid "Consider the following wrapper for optional values:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:650
#, no-wrap
msgid ""
"   record First a where\n"
"     constructor MkFirst\n"
"     value : Maybe a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:660
#, no-wrap
msgid ""
"   Implement interfaces `Eq`, `Ord`, `Show`, `FromString`, `FromChar`, "
"`FromDouble`,\n"
"   `Num`, `Neg`, `Integral`, and `Fractional` for `First a`. All of these "
"will require\n"
"   corresponding constraints on type parameter `a`. Consider implementing "
"and\n"
"   using the following utility functions where they make sense:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:661
#, no-wrap
msgid ""
"   pureFirst : a -> First a\n"
"\n"
"   mapFirst : (a -> b) -> First a -> First b\n"
"\n"
"   mapFirst2 : (a -> b -> c) -> First a -> First b -> First c\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Interfaces.md:673
msgid ""
"Implement interfaces `Semigroup` and `Monoid` for `First a` in such a way, "
"that `(<+>)` will return the first non-nothing argument and `neutral` is the "
"corresponding neutral element. There must be no constraints on type "
"parameter `a` in these implementations."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Interfaces.md:676
msgid ""
"Repeat exercises 3 and 4 for record `Last`. The `Semigroup` implementation "
"should return the last non-nothing value."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:677
#, no-wrap
msgid ""
"   record Last a where\n"
"     constructor MkLast\n"
"     value : Maybe a\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Interfaces.md:687
msgid ""
"Function `foldMap` allows us to map a function returning a `Monoid` over a "
"list of values and accumulate the result using `(<+>)` at the same time.  "
"This is a very powerful way to accumulate the values stored in a list.  Use "
"`foldMap` and `Last` to extract the last element (if any) from a list."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:692
#, no-wrap
msgid ""
"   Note, that the type of `foldMap` is more general and not specialized\n"
"   to lists only. It works also for `Maybe`, `Either` and other container\n"
"   types we haven't looked at so far. We will learn about\n"
"   interface `Foldable` in a later section.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Interfaces.md:694
msgid "Consider record wrappers `Any` and `All` for boolean values:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:695
#, no-wrap
msgid ""
"   record Any where\n"
"     constructor MkAny\n"
"     any : Bool\n"
"\n"
"   record All where\n"
"     constructor MkAll\n"
"     all : Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:708
#, no-wrap
msgid ""
"   Implement `Semigroup` and `Monoid` for `Any`, so that the result of\n"
"   `(<+>)` is `True`, if and only if at least one of the arguments is "
"`True`.\n"
"   Make sure that `neutral` is indeed the neutral element for this "
"operation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:712
#, no-wrap
msgid ""
"   Likewise, implement `Semigroup` and `Monoid` for `All`, so that the "
"result of\n"
"   `(<+>)` is `True`, if and only if both of the arguments are `True`.\n"
"   Make sure that `neutral` is indeed the neutral element for this "
"operation.\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Interfaces.md:715
msgid ""
"Implement functions `anyElem` and `allElems` using `foldMap` and `Any` or "
"`All`, respectively:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:716
#, no-wrap
msgid ""
"   -- True, if the predicate holds for at least one element\n"
"   anyElem : (a -> Bool) -> List a -> Bool\n"
"\n"
"   -- True, if the predicate holds for all elements\n"
"   allElems : (a -> Bool) -> List a -> Bool\n"
msgstr ""

#. type: Bullet: '9. '
#: ../src/Tutorial/Interfaces.md:726
msgid "Record wrappers `Sum` and `Product` are mainly used to hold numeric types."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:727
#, no-wrap
msgid ""
"   record Sum a where\n"
"     constructor MkSum\n"
"     value : a\n"
"\n"
"   record Product a where\n"
"     constructor MkProduct\n"
"     value : a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:739
#, no-wrap
msgid ""
"   Given an implementation of `Num a`, implement `Semigroup (Sum a)`\n"
"   and `Monoid (Sum a)`, so that `(<+>)` corresponds to addition.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:742
#, no-wrap
msgid ""
"   Likewise, implement `Semigroup (Product a)` and `Monoid (Product a)`,\n"
"   so that `(<+>)` corresponds to multiplication.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:745
#, no-wrap
msgid ""
"   When implementing `neutral`, remember that you can use integer\n"
"   literals when working with numeric types.\n"
msgstr ""

#. type: Bullet: '10. '
#: ../src/Tutorial/Interfaces.md:748
msgid ""
"Implement `sumList` and `productList` by using `foldMap` together with the "
"wrappers from Exercise 9:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:751
#, no-wrap
msgid ""
"    ```idris\n"
"    sumList : Num a => List a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:754
#, no-wrap
msgid ""
"    productList : Num a => List a -> a\n"
"    ```\n"
msgstr ""

#. type: Bullet: '11. '
#: ../src/Tutorial/Interfaces.md:760
msgid ""
"To appreciate the power and versatility of `foldMap`, after solving "
"exercises 6 to 10 (or by loading `Solutions.Inderfaces` in a REPL session), "
"run the following at the REPL, which will - in a single list traversal! - "
"calculate the first and last element of the list as well as the sum and "
"product of all values."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:765
#, no-wrap
msgid ""
"    ```repl\n"
"    > foldMap (\\x => (pureFirst x, pureLast x, MkSum x, MkProduct x)) "
"[3,7,4,12]\n"
"    (MkFirst (Just 3), (MkLast (Just 12), (MkSum 26, MkProduct 1008)))\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:772
#, no-wrap
msgid ""
"    Note, that there are also `Semigroup` implementations for\n"
"    types with an `Ord` implementation, which will return\n"
"    the smaller or larger of two values. In case of types\n"
"    with an absolute minimum or maximum (for instance, 0 for\n"
"    natural numbers, or 0 and 255 for `Bits8`), these can even\n"
"    be extended to `Monoid`.\n"
msgstr ""

#. type: Bullet: '12. '
#: ../src/Tutorial/Interfaces.md:778
msgid ""
"In an earlier exercise, you implemented a data type representing chemical "
"elements and wrote a function for calculating their atomic masses. Define a "
"new single field record type for representing atomic masses, and implement "
"interfaces `Eq`, `Ord`, `Show`, `FromDouble`, `Semigroup`, and `Monoid` for "
"this."
msgstr ""

#. type: Bullet: '13. '
#: ../src/Tutorial/Interfaces.md:782
msgid ""
"Use the new data type from exercise 12 to calculate the atomic mass of an "
"element and compute the molecular mass of a molecule given by its formula."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:785
#, no-wrap
msgid ""
"    Hint: With a suitable utility function, you can use `foldMap`\n"
"    once again for this.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:791
#, no-wrap
msgid ""
"Final notes: If you are new to functional programming, make sure\n"
"to give your implementations of exercises 6 to 10 a try at the REPL.\n"
"Note, how we can implement all of these functions with a minimal amount\n"
"of code and how, as shown in exercise 11, these behaviors can be\n"
"combined in a single list traversal.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interfaces allow us to implement the same function with different behavior "
"for different types."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Functions taking one or more interface implementations as arguments are "
"called *constrained functions*."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid "Interfaces can be organized hierarchically by *extending* other interfaces."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interfaces implementations can themselves be *constrained* requiring other "
"implementations to be available."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interface functions can be given a *default implementation*, which can be "
"overridden by implementers, for instance for reasons of efficiency."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Certain interfaces allow us to use literal values such as string or integer "
"literals for our own data types."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:812
#, no-wrap
msgid ""
"Note, that I did not yet tell the whole story about literal values\n"
"in this section. More details for using literals with types that\n"
"accept only a restricted set of values can be found in the\n"
"chapter about [primitives](Prim.md).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:819
#, no-wrap
msgid ""
"In the [next chapter](Functions2.md), we have a closer look\n"
"at functions and their types. We will learn about named arguments,\n"
"implicit arguments, and erased arguments as well as some\n"
"constructors for implementing more complex functions.\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Intro.md:1
#, no-wrap
msgid "Introduction"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:15
#, no-wrap
msgid ""
"Welcome to my Idris 2 tutorial. I'll try and treat as many aspects\n"
"of the Idris 2 programming language as possible here.\n"
"All `.md` files in here a literate Idris files: They consist of\n"
"Markdown (hence the `.md` ending), which is being pretty printed\n"
"by GitHub together with Idris code blocks, which can be\n"
"type checked and built by the Idris compiler (more on this later).\n"
"Note, however, that regular Idris source files use an `.idr` ending,\n"
"and that you go with that file type unless you end up writing\n"
"much more prose than code as I do at the moment. Later in this\n"
"tutorial, you'll have to solve some exercises, the solutions of\n"
"which can be found in the `src/Solutions` subfolder. There, I\n"
"use regular `.idr` files.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:19
#, no-wrap
msgid ""
"Every Idris source file should typically start with a module\n"
"name plus some necessary imports, and this document is no\n"
"exception:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:20
#, no-wrap
msgid "module Tutorial.Intro\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:27
#, no-wrap
msgid ""
"A module name consists of a list of identifiers separated\n"
"by dots and must reflect the folder structure plus the module\n"
"file's name.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Intro.md:28
#, no-wrap
msgid "About the Idris Programming Language"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:33
#, no-wrap
msgid ""
"Idris is a *pure*, *dependently typed*, *total* *functional*\n"
"programming language. I'll quickly explain each of these adjectives\n"
"in this section.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Intro.md:34
#, no-wrap
msgid "Functional Programming"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:42
#, no-wrap
msgid ""
"In functional programming languages, functions are first-class\n"
"constructs, meaning that they can be assigned to variables,\n"
"passed as arguments to other functions, and returned as results\n"
"from functions. Unlike for instance in\n"
"object-oriented programming languages, in functional programming,\n"
"functions are the main form of abstraction.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:46
#, no-wrap
msgid ""
"Functional programming languages are concerned with the evaluation\n"
"of functions, unlike classical imperative languages, which are\n"
"concerned with the execution of statements.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Intro.md:47
#, no-wrap
msgid "Pure Functional Programming"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:57
#, no-wrap
msgid ""
"Pure functional programming languages come with an additional\n"
"important guarantee: Functions don't have side effects like\n"
"writing to a file or mutating global state. They can only\n"
"compute a result from their arguments possibly by invoking other\n"
"pure functions, *and nothing else*. As a consequence, given\n"
"the same input, they will *always* generate the same output.\n"
"This property is known as\n"
"[referential "
"transparency](https://en.wikipedia.org/wiki/Referential_transparency).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:59
#, no-wrap
msgid "Pure functions have several advantages:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:62
msgid ""
"They can easily be tested by specifying (possibly randomly generated)  sets "
"of input arguments together with the expected results."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:66
msgid ""
"They are thread-safe, since the don't mutate global state, and as such can "
"be freely used in several computations running in parallel."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:68
#, no-wrap
msgid "There are, of course, also some disadvantages:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:71
msgid "Some algorithms are hard to implement efficiently using only pure functions."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:75
msgid ""
"Writing programs that actually *do* something (have some observable effect) "
"is a bit trickier but certainly possible."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:83
#, no-wrap
msgid ""
"Idris is a strongly, statically typed programming language. This\n"
"means, that ever Idris expression is given a *type* (for instance:\n"
"integer, list of strings, boolean, function from integer to boolean, etc.)\n"
"and types are verified at compile time to rule out certain\n"
"common programming errors.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:89
#, no-wrap
msgid ""
"For instance, if a function expects an argument of type `String`\n"
"(a sequence of unicode characters, such as `\"Hello123\"`), it\n"
"is a *type error* to invoke this function with an argument of\n"
"type `Integer`, and the Idris compiler will refuse to\n"
"generate an executable from such an ill-typed program.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:97
#, no-wrap
msgid ""
"Even more, Idris is *dependently typed*, which is one of its most\n"
"characteristic properties in the landscape of programming\n"
"languages. In Idris, types are *first class*: Types can be passed\n"
"as arguments to functions, and functions can return types as\n"
"their results. Even more, types can *depend* on other *values*.\n"
"What this means, and why this is incredibly useful, we'll explore\n"
"in due time.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Intro.md:98
#, no-wrap
msgid "Total Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:104
#, no-wrap
msgid ""
"A *total* function is a pure function, that is guaranteed to return\n"
"a value of the expected return type for every possible input in\n"
"a finite amount of time. A total function will never fail with an\n"
"exception or loop infinitely.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:113
#, no-wrap
msgid ""
"Idris comes with a totality checker built in, which enables us to\n"
"verify the functions we write to be provably total. Totality\n"
"in Idris is opt-in, as in general, checking the totality of\n"
"an arbitrary computer program is undecidable\n"
"(see also the [halting "
"problem](https://en.wikipedia.org/wiki/Halting_problem)).\n"
"However, if we annotate a function with the `total` keyword,\n"
"Idris will fail with a type error, if its totality checker\n"
"cannot verify that the function in question is indeed total.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Intro.md:114
#, no-wrap
msgid "Using the REPL"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:121
#, no-wrap
msgid ""
"Idris comes with a useful REPL (an acronym for *Read Evaluate\n"
"Print Loop*), which we will use for tinkering with small\n"
"ideas, and for quickly experimenting with the code we just wrote.\n"
"In order to start a REPL session, run the following command\n"
"in a terminal.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:122
#, no-wrap
msgid "rlwrap idris2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:131
#, no-wrap
msgid ""
"(Using command-line utility `rlwrap` is optional. It\n"
"leads to a somewhat nicer user experience, as it allows us\n"
"to use the up and down arrow keys to scroll through a history\n"
"of commands and expressions we entered. It should be available\n"
"for most Linux distributions.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:133
#, no-wrap
msgid "Idris should now be ready to accept you commands:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:134
#, no-wrap
msgid ""
"     ____    __     _         ___\n"
"    /  _/___/ /____(_)____   |__ \\\n"
"    / // __  / ___/ / ___/   __/ /     Version 0.5.1-3c532ea35\n"
"  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org\n"
" /___/\\__,_/_/  /_/____/   /____/      Type :? for help\n"
"\n"
"Welcome to Idris 2.  Enjoy yourself!\n"
"Main>\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:147
#, no-wrap
msgid ""
"We can go ahead and enter some simple arithmetic expressions. Idris\n"
"will *evaluate* these and print the result:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:148
#, no-wrap
msgid ""
"Main> 2 * 4\n"
"8\n"
"Main> 3 * (7 + 100)\n"
"321\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:157
#, no-wrap
msgid ""
"Since every expression in Idris has an associated *type*,\n"
"we might want to inspect these as well:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:158
#, no-wrap
msgid ""
"Main> :t 2\n"
"2 : Integer\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:166
#, no-wrap
msgid ""
"Here `:t` is a command of the Idris REPL (it is not part of the\n"
"Idris programming language), and it is used to inspect the type\n"
"of an expression.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:167
#, no-wrap
msgid ""
"Main> :t 2 * 4\n"
"2 * 4 : Integer\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:182
#, no-wrap
msgid ""
"Whenever we perform calculations with integer literals without\n"
"being explicit about the types we want to use, Idris will\n"
"use `Integer` as a default. `Integer` is an arbitrary precision\n"
"signed integer type. It is one of the *primitive types* built\n"
"into the language. Other primitives include fixed precision\n"
"signed and unsigned integral types (`Bits8`, `Bits16`, `Bits32`\n"
"`Bits64`, `Int8`, `Int16`, `Int32`, and `Int64`), double\n"
"precision (64 bit) floating point numbers (`Double`), unicode\n"
"characters (`Char`) and strings of unicode characters (`String`).\n"
"We will use many of these in due time.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Intro.md:183
#, no-wrap
msgid "A First Idris Program"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:190
#, no-wrap
msgid ""
"We will often start up a REPL for tinkering with small parts\n"
"of the Idris language, for reading some documentation, or\n"
"for inspecting the content of an Idris module, but now we will\n"
"write a minimal Idris program to get started with\n"
"the language. Here comes the mandatory *Hello World*:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:191
#, no-wrap
msgid ""
"main : IO ()\n"
"main = putStrLn \"Hello World!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:199
#, no-wrap
msgid ""
"We will inspect the code above in some detail in a moment,\n"
"but first we'd like to compile and run it. From this project's\n"
"root directory, run the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:199
#, no-wrap
msgid "idris2 --find-ipkg -o hello src/Tutorial/Intro.md\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:207
#, no-wrap
msgid ""
"This will create executable `hello` in directory `build/exec`,\n"
"which can be invoked from the command-line like so (without the\n"
"dollar prefix; this is used here to distinguish the terminal command\n"
"from its output):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:208
#, no-wrap
msgid ""
"$ build/exec/hello\n"
"Hello World!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:219
#, no-wrap
msgid ""
"The `--find-ipkg` option will look for an `.ipkg` file in the\n"
"current directory or one of its parent directories, from which\n"
"it will get other settings like the source directory to use\n"
"(`src` in our case). The `-o` option gives the name of the\n"
"executable to be generated. Type `idris2 --help` for a list\n"
"of available command-line options and environment variables.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:222
#, no-wrap
msgid ""
"As an alternative, you can also load this source file in a REPL\n"
"session and invoke function `main` from there:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:223
#, no-wrap
msgid "rlwrap idris2 --find-ipkg src/Tutorial/Intro.md\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:227
#, no-wrap
msgid ""
"Tutorial.Intro> :exec main\n"
"Hello World!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:234
#, no-wrap
msgid ""
"Go ahead and try both ways of building and running function `main`\n"
"on your system!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:239
#, no-wrap
msgid ""
"Note: It might be instructive to omit the `--find-ipkg` option.\n"
"You will get an error message about the module name `Tutorial.Intro`\n"
"not matching the file path `src/Tutorial/Intro.md`. You can\n"
"also use option `--source-dir src` to silence this error.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Intro.md:240
#, no-wrap
msgid "The Shape of an Idris Definition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:244
#, no-wrap
msgid ""
"Now that we executed our first Idris program, we will talk\n"
"a bit more about the code we had to write to define it.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:251
#, no-wrap
msgid ""
"A typical top level function in Idris consists of three things:\n"
"The function's name (`main` in our case), its type (`IO ()`)\n"
"plus its implementation (`putStrLn \"Hello World\"`). It is easier\n"
"to explain these things with a couple of simple examples. Below,\n"
"we define a top level constant for the largest unsigned eight bit\n"
"integer:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:252
#, no-wrap
msgid ""
"maxBits8 : Bits8\n"
"maxBits8 = 255\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:266
#, no-wrap
msgid ""
"The first line can be read as: \"We'd like to declare  (nullary)\n"
"function `maxBits8`. It is of type `Bits8`\". This is\n"
"called the *function declaration*: We declare, that there\n"
"shall be a function of the given name and type. The second line\n"
"reads: \"The result of invoking `maxBits8` should be `255`.\"\n"
"(As you can see, we can use integer literals for other integral\n"
"types than just `Integer`.) This is called the *function definition*:\n"
"Function `maxBits8` should behave as described here when being\n"
"evaluated.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:269
#, no-wrap
msgid ""
"We can inspect this at the REPL. Load this source file into\n"
"an Idris REPL (as described above), and run the following tests.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:270
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8\n"
"255\n"
"Tutorial.Intro> :t maxBits8\n"
"Tutorial.Intro.maxBits8 : Bits8\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:278
#, no-wrap
msgid "We can also use `maxBits8` as part of another expression:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:279
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8 - 100\n"
"155\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:286
#, no-wrap
msgid ""
"I called `maxBits8` a *nullary function*, which is just a fancy\n"
"word for *constant*. Let's write and test our first *real* function:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:287
#, no-wrap
msgid ""
"distanceToMax : Bits8 -> Bits8\n"
"distanceToMax n = maxBits8 - n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:299
#, no-wrap
msgid ""
"This introduces some new syntax and a new kind of type: Function\n"
"types. `distanceToMax : Bits8 -> Bits8` can be read as follows:\n"
"\"`distanceToMax` is a function of one argument of type `Bits8`, which\n"
"returns a result of type `Bits8`\". In the implementation, the argument\n"
"is given a local identifier `n`, which is then used in the\n"
"calculation on the right hand side. Again, go ahead and try this\n"
"function at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:300
#, no-wrap
msgid ""
"Tutorial.Intro> distanceToMax 12\n"
"243\n"
"Tutorial.Intro> :t distanceToMax\n"
"Tutorial.Intro.distanceToMax : Bits8 -> Bits8\n"
"Tutorial.Intro> :t distanceToMax 12\n"
"distanceToMax 12 : Bits8\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:311
#, no-wrap
msgid ""
"As a final example, let's implement a function to calculate\n"
"the square of an integer:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:312
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:325
#, no-wrap
msgid ""
"We now learn a very important aspect of programming\n"
"in Idris: Idris is\n"
"a *statically typed* programming language. We are not\n"
"allowed to freely mix types as we please. Doing so\n"
"will result in an error message from the type checker\n"
"(which is part of the compilation process of Idris).\n"
"For instance, if we try the following at the REPL,\n"
"we will get a type error:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:326
#, no-wrap
msgid ""
"Tutorial.Intro> square maxBits8\n"
"Error: ...\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:336
#, no-wrap
msgid ""
"The reason: `square` expects an argument of type `Integer`,\n"
"but `maxBits8` is of type `Bits8`. Many primitive types\n"
"are interconvertible (sometimes with the risk of loss\n"
"of precision) using function `cast` (more on the details\n"
"later):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:337
#, no-wrap
msgid ""
"Tutorial.Intro> square (cast maxBits8)\n"
"65025\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:348
#, no-wrap
msgid ""
"Note, that in the example above the result is much larger\n"
"that `maxBits8`. The reason is, that `maxBits8` is first\n"
"converted to an `Integer` of the same value, which is\n"
"then squared. If on the other hand we squared `maxBits8`\n"
"directly, the result would be truncated to still fit the\n"
"valid range of `Bits8`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:349
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8 * maxBits8\n"
"1\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Intro.md:354
#, no-wrap
msgid "Where to get Help"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:359
#, no-wrap
msgid ""
"There are several resources available online and in print, where\n"
"you can find help and documentation about the Idris programming\n"
"language. Here is a non-comprehensive list of them:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:361
msgid ""
"[Type-Driven Development with "
"Idris](https://www.manning.com/books/type-driven-development-with-idris)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:368
#, no-wrap
msgid ""
"  *The* Idris book! This describes in great detail\n"
"  the core concepts for using Idris and dependent types\n"
"  to write robust and concise code. It uses Idris 1 in\n"
"  its examples, so parts of it have to be slightly adjusted\n"
"  when using Idris 2. There is also a\n"
"  [list of required "
"updates](https://idris2.readthedocs.io/en/latest/typedd/typedd.html).\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:370
msgid ""
"[A Crash Course in Idris "
"2](https://idris2.readthedocs.io/en/latest/tutorial/index.html)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:375
#, no-wrap
msgid ""
"  The official Idris 2 tutorial. A comprehensive but dense explanation of\n"
"  all features of Idris 2. I find this to be useful as a reference, and as "
"such\n"
"  it is highly accessible. However, it is not an introduction to "
"functional\n"
"  programming or type-driven development in general.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:377
msgid "[The Idris 2 GitHub Repository](https://github.com/idris-lang/Idris2)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:384
#, no-wrap
msgid ""
"  Look here for detailed installation instructions and some\n"
"  introductory material. There is also a "
"[wiki](https://github.com/idris-lang/Idris2/wiki),\n"
"  where you can find a [list of editor "
"plugins](https://github.com/idris-lang/Idris2/wiki/The-Idris-editor-experience),\n"
"  a [list of community "
"libraries](https://github.com/idris-lang/Idris2/wiki/Libraries),\n"
"  a [list of external "
"backends](https://github.com/idris-lang/Idris2/wiki/External-backends),\n"
"  and other useful information.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:386
msgid "[The Idris 2 Discord Channel](https://discord.gg/UX68fDs2jc)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:392
#, no-wrap
msgid ""
"  If you get stuck with a piece of code, want to ask about some\n"
"  obscure language feature, want to promote your new library,\n"
"  or want to just hang out with other Idris programmers, this\n"
"  is the place to go. The discord channel is pretty active and\n"
"  *very* friendly towards newcomers.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:394
msgid "The Idris REPL"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:400
#, no-wrap
msgid ""
"  Finally, a lot of useful information can be provided by\n"
"  Idris itself. I tend to have at least one REPL session open all the\n"
"  time when programming in Idris. My editor (neovim) is set up\n"
"  to use the [language server for Idris "
"2](https://github.com/idris-community/idris2-lsp),\n"
"  which is incredibly useful. In the REPL,\n"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:t` to inspect the type of an expression or meta variable (hole): `:t "
"foldl`,"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:ti` to inspect the type of a function including implicit arguments: "
"`:ti foldl`,"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid "use `:m` to list all meta variables (holes) in scope,"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:doc` to access the documentation of a top level function (`:doc the`), "
"a data type plus all its constructors and available hints (`:doc Bool`), a "
"language feature (`:doc case`, `:doc let`, `:doc interface`, `:doc record`, "
"or even `:doc ?`), or an interface (`:doc Uninhabited`),"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:module` to import a module from one of the available packages: "
"`:module Data.Vect`,"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:browse` to list the names and types of all functions exported by a "
"loaded module: `:browse Data.Vect`,"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:help` to get a list of other commands plus a short description for "
"each."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Intro.md:418
#, no-wrap
msgid "Summary"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:425
#, no-wrap
msgid ""
"In this introduction we learned about the most basic\n"
"features of the Idris programming language. We used\n"
"the REPL to tinker with our ideas and inspect the\n"
"types of things in our code, and we used the Idris\n"
"compiler to compile an Idris source file to an executable.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:429
#, no-wrap
msgid ""
"We also learned about the basic shape of a top level\n"
"definition in Idris, which always consists of an identifier\n"
"(its name), a type, and an implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:436
#, no-wrap
msgid ""
"In the [next chapter](Functions1.md), we start programming\n"
"in Idris for real. We learn how to write our own pure\n"
"functions, how functions compose, and how we can treat\n"
"functions just like other values and pass them around\n"
"as arguments to other functions.\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/IO.md:1
#, no-wrap
msgid "IO: Programming with Side Effects"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:7
#, no-wrap
msgid ""
"So far, all our examples and exercises dealt with pure, total functions.\n"
"We didn't read or write content from or to files, nor did\n"
"we write any messages to the standard output. It is time to change\n"
"that and learn, how we can write effectful programs in Idris.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:8
#, no-wrap
msgid ""
"module Tutorial.IO\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import System.File\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/IO.md:20
#, no-wrap
msgid "Pure Side Effects?"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:24
#, no-wrap
msgid ""
"If we once again look at the *hello world* example from the\n"
"[introduction](Intro.md), it had the following type and implementation:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:25
#, no-wrap
msgid ""
"hello : IO ()\n"
"hello = putStrLn \"Hello World!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:32
#, no-wrap
msgid ""
"If you load this module in a REPL session and evaluate `hello`,\n"
"you'll get the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:33
#, no-wrap
msgid ""
"Tutorial.IO> hello\n"
"MkIO (prim__putStr \"Hello World!\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:41
#, no-wrap
msgid ""
"This might not be what you expected, given that we'd actually wanted the\n"
"program to just print \"Hello World!\". In order to explain what's going\n"
"on here, we need to quickly look at how evaluation at the REPL works.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:51
#, no-wrap
msgid ""
"When we evaluate some expression at the REPL, Idris tries to\n"
"reduce it to a value until it gets stuck somewhere. In the above case,\n"
"Idris gets stuck at function `prim__putStr`. This is\n"
"a *foreign function* defined in the *Prelude*, which has to be implemented\n"
"by each backend in order to be available there. At compile time (and at the "
"REPL),\n"
"Idris knows nothing about the implementations of foreign functions\n"
"and therefore can't reduce foreign function calls, unless they are\n"
"built into the compiler itself. But even then, values of type `IO a`\n"
"(`a` being a type parameter) are typically not reduced.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:61
#, no-wrap
msgid ""
"It is important to understand that values of type `IO a` *describe*\n"
"a program, which, when being *executed*, will return a value of type `a`,\n"
"after performing arbitrary side effects along the way. For instance,\n"
"`putStrLn` has type `String -> IO ()`. Read this as: \"`putStrLn` is a "
"function,\n"
"which, when given a `String` argument, will return a description of\n"
"an effectful program with an output type of `()`\".\n"
"(`()` is syntactic sugar for type `Unit`, the\n"
"empty tuple defined at the *Prelude*, which has only one value called "
"`MkUnit`,\n"
"for which we can also use `()` in our code.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:72
#, no-wrap
msgid ""
"Since values of type `IO a` are mere descriptions of effectful "
"computations,\n"
"functions returning such values or taking such values as\n"
"arguments are still *pure* and thus referentially transparent.\n"
"It is, however, not possible to extract a value of type `a` from\n"
"a value of type `IO a`, that is, there is no generic function `IO a -> a`,\n"
"as such a function would inadvertently execute the side\n"
"effects when extracting the result from its argument,\n"
"thus breaking referential transparency.\n"
"(Actually, there *is* such a function called `unsafePerformIO`.\n"
"Do not ever use it in your code unless you know what you are doing.)\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:73
#, no-wrap
msgid "Do Blocks"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:83
#, no-wrap
msgid ""
"If you are new to pure functional programming, you might now - rightfully "
"-\n"
"mumble something about how useless it is to\n"
"have descriptions of effectful programs without being able to run them.\n"
"So please, hear me out. While we are not able to run values of type\n"
"`IO a` when writing programs, that is, there is no function of\n"
"type `IO a -> a`, we are able to chain such computations and describe more\n"
"complex programs. Idris provides special syntax for this: *Do blocks*.\n"
"Here's an example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:84
#, no-wrap
msgid ""
"readHello : IO ()\n"
"readHello = do\n"
"  name <- getLine\n"
"  putStrLn $ \"Hello \" ++ name ++ \"!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:93
#, no-wrap
msgid ""
"Before we talk about what's going on here, let's give this a go at\n"
"the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:94
#, no-wrap
msgid ""
"Tutorial.IO> :exec readHello\n"
"Stefan\n"
"Hello Stefan!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:104
#, no-wrap
msgid ""
"This is an interactive program, which will read a line from standard\n"
"input (`getLine`), assign the result to variable `name`, and then\n"
"use `name` to create a friendly greeting and write it to\n"
"standard output.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:114
#, no-wrap
msgid ""
"Note the `do` keyword at the beginning of the implementation of "
"`readHello`:\n"
"It starts a *do block*, where we can chain `IO` computations and bind\n"
"intermediary results to variables using arrows pointing\n"
"to the left (`<-`), which can then be used in later\n"
"`IO` actions. This concept is powerful enough to let us encapsulate "
"arbitrary\n"
"programs with side effects in a single value of type `IO`. Such a\n"
"description can then be returned by function `main`, the main entry point\n"
"to an Idris program, which is being executed when we run a compiled\n"
"Idris binary.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:115
#, no-wrap
msgid "The Difference between Program Description and Execution"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:120
#, no-wrap
msgid ""
"In order to better understand the difference between *describing*\n"
"an effectful computation and *executing* or *running* it, here is a small\n"
"program:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:121
#, no-wrap
msgid ""
"launchMissiles : IO ()\n"
"launchMissiles = putStrLn \"Boom! You're dead.\"\n"
"\n"
"friendlyReadHello : IO ()\n"
"friendlyReadHello = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
"\n"
"actions : Vect 3 (IO ())\n"
"actions = [launchMissiles, friendlyReadHello, friendlyReadHello]\n"
"\n"
"runActions : Vect (S n) (IO ()) -> IO ()\n"
"runActions (_ :: xs) = go xs\n"
"  where go : Vect k (IO ()) -> IO ()\n"
"        go []        = pure ()\n"
"        go (y :: ys) = do\n"
"          _ <- y\n"
"          go ys\n"
"\n"
"readHellos : IO ()\n"
"readHellos = runActions actions\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:153
#, no-wrap
msgid ""
"Before I explain what the code above does, please note function\n"
"`pure` used in the implementation of `runActions`. It is\n"
"a constrained function, about which we will learn in the next\n"
"chapter. Specialized to `IO`, it has generic type `a -> IO a`:\n"
"It allows us to wrap a value in an `IO` action. The resulting\n"
"`IO` program will just return the wrapped value without performing\n"
"any side effects. We can now look at the big picture of what's\n"
"going on in `readHellos`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:160
#, no-wrap
msgid ""
"First, we define a friendlier version of `readHello`: When executed, this "
"will\n"
"ask about our name explicitly. Since we will not use the result\n"
"of `putStrLn` any further, we can use an underscore as a catch-all\n"
"pattern here. Afterwards, `readHello` is invoked. We also define\n"
"`launchMissiles`, which, when being executed, will lead to the\n"
"destruction of planet earth.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:169
#, no-wrap
msgid ""
"Now, `runActions` is the function we use to\n"
"demonstrate that *describing* an `IO` action is not the\n"
"same as *running* it. It will drop the first action from\n"
"the non-empty vector it takes as its\n"
"argument and return a new `IO` action, which describes the\n"
"execution of the remaining `IO` actions in sequence. If this behaves\n"
"as expected, the first `IO` action passed to `runActions` should be\n"
"silently dropped together with all its potential side effects.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:174
#, no-wrap
msgid ""
"When we execute `readHellos` at the REPL, we will be asked for our\n"
"name twice, although `actions` also contains `launchMissiles` at the\n"
"beginning. Luckily, although we described how to destroy the planet,\n"
"the action was not executed, and we are (probably) still here.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:176
#, no-wrap
msgid "From this example we learn several things:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:180
msgid ""
"Values of type `IO a` are *pure descriptions* of programs, which, when being "
"*executed*, perform arbitrary side effects before returning a value of type "
"`a`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:184
msgid ""
"Values of type `IO a` can be safely returned from functions and passed "
"around as arguments or in data structures, without the risk of them being "
"executed."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:187
msgid ""
"Values of type `IO a` can be safely combined in *do blocks* to *describe* "
"new `IO` actions."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:191
msgid ""
"An `IO` action will only ever get executed when it's passed to `:exec` at "
"the REPL, or when it is the `main` function of a compiled Idris program that "
"is being executed."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:196
msgid ""
"It is not possible to ever break out of the `IO` context: There is no "
"function of type `IO a -> a`, as such a function would need to execute its "
"argument in order to extract the final result, and this would break "
"referential transparency."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:197
#, no-wrap
msgid "Combining Pure Code with `IO` Actions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:202
#, no-wrap
msgid ""
"The title of this subsection is somewhat misleading. `IO` actions\n"
"*are* pure values, but what is typically meant here, is that we\n"
"combine non-`IO` functions with effectful computations.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:208
#, no-wrap
msgid ""
"As a demonstration, in this section we are going to write a small\n"
"program for evaluating arithmetic expressions. We are going to\n"
"keep things simple and allow only expressions with a single\n"
"operator and two arguments, both of which must be integers,\n"
"for instance `12 + 13`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:216
#, no-wrap
msgid ""
"We are going to use function `split` from `Data.String` in\n"
"*base* to tokenize arithmetic expressions. We are then trying\n"
"to parse the two integer values and the operator. These operations\n"
"might fail, since user input can be invalid, so we also need an\n"
"error type. We could actually just use `String`, but I\n"
"consider it to be good practice to use custom sum types\n"
"for erroneous conditions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:217
#, no-wrap
msgid ""
"data Error : Type where\n"
"  NotAnInteger    : (value : String) -> Error\n"
"  UnknownOperator : (value : String) -> Error\n"
"  ParseError      : (input : String) -> Error\n"
"\n"
"dispError : Error -> String\n"
"dispError (NotAnInteger v)    = \"Not an integer: \" ++ v ++ \".\"\n"
"dispError (UnknownOperator v) = \"Unknown operator: \" ++ v ++ \".\"\n"
"dispError (ParseError v)      = \"Invalid expression: \" ++ v ++ \".\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:231
#, no-wrap
msgid ""
"In order to parse integer literals, we use function `parseInteger`\n"
"from `Data.String`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:232
#, no-wrap
msgid ""
"readInteger : String -> Either Error Integer\n"
"readInteger s = maybe (Left $ NotAnInteger s) Right $ parseInteger s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:239
#, no-wrap
msgid ""
"Likewise, we declare and implement a function for parsing\n"
"arithmetic operators:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:240
#, no-wrap
msgid ""
"readOperator : String -> Either Error (Integer -> Integer -> Integer)\n"
"readOperator \"+\" = Right (+)\n"
"readOperator \"*\" = Right (*)\n"
"readOperator s   = Left (UnknownOperator s)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:254
#, no-wrap
msgid ""
"We are now ready to parse and evaluate simple arithmetic\n"
"expressions. This consists of several steps (splitting the\n"
"input string, parsing each literal), each of which can fail.\n"
"Later, when we learn about monads, we will see that do\n"
"blocks can be used in such occasions just as well. However,\n"
"in this case we can use an alternative syntactic convenience:\n"
"Pattern matching in let bindings. Here is the code:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:255
#, no-wrap
msgid ""
"eval : String -> Either Error Integer\n"
"eval s =\n"
"  let [x,y,z]  := forget $ split isSpace s | _ => Left (ParseError s)\n"
"      Right v1 := readInteger x  | Left e => Left e\n"
"      Right op := readOperator y | Left e => Left e\n"
"      Right v2 := readInteger z  | Left e => Left e\n"
"   in Right $ op v1 v2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:280
#, no-wrap
msgid ""
"Let's break this down a bit. On the first line, we split\n"
"the input string at all whitespace occurrences. Since\n"
"`split` returns a `List1` (a type for non-empty lists\n"
"exported from `Data.List1` in *base*) but pattern matching\n"
"on `List` is more convenient, we convert the result using\n"
"`Data.List1.forget`. Note, how we use a pattern match\n"
"on the left hand side of the assignment operator `:=`.\n"
"This is a partial pattern match (*partial* meaning,\n"
"that it doesn't cover all possible cases), therefore we have\n"
"to deal with the other possibilities as well, which is\n"
"done after the vertical line. This can be read as follows:\n"
"\"If the pattern match on the left hand side is successful,\n"
"and we get a list of exactly three tokens, continue with\n"
"the `let` expression, otherwise return a `ParseError` in\n"
"a `Left` immediately\".\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:286
#, no-wrap
msgid ""
"The other three lines behave exactly the same: Each has\n"
"a partial pattern match on the left hand side with\n"
"instructions what to return in case of invalid input after\n"
"the vertical bar. We will later see, that this syntax is also\n"
"available in *do blocks*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:294
#, no-wrap
msgid ""
"Note, how all of the functionality implemented so far is\n"
"*pure*, that is, it does not describe computations with\n"
"side effects. (One could argue that already the possibility\n"
"of failure is an observable *effect*, but even then, the code above\n"
"is still referentially transparent,\n"
"can be easily tested at the REPL, and evaluated at\n"
"compile time, which is the important thing here.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:298
#, no-wrap
msgid ""
"Finally, we can wrap this functionality in an `IO`\n"
"action, which reads a string from standard input\n"
"and tries to evaluate the arithmetic expression:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:299
#, no-wrap
msgid ""
"exprProg : IO ()\n"
"exprProg = do\n"
"  s <- getLine\n"
"  case eval s of\n"
"    Left err  => do\n"
"      putStrLn \"An error occured:\"\n"
"      putStrLn (dispError err)\n"
"    Right res => putStrLn (s ++ \" = \" ++ show res)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:316
#, no-wrap
msgid ""
"Note, how in `exprProg` we were forced to deal with the\n"
"possibility of failure and handle both constructors\n"
"of `Either` differently in order to print a result.\n"
"Note also, that *do blocks* are ordinary expressions,\n"
"and we can, for instance, start a new *do block* on\n"
"the right hand side of a case expression.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:329
#, no-wrap
msgid ""
"In these exercises, you are going to implement some\n"
"small command-line applications. Some of these will potentially\n"
"run forever, as they will only stop when the user enters\n"
"a keyword for quitting the application. Such programs\n"
"are no longer provably total. If you added the\n"
"`%default total` pragma at the top of your source file,\n"
"you'll need to annotate these functions with `covering`,\n"
"meaning that you covered all cases in all pattern matches\n"
"but your program might still loop due to unrestricted\n"
"recursion.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:333
msgid ""
"Implement function `rep`, which will read a line of input from the terminal, "
"evaluate it using the given function, and print the result to standard "
"output:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:334
#, no-wrap
msgid "   rep : (String -> String) -> IO ()\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:341
msgid ""
"Implement function `repl`, which behaves just like `rep` but will repeat "
"itself forever (or until being forcefully terminated):"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:342
#, no-wrap
msgid ""
"   covering\n"
"   repl : (String -> String) -> IO ()\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/IO.md:351
msgid ""
"Implement function `replTill`, which behaves just like `repl` but will only "
"continue looping if the given function returns a `Right`. If it returns a "
"`Left`, `replTill` should print the final message wrapped in the `Left` and "
"then stop."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:352
#, no-wrap
msgid ""
"   covering\n"
"   replTill : (String -> Either String String) -> IO ()\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/IO.md:364
msgid ""
"Write a program, which reads arithmetic expressions from standard input, "
"evaluates them using `eval`, and prints the result to standard output. The "
"program should loop until users stops it by entering \"done\", in which case "
"the program should terminate with a friendly greeting.  Use `replTill` in "
"your implementation."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/IO.md:373
msgid ""
"Implement function `replWith`, which behaves just like `repl` but uses some "
"internal state to accumulate values.  At each iteration (including the very "
"first one!), the current state should be printed to standard output using "
"function `dispState`, and the next state should be computed using function "
"`next`.  The loop should terminate in case of a `Left` and print a final "
"message using `dispResult`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:374
#, no-wrap
msgid ""
"   covering\n"
"   replWith :  (state      : s)\n"
"            -> (next       : s -> String -> Either res s)\n"
"            -> (dispState  : s -> String)\n"
"            -> (dispResult : res -> s -> String)\n"
"            -> IO ()\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/IO.md:388
msgid ""
"Use `replWith` from Exercise 5 to write a program for reading natural "
"numbers from standard input and printing the accumulated sum of these "
"numbers.  The program should terminate in case of invalid input and if a "
"user enters \"done\"."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/IO.md:389
#, no-wrap
msgid "Do Blocks, Desugared"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:402
#, no-wrap
msgid ""
"Here's an important piece of information: There is nothing\n"
"special about *do blocks*. They are just syntactic sugar,\n"
"which is converted to a sequence of operator applications.\n"
"With [syntactic sugar](https://en.wikipedia.org/wiki/Syntactic_sugar),\n"
"we mean syntax in a programming language that makes it\n"
"easier to express certain things in that language without\n"
"making the language itself any more powerful or expressive.\n"
"Here, it means you could write all the `IO` programs\n"
"without using `do` notation, but the code you'll write\n"
"will sometimes be harder to read, so *do blocks* provide\n"
"nicer syntax for these occasions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:404
#, no-wrap
msgid "Consider the following example program:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:405
#, no-wrap
msgid ""
"sugared1 : IO ()\n"
"sugared1 = do\n"
"  str1 <- getLine\n"
"  str2 <- getLine\n"
"  str3 <- getLine\n"
"  putStrLn (str1 ++ str2 ++ str3)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:416
#, no-wrap
msgid ""
"The compiler will convert this to the following program\n"
"*before disambiguating function names and type checking*:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:417
#, no-wrap
msgid ""
"desugared1 : IO ()\n"
"desugared1 =\n"
"  getLine >>= (\\str1 =>\n"
"    getLine >>= (\\str2 =>\n"
"      getLine >>= (\\str3 =>\n"
"        putStrLn (str1 ++ str2 ++ str3)\n"
"      )\n"
"    )\n"
"  )\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:432
#, no-wrap
msgid ""
"There is a new operator (`(>>=)`) called *bind* in the\n"
"implementation of `desugared1`. If you look at its type\n"
"at the REPL, you'll see the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:433
#, no-wrap
msgid ""
"Main> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:441
#, no-wrap
msgid ""
"This is a constrained function requiring an interface called `Monad`.\n"
"We will talk about `Monad` and some of its friends in the next\n"
"chapter. Specialized to `IO`, *bind* has the following type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:442
#, no-wrap
msgid ""
"Main> :t (>>=) {m = IO}\n"
">>= : IO a -> (a -> IO b) -> IO b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:451
#, no-wrap
msgid ""
"This describes a sequencing of `IO` actions. Upon execution,\n"
"the first `IO` action is being run and its result is\n"
"being passed as an argument to the function generating\n"
"the second `IO` action, which is then also being executed.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:466
#, no-wrap
msgid ""
"You might remember, that you already implemented something\n"
"similar in an earlier exercise: In [Algebraic Data Types](DataTypes.md),\n"
"you implemented *bind* for `Maybe` and `Either e`. We will\n"
"learn in the next chapter, that `Maybe` and `Either e` too come\n"
"with an implementation of `Monad`. For now, suffice to say\n"
"that `Monad` allows us to run computations with some kind\n"
"of effect in sequence by passing the *result* of the\n"
"first computation to the function returning the\n"
"second computation. In `desugared1` you can see, how\n"
"we first perform an `IO` action and use its result\n"
"to compute the next `IO` action and so on. The code is somewhat\n"
"hard to read, since we use several layers of nested\n"
"anonymous function, that's why in such cases, *do blocks*\n"
"are a nice alternative to express the same functionality.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:471
#, no-wrap
msgid ""
"Since *do block* are always desugared to sequences of\n"
"applied *bind* operators, we can use them to chain\n"
"any monadic computation. For instance, we can rewrite\n"
"function `eval` by using a *do block* like so:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:472
#, no-wrap
msgid ""
"evalDo : String -> Either Error Integer\n"
"evalDo s = case forget $ split isSpace s of\n"
"  [x,y,z] => do\n"
"    v1 <- readInteger x\n"
"    op <- readOperator y\n"
"    v2 <- readInteger z\n"
"    Right $ op v1 v2\n"
"  _       => Left (ParseError s)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:488
#, no-wrap
msgid ""
"Don't worry, if this doesn't make too much sense yet. We will\n"
"see many more examples, and you'll get the hang of this\n"
"soon enough. The important thing to remember is how *do\n"
"blocks* are always converted to sequences of *bind*\n"
"operators as shown in `desugared1`.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:489
#, no-wrap
msgid "Binding Unit"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:492
#, no-wrap
msgid "Remember our implementation of `friendlyReadHello`? Here it is again:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:493
#, no-wrap
msgid ""
"friendlyReadHello' : IO ()\n"
"friendlyReadHello' = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:505
#, no-wrap
msgid ""
"The underscore in there is a bit ugly and unnecessary. In fact,\n"
"a common use case is to just chain effectful computations with\n"
"result type `Unit` (`()`), merely for the side\n"
"effects they perform. For instance, we could repeat `friendlyReadHello`\n"
"three times, like so:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:506
#, no-wrap
msgid ""
"friendly3 : IO ()\n"
"friendly3 = do\n"
"  _ <- friendlyReadHello\n"
"  _ <- friendlyReadHello\n"
"  friendlyReadHello\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:516
#, no-wrap
msgid ""
"This is such a common thing to do, that Idris allows us to\n"
"drop the bound underscores altogether:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:517
#, no-wrap
msgid ""
"friendly4 : IO ()\n"
"friendly4 = do\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:527
#, no-wrap
msgid "Note, however, that the above gets desugared slightly differently:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:528
#, no-wrap
msgid ""
"friendly4Desugared : IO ()\n"
"friendly4Desugared =\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:538
#, no-wrap
msgid "Operator `(>>)` has the following type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:539
#, no-wrap
msgid ""
"Main> :t (>>)\n"
"Prelude.>> : Monad m => m () -> Lazy (m b) -> m b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:550
#, no-wrap
msgid ""
"Note the `Lazy` keyword in the type signature. This means,\n"
"that the wrapped argument will be *lazily evaluated*. This\n"
"makes sense in many occasions. For instance, if the `Monad`\n"
"in question is `Maybe` the result will be `Nothing` if\n"
"the first argument is `Nothing`, in which case there is no\n"
"need to even evaluate the second argument.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:551
#, no-wrap
msgid "Do, Overloaded"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:562
#, no-wrap
msgid ""
"Because Idris supports function and operator overloading, we\n"
"can write custom *bind* operators, which allows us to\n"
"use *do notation* for types without an implementation\n"
"of `Monad`. For instance, here is a custom implementation of\n"
"`(>>=)` for sequencing computations returning vectors.\n"
"Every value in the first vector (of length `m`)\n"
"will be converted to a vector of length `n`, and\n"
"the results will be concatenated leading to\n"
"a vector of length `m * n`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:563
#, no-wrap
msgid ""
"flatten : Vect m (Vect n a) -> Vect (m * n) a\n"
"flatten []        = []\n"
"flatten (x :: xs) = x ++ flatten xs\n"
"\n"
"(>>=) : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"as >>= f = flatten (map f as)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:580
#, no-wrap
msgid ""
"It is not possible to write an implementation of `Monad`,\n"
"which encapsulates this behavior, as the types wouldn't\n"
"match: Monadic *bind* specialized to `Vect` has\n"
"type `Vect k a -> (a -> Vect k b) -> Vect k b`. As you\n"
"see, the sizes of all three occurrences of `Vect`\n"
"have to be the same, which is not what we expressed\n"
"in our custom version of *bind*. Here is an example to\n"
"see this in action:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:581
#, no-wrap
msgid ""
"modString : String -> Vect 4 String\n"
"modString s = [s, reverse s, toUpper s, toLower s]\n"
"\n"
"testDo : Vect 24 String\n"
"testDo = IO.do\n"
"  s1 <- [\"Hello\", \"World\"]\n"
"  s2 <- [1, 2, 3]\n"
"  modString (s1 ++ show s2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:601
#, no-wrap
msgid ""
"Try to figure out how `testDo` works by desugaring it\n"
"manually and then comparing its result with what you\n"
"expected at the REPL. Note, how we helped Idris disambiguate,\n"
"which version of the *bind* operator to use by prefixing\n"
"the `do` keyword with part of the operator's namespace.\n"
"In this case, this wasn't strictly necessary, although\n"
"`Vect k` does have an implementation of `Monad`, but it is\n"
"still good to know that it is possible to help\n"
"the compiler with disambiguating do blocks.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:605
#, no-wrap
msgid ""
"Of course, we can (and should!) overload `(>>)` in the\n"
"same manner as `(>>=)`, if we want to overload the\n"
"behavior of *do blocks*.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/IO.md:606
#, no-wrap
msgid "Modules and Namespaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:614
#, no-wrap
msgid ""
"Every data type, function, or operator can be unambiguously\n"
"identified by prefixing it with its *namespace*. A function's\n"
"namespace typically is the same as the module where it was defined.\n"
"For instance, the fully qualified name of function `eval`\n"
"would be `Tutorial.IO.eval`. Function and operator names must\n"
"be unique in their namespace.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:620
#, no-wrap
msgid ""
"As we already learned, Idris can often disambiguate between\n"
"functions with the same name but defined in different namespaces\n"
"based on the types involved. If this is not possible, we can help\n"
"the compiler by *prefixing* the function or operator name with\n"
"a *suffix* of the full namespace. Let's demonstrate this at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:621
#, no-wrap
msgid ""
"Tutorial.IO> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:633
#, no-wrap
msgid ""
"As you can see, if we load this module in a REPL session and\n"
"inspect the type of `(>>=)`, we get two results as two\n"
"operators with this name are in scope. If we only want\n"
"the REPL to print the type of our custom *bind* operator,\n"
"is is sufficient to prefix it with `IO`, although we could\n"
"also prefix it with its full namespace:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:634
#, no-wrap
msgid ""
"Tutorial.IO> :t IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"Tutorial.IO> :t Tutorial.IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:649
#, no-wrap
msgid ""
"Since function names must be unique in their namespace and\n"
"we still may want to define two overloaded versions of a function\n"
"in an Idris module, Idris makes it possible to add\n"
"additional namespaces to modules. For instance, in order\n"
"to define another function called `eval`, we need to add\n"
"it to its own namespace (note, that all definitions in a\n"
"namespace must be indented by the same amount of\n"
"white space):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:650
#, no-wrap
msgid ""
"namespace Foo\n"
"  export\n"
"  eval : Nat -> Nat -> Nat\n"
"  eval = (*)\n"
"\n"
"-- prefixing `eval` with its namespace is not strictly necessary here\n"
"testFooEval : Nat\n"
"testFooEval = Foo.eval 12 100\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:665
#, no-wrap
msgid ""
"Now, here is an important thing: For functions and data types to\n"
"be accessible from outside their namespace or module, they need to\n"
"be *exported* by annotating them with the `export` or `public export`\n"
"keywords.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:674
#, no-wrap
msgid ""
"The difference between `export` and `public export` is the following:\n"
"A function annotated with `export` exports its type and can be\n"
"called from other namespaces. A data type annotated with `export`\n"
"exports its type constructor but not its data constructors.\n"
"A function annotated with `public export` also exports its\n"
"implementation. This is necessary to use the function in compile-time\n"
"computations. A data type annotated with `public export`\n"
"exports its data constructors as well.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:680
#, no-wrap
msgid ""
"In general, consider annotating data types with `public export`,\n"
"since otherwise you will not be able to create values of these\n"
"types or deconstruct them in pattern matches. Likewise, unless you\n"
"plan to use your functions in compile-time computations, annotate\n"
"them with `export`.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:681
#, no-wrap
msgid "Bind, with a Bang"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:688
#, no-wrap
msgid ""
"Sometimes, even *do blocks* are too noisy to express a\n"
"combination of effectful computations. In this case, we\n"
"can prefix the effectful parts with an exclamation mark\n"
"(wrapping them in parentheses if they contain additional\n"
"white space), while leaving pure expressions unmodified:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:689
#, no-wrap
msgid ""
"getHello : IO ()\n"
"getHello = putStrLn $ \"Hello \" ++ !getLine ++ \"!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:695
#, no-wrap
msgid "The above gets desugared to the following *do block*:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:696
#, no-wrap
msgid ""
"getHello' : IO ()\n"
"getHello' = do\n"
"  s <- getLine\n"
"  putStrLn $ \"Hello \" ++ s ++ \"!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:704
#, no-wrap
msgid "Here is another example:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:705
#, no-wrap
msgid ""
"bangExpr : String -> String -> String -> Maybe Integer\n"
"bangExpr s1 s2 s3 =\n"
"  Just $ !(parseInteger s1) + !(parseInteger s2) * !(parseInteger s3)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:712
#, no-wrap
msgid "And here is the desugared *do block*:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:713
#, no-wrap
msgid ""
"bangExpr' : String -> String -> String -> Maybe Integer\n"
"bangExpr' s1 s2 s3 = do\n"
"  x1 <- parseInteger s1\n"
"  x2 <- parseInteger s2\n"
"  x3 <- parseInteger s3\n"
"  Just $ x1 + x2 * x3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:727
#, no-wrap
msgid ""
"Please remember the following: Syntactic sugar has been introduced\n"
"to make code more readable or more convenient to write. If\n"
"it is abused just to show how clever you are, you make things\n"
"harder for other people (including your future self!)\n"
"reading and trying to understand your code.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:733
msgid ""
"Reimplement the following *do blocks*, once by using *bang notation*, and "
"once by writing them in their desugared form with nested *bind*s:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:734
#, no-wrap
msgid ""
"   ex1a : IO String\n"
"   ex1a = do\n"
"     s1 <- getLine\n"
"     s2 <- getLine\n"
"     s3 <- getLine\n"
"     pure $ s1 ++ reverse s2 ++ s3\n"
"\n"
"   ex1b : Maybe Integer\n"
"   ex1b = do\n"
"     n1 <- parseInteger \"12\"\n"
"     n2 <- parseInteger \"300\"\n"
"     Just $ n1 + n2 * 100\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:752
msgid ""
"Below is the definition of an indexed family of types, the index of which "
"keeps track of whether the value in question is possibly empty or provably "
"non-empty:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:766
#, no-wrap
msgid ""
"   Please note, that the `Nil` case *must* have the `nonEmpty`\n"
"   tag set to `False`, while with the *cons* case, this is\n"
"   optional. So, a `List01 False a` can be empty or non-empty,\n"
"   and we'll only find out, which is the case, by pattern\n"
"   matching on it. A `List01 True a` on the other hand *must*\n"
"   be a *cons*, as for the `Nil` case the `nonEmpty` tag is\n"
"   always set to `False`.\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/IO.md:768
msgid "Declare and implement function `head` for non-empty lists:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:772
#, no-wrap
msgid ""
"      ```idris\n"
"      head : List01 True a -> a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/IO.md:776
msgid ""
"Declare and implement function `weaken` for converting any `List01 ne a` to "
"a `List01 False a` of the same length and order of values."
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/IO.md:779
msgid ""
"Declare and implement function `tail` for extracting the possibly empty tail "
"from a non-empty list."
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/IO.md:784
msgid ""
"Implement function `(++)` for concatenating two values of type "
"`List01`. Note, how we use a type-level computation to make sure the result "
"is non-empty if and only if at least one of the two arguments is non-empty:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:788
#, no-wrap
msgid ""
"      ```idris\n"
"      (++) : List01 b1 a -> List01 b2 a -> List01 (b1 || b2) a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/IO.md:794
msgid ""
"Implement utility function `concat'` and use it in the implementation of "
"`concat`. Note, that in `concat` the two boolean tags are passed as "
"unrestricted implicits, since you will need to pattern match on these to "
"determine whether the result is provably non-empty or not:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:797
#, no-wrap
msgid ""
"      ```idris\n"
"      concat' : List01 ne1 (List01 ne2 a) -> List01 False a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:802
#, no-wrap
msgid ""
"      concat :  {ne1, ne2 : _}\n"
"             -> List01 ne1 (List01 ne2 a)\n"
"             -> List01 (ne1 && ne2) a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/IO.md:804
msgid "Implement `map01`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:808
#, no-wrap
msgid ""
"      ```idris\n"
"      map01 : (a -> b) -> List01 ne a -> List01 ne b\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   7. '
#: ../src/Tutorial/IO.md:811
msgid ""
"Implement a custom *bind* operator in namespace `List01` for sequencing "
"computations returning `List01`s."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:814
#, no-wrap
msgid ""
"      Hint: Use `map01` and `concat` in your implementation and\n"
"      make sure to use unrestricted implicits where necessary.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:817
#, no-wrap
msgid ""
"      You can use the following examples to test your\n"
"      custom *bind* operator:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:823
#, no-wrap
msgid ""
"      ```idris\n"
"      -- this and lf are necessary to make sure, which tag to use\n"
"      -- when using list literals\n"
"      lt : List01 True a -> List01 True a\n"
"      lt = id\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:826
#, no-wrap
msgid ""
"      lf : List01 False a -> List01 False a\n"
"      lf = id\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:833
#, no-wrap
msgid ""
"      test : List01 True Integer\n"
"      test = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- lt [4,5,6,7]\n"
"        op <- lt [(*), (+), (-)]\n"
"        [op x y]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:841
#, no-wrap
msgid ""
"      test2 : List01 False Integer\n"
"      test2 = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- Nil {a = Integer}\n"
"        op <- lt [(*), (+), (-)]\n"
"        lt [op x y]\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:857
#, no-wrap
msgid ""
"Some notes on Exercise 2: Here, we combined the capabilities\n"
"of `List` and `Data.List1` in a single indexed type family.\n"
"This allowed us to treat list concatenation correctly: If\n"
"at least one of the arguments is provably non-empty, the\n"
"result is also non-empty. To tackle this correctly with\n"
"`List` and `List1`, a total of four concatenation functions\n"
"would have to be written. So, while it is often possible to\n"
"define distinct data types instead of indexed families,\n"
"the latter allow us to perform type-level computations to\n"
"be more precise about the pre- and postconditions of the functions\n"
"we write, at the cost of more-complex type signatures.\n"
"In addition, sometimes it's not possible to derive the\n"
"values of the indices from pattern matching on the data\n"
"values alone, so they have to be passed as unerased\n"
"(possibly implicit) arguments.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:864
#, no-wrap
msgid ""
"Please remember, that *do blocks* are first desugared, before\n"
"type-checking, disambiguating which *bind* operator to use,\n"
"and filling in implicit arguments. It is therefore perfectly fine\n"
"to define *bind* operators with arbitrary constraints or\n"
"implicit arguments as was shown above. Idris will handle\n"
"all the details, *after* desugaring the *do blocks*.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/IO.md:865
#, no-wrap
msgid "Working with Files"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:872
#, no-wrap
msgid ""
"Module `System.File` from the *base* library exports utilities necessary\n"
"to work with file handles and read and write from and to files. When\n"
"you have a file path (for instance "
"\"/home/hock/idris/tutorial/tutorial.ipkg\"),\n"
"the first thing we will typically do is to try and create a file handle\n"
"(of type `System.File.File` by calling `fileOpen`).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:874
#, no-wrap
msgid "Here is a program for counting all empty lines in a Unix/Linux-file:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:875
#, no-wrap
msgid ""
"covering\n"
"countEmpty : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty path = openFile path Read >>= either (pure . Left) (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => closeFile file $> Right k\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => closeFile file $> Left err\n"
"          go (k + 1) file\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:894
#, no-wrap
msgid ""
"In the example above, I invoked `(>>=)` without starting a *do block*.\n"
"Make sure you understand what's going on here. Reading concise functional\n"
"code is important in order to understand other people's code.\n"
"Have a look at function `either` at the REPL, try figuring out what\n"
"`(pure . Left)` does, and note how we use a curried version of `go`\n"
"as the second argument to `either`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:905
#, no-wrap
msgid ""
"Function `go` calls for some additional explanations. First, note how\n"
"we used the same syntax for pattern matching intermediary results\n"
"as we also saw for `let` bindings. As you can see, we can use several\n"
"vertical bars to handle more than one additional pattern. In order to\n"
"read a single line from a file, we use function `fGetLine`. As with\n"
"most operations working with the file system, this function might fail\n"
"with a `FileError`, which we have to handle correctly. Note also, that\n"
"`fGetLine` will return the line including its trailing newline character\n"
"`'\\n'`, so in order to check for empty lines, we have to match against\n"
"`\"\\n\"` instead of the empty string `\"\"`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:910
#, no-wrap
msgid ""
"Finally, `go` is not provably total and rightfully so.\n"
"Files like `/dev/urandom` or `/dev/zero` provide infinite\n"
"streams of data, so `countEmpty` will never\n"
"terminate when invoked with such a file path.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:911
#, no-wrap
msgid "Safe Resource Handling"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:919
#, no-wrap
msgid ""
"Note, how we had to manually open and close the file handle in\n"
"`countEmpty`. This is error-prone and tedious. Resource handling\n"
"is a big topic, and we definitely won't be going into the\n"
"details here, but there is a convenient function exported\n"
"from `System.File`: `withFile`, which handles the opening,\n"
"closing and handling of file errors for us.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:920
#, no-wrap
msgid ""
"covering\n"
"countEmpty' : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty' path = withFile path Read pure (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => pure (Right k)\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => pure (Left err)\n"
"          go (k + 1) file\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:937
#, no-wrap
msgid ""
"Go ahead, and have a look at the type of `withFile`, then\n"
"have a look how we use it to simplify the implementation of\n"
"`countEmpty'`. Reading and understanding slightly more complex\n"
"function types is important when learning to program in Idris.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/IO.md:938
#, no-wrap
msgid "Interface `HasIO`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:948
#, no-wrap
msgid ""
"When you look at the `IO` functions we used so far, you'll\n"
"notice that most if not all of them actually don't work\n"
"with `IO` itself but with a type parameter `io` with a\n"
"constraint of `HasIO`. This interface allows us to *lift*\n"
"a value of type `IO a` into another context. We will see\n"
"use cases for this in later chapters, especially when we\n"
"talk about monad transformers. For now, you can treat these\n"
"`io` parameters as being specialized to `IO`.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:959
msgid ""
"As we have seen in the examples above, `IO` actions working with file "
"handles often come with the risk of failure. We can therefore simplify "
"things by writing some utility functions and a custom *bind* operator to "
"work with these nested effects. In a new namespace `IOErr`, implement the "
"following utility functions and use these to further cleanup the "
"implementation of `countEmpty'`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:960
#, no-wrap
msgid ""
"   pure : a -> IO (Either e a)\n"
"\n"
"   fail : e -> IO (Either e a)\n"
"\n"
"   lift : IO a -> IO (Either e a)\n"
"\n"
"   catch : IO (Either e1 a) -> (e1 -> IO (Either e2 a)) -> IO (Either e2 "
"a)\n"
"\n"
"   (>>=) : IO (Either e a) -> (a -> IO (Either e b)) -> IO (Either e b)\n"
"\n"
"   (>>) : IO (Either e ()) -> Lazy (IO (Either e a)) -> IO (Either e a)\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:977
msgid ""
"Write a function `countWords` for counting the words in a file.  Consider "
"using `Data.String.words` and the utilities from exercise 1 in your "
"implementation."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/IO.md:983
msgid ""
"We can generalize the functionality used in `countEmpty` and `countWords`, "
"by implementing a helper function for iterating over the lines in a file and "
"accumulating some state along the way. Implement `withLines` and use it to "
"reimplement `countEmpty` and `countWords`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:984
#, no-wrap
msgid ""
"   covering\n"
"   withLines :  (path : String)\n"
"             -> (accum : s -> String -> s)\n"
"             -> (initialState : s)\n"
"             -> IO (Either FileError s)\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/IO.md:996
msgid ""
"We often use a `Monoid` for accumulating values.  It is therefore convenient "
"to specialize `withLines` for this case. Use `withLines` to implement "
"`foldLines` according to the type given below:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:997
#, no-wrap
msgid ""
"   covering\n"
"   foldLines :  Monoid s\n"
"             => (path : String)\n"
"             -> (f    : String -> s)\n"
"             -> IO (Either FileError s)\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/IO.md:1012
msgid ""
"Implement function `wordCount` for counting the number of lines, words, and "
"characters in a text document. Define a custom record type together with an "
"implementation of `Monoid` for storing and accumulating these values and use "
"`foldLines` in your implementation of `wordCount`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/IO.md:1013
#, no-wrap
msgid "How `IO` is Implemented"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1019
#, no-wrap
msgid ""
"In this final section of an already lengthy chapter, we will risk\n"
"a glance at how `IO` is implemented in Idris. It is interesting\n"
"to note, that `IO` is not a built-in type but a regular data type\n"
"with only one minor speciality. Let's learn about it at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1020
#, no-wrap
msgid ""
"Tutorial.IO> :doc IO\n"
"data PrimIO.IO : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIO : (1 _ : PrimIO a) -> IO a\n"
"  Hints:\n"
"    Applicative IO\n"
"    Functor IO\n"
"    HasLinearIO IO\n"
"    Monad IO\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1037
#, no-wrap
msgid ""
"Here, we learn that `IO` has a single data constructor\n"
"called `MkIO`, which takes a single argument of type\n"
"`PrimIO a` with quantity *1*. We are not going to\n"
"talk about the quantities here, as in fact they are not\n"
"important to understand how `IO` works.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1039
#, no-wrap
msgid "Now, `PrimIO a` is a type alias for the following function:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1040
#, no-wrap
msgid ""
"Tutorial.IO> :printdef PrimIO\n"
"PrimIO.PrimIO : Type -> Type\n"
"PrimIO a = (1 _ : %World) -> IORes a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1049
#, no-wrap
msgid ""
"Again, don't mind the quantities. There is only\n"
"one piece of the puzzle missing: `IORes a`, which is\n"
"a publicly exported record type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1050
#, no-wrap
msgid ""
"Solutions.IO> :doc IORes\n"
"data PrimIO.IORes : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIORes : a -> (1 _ : %World) -> IORes a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1059
#, no-wrap
msgid ""
"So, to put this all together, `IO` is a wrapper around\n"
"something similar to the following function type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1060
#, no-wrap
msgid "%World -> (a, %World)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1072
#, no-wrap
msgid ""
"You can think of type `%World` as a placeholder for the\n"
"state of the outside world of a program (file system,\n"
"memory, network connections, and so on). Conceptually,\n"
"to execute an `IO a` action, we pass it the current state\n"
"of the world, and in return get an updated world state\n"
"plus a result of type `a`. The world state being updated\n"
"represents all the side effects describable in a computer\n"
"program.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1088
#, no-wrap
msgid ""
"Now, it is important to understand that there is no such\n"
"thing as the *state of the world*. The `%World` type is\n"
"just a placeholder, which is converted to some kind of\n"
"constant that's passed around and never inspected at\n"
"runtime. So, if we had a value of type `%World`, we could\n"
"pass it to an `IO a` action and execute it, and this is\n"
"exactly what happens at runtime: A single value of\n"
"type `%World` (an uninteresting placeholder like `null`,\n"
"`0`, or - in case of the JavaScript backends - `undefined`)\n"
"is passed to the `main` function, thus\n"
"setting the whole program in motion. However, it\n"
"is impossible to programmatically create a value of\n"
"type `%World` (it is an abstract, primitive type), and\n"
"therefore we cannot ever extract a value of type `a`\n"
"from an `IO a` action (modulo `unsafePerformIO`).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1094
#, no-wrap
msgid ""
"Once we will talk about monad transformers and the state\n"
"monad, you will see that `IO` is nothing else but\n"
"a state monad in disguise but with an abstract state\n"
"type, which makes it impossible for us to run the\n"
"stateful computation.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1099
msgid ""
"Values of type `IO a` describe programs with side effects, which will "
"eventually result in a value of type `a`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1104
msgid ""
"While we cannot safely extract a value of type `a` from an `IO a`, we can "
"use several combinators and syntactic constructs to combine `IO` actions and "
"build more-complex programs."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1107
msgid ""
"*Do blocks* offer a convenient way to run and combine `IO` actions "
"sequentially."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1110
msgid ""
"*Do blocks* are desugared to nested applications of *bind* operators "
"(`(>>=)`)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1114
msgid ""
"*Bind* operators, and thus *do blocks*, can be overloaded to achieve custom "
"behavior instead of the default (monadic) *bind*."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1117
msgid ""
"Under the hood, `IO` actions are stateful computations operating on a "
"symbolic `%World` state."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1123
#, no-wrap
msgid ""
"Now, that we had a glimpse at *monads* and the *bind* operator,\n"
"it is time to in the [next chapter](Functor.md) introduce `Monad` and some\n"
"related interfaces for real.\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Predicates.md:1
#, no-wrap
msgid "Predicates and Proof Search"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:12
#, no-wrap
msgid ""
"In the [last chapter](Eq.md) we learned about propositional\n"
"equality, which allowed us to proof that two values are\n"
"equal. Equality is a relation between values, and we used\n"
"an indexed data type to encode this relation by limiting\n"
"the degrees of freedom of the indices in the sole data\n"
"constructor. There are other relations and contracts we\n"
"can encode this way. This will allow us to restrict the\n"
"values we accept as a function's arguments or the values\n"
"returned by functions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:13
#, no-wrap
msgid ""
"module Tutorial.Predicates\n"
"\n"
"import Data.Either\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"import Data.HList\n"
"import Decidable.Equality\n"
"\n"
"import Text.CSV\n"
"import System.File\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:29
#, no-wrap
msgid "Preconditions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:38
#, no-wrap
msgid ""
"Often, when we implement functions operating on values\n"
"of a given type, not all values are considered to be\n"
"valid arguments for the function in question. For instance,\n"
"we typically do not allow division by zero, as the result\n"
"is undefined in the general case. This concept of putting\n"
"a *precondition* on a function argument comes up pretty often,\n"
"and there are several ways to go about this.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:45
#, no-wrap
msgid ""
"A very common operation when working with lists or other\n"
"container types is to extract the first value in the sequence.\n"
"This function, however, cannot work in the general case, because\n"
"in order to extract a value from a list, the list must not\n"
"be empty. Here are a couple of ways to encode and implement\n"
"this, each with its own advantages and disadvantages:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:57
msgid ""
"Wrap the result in a failure type, such as a `Maybe` or `Either e` with some "
"custom error type `e`. This makes it immediately clear that the function "
"might not be able to return a result. It is a natural way to deal with "
"unvalidated input from unknown sources. The drawback of this approach is "
"that results will carry the `Maybe` stain, even in situations when we *know* "
"that the *nil* case is impossible, for instance because we know the value of "
"the list argument at compile-time, or because we already *refined* the input "
"value in such a way that we can be sure it is not empty (due to an earlier "
"pattern match, for instance)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:67
msgid ""
"Define a new data type for non-empty lists and use this as the function's "
"argument. This is the approach taken in module `Data.List1`. It allows us to "
"return a pure value (meaning \"not wrapped in a failure type\" here), "
"because the function cannot possibly fail, but it comes with the burden of "
"reimplementing many of the utility functions and interfaces we already "
"implemented for `List`. For a very common data structure this can be a valid "
"option, but for rare use cases it is often too cumbersome."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:81
msgid ""
"Use an index to keep track of the property we are interested in. This was "
"the approach we took with type family `List01`, which we saw in several "
"examples and exercises in this guide so far. This is also the approach taken "
"with vectors, where we use the exact length as our index, which is even more "
"expressive. While this allows us to implement many functions only once and "
"with greater precision at the type level, it also comes with the burden of "
"keeping track of changes in the types, making for more complex function "
"types and forcing us to at times return existentially quantified wrappers "
"(for instance, dependent pairs), because the outcome of a computation is not "
"known until runtime."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:87
msgid ""
"Fail with a runtime exception. This is a popular solution in many "
"programming languages (even Haskell), but in Idris we try to avoid this, "
"because it breaks totality in a way, which also affects client "
"code. Luckily, we can make use of our powerful type system to avoid this "
"situation in general."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:94
msgid ""
"Take an additional (possibly erased) argument of a type we can use as a "
"witness that the input value is of the correct kind or shape. This is the "
"solution we will discuss in this chapter in great detail. It is an "
"incredibly powerful way to talk about restrictions on values without having "
"to replicate a lot of already existing functionality."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:100
#, no-wrap
msgid ""
"There is a time and place for most if not all of the solutions\n"
"listed above in Idris, but we will often turn to the last one and\n"
"refine function arguments with predicates (so called\n"
"*preconditions*), because it makes our functions nice to use at\n"
"runtime *and* compile time.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:101
#, no-wrap
msgid "Example: Non-empty Lists"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:107
#, no-wrap
msgid ""
"Remember how we implemented an indexed data type for\n"
"propositional equality: We restricted the valid\n"
"values of the indices in the constructors. We can do\n"
"the same thing for a predicate for non-empty lists:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:108
#, no-wrap
msgid ""
"data NotNil : (as : List a) -> Type where\n"
"  IsNotNil : NotNil (h :: t)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:117
#, no-wrap
msgid ""
"This is a single-value data type, so we can always use it\n"
"as an erased function argument and still pattern match on\n"
"it. We can now use this to implement a safe and pure `head`\n"
"function:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:118
#, no-wrap
msgid ""
"head1 : (as : List a) -> (0 _ : NotNil as) -> a\n"
"head1 (h :: _) _ = h\n"
"head1 [] IsNotNil impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:129
#, no-wrap
msgid ""
"Note, how value `IsNotNil` is a *witness* that its index,\n"
"which corresponds to our list argument, is indeed non-empty,\n"
"because this is what we specified in its type.\n"
"The impossible case in the implementation of `head1` is not\n"
"strictly necessary here. It was given above for completeness.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:134
#, no-wrap
msgid ""
"We call `NotNil` a *predicate* on lists, as it restricts\n"
"the values allowed in the index. We can express a function's\n"
"preconditions by adding additional (possibly erased) predicates\n"
"to the function's list of arguments.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:138
#, no-wrap
msgid ""
"The first really cool thing is how we can safely use `head1`,\n"
"if we can at compile-time show that our list argument is\n"
"indeed non-empty:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:139
#, no-wrap
msgid ""
"headEx1 : Nat\n"
"headEx1 = head1 [1,2,3] IsNotNil\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:152
#, no-wrap
msgid ""
"It is a bit cumbersome that we have to pass the `IsNotNil` proof\n"
"manually. Before we scratch that itch, we will first discuss what\n"
"to do with lists, the values of which are not known until\n"
"runtime. For these cases, we have to try and produce a value\n"
"of the predicate programmatically by inspecting the runtime\n"
"list value. In the most simple case, we can wrap the proof\n"
"in a `Maybe`, but if we can show that our predicate is *decidable*,\n"
"we can get even stronger guarantees by returning a `Dec`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:153
#, no-wrap
msgid ""
"Uninhabited (NotNil []) where\n"
"  uninhabited IsNotNil impossible\n"
"\n"
"nonEmpty : (as : List a) -> Dec (NotNil as)\n"
"nonEmpty (x :: xs) = Yes IsNotNil\n"
"nonEmpty []        = No uninhabited\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:164
#, no-wrap
msgid ""
"With this, we can implement function `headMaybe`, which\n"
"is to be used with lists of unknown origin:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:165
#, no-wrap
msgid ""
"headMaybe1 : List a -> Maybe a\n"
"headMaybe1 as = case nonEmpty as of\n"
"  Yes prf => Just $ head1 as prf\n"
"  No  _   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:176
#, no-wrap
msgid ""
"Of course, for trivial functions like `headMaybe` it makes\n"
"more sense to implement them directly by pattern matching on\n"
"the list argument, but we will soon see examples of predicates\n"
"the values of which are more cumbersome to create.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:177
#, no-wrap
msgid "Auto Implicits"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:187
#, no-wrap
msgid ""
"Having to manually pass a proof of being non-empty to\n"
"`head1` makes this function unnecessarily verbose to\n"
"use at compile time. Idris allows us to define implicit\n"
"function arguments, the values of which it tries to assemble\n"
"on its own by means of a technique called *proof search*. This is not\n"
"to be confused with type inference, which means inferring\n"
"values or types from the surrounding context. It's best\n"
"to look at some examples to explain the difference.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:190
#, no-wrap
msgid ""
"Let us first have a look at the following implementation of\n"
"`replicate` for vectors:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:191
#, no-wrap
msgid ""
"replicate' : {n : _} -> a -> Vect n a\n"
"replicate' {n = 0}   _ = []\n"
"replicate' {n = S _} v = v :: replicate' v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:202
#, no-wrap
msgid ""
"Function `replicate'` takes an unerased implicit argument.\n"
"The *value* of this argument must be derivable from the surrounding\n"
"context. For instance, in the following example it is\n"
"immediately clear that `n` equals three, because that is\n"
"the length of the vector we want:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:203
#, no-wrap
msgid ""
"replicateEx1 : Vect 3 Nat\n"
"replicateEx1 = replicate' 12\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:211
#, no-wrap
msgid ""
"In the next example, the value of `n` is not known at compile time,\n"
"but it is available as an unerased implicit, so this can again\n"
"be passed as is to `replicate'`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:212
#, no-wrap
msgid ""
"replicateEx2 : {n : _} -> Vect n Nat\n"
"replicateEx2 = replicate' 12\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:223
#, no-wrap
msgid ""
"However, in the following example, the value of `n` can't\n"
"be inferred, as the intermediary vector is immediately converted\n"
"to a list of unknown length. Although Idris could try and insert\n"
"any value for `n` here, it won't do so, because it can't be\n"
"sure that this is the length we want. We therefore have to pass the\n"
"length explicitly:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:224
#, no-wrap
msgid ""
"replicateEx3 : List Nat\n"
"replicateEx3 = toList $ replicate' {n = 17} 12\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:234
#, no-wrap
msgid ""
"Note, how the *value* of `n` had to be inferable in\n"
"these examples, which means it had to make an appearance\n"
"in the surrounding context. With auto implicit arguments,\n"
"this works differently. Here is the `head` example, this\n"
"time with an auto implicit:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:235
#, no-wrap
msgid ""
"head : (as : List a) -> {auto 0 prf : NotNil as} -> a\n"
"head (x :: _) = x\n"
"head [] impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:249
#, no-wrap
msgid ""
"Note the `auto` keyword before the quantity of implicit argument\n"
"`prf`. This means, we want Idris to construct this value\n"
"on its own, without it being visible in the surrounding context.\n"
"In order to do so, Idris will have to at compile time know the\n"
"structure of the list argument `as`. It will then try and build\n"
"such a value from the data type's constructors. If it succeeds,\n"
"this value will then be automatically filled in as the desired argument,\n"
"otherwise, Idris will fail with a type error.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:251
#, no-wrap
msgid "Let's see this in action:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:252
#, no-wrap
msgid ""
"headEx3 : Nat\n"
"headEx3 = Predicates.head [1,2,3]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:258
#, no-wrap
msgid "The following example fails with an error:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:259
#, no-wrap
msgid ""
"failing \"Can't find an implementation\\nfor NotNil [].\"\n"
"  errHead : Nat\n"
"  errHead = Predicates.head []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:276
#, no-wrap
msgid ""
"Wait! \"Can't find an implementation for...\"? Is this not the\n"
"error message we get for missing interface implementations?\n"
"That's correct, and I'll show you that interface resolution\n"
"is just proof search at the end of this chapter. What I can\n"
"show you already, is that writing the lengthy `{auto prf : t} ->`\n"
"all the times can be cumbersome. Idris therefore allows us\n"
"to use the same syntax as for constrained functions instead:\n"
"`(prf : t) =>`, or even `t =>`, if we don't need to name the\n"
"constraint. As usual, we can then access a constraint in the\n"
"function body by its name (if any). Here is another implementation\n"
"of `head`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:277
#, no-wrap
msgid ""
"head' : (as : List a) -> (0 _ : NotNil as) => a\n"
"head' (x :: _) = x\n"
"head' [] impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:287
#, no-wrap
msgid ""
"During proof search, Idris will also look for values of\n"
"the required type in the current function context. This allows\n"
"us to implement `headMaybe` without having to pass on\n"
"the `NotNil` proof manually:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:288
#, no-wrap
msgid ""
"headMaybe : List a -> Maybe a\n"
"headMaybe as = case nonEmpty as of\n"
"  -- `prf` is available during proof seach\n"
"  Yes prf => Just $ Predicates.head as\n"
"  No  _   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:304
#, no-wrap
msgid ""
"To conclude: Predicates allow us to restrict the values\n"
"a function accepts as arguments. At runtime, we need to\n"
"build such *witnesses* by pattern matching on the function\n"
"arguments. These operations can typically fail. At compile\n"
"time, we can let Idris try and build these values for us\n"
"using a technique called *proof search*. This allows us\n"
"to make functions safe and convenient to use at the same\n"
"time.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:312
#, no-wrap
msgid ""
"In these exercises, you'll have to implement several\n"
"functions making use of auto implicits, to constrain\n"
"the values accepted as function arguments. The results\n"
"should be *pure*, that is, not wrapped in a failure type\n"
"like `Maybe`.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:314
msgid "Implement `tail` for lists."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:318
msgid ""
"Implement `concat1` and `foldMap1` for lists. These should work like "
"`concat` and `foldMap`, but taking only a `Semigroup` constraint on the "
"element type."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:321
msgid ""
"Implement functions for returning the largest and smallest element in a "
"list."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:325
msgid ""
"Define a predicate for strictly positive natural numbers and use it to "
"implement a safe and provably total division function on natural numbers."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Predicates.md:330
msgid ""
"Define a predicate for a non-empty `Maybe` and use it to safely extract the "
"value stored in a `Just`. Show that this predicate is decidable by "
"implementing a corresponding conversion function."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Predicates.md:334
msgid ""
"Define and implement functions for safely extracting values from a `Left` "
"and a `Right` by using suitable predicates.  Show again that these "
"predicates are decidable."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:339
#, no-wrap
msgid ""
"The predicates you implemented in these exercises are already\n"
"available in the *base* library: `Data.List.NonEmpty`,\n"
"`Data.Maybe.IsJust`, `Data.Either.IsLeft`, `Data.Either.IsRight`,\n"
"and `Data.Nat.IsSucc`.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:340
#, no-wrap
msgid "Contracts between Values"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:346
#, no-wrap
msgid ""
"The predicates we saw so far restricted the values of\n"
"a single type, but it is also possible to define predicates\n"
"describing contracts between several values of possibly\n"
"distinct types.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:347
#, no-wrap
msgid "The `Elem` Predicate"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:351
#, no-wrap
msgid ""
"Assume we'd like to extract a value of a given type from\n"
"a heterogeneous list:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:352
#, no-wrap
msgid "get' : (0 t : Type) -> HList ts -> t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:358
#, no-wrap
msgid ""
"This can't work in general: If we could implement this we would\n"
"immediately have a proof of void:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:359
#, no-wrap
msgid ""
"voidAgain : Void\n"
"voidAgain = get' Void []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:367
#, no-wrap
msgid ""
"The problem is obvious: The type of which we'd like to extract\n"
"a value must be an element of the index of the heterogeneous list.\n"
"Here is a predicate, with which we can express this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:368
#, no-wrap
msgid ""
"data Elem : (elem : a) -> (as : List a) -> Type where\n"
"  Here  : Elem x (x :: xs)\n"
"  There : Elem x xs -> Elem x (y :: xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:386
#, no-wrap
msgid ""
"This is a predicate describing a contract between two values:\n"
"A value of type `a` and a list of `a`s. Values of this predicate\n"
"are witnesses that the value is an element of the list.\n"
"Note, how this is defined recursively: The case\n"
"where the value we look for is at the head of the list is\n"
"handled by the `Here` constructor, where the same variable (`x`) is used\n"
"for the element and the head of the list. The case where the value\n"
"is deeper within  the list is handled by the `There`\n"
"constructor. This can be read as follows: If `x` is and element\n"
"of `xs`, then `x` is also an element of `y :: xs` for any\n"
"value `y`. Let's write down some examples to get a feel\n"
"for these:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:387
#, no-wrap
msgid ""
"MyList : List Nat\n"
"MyList = [1,3,7,8,4,12]\n"
"\n"
"oneElemMyList : Elem 1 MyList\n"
"oneElemMyList = Here\n"
"\n"
"sevenElemMyList : Elem 7 MyList\n"
"sevenElemMyList = There $ There Here\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:402
#, no-wrap
msgid ""
"Now, `Elem` is just another way of indexing into a list\n"
"of values. Instead of using a `Fin` index, which is limited\n"
"by the list's length, we use a proof that a value can be found\n"
"at a certain position.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:405
#, no-wrap
msgid ""
"We can use the `Elem` predicate to extract a value from\n"
"the desired type of a heterogeneous list:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:406
#, no-wrap
msgid "get : (0 t : Type) -> HList ts -> (prf : Elem t ts) => t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:415
#, no-wrap
msgid ""
"It is important to note that the auto implicit must not be\n"
"erased in this case. This is no longer a single value data type,\n"
"and we must be able to pattern match on this value in order to\n"
"figure out, how far within the heterogeneous list our value\n"
"is stored:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:416
#, no-wrap
msgid ""
"get t (v :: vs) {prf = Here}    = v\n"
"get t (v :: vs) {prf = There p} = get t vs\n"
"get _ [] impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:425
#, no-wrap
msgid ""
"It can be instructive to implement `get` yourself, using holes on\n"
"the right hand side to see the context and types of values Idris\n"
"infers based on the value of the `Elem` predicate.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:427
#, no-wrap
msgid "Let's give this a spin at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:428
#, no-wrap
msgid ""
"Tutorial.Predicates> get Nat [\"foo\", Just \"bar\", S Z]\n"
"1\n"
"Tutorial.Predicates> get Nat [\"foo\", Just \"bar\"]\n"
"Error: Can't find an implementation for Elem Nat [String, Maybe String].\n"
"\n"
"(Interactive):1:1--1:28\n"
" 1 | get Nat [\"foo\", Just \"bar\"]\n"
"     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:446
#, no-wrap
msgid ""
"With this example we start to appreciate what *proof search*\n"
"actually means: Given a value `v` and a list of values `vs`, Idris tries\n"
"to find a proof that `v` is an element of `vs`.\n"
"Now, before we continue, please note that proof search is\n"
"not a silver bullet. The search algorithm has a reasonably limited\n"
"*search depth*, and will fail with the search if this limit\n"
"is exceeded. For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:447
#, no-wrap
msgid ""
"Tps : List Type\n"
"Tps = List.replicate 50 Nat ++ [Maybe String]\n"
"\n"
"hlist : HList Tps\n"
"hlist = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , Nothing ]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:462
#, no-wrap
msgid ""
"Tutorial.Predicates> get (Maybe String) hlist\n"
"Error: Can't find an implementation for Elem (Maybe String) [Nat,...\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:474
#, no-wrap
msgid ""
"As you can see, Idris fails to find a proof that `Maybe String`\n"
"is an element of `Tps`. The search depth can be increased with\n"
"the `%auto_implicit_depth` directive, which will hold for the\n"
"rest of the source file or until set to a different value.\n"
"The default value is set at 25. In general, it is not advisable\n"
"to set this to a too large value as this can drastically increase\n"
"compile times.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:475
#, no-wrap
msgid ""
"%auto_implicit_depth 100\n"
"aMaybe : Maybe String\n"
"aMaybe = get _ hlist\n"
"\n"
"%auto_implicit_depth 25\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:483
#, no-wrap
msgid "Use Case: A nicer Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:492
#, no-wrap
msgid ""
"In the chapter about [sigma types](DPair.md), we introduced\n"
"a schema for CSV files. This was not very nice to use, because\n"
"we had to use natural numbers to access a certain column. Even\n"
"worse, users of our small library had to do the same. There was\n"
"no way to define a name for each column and access columns by\n"
"name. We are going to change this. Here is an encoding\n"
"for this use case:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:493
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"record Column where\n"
"  constructor MkColumn\n"
"  name : String\n"
"  type : ColType\n"
"\n"
"infixr 8 :>\n"
"\n"
"(:>) : String -> ColType -> Column\n"
"(:>) = MkColumn\n"
"\n"
"Schema : Type\n"
"Schema = List Column\n"
"\n"
"Show ColType where\n"
"  show I64     = \"I64\"\n"
"  show Str     = \"Str\"\n"
"  show Boolean = \"Boolean\"\n"
"  show Float   = \"Float\"\n"
"\n"
"Show Column where\n"
"  show (MkColumn n ct) = \"\\{n}:\\{show ct}\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map show\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:531
#, no-wrap
msgid ""
"As you can see, in a schema we now pair a column's type\n"
"with its name. Here is an example schema for a CSV file\n"
"holding information about employees in a company:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:532
#, no-wrap
msgid ""
"EmployeeSchema : Schema\n"
"EmployeeSchema = [ \"firstName\"  :> Str\n"
"                 , \"lastName\"   :> Str\n"
"                 , \"email\"      :> Str\n"
"                 , \"age\"        :> I64\n"
"                 , \"salary\"     :> Float\n"
"                 , \"management\" :> Boolean\n"
"                 ]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:549
#, no-wrap
msgid ""
"Such a schema could of course again be read from user\n"
"input, but we will wait with implementing a parser until\n"
"later in this chapter.\n"
"Using this new schema with an `HList` directly led to issues\n"
"with type inference, therefore I quickly wrote a custom\n"
"row type: A heterogeneous list indexed over a schema.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:550
#, no-wrap
msgid ""
"data Row : Schema -> Type where\n"
"  Nil  : Row []\n"
"\n"
"  (::) :  {0 name : String}\n"
"       -> {0 type : ColType}\n"
"       -> (v : IdrisType type)\n"
"       -> Row ss\n"
"       -> Row (name :> type :: ss)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:565
#, no-wrap
msgid ""
"In the signature of *cons*, I list the erased implicit arguments\n"
"explicitly. This is good practice, as otherwise Idris will often\n"
"issue shadowing warnings when using such data constructors in client\n"
"code.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:567
#, no-wrap
msgid "We can now define a type alias for CSV rows representing employees:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:568
#, no-wrap
msgid ""
"0 Employee : Type\n"
"Employee = Row EmployeeSchema\n"
"\n"
"hock : Employee\n"
"hock = [ \"Stefan\", \"Höck\", \"hock@foo.com\", 46, 5443.2, False ]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:584
#, no-wrap
msgid ""
"Note, how I gave `Employee` a zero quantity. This means, we are\n"
"only ever allowed to use this function at compile time\n"
"but never at runtime. This is a safe way to make sure\n"
"our type-level functions and aliases do not leak into the\n"
"executable when we build our application. We are allowed\n"
"to use zero-quantity functions and values in type signatures\n"
"and when computing other erased values, but not for runtime-relevant\n"
"computations.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:602
#, no-wrap
msgid ""
"We would now like to access a value in a row based on\n"
"the name given. For this, we write a custom predicate, which\n"
"serves as a witness that a column with the given name is\n"
"part of the schema. Now, here is an important thing to note:\n"
"In this predicate we include an index for the *type* of the\n"
"column with the given name. We need this, because when we\n"
"access a column by name, we need a way to figure out\n"
"the return type. But during proof search, this type will\n"
"have to be derived by Idris based on the column name and\n"
"schema in question (otherwise, the proof search will fail\n"
"unless the return type is known in advance).\n"
"We therefore *must* tell Idris, that\n"
"it can't include this type in the list of search criteria,\n"
"otherwise it will try and infer the column type from the\n"
"context (using type inference) before running the proof\n"
"search. This can be done by listing the indices to be used in\n"
"the search like so: `[search name schema]`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:603
#, no-wrap
msgid ""
"data InSchema :  (name    : String)\n"
"              -> (schema  : Schema)\n"
"              -> (colType : ColType)\n"
"              -> Type where\n"
"  [search name schema]\n"
"  IsHere  : InSchema n (n :> t :: ss) t\n"
"  IsThere : InSchema n ss t -> InSchema n (fld :: ss) t\n"
"\n"
"Uninhabited (InSchema n [] c) where\n"
"  uninhabited IsHere impossible\n"
"  uninhabited (IsThere _) impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:619
#, no-wrap
msgid ""
"With this, we are now ready to access the value\n"
"at a given column based on the column's name:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:620
#, no-wrap
msgid ""
"getAt :  {0 ss : Schema}\n"
"      -> (name : String)\n"
"      -> (row  : Row ss)\n"
"      -> (prf  : InSchema name ss c)\n"
"      => IdrisType c\n"
"getAt name (v :: vs) {prf = IsHere}    = v\n"
"getAt name (_ :: vs) {prf = IsThere p} = getAt name vs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:638
#, no-wrap
msgid ""
"Below is an example how to use this at compile time. Note\n"
"the amount of work Idris performs for us: It first comes\n"
"up with proofs that `firstName`, `lastName`, and `age`\n"
"are indeed valid names in the `Employee` schema. From\n"
"these proofs it automatically figures out the return types\n"
"of the calls to `getAt` and extracts the corresponding values\n"
"from the row. All of this happens in a provably total and type\n"
"safe way.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:639
#, no-wrap
msgid ""
"shoeck : String\n"
"shoeck =  getAt \"firstName\" hock\n"
"       ++ \" \"\n"
"       ++ getAt \"lastName\" hock\n"
"       ++ \": \"\n"
"       ++ show (getAt \"age\" hock)\n"
"       ++ \" years old.\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:657
#, no-wrap
msgid ""
"In order to at runtime specify a column name, we need a way\n"
"for computing values of type `InSchema` by comparing\n"
"the column names with the schema in question. Since we have\n"
"to compare two string values for being propositionally equal,\n"
"we use the `DecEq` implementation for `String` here (Idris provides "
"`DecEq`\n"
"implementations for all primitives). We extract the column type\n"
"at the same time and pair this (as a dependent pair) with\n"
"the `InSchema` proof:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:658
#, no-wrap
msgid ""
"inSchema : (ss : Schema) -> (n : String) -> Maybe (c ** InSchema n ss c)\n"
"inSchema []                    _ = Nothing\n"
"inSchema (MkColumn cn t :: xs) n = case decEq cn n of\n"
"  Yes Refl   => Just (t ** IsHere)\n"
"  No  contra => case inSchema xs n of\n"
"    Just (t ** prf) => Just $ (t ** IsThere prf)\n"
"    Nothing         => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:671
#, no-wrap
msgid ""
"At the end of this chapter we will use `InSchema` in\n"
"our CSV command-line application to list all values\n"
"in a column.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:676
msgid ""
"Show that `InSchema` is decidable by changing the output type of `inSchema` "
"to `Dec (c ** InSchema n ss c)`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:679
msgid ""
"Declare and implement a function for modifying a field in a row based on the "
"column name given."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:684
msgid ""
"Define a predicate to be used as a witness that one list contains only "
"elements in the second list in the same order and use this predicate to "
"extract several columns from a row at once."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:688
#, no-wrap
msgid ""
"   For instance, `[2,4,5]` contains elements from\n"
"   `[1,2,3,4,5,6]` in the correct order, but `[4,2,5]`\n"
"   does not.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:694
msgid ""
"Improve the functionality from exercise 3 by defining a new predicate, "
"witnessing that all strings in a list correspond to column names in a schema "
"(in arbitrary order).  Use this to extract several columns from a row at "
"once in arbitrary order."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:698
#, no-wrap
msgid ""
"   Hint: Make sure to include the resulting schema as an index,\n"
"   but search only based on the list of names and the input\n"
"   schema.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:699
#, no-wrap
msgid "Use Case: Flexible Error Handling"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:718
#, no-wrap
msgid ""
"A recurring pattern when writing larger applications is\n"
"the combination of different parts of a program each with\n"
"their own failure types in a larger effectful computation.\n"
"We saw this, for instance, when implementing a command-line\n"
"tool for handling CSV files. There, we read and wrote data\n"
"from and to files, we parsed column types and schemata,\n"
"we parsed row and column indices and command-line commands.\n"
"All these operations came with the potential of failure and\n"
"might be implemented in different parts of our application.\n"
"In order to unify these different failure types, we wrote\n"
"a custom sum type encapsulating each of them, and wrote a\n"
"single handler for this sum type. This approach was alright\n"
"then, but it does not scale well and is lacking in terms of\n"
"flexibility. We are therefore trying a different\n"
"approach here. Before we continue, we quickly implement a\n"
"couple of functions with the potential of failure plus\n"
"some custom error types:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:719
#, no-wrap
msgid ""
"record NoNat where\n"
"  constructor MkNoNat\n"
"  str : String\n"
"\n"
"readNat' : String -> Either NoNat Nat\n"
"readNat' s = maybeToEither (MkNoNat s) $ parsePositive s\n"
"\n"
"record NoColType where\n"
"  constructor MkNoColType\n"
"  str : String\n"
"\n"
"readColType' : String -> Either NoColType ColType\n"
"readColType' \"I64\"     = Right I64\n"
"readColType' \"Str\"     = Right Str\n"
"readColType' \"Boolean\" = Right Boolean\n"
"readColType' \"Float\"   = Right Float\n"
"readColType' s         = Left $ MkNoColType s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:746
#, no-wrap
msgid ""
"However, if we wanted to parse a `Fin n`, there'd be already\n"
"two ways how this could fail: The string in question could not\n"
"represent a natural number (leading to a `NoNat` error), or it\n"
"could be out of bounds (leading to an `OutOfBounds` error).\n"
"We have to somehow encode these two possibilities in the\n"
"return type, for instance, by using an `Either` as the error\n"
"type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:747
#, no-wrap
msgid ""
"record OutOfBounds where\n"
"  constructor MkOutOfBounds\n"
"  size  : Nat\n"
"  index : Nat\n"
"\n"
"readFin' : {n : _} -> String -> Either (Either NoNat OutOfBounds) (Fin n)\n"
"readFin' s = do\n"
"  ix <- mapFst Left (readNat' s)\n"
"  maybeToEither (Right $ MkOutOfBounds n ix) $ natToFin ix n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:767
#, no-wrap
msgid ""
"This is incredibly ugly. A custom sum type might have been slightly "
"better,\n"
"but we still would have to use `mapFst` when invoking `readNat'`, and\n"
"writing custom sum types for every possible combination of errors\n"
"will get cumbersome very quickly as well.\n"
"What we are looking for, is a generalized sum type: A type\n"
"indexed by a list of types (the possible choices) holding\n"
"a single value of exactly one of the types in question.\n"
"Here is a first naive try:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:768
#, no-wrap
msgid ""
"data Sum : List Type -> Type where\n"
"  MkSum : (val : t) -> Sum ts\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:783
#, no-wrap
msgid ""
"However, there is a crucial piece of information missing:\n"
"We have not verified that `t` is an element of `ts`, nor\n"
"*which* type it actually is. In fact, this is another case\n"
"of an erased existential, and we will have no way to at runtime\n"
"learn something about `t`. What we need to do is to pair the value\n"
"with a proof, that its type `t` is an element of `ts`.\n"
"We could use `Elem` again for this, but for some use cases\n"
"we will require access to the number of types in the list.\n"
"We will therefore use a vector instead of a list as our index.\n"
"Here is a predicate similar to `Elem` but for vectors:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:784
#, no-wrap
msgid ""
"data Has :  (v : a) -> (vs  : Vect n a) -> Type where\n"
"  Z : Has v (v :: vs)\n"
"  S : Has v vs -> Has v (w :: vs)\n"
"\n"
"Uninhabited (Has v []) where\n"
"  uninhabited Z impossible\n"
"  uninhabited (S _) impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:797
#, no-wrap
msgid ""
"A value of type `Has v vs` is a witness that `v` is an\n"
"element of `vs`. With this, we can now implement an indexed\n"
"sum type (also called an *open union*):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:798
#, no-wrap
msgid ""
"data Union : Vect n Type -> Type where\n"
"  U : (ix : Has t ts) -> (val : t) -> Union ts\n"
"\n"
"Uninhabited (Union []) where\n"
"  uninhabited (U ix _) = absurd ix\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:811
#, no-wrap
msgid ""
"Note the difference between `HList` and `Union`. `HList` is\n"
"a *generalized product type*: It holds a value for each type\n"
"in its index. `Union` is a *generalized sum type*: It holds\n"
"only a single value, which must be of a type listed in the index.\n"
"With this we can now define a much more flexible error type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:812
#, no-wrap
msgid ""
"0 Err : Vect n Type -> Type -> Type\n"
"Err ts t = Either (Union ts) t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:820
#, no-wrap
msgid ""
"A function returning an `Err ts a` describes a computation, which\n"
"can fail with one of the errors listed in `ts`.\n"
"We first need some utility functions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:821
#, no-wrap
msgid ""
"inject : (prf : Has t ts) => (v : t) -> Union ts\n"
"inject v = U prf v\n"
"\n"
"fail : Has t ts => (err : t) -> Err ts a\n"
"fail err = Left $ inject err\n"
"\n"
"failMaybe : Has t ts => (err : Lazy t) -> Maybe a -> Err ts a\n"
"failMaybe err = maybeToEither (inject err)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:834
#, no-wrap
msgid ""
"Next, we can write more flexible versions of the\n"
"parsers we wrote above:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:835
#, no-wrap
msgid ""
"readNat : Has NoNat ts => String -> Err ts Nat\n"
"readNat s = failMaybe (MkNoNat s) $ parsePositive s\n"
"\n"
"readColType : Has NoColType ts => String -> Err ts ColType\n"
"readColType \"I64\"     = Right I64\n"
"readColType \"Str\"     = Right Str\n"
"readColType \"Boolean\" = Right Boolean\n"
"readColType \"Float\"   = Right Float\n"
"readColType s         = fail $ MkNoColType s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:849
#, no-wrap
msgid ""
"Before we implement `readFin`, we introduce a short cut for\n"
"specifying that several error types must be present:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:850
#, no-wrap
msgid ""
"0 Errs : List Type -> Vect n Type -> Type\n"
"Errs []        _  = ()\n"
"Errs (x :: xs) ts = (Has x ts, Errs xs ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:860
#, no-wrap
msgid ""
"Function `Errs` returns a tuple of constraints. This can\n"
"be used as a witness that all listed types are present\n"
"in the vector of types: Idris will automatically extract\n"
"the proofs from the tuple as needed.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:862
#, no-wrap
msgid ""
"readFin : {n : _} -> Errs [NoNat, OutOfBounds] ts => String -> Err ts (Fin "
"n)\n"
"readFin s = do\n"
"  S ix <- readNat s | Z => fail (MkOutOfBounds n Z)\n"
"  failMaybe (MkOutOfBounds n (S ix)) $ natToFin ix n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:871
#, no-wrap
msgid ""
"As a last example, here are parsers for schemata and\n"
"CSV rows:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:872
#, no-wrap
msgid ""
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"record InvalidColumn where\n"
"  constructor MkInvalidColumn\n"
"  str : String\n"
"\n"
"readColumn : Errs [InvalidColumn, NoColType] ts => String -> Err ts Column\n"
"readColumn s = case forget $ split (':' ==) s of\n"
"  [n,ct] => MkColumn n <$> readColType ct\n"
"  _      => fail $ MkInvalidColumn s\n"
"\n"
"readSchema : Errs [InvalidColumn, NoColType] ts => String -> Err ts Schema\n"
"readSchema = traverse readColumn . fromCSV\n"
"\n"
"data RowError : Type where\n"
"  InvalidField  : (row, col : Nat) -> (ct : ColType) -> String -> RowError\n"
"  UnexpectedEOI : (row, col : Nat) -> RowError\n"
"  ExpectedEOI   : (row, col : Nat) -> RowError\n"
"\n"
"decodeField :  Has RowError ts\n"
"            => (row,col : Nat)\n"
"            -> (c : ColType)\n"
"            -> String\n"
"            -> Err ts (IdrisType c)\n"
"decodeField row col c s =\n"
"  let err = InvalidField row col c s\n"
"   in case c of\n"
"        I64     => failMaybe err $ read s\n"
"        Str     => failMaybe err $ read s\n"
"        Boolean => failMaybe err $ read s\n"
"        Float   => failMaybe err $ read s\n"
"\n"
"decodeRow :  Has RowError ts\n"
"          => {s : _}\n"
"          -> (row : Nat)\n"
"          -> (str : String)\n"
"          -> Err ts (Row s)\n"
"decodeRow row = go 1 s . fromCSV\n"
"  where go : Nat -> (cs : Schema) -> List String -> Err ts (Row cs)\n"
"        go k []       []                    = Right []\n"
"        go k []       (_ :: _)              = fail $ ExpectedEOI row k\n"
"        go k (_ :: _) []                    = fail $ UnexpectedEOI row k\n"
"        go k (MkColumn n c :: cs) (s :: ss) =\n"
"          [| decodeField row k c s :: go (S k) cs ss |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:925
#, no-wrap
msgid ""
"Here is an example REPL session, where I test `readSchema`. I defined\n"
"variable `ts` using the `:let` command to make this more convenient.\n"
"Note, how the order of error types is of no importance, as long\n"
"as types `InvalidColumn` and `NoColType` are present in the list of\n"
"errors:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:926
#, no-wrap
msgid ""
"Tutorial.Predicates> :let ts = the (Vect 3 _) "
"[NoColType,NoNat,InvalidColumn]\n"
"Tutorial.Predicates> readSchema {ts} \"foo:bar\"\n"
"Left (U Z (MkNoColType \"bar\"))\n"
"Tutorial.Predicates> readSchema {ts} \"foo:Float\"\n"
"Right [MkColumn \"foo\" Float]\n"
"Tutorial.Predicates> readSchema {ts} \"foo Float\"\n"
"Left (U (S (S Z)) (MkInvalidColumn \"foo Float\"))\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:936
#, no-wrap
msgid "Error Handling"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:943
#, no-wrap
msgid ""
"There are several techniques for handling errors, all of which\n"
"are useful at times. For instance, we might want to handle some\n"
"errors early on and individually, while dealing with others\n"
"much later in our application. Or we might want to handle\n"
"them all in one fell swoop. We look at both approaches here.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:950
#, no-wrap
msgid ""
"First, in order to handle a single error individually, we need\n"
"to *split* a union into one of two possibilities: A value of\n"
"the error type in question or a new union, holding one of the\n"
"other error types. We need a new predicate for this, which\n"
"not only encodes the presence of a value in a vector\n"
"but also the result of removing that value:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:951
#, no-wrap
msgid ""
"data Rem : (v : a) -> (vs : Vect (S n) a) -> (rem : Vect n a) -> Type "
"where\n"
"  [search v vs]\n"
"  RZ : Rem v (v :: rem) rem\n"
"  RS : Rem v vs rem -> Rem v (w :: vs) (w :: rem)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:962
#, no-wrap
msgid ""
"Once again, we want to use one of the indices (`rem`) in our\n"
"functions' return types, so we only use the other indices during\n"
"proof search. Here is a function for splitting off a value from\n"
"an open union:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:963
#, no-wrap
msgid ""
"split : (prf : Rem t ts rem) => Union ts -> Either t (Union rem)\n"
"split {prf = RZ}   (U Z     val) = Left val\n"
"split {prf = RZ}   (U (S x) val) = Right (U x val)\n"
"split {prf = RS p} (U Z     val) = Right (U Z val)\n"
"split {prf = RS p} (U (S x) val) = case split {prf = p} (U x val) of\n"
"  Left vt        => Left vt\n"
"  Right (U ix y) => Right $ U (S ix) y\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:977
#, no-wrap
msgid ""
"This tries to extract a value of type `t` from a union. If it works,\n"
"the result is wrapped in a `Left`, otherwise a new union is returned\n"
"in a `Right`, but this one has `t` removed from its list of possible\n"
"types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:982
#, no-wrap
msgid ""
"With this, we can implement a handler for single errors.\n"
"Error handling often happens in an effectful context (we might want to\n"
"print a message to the console or write the error to a log file), so\n"
"we use an applicative effect type to handle errors in.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:983
#, no-wrap
msgid ""
"handle :  Applicative f\n"
"       => Rem t ts rem\n"
"       => (h : t -> f a)\n"
"       -> Err ts a\n"
"       -> f (Err rem a)\n"
"handle h (Left x)  = case split x of\n"
"  Left v    => Right <$> h v\n"
"  Right err => pure $ Left err\n"
"handle _ (Right x) = pure $ Right x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:998
#, no-wrap
msgid ""
"For handling all errors at once, we can use a handler type\n"
"indexed by the vector of errors, and parameterized by the\n"
"output type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:999
#, no-wrap
msgid ""
"namespace Handler\n"
"  public export\n"
"  data Handler : (ts : Vect n Type) -> (a : Type) -> Type where\n"
"    Nil  : Handler [] a\n"
"    (::) : (t -> a) -> Handler ts a -> Handler (t :: ts) a\n"
"\n"
"extract : Handler ts a -> Has t ts -> t -> a\n"
"extract (f :: _)  Z     val = f val\n"
"extract (_ :: fs) (S y) val = extract fs y val\n"
"extract []        ix    _   = absurd ix\n"
"\n"
"handleAll : Applicative f => Handler ts (f a) -> Err ts a -> f a\n"
"handleAll _ (Right v)       = pure v\n"
"handleAll h (Left $ U ix v) = extract h ix v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1019
#, no-wrap
msgid ""
"Below, we will see an additional way of handling all\n"
"errors at once by defining a custom interface for\n"
"error handling.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:1023
msgid "Implement the following utility functions for `Union`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1024
#, no-wrap
msgid ""
"   project : (0 t : Type) -> (prf : Has t ts) => Union ts -> Maybe t\n"
"\n"
"   project1 : Union [t] -> t\n"
"\n"
"   safe : Err [] a -> a\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:1034
msgid ""
"Implement the following two functions for embedding an open union in a "
"larger set of possibilities.  Note the unerased implicit in `extend`!"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1035
#, no-wrap
msgid ""
"   weaken : Union ts -> Union (ts ++ ss)\n"
"\n"
"   extend : {m : _} -> {0 pre : Vect m _} -> Union ts -> Union (pre ++ ts)\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:1043
msgid ""
"Find a general way to embed a `Union ts` in a `Union ss`, so that the "
"following is possible:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1044
#, no-wrap
msgid ""
"   embedTest :  Err [NoNat,NoColType] a\n"
"             -> Err [FileError, NoColType, OutOfBounds, NoNat] a\n"
"   embedTest = mapFst embed\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:1052
msgid ""
"Make `handle` more powerful, by letting the handler convert the error in "
"question to an `f (Err rem a)`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:1053
#, no-wrap
msgid "The Truth about Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1065
#, no-wrap
msgid ""
"Well, here it finally is: The truth about interfaces. Internally,\n"
"an interface is just a record data type, with its fields corresponding\n"
"to the members of the interface. An interface implementation is\n"
"a *value* of such a record, annotated with a `%hint` pragma (see\n"
"below) to make the value available during proof search. Finally,\n"
"a constrained function is just a function with one or more auto implicit\n"
"arguments. For instance, here is the same function for looking up\n"
"an element in a list, once with the known syntax for constrained\n"
"functions, and once with an auto implicit argument. The code\n"
"produced by Idris is the same in both cases:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1066
#, no-wrap
msgid ""
"isElem1 : Eq a => a -> List a -> Bool\n"
"isElem1 v []        = False\n"
"isElem1 v (x :: xs) = x == v || isElem1 v xs\n"
"\n"
"isElem2 : {auto _ : Eq a} -> a -> List a -> Bool\n"
"isElem2 v []        = False\n"
"isElem2 v (x :: xs) = x == v || isElem2 v xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1079
#, no-wrap
msgid ""
"Being mere records, we can also take interfaces as\n"
"regular function arguments and dissect them with a pattern\n"
"match:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1080
#, no-wrap
msgid ""
"eq : Eq a -> a -> a -> Bool\n"
"eq (MkEq feq fneq) = feq\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:1085
#, no-wrap
msgid "A manual Interface Definition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1093
#, no-wrap
msgid ""
"I'll now demonstrate how we can achieve the same behavior\n"
"with proof search as with a regular interface definition\n"
"plus implementations. Since I want to finish the CSV\n"
"example with our new error handling tools, we are\n"
"going to implement some error handlers.\n"
"First, an interface is just a record:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1094
#, no-wrap
msgid ""
"record Print a where\n"
"  constructor MkPrint\n"
"  print' : a -> String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1104
#, no-wrap
msgid ""
"In order to access the record in a constrained function,\n"
"we use the `%search` keyword, which will try to conjure a\n"
"value of the desired type (`Print a` in this case) by\n"
"means of a proof search:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1105
#, no-wrap
msgid ""
"print : Print a => a -> String\n"
"print = print' %search\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1112
#, no-wrap
msgid ""
"As an alternative, we could use a named constraint, and access\n"
"it directly via its name:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1113
#, no-wrap
msgid ""
"print2 : (impl : Print a) => a -> String\n"
"print2 = print' impl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1120
#, no-wrap
msgid ""
"As yet another alternative, we could use the syntax for auto\n"
"implicit arguments:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1121
#, no-wrap
msgid ""
"print3 : {auto impl : Print a} -> a -> String\n"
"print3 = print' impl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1129
#, no-wrap
msgid ""
"All three versions of `print` behave exactly the same at runtime.\n"
"So, whenever we write `{auto x : Foo} ->` we can just as well\n"
"write `(x : Foo) =>` and vice versa.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1133
#, no-wrap
msgid ""
"Interface implementations are just values of the given\n"
"record type, but in order to be available during proof search,\n"
"these need to be annotated with a `%hint` pragma:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1134
#, no-wrap
msgid ""
"%hint\n"
"noNatPrint : Print NoNat\n"
"noNatPrint = MkPrint $ \\e => \"Not a natural number: \\{e.str}\"\n"
"\n"
"%hint\n"
"noColTypePrint : Print NoColType\n"
"noColTypePrint = MkPrint $ \\e => \"Not a column type: \\{e.str}\"\n"
"\n"
"%hint\n"
"outOfBoundsPrint : Print OutOfBounds\n"
"outOfBoundsPrint = MkPrint $ \\e => \"Index is out of bounds: \\{show "
"e.index}\"\n"
"\n"
"%hint\n"
"rowErrorPrint : Print RowError\n"
"rowErrorPrint = MkPrint $\n"
"  \\case InvalidField r c ct s =>\n"
"          \"Not a \\{show ct} in row \\{show r}, column \\{show "
"c}. \\{s}\"\n"
"        UnexpectedEOI r c =>\n"
"          \"Unexpected end of input in row \\{show r}, column \\{show "
"c}.\"\n"
"        ExpectedEOI r c =>\n"
"          \"Expected end of input in row \\{show r}, column \\{show c}.\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1162
#, no-wrap
msgid ""
"We can also write an implementation of `Print` for\n"
"a union or errors. For this, we first come up with a\n"
"proof that all types in the union's index come with an\n"
"implementation of `Print`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1163
#, no-wrap
msgid ""
"0 All : (f : a -> Type) -> Vect n a -> Type\n"
"All f []        = ()\n"
"All f (x :: xs) = (f x, All f xs)\n"
"\n"
"unionPrintImpl : All Print ts => Union ts -> String\n"
"unionPrintImpl (U Z val)     = print val\n"
"unionPrintImpl (U (S x) val) = unionPrintImpl $ U x val\n"
"\n"
"%hint\n"
"unionPrint : All Print ts => Print (Union ts)\n"
"unionPrint = MkPrint unionPrintImpl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1184
#, no-wrap
msgid ""
"Defining interfaces this way can be an advantage, as there\n"
"is much less magic going on, and we have more fine grained\n"
"control over the types and values of our fields. Note also,\n"
"that all of the magic comes from the search hints, with\n"
"which our \"interface implementations\" were annotated.\n"
"These made the corresponding values and functions available\n"
"during proof search.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Predicates.md:1185
#, no-wrap
msgid "Parsing CSV Commands"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1195
#, no-wrap
msgid ""
"To conclude this chapter, we reimplement our CSV command\n"
"parser, using the flexible error handling approach from\n"
"the last section. While not necessarily less verbose than\n"
"the original parser, this approach decouples the handling\n"
"of errors and printing of error messages from the rest\n"
"of the application: Functions with a possibility of failure\n"
"are reusable in different contexts, as are the pretty\n"
"printers we use for the error messages.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1198
#, no-wrap
msgid ""
"First, we repeat some stuff from earlier chapters. I sneaked\n"
"in a new command for printing all values in a column:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1199
#, no-wrap
msgid ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"data Command : (t : Table) -> Type where\n"
"  PrintSchema :  Command t\n"
"  PrintSize   :  Command t\n"
"  New         :  (newSchema : Schema) -> Command t\n"
"  Prepend     :  Row (schema t) -> Command t\n"
"  Get         :  Fin (size t) -> Command t\n"
"  Delete      :  Fin (size t) -> Command t\n"
"  Col         :  (name : String)\n"
"              -> (tpe  : ColType)\n"
"              -> (prf  : InSchema name t.schema tpe)\n"
"              -> Command t\n"
"  Quit        : Command t\n"
"\n"
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand t                 (Col _ _ _) = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1235
#, no-wrap
msgid ""
"Next, below is the command parser reimplemented. In total,\n"
"it can fail in seven different was, at least some of which\n"
"might also be possible in other parts of a larger application.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1236
#, no-wrap
msgid ""
"record UnknownCommand where\n"
"  constructor MkUnknownCommand\n"
"  str : String\n"
"\n"
"%hint\n"
"unknownCommandPrint : Print UnknownCommand\n"
"unknownCommandPrint = MkPrint $ \\v => \"Unknown command: \\{v.str}\"\n"
"\n"
"record NoColName where\n"
"  constructor MkNoColName\n"
"  str : String\n"
"\n"
"%hint\n"
"noColNamePrint : Print NoColName\n"
"noColNamePrint = MkPrint $ \\v => \"Unknown column: \\{v.str}\"\n"
"\n"
"0 CmdErrs : Vect 7 Type\n"
"CmdErrs = [ InvalidColumn\n"
"          , NoColName\n"
"          , NoColType\n"
"          , NoNat\n"
"          , OutOfBounds\n"
"          , RowError\n"
"          , UnknownCommand ]\n"
"\n"
"readCommand : (t : Table) -> String -> Err CmdErrs (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow 1 (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  [\"column\", str] => case inSchema ts str of\n"
"    Just (ct ** prf) => Right $ Col str ct prf\n"
"    Nothing          => fail $ MkNoColName str\n"
"  _               => fail $ MkUnknownCommand s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1280
#, no-wrap
msgid ""
"Note, how we could invoke functions like `readFin` or\n"
"`readSchema` directly, because the necessary error types\n"
"are part of our list of possible errors.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1286
#, no-wrap
msgid ""
"To conclude this sections, here is the functionality\n"
"for printing the result of a command plus the application's\n"
"main loop. Most of this is repeated from earlier chapters,\n"
"but note how we can handle all errors at once with a single\n"
"call to `print`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1287
#, no-wrap
msgid ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (s : Schema) -> Row s -> String\n"
"encodeRow s = concat . intersperse \",\" . go s\n"
"  where go : (s' : Schema) -> Row s' -> Vect (length s') String\n"
"        go []        []        = []\n"
"        go (MkColumn _ c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"encodeCol :  (name : String)\n"
"          -> (c    : ColType)\n"
"          -> InSchema name s c\n"
"          => Vect n (Row s)\n"
"          -> String\n"
"encodeCol name c = unlines . toList . map (\\r => encodeField c $ getAt name "
"r)\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema   = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize     = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)      = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r)   = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)    = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit          = \"Goodbye.\"\n"
"result t (Col n c prf) = \"Column \\{n}:\\n\\{encodeCol n c t.rows}\"\n"
"result t (Get x)       =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (print err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1336
#, no-wrap
msgid "Here is an example REPL session:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1337
#, no-wrap
msgid ""
"Tutorial.Predicates> :exec main\n"
"Enter a command: new name:Str,age:Int64,salary:Float\n"
"Not a column type: Int64\n"
"Enter a command: new name:Str,age:I64,salary:Float\n"
"Created table. Schema: name:Str,age:I64,salary:Float\n"
"Enter a command: add John Doe,44,3500\n"
"Row prepended: \"John Doe\",44,3500.0\n"
"Enter a command: add Jane Doe,50,4000\n"
"Row prepended: \"Jane Doe\",50,4000.0\n"
"Enter a command: get 1\n"
"Row 1: \"Jane Doe\",50,4000.0\n"
"Enter a command: column salary\n"
"Column salary:\n"
"4000.0\n"
"3500.0\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1367
#, no-wrap
msgid ""
"Predicates allow us to describe contracts between types\n"
"and to refine the values we accept as valid function arguments.\n"
"They allow us to make a function safe and convenient to use\n"
"at runtime *and* compile time by using them as auto implicit\n"
"arguments, which Idris should try to construct on its own if\n"
"it has enough information about the structure of a function's\n"
"arguments.\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Prim.md:1
#, no-wrap
msgid "Primitives"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:7
#, no-wrap
msgid ""
"In the topics we covered so far, we hardly ever talked about primitive\n"
"types in Idris. They where around and we used them in some computations,\n"
"but I never really explained how they work and where they come from,\n"
"nor did I show in detail what we can and can't do with them.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:8
#, no-wrap
msgid ""
"module Tutorial.Prim\n"
"\n"
"import Data.Bits\n"
"import Data.String\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:17
#, no-wrap
msgid "How Primitives are Implemented"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:19
#, no-wrap
msgid "A Short Note on Backends"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:30
#, no-wrap
msgid ""
"According to [Wikipedia](https://en.wikipedia.org/wiki/Compiler),\n"
"a compiler is \"a computer program that translates computer code\n"
"written in one programming language (the source language) into\n"
"another language (the target language)\". The Idris compiler is\n"
"exactly that: A program translating programs written in Idris\n"
"into programs written in Chez Scheme. This scheme code is then\n"
"parsed and interpreted by a Chez Scheme interpreter, which must\n"
"be installed on the computers we use to run compiled Idris\n"
"programs.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:37
#, no-wrap
msgid ""
"But that's only part of the story. Idris 2 was from the beginning\n"
"designed to support different code generators (so called *backends*),\n"
"which allows us to write Idris code to target different platforms,\n"
"and your Idris installation comes with several additional\n"
"backends available. You can specify the backend to use with the `--cg` "
"command\n"
"line argument (`cg` stands for *code generator*). For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:38
#, no-wrap
msgid "idris2 --cg racket\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:45
#, no-wrap
msgid ""
"Here is a non-comprehensive list of the backends available with a\n"
"standard Idris installation (the name to be used in the command line\n"
"argument is given in parentheses):\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid ""
"Racket Scheme (`racket`): This is a different flavour of the scheme "
"programming language, which can be useful to use when Chez Scheme is not "
"available on your operating system."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid "Node.js (`node`): This converts an Idris program to JavaScript."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid ""
"Browser (`javascript`): Another JavaScript backend which allows you to write "
"web applications which run in the browser in Idris."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid ""
"RefC (`refc`): A backend compiling Idris to C code, which is then further "
"compiled by a C compiler."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:57
#, no-wrap
msgid ""
"I plan to at least cover the JavaScript backends in some more detail\n"
"in another part of this Idris guide, as I use them pretty often myself.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:62
#, no-wrap
msgid ""
"There are also several external backends not officially supported by\n"
"the Idris project, amongst which are backends for compiling Idris code\n"
"to Java and Python. You can find a list of external backends on\n"
"the [Idris "
"Wiki](https://github.com/idris-lang/Idris2/wiki/1-%5BLanguage%5D-External-backends).\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:63
#, no-wrap
msgid "The Idris Primitives"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:69
#, no-wrap
msgid ""
"A *primitive data type* is a type that is built into the Idris compiler\n"
"together with a set of *primitive functions*, which are used to perform\n"
"calculations on the primitives. You will therefore not find a definition\n"
"of a primitive type or function in the source code of the *Prelude*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:71
#, no-wrap
msgid "Here is again the list of primitive types in Idris:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid ""
"* Signed, fixed precision integers:\n"
"  * `Int8`: Integer in the range [-128,127]\n"
"  * `Int16`: Integer in the range [-32768,32767]\n"
"  * `Int32`: Integer in the range [-2147483648,2147483647]\n"
"  * `Int64`: Integer in the range "
"[-9223372036854775808,9223372036854775807]\n"
"* Unsigned, fixed precision integers:\n"
"  * `Bits8`: Integer in the range [0,255]\n"
"  * `Bits16`: Integer in the range [0,65535]\n"
"  * `Bits32`: Integer in the range [0,4294967295]\n"
"  * `Bits64`: Integer in the range [0,18446744073709551615]\n"
"* `Integer`: A signed, arbitrary precision integer.\n"
"* `Double`: A double precision (64 bit) floating point number.\n"
"* `Char`: A unicode character.\n"
"* `String`: A sequence of unicode characters.\n"
"* `%World`: A symbolic representation of the current world state.\n"
"  We learned about this when I showed you how `IO` is implemented.\n"
"  Most of the time, you will not handle values of this type in your own\n"
"  code.\n"
"* `Int`: This one is special. It is a fixed precision, signed integer,\n"
"   but the bit size is somewhat dependent on the backend and\n"
"   (maybe) platform we use.\n"
"   For instance, if you use the default Chez Scheme backend, `Int` is\n"
"   a 64 bit signed integer, while on the JavaScript backends it is a\n"
"   32 bit signed integer for performance reasons. Therefore, `Int` comes\n"
"   with very few guarantees, and you should use one of the well\n"
"   specified integer types listed above whenever possible.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:104
#, no-wrap
msgid ""
"It can be instructive to learn, where in the compiler's source\n"
"code the primitive types and functions are defined. This source\n"
"code can be found in folder `src` of the [Idris "
"project](https://github.com/idris-lang/Idris2)\n"
"and the primitive types are the constant constructors of\n"
"data type `Core.TT.Constant`.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:105
#, no-wrap
msgid "Primitive Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:112
#, no-wrap
msgid ""
"All calculations operating on primitives are based on two\n"
"kinds of primitive functions: The ones built into the compiler\n"
"(see below) and the ones defined by programmers via the\n"
"foreign function interface (FFI), about which I'll talk in\n"
"another chapter.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:119
#, no-wrap
msgid ""
"Built-in primitive functions are functions known to the compiler\n"
"the definition of which can not be found in the *Prelude*. They\n"
"define the core functionality available for the primitive\n"
"types. Typically, you do not invoke these directly (although\n"
"it is perfectly fine to do so in most cases) but via functions\n"
"and interfaces exported by the *Prelude* or the *base* library.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:123
#, no-wrap
msgid ""
"For instance, the primitive function for adding two eight bit\n"
"unsigned integers is `prim__add_Bits8`. You can inspect its\n"
"type and behavior at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:124
#, no-wrap
msgid ""
"Tutorial.Prim> :t prim__add_Bits8\n"
"prim__add_Bits8 : Bits8 -> Bits8 -> Bits8\n"
"Tutorial.Prim> prim__add_Bits8 12 100\n"
"112\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:148
#, no-wrap
msgid ""
"If you look at the source code implementing interface `Num`\n"
"for `Bits8`, you will see that the plus operator just invokes\n"
"`prim__add_Bits8` internally. The same goes for most of the other\n"
"functions in primitive interface implementations.\n"
"For instance, every primitive type with the exception of\n"
"`%World` comes with primitive comparison functions.\n"
"For `Bits8`, these are:\n"
"`prim__eq_Bits8`, `prim__gt_Bits8`, `prim__lt_Bits8`,\n"
"`prim__gte_Bits8`, and `prim__lte_Bits8`.\n"
"Note, that these functions do not return a `Bool` (which\n"
"is *not* a primitive type in Idris), but an `Int`. They are\n"
"therefore not as safe or convenient to use as the corresponding\n"
"operator implementations form interfaces `Eq` and `Comp`.\n"
"On the other hand, they do not go via a conversion to `Bool`\n"
"and might therefore perform slightly better in performance\n"
"critical code (which you can only identify after some\n"
"serious profiling).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:152
#, no-wrap
msgid ""
"As with primitive types, the primitive functions are listed as\n"
"constructors in a data type (`Core.TT.PrimFn`) in the compiler\n"
"sources. We will look at most of these in the following sections.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:153
#, no-wrap
msgid "Consequences of being Primitive"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:163
#, no-wrap
msgid ""
"Primitive functions and types are opaque to the compiler\n"
"in most regards: They have to be defined and implemented by each\n"
"backend individually, therefore, the compiler knows nothing about the "
"inner\n"
"structure of a primitive value nor about the inner workings\n"
"of primitive functions. For instance, in the following recursive\n"
"function, *we* know that the argument in the recursive call\n"
"must be converging towards the base case (unless there is a bug\n"
"in the backend we use), but the compiler does not:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:164
#, no-wrap
msgid ""
"covering\n"
"replicateBits8' : Bits8 -> a -> List a\n"
"replicateBits8' 0 _ = []\n"
"replicateBits8' n v = v :: replicateBits8' (n - 1) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:174
#, no-wrap
msgid ""
"In these cases, we either must be content with just a\n"
"*covering* function, or we use `assert_smaller` to\n"
"convince the totality checker (the preferred way):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:175
#, no-wrap
msgid ""
"replicateBits8 : Bits8 -> a -> List a\n"
"replicateBits8 0 _ = []\n"
"replicateBits8 n v = v :: replicateBits8 (assert_smaller n $ n - 1) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:184
#, no-wrap
msgid ""
"I have shown you the risks of using `assert_smaller` before, so we\n"
"must be extra careful in making sure that the new function argument\n"
"is indeed smaller with relation to the base case.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:189
#, no-wrap
msgid ""
"While Idris knows nothing about the internal workings of primitives\n"
"and related functions, most of these functions still reduce during\n"
"evaluation when fed with values known at compile time. For instance,\n"
"we can trivially proof that for `Bits8` the following equation holds:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:190
#, no-wrap
msgid ""
"zeroBits8 : the Bits8 0 = 255 + 1\n"
"zeroBits8 = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:200
#, no-wrap
msgid ""
"Having no clue about the internal structure of a primitive\n"
"nor about the implementations of primitive functions,\n"
"Idris can't help us proofing any *general* properties of such functions\n"
"and values. Here is an example to demonstrate this. Assume we'd\n"
"like to wrap a list in a data type indexed by the list's length:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:201
#, no-wrap
msgid ""
"data LenList : (n : Nat) -> Type -> Type where\n"
"  MkLenList : (as : List a) -> LenList (length as) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:209
#, no-wrap
msgid ""
"When we concatenate two `LenList`s, the length indices\n"
"should be added. That's how list concatenation affects the\n"
"length of lists. We can safely teach Idris that this is true:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:210
#, no-wrap
msgid ""
"0 concatLen : (xs,ys : List a) -> length xs + length ys = length (xs ++ "
"ys)\n"
"concatLen []        ys = Refl\n"
"concatLen (x :: xs) ys = cong S $ concatLen xs ys\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:217
#, no-wrap
msgid "With the above lemma, we can implement concatenation of `LenList`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:218
#, no-wrap
msgid ""
"(++) : LenList m a -> LenList n a -> LenList (m + n) a\n"
"MkLenList xs ++ MkLenList ys =\n"
"  rewrite concatLen xs ys in MkLenList (xs ++ ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:231
#, no-wrap
msgid ""
"The same is not possible for strings. There are applications where\n"
"pairing a string with its length would be useful (for instance, if we\n"
"wanted to make sure that strings are getting strictly shorter\n"
"during parsing and will therefore eventually be wholly\n"
"consumed), but Idris cannot help us getting these things right.\n"
"There is no way to implement and thus proof the following\n"
"lemma in a safe way:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:232
#, no-wrap
msgid "0 concatLenStr : (a,b : String) -> length a + length b = length (a ++ b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:237
#, no-wrap
msgid "<!-- markdownlint-disable MD026 -->\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:237
#, no-wrap
msgid "Believe Me!"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:239
#, no-wrap
msgid "<!-- markdownlint-enable MD026 -->\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:245
#, no-wrap
msgid ""
"In order to implement `concatLenStr`, we have to abandon all\n"
"safety and use the ten ton wrecking ball of type coercion:\n"
"`believe_me`. This primitive function allows us to freely\n"
"coerce a value of any type into a value of any other type.\n"
"Needless to say, this is only safe if we *really* know what we are doing:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:246
#, no-wrap
msgid "concatLenStr a b = believe_me $ Refl {x = length a + length b}\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:257
#, no-wrap
msgid ""
"The explicit assignment of variable `x` in `{x = length a + length b}`\n"
"is necessary, because otherwise Idris will complain about an *unsolved\n"
"hole*: It can't infer the type of parameter `x` in the `Refl`\n"
"constructor. We could assign any type to `x` here, because we\n"
"are passing the result to `believe_me` anyway, but I consider it\n"
"to be good practice to assign one of the two sides of the equality\n"
"to make our intention clear.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:262
#, no-wrap
msgid ""
"The higher the complexity of a primitive type, the riskier\n"
"it is to assume even the most basic properties for it to hold.\n"
"For instance, we might act under the delusion that floating\n"
"point addition is associative:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:263
#, no-wrap
msgid ""
"0 doubleAddAssoc : (x,y,z : Double) -> x + (y + z) = (x + y) + z\n"
"doubleAddAssoc x y z = believe_me $ Refl {x = x + (y + z)}\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:270
#, no-wrap
msgid ""
"Well, guess what: That's a lie. And lies lead us straight\n"
"into the `Void`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:271
#, no-wrap
msgid ""
"Tiny : Double\n"
"Tiny = 0.0000000000000001\n"
"\n"
"One : Double\n"
"One = 1.0\n"
"\n"
"wrong : (0 _ : 1.0000000000000002 = 1.0) -> Void\n"
"wrong Refl impossible\n"
"\n"
"boom : Void\n"
"boom = wrong (doubleAddAssoc One Tiny Tiny)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:291
#, no-wrap
msgid ""
"Here's what happens in the code above: The call to `doubleAddAssoc`\n"
"returns a proof that `One + (Tiny + Tiny)` is equal to\n"
"`(One + Tiny) + Tiny`. But `One + (Tiny + Tiny)` equals\n"
"`1.0000000000000002`, while `(One + Tiny) + Tiny` equals `1.0`.\n"
"We can therefore pass our (wrong) proof to `wrong`, because it\n"
"is of the correct type, and from this follows a proof of `Void`.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:292
#, no-wrap
msgid "Working with Strings"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:297
#, no-wrap
msgid ""
"Module `Data.String` in *base* offers a rich set of functions\n"
"for working with strings. All these are based on the following\n"
"primitive operations built into the compiler:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strLength`: Returns the length of a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strHead`: Extracts the first character from a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strTail`: Removes the first character from a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strCons`: Prepends a character to a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strAppend`: Appends two strings."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strIndex`: Extracts a character at the given position from a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strSubstr`: Extracts the substring between the given positions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:311
#, no-wrap
msgid ""
"Needless to say, not all of these functions are total. Therefore, Idris\n"
"must make sure that invalid calls do not reduce during compile time, as\n"
"otherwise the compiler would crash. If, however we force the evaluation\n"
"of a partial primitive function by compiling and running the corresponding\n"
"program, this program will crash with an error:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:312
#, no-wrap
msgid ""
"Tutorial.Prim> prim__strTail \"\"\n"
"prim__strTail \"\"\n"
"Tutorial.Prim> :exec putStrLn (prim__strTail \"\")\n"
"Exception in substring: 1 and 0 are not valid start/end indices for \"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:323
#, no-wrap
msgid ""
"Note, how `prim__strTail \"\"` is not reduced at the REPL and how the\n"
"same expression leads to a runtime exception if we compile and\n"
"execute the program. Valid calls to `prim__strTail` are reduced\n"
"just fine, however:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:324
#, no-wrap
msgid ""
"tailExample : prim__strTail \"foo\" = \"oo\"\n"
"tailExample = Refl\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:329
#, no-wrap
msgid "Pack and Unpack"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:339
#, no-wrap
msgid ""
"Two of the most important functions for working with strings\n"
"are `unpack` and `pack`, which convert a string to a list\n"
"of characters and vice versa. This allows us to conveniently\n"
"implement many string operations by iterating or folding\n"
"over the list of characters instead. This might not always\n"
"be the most efficient thing to do, but unless you plan to\n"
"handle very large amounts of text, they work and perform\n"
"reasonably well.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:340
#, no-wrap
msgid "String Interpolation"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:345
#, no-wrap
msgid ""
"Idris allows us to include arbitrary string expressions in\n"
"a string literal by wrapping them in curly braces, the first\n"
"of which has to be escaped with a backslash. For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:346
#, no-wrap
msgid ""
"interpEx1 : Bits64 -> Bits64 -> String\n"
"interpEx1 x y = \"\\{show x} + \\{show y} = \\{show $ x + y}\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:356
#, no-wrap
msgid ""
"This is a very convenient way to assemble complex strings\n"
"from values of different types.\n"
"In addition, there is interface `Interpolation`, which\n"
"allows us to use values in interpolated strings without\n"
"having to convert them to strings first:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:357
#, no-wrap
msgid ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"Formula : Type\n"
"Formula = List (Element,Nat)\n"
"\n"
"Interpolation Element where\n"
"  interpolate H  = \"H\"\n"
"  interpolate He = \"He\"\n"
"  interpolate C  = \"C\"\n"
"  interpolate N  = \"N\"\n"
"  interpolate O  = \"O\"\n"
"  interpolate F  = \"F\"\n"
"  interpolate Ne = \"Ne\"\n"
"\n"
"Interpolation (Element,Nat) where\n"
"  interpolate (_, 0) = \"\"\n"
"  interpolate (x, 1) = \"\\{x}\"\n"
"  interpolate (x, k) = \"\\{x}\\{show k}\"\n"
"\n"
"Interpolation Formula where\n"
"  interpolate = foldMap interpolate\n"
"\n"
"ethanol : String\n"
"ethanol = \"The formulat of ethanol is: \\{[(C,2),(H,6),(O, the Nat 1)]}\"\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:384
#, no-wrap
msgid "Raw and Multiline String Literals"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:388
#, no-wrap
msgid ""
"In string literals, we have to escape certain characters\n"
"like quotes, backslashes or new line characters. For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:389
#, no-wrap
msgid ""
"escapeExample : String\n"
"escapeExample = \"A quote: \\\". \\nThis is on a new line.\\nA backslash: "
"\\\\\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:398
#, no-wrap
msgid ""
"Idris allows us to enter raw string literals, where there\n"
"is no need to escape quotes and backslashes, by pre- and\n"
"postfixing the wrapping quote characters with the same number\n"
"of hash characters. For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:399
#, no-wrap
msgid ""
"rawExample : String\n"
"rawExample = #\"A quote: \". A blackslash: \\\"#\n"
"\n"
"rawExample2 : String\n"
"rawExample2 = ##\"A quote: \". A blackslash: \\\"##\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:411
#, no-wrap
msgid ""
"With raw string literals, it is still possible to use string\n"
"interpolation, but the opening curly brace has to be prefixed\n"
"with a backslash and the same number of hashes as are being used\n"
"for opening and closing the string literal:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:412
#, no-wrap
msgid ""
"rawInterpolExample : String\n"
"rawInterpolExample = ##\"An interpolated \"string\": \\##{rawExample}\"##\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:424
#, no-wrap
msgid ""
"Finally, Idris also allows us to conveniently write multiline\n"
"strings. These can be pre- and postfixed with hashes if we want\n"
"raw multiline string literals, and they also can be combined with\n"
"string interpolation. Multiline literals are opened and closed with\n"
"triple quote characters. Indenting the closing triple quotes\n"
"allows us to indent the whole multiline literal. Whitespace used\n"
"for indentation will not appear in the resulting string. For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:425
#, no-wrap
msgid ""
"multiline1 : String\n"
"multiline1 = \"\"\"\n"
"  And I raise my head and stare\n"
"  Into the eyes of a stranger\n"
"  I've always known that the mirror never lies\n"
"  People always turn away\n"
"  From the eyes of a stranger\n"
"  Afraid to see what hides behind the stare\n"
"  \"\"\"\n"
"\n"
"multiline2 : String\n"
"multiline2 = #\"\"\"\n"
"  An example for a simple expression:\n"
"  \"foo\" ++ \"bar\".\n"
"  This is reduced to \"\\#{\"foo\" ++ \"bar\"}\".\n"
"  \"\"\"#\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:447
#, no-wrap
msgid ""
"Make sure to look at the example strings at the\n"
"REPL to see the effect of interpolation and raw string\n"
"literals and compare it with the syntax we used.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:454
#, no-wrap
msgid ""
"In these exercises, you are supposed to implement a bunch\n"
"of utility functions for consuming and converting strings.\n"
"I don't give the expected types here, because you are\n"
"supposed to come up with those yourself.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:458
msgid ""
"Implement functions similar to `map`, `filter`, and `mapMaybe` for "
"strings. The output type of these should always be a string."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:461
msgid "Implement functions similar to `foldl` and `foldMap` for strings."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:464
msgid ""
"Implement a function similar to `traverse` for strings. The output type "
"should be a wrapped string."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:467
msgid ""
"Implement the bind operator for strings. The output type should again be a "
"string."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:468
#, no-wrap
msgid "Integers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:475
#, no-wrap
msgid ""
"As listed at the beginning of this chapter, Idris provides different\n"
"fixed-precision signed and unsigned integer types as well as `Integer`,\n"
"an arbitrary precision signed integer type.\n"
"All of them come with the following primitive functions (given\n"
"here for `Bits8` as an example):\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__add_Bits8`: Integer addition."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__sub_Bits8`: Integer subtraction."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__mul_Bits8`: Integer multiplication."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__div_Bits8`: Integer division."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__mod_Bits8`: Modulo function."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__shl_Bits8`: Bitwise left shift."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__shr_Bits8`: Bitwise right shift."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__and_Bits8`: Bitwise *and*."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__or_Bits8`: Bitwise *or*."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__xor_Bits8`: Bitwise *xor*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:493
#, no-wrap
msgid ""
"Typically, you use the functions for addition and multiplication\n"
"through the operators from interface `Num`, the function\n"
"for subtraction through interface `Neg`, and the functions\n"
"for division (`div` and `mod`) through interface `Integral`.\n"
"The bitwise operations are available through interfaces\n"
"`Data.Bits.Bits` and `Data.Bits.FiniteBits`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:497
#, no-wrap
msgid ""
"For all integral types, the following laws are assumed to\n"
"hold for numeric operations (`x`, `y`, and `z` are\n"
"arbitrary value of the same primitive integral type):\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x + y = y + x`: Addition is commutative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x + (y + z) = (x + y) + z`: Addition is associative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x + 0 = x`: Zero is the neutral element of addition."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x - x = x + (-x) = 0`: `-x` is the additive inverse of `x`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * y = y * x`: Multiplication is commutative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * (y * z) = (x * y) * z`: Multiplication is associative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * 1 = x`: One is the neutral element of multiplication."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * (y + z) = x * y + x * z`: The distributive law holds."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "``y * (x `div` y) + (x `mod` y) = x`` (for `y /= 0`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:515
#, no-wrap
msgid ""
"Please note, that the officially supported backends use\n"
"*Euclidian modulus* for calculating `mod`:\n"
"For `y /= 0`, ``x `mod` y`` is always a non-negative value\n"
"strictly smaller than `abs y`, so that the law given above\n"
"does hold. If `x` or `y` are negative numbers, this is different\n"
"to what many other languages do but for good reasons as explained\n"
"in the following "
"[article](https://www.microsoft.com/en-us/research/publication/division-and-modulus-for-computer-scientists/).\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:516
#, no-wrap
msgid "Unsigned Integers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:526
#, no-wrap
msgid ""
"The unsigned fixed precision integer types (`Bits8`, `Bits16`,\n"
"`Bits32`, and `Bits64`) come with implementations of all\n"
"integral interfaces (`Num`, `Neg`, and `Integral`) and\n"
"the two interfaces for bitwise operations (`Bits` and `FiniteBits`).\n"
"All functions with the exception of `div` and `mod` are\n"
"total. Overflows are handled by calculating the remainder\n"
"modulo `2^bitsize`. For instance, for `Bits8`, all operations\n"
"calculate their results modulo 256:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:527
#, no-wrap
msgid ""
"Main> the Bits8 255 + 1\n"
"0\n"
"Main> the Bits8 255 + 255\n"
"254\n"
"Main> the Bits8 128 * 2 + 7\n"
"7\n"
"Main> the Bits8 12 - 13\n"
"255\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:538
#, no-wrap
msgid "Signed Integers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:549
#, no-wrap
msgid ""
"Like the unsigned integer types, the signed fixed precision\n"
"integer types (`Int8`, `Int16`, `Int32`, and `Int64`) come with\n"
"implementations of all integral interfaces and\n"
"the two interfaces for bitwise operations (`Bits` and `FiniteBits`).\n"
"Overflows are handled by calculating the remainder\n"
"modulo `2^bitsize` and adding the lower bound (a negative number)\n"
"if the result is still out of range. For instance, for `Int8`, all "
"operations\n"
"calculate their results modulo 256, subtracting 128 if the\n"
"result is still out of bounds:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:550
#, no-wrap
msgid ""
"Main> the Int8 2 * 127\n"
"-2\n"
"Main> the Int8 3 * 127\n"
"125\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:557
#, no-wrap
msgid "Bitwise Operations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:568
#, no-wrap
msgid ""
"Module `Data.Bits` exports interfaces for performing bitwise\n"
"operations on integral types. I'm going to show a couple of\n"
"examples on unsigned 8-bit numbers (`Bits8`) to explain the concept\n"
"to readers new to bitwise arithmetics. Note, that this is much easier\n"
"to grasp for unsigned integer types than for the signed versions.\n"
"Those have to include information about the *sign* of numbers in their\n"
"bit pattern, and it is assumed that signed integers in Idris use\n"
"a [two's complement "
"representation](https://en.wikipedia.org/wiki/Two%27s_complement),\n"
"about which I will not go into the details here.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:573
#, no-wrap
msgid ""
"An unsigned 8-bit binary number is represented internally as\n"
"a sequence of eight bits (with values 0 or 1), each of which\n"
"corresponds to a power of 2. For instance,\n"
"the number 23 (= 16 + 4 + 2 + 1) is represented as `0001 0111`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:574
#, no-wrap
msgid ""
"23 in binary:    0  0  0  1    0  1  1  1\n"
"\n"
"Bit number:      7  6  5  4    3  2  1  0\n"
"Decimal value: 128 64 32 16    8  4  2  1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:583
#, no-wrap
msgid ""
"We can use function `testBit` to check if the bit at the given\n"
"position is set or not:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:584
#, no-wrap
msgid ""
"Tutorial.Prim> testBit (the Bits8 23) 0\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 1\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 3\n"
"False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:595
#, no-wrap
msgid ""
"Likewise, we can use functions `setBit` and `clearBit` to\n"
"set or unset a bit at a certain position:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:596
#, no-wrap
msgid ""
"Tutorial.Prim> setBit (the Bits8 23) 3\n"
"31\n"
"Tutorial.Prim> clearBit (the Bits8 23) 2\n"
"19\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:610
#, no-wrap
msgid ""
"There are also operators `(.&.)` (bitwise *and*) and `(.|.)`\n"
"(bitwise *or*) as well as function `xor` (bitwise *exclusive or*)\n"
"for performing boolean operations on integral values.\n"
"For instance `x .&. y` has exactly those bits set, which both `x`\n"
"and `y` have set, while `x .|. y` has all bits set that are either\n"
"set in `x` or `y` (or both), and ``x `xor` y`` has those bits\n"
"set that are set in exactly one of the two values:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:611
#, no-wrap
msgid ""
"23 in binary:          0  0  0  1    0  1  1  1\n"
"11 in binary:          0  0  0  0    1  0  1  1\n"
"\n"
"23 .&. 11 in binary:   0  0  0  0    0  0  1  1\n"
"23 .|. 11 in binary:   0  0  0  1    1  1  1  1\n"
"23 `xor` 11 in binary: 0  0  0  1    1  1  0  0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:621
#, no-wrap
msgid "And here are the examples at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:622
#, no-wrap
msgid ""
"Tutorial.Prim> the Bits8 23 .&. 11\n"
"3\n"
"Tutorial.Prim> the Bits8 23 .|. 11\n"
"31\n"
"Tutorial.Prim> the Bits8 23 `xor` 11\n"
"28\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:637
#, no-wrap
msgid ""
"Finally, it is possible to shift all bits to the right or left\n"
"by a certain number of steps by using functions `shiftR` and\n"
"`shiftL`, respectively (overflowing bits will just be dropped).\n"
"A left shift can therefore be viewed as a multiplication by a\n"
"power of two, while a right shift can be seen as a division\n"
"by a power of two:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:638
#, no-wrap
msgid ""
"22 in binary:            0  0  0  1    0  1  1  0\n"
"\n"
"22 `shiftL` 2 in binary: 0  1  0  1    1  0  0  0\n"
"22 `shiftR` 1 in binary: 0  0  0  0    1  0  1  1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:647
#, no-wrap
msgid ""
"Tutorial.Prim> the Bits8 22 `shiftL` 2\n"
"88\n"
"Tutorial.Prim> the Bits8 22 `shiftR` 1\n"
"11\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:657
#, no-wrap
msgid ""
"Bitwise operations are often used in specialized code or\n"
"certain high-performance applications. As programmers, we\n"
"have to know they exist and how they work.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:658
#, no-wrap
msgid "Integer Literals"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:666
#, no-wrap
msgid ""
"So far, we always required an implementation of `Num` in order to\n"
"be able to use integer literals for a given type. However,\n"
"it is actually only necessary to implement a function `fromInteger`\n"
"converting an `Integer` to the type in question. As we will\n"
"see in the last section, such a function can even restrict\n"
"the values allowed as valid literals.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:671
#, no-wrap
msgid ""
"For instance, assume we'd like to define a data type for\n"
"representing the charge of a chemical molecule. Such a value\n"
"can be positive or negative and (theoretically) of almost\n"
"arbitrary magnitude:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:672
#, no-wrap
msgid ""
"record Charge where\n"
"  constructor MkCharge\n"
"  value : Integer\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:683
#, no-wrap
msgid ""
"It makes sense to be able to sum up charges, but not to\n"
"multiply them. They should therefore have an implementation\n"
"of `Monoid` but not of `Num`. Still, we'd like to have\n"
"the convenience of integer literals when using constant\n"
"charges at compile time. Here's how to do this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:684
#, no-wrap
msgid ""
"fromInteger : Integer -> Charge\n"
"fromInteger = MkCharge\n"
"\n"
"Semigroup Charge where\n"
"  x <+> y = MkCharge $ x.value + y.value\n"
"\n"
"Monoid Charge where\n"
"  neutral = 0\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Prim.md:695
#, no-wrap
msgid "Alternative Bases"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:702
#, no-wrap
msgid ""
"In addition to the well known decimal literals, it is also\n"
"possible to use integer literals in binary, octal, or\n"
"hexadecimal representation. These have to be prefixed\n"
"with a zero following by a `b`, `o`, or `x` for\n"
"binary, octal, and hexadecimal, respectively:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:703
#, no-wrap
msgid ""
"Tutorial.Prim> 0b1101\n"
"13\n"
"Tutorial.Prim> 0o773\n"
"507\n"
"Tutorial.Prim> 0xffa2\n"
"65442\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:716
msgid ""
"Define a wrapper record for integral values and implement `Monoid` so that "
"`(<+>)` corresponds to `(.&.)`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:719
#, no-wrap
msgid ""
"   Hint: Have a look at the functions available from interface\n"
"   `Bits` to find a value suitable as the neutral element.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:722
msgid ""
"Define a wrapper record for integral values and implement `Monoid` so that "
"`(<+>)` corresponds to `(.|.)`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:725
msgid ""
"Use bitwise operations to implement a function, which tests if a given value "
"of type `Bits64` is even or not."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:727
msgid "Convert a value of type `Bits64` to a string in binary representation."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Prim.md:729
msgid "Convert a value of type `Bits64` to a string in hexadecimal representation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:732
#, no-wrap
msgid ""
"   Hint: Use `shiftR` and `(.&. 15)` to access subsequent packages of\n"
"   four bits.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:733
#, no-wrap
msgid "Refined Primitives"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:741
#, no-wrap
msgid ""
"We often do not want to allow all values of a type in a certain\n"
"context. For instance, `String` as an arbitrary sequence of\n"
"UTF-8 characters (several of which are not even printable), is\n"
"too general most of the time. Therefore, it is usually advisable\n"
"to rule out invalid values early on, by pairing a value with\n"
"an erased proof of validity.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:749
#, no-wrap
msgid ""
"We have learned how we can write elegant predicates, with\n"
"which we can proof our functions to be total, and from which we\n"
"can - in the ideal case - derive other, related predicates. However,\n"
"when we define predicates on primitives they are to a certain degree\n"
"doomed to live in isolation, unless we come up with a set of\n"
"primitive axioms (implemented most likely using `believe_me`), with\n"
"which we can manipulate our predicates.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:750
#, no-wrap
msgid "Use Case: ASCII Strings"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:756
#, no-wrap
msgid ""
"String encodings is a difficult topic, so in many low level routines\n"
"it makes sense to rule out most characters from the beginning. Assume\n"
"therefore, we'd like to make sure the strings we accept in our\n"
"application only consist of ASCII characters:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:757
#, no-wrap
msgid ""
"isAsciiChar : Char -> Bool\n"
"isAsciiChar c = ord c <= 127\n"
"\n"
"isAsciiString : String -> Bool\n"
"isAsciiString = all isAsciiChar . unpack\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:767
#, no-wrap
msgid ""
"We can now *refine* a string value by pairing it with an erased\n"
"proof of validity:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:768
#, no-wrap
msgid ""
"record Ascii where\n"
"  constructor MkAscii\n"
"  value : String\n"
"  0 prf : isAsciiString value === True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:779
#, no-wrap
msgid ""
"It is now *impossible* to at runtime or compile time create\n"
"a value of type `Ascii` without first validating the wrapped\n"
"string. With this, it is already pretty easy to safely wrap strings at\n"
"compile time in a value of type `Ascii`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:780
#, no-wrap
msgid ""
"hello : Ascii\n"
"hello = MkAscii \"Hello World!\" Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:800
#, no-wrap
msgid ""
"And yet, it would be much more convenient to still use string\n"
"literals for this, without having to sacrifice the comfort of\n"
"safety. To do so, we can't use interface `FromString`, as its\n"
"function `fromString` would force us to convert *any* string,\n"
"even an invalid one. However, we actually don't need an implementation of\n"
"`FromString` to support string literals, just like we didn't\n"
"require an implementation of `Num` to support integer literals.\n"
"What we really need is a function named `fromString`. Now, when\n"
"string literals are desugared, they are converted to invocations\n"
"of `fromString` with the given string value as its argument.\n"
"For instance, literal `\"Hello\"` gets desugared to `fromString "
"\"Hello\"`.\n"
"This happens before type checking and filling in of (auto) implicit\n"
"values. It is therefore perfectly fine, to define a custom `fromString`\n"
"function with an erased auto implicit argument as a proof of\n"
"validity:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:801
#, no-wrap
msgid ""
"fromString : (s : String) -> {auto 0 prf : isAsciiString s === True} -> "
"Ascii\n"
"fromString s = MkAscii s prf\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:808
#, no-wrap
msgid ""
"With this, we can us (valid) string literals for coming up with\n"
"values of type `Ascii` directly:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:809
#, no-wrap
msgid ""
"hello2 : Ascii\n"
"hello2 = \"Hello World!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:817
#, no-wrap
msgid ""
"In order to at runtime create values of type `Ascii` from strings\n"
"of an unknown source, we can use a refinement function returning\n"
"some kind of failure type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:818
#, no-wrap
msgid ""
"test : (b : Bool) -> Dec (b === True)\n"
"test True  = Yes Refl\n"
"test False = No absurd\n"
"\n"
"ascii : String -> Maybe Ascii\n"
"ascii x = case test (isAsciiString x) of\n"
"  Yes prf   => Just $ MkAscii x prf\n"
"  No contra => Nothing\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Prim.md:829
#, no-wrap
msgid "Disadvantages of Boolean Proofs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:834
#, no-wrap
msgid ""
"For many use cases, what we described above for ASCII strings can\n"
"take us very far. However, one drawback of this approach is that we\n"
"can't safely perform any computations with the proofs at hand.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:839
#, no-wrap
msgid ""
"For instance, we know it will be perfectly fine to concatenate\n"
"two ASCII strings, but in order to convince Idris of this, we\n"
"will have to use `believe_me`, because we will not be able to\n"
"proof the following lemma otherwise:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:840
#, no-wrap
msgid ""
"0 allAppend :  (f : Char -> Bool)\n"
"            -> (s1,s2 : String)\n"
"            -> (p1 : all f (unpack s1) === True)\n"
"            -> (p2 : all f (unpack s2) === True)\n"
"            -> all f (unpack (s1 ++ s2)) === True\n"
"allAppend f s1 s2 p1 p2 = believe_me $ Refl {x = True}\n"
"\n"
"namespace Ascii\n"
"  export\n"
"  (++) : Ascii -> Ascii -> Ascii\n"
"  MkAscii s1 p1 ++ MkAscii s2 p2 =\n"
"    MkAscii (s1 ++ s2) (allAppend isAsciiChar s1 s2 p1 p2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:861
#, no-wrap
msgid ""
"The same goes for all operations extracting a substring from\n"
"a given string: We will have to implement according rules using\n"
"`believe_me`. Finding a reasonable set of axioms to conveniently\n"
"deal with refined primitives can therefore be challenging at times,\n"
"and whether such axioms are even required very much depends\n"
"on the use case at hand.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:862
#, no-wrap
msgid "Use Case: Sanitized HTML"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:869
#, no-wrap
msgid ""
"Assume you write a simple web application for scientific\n"
"discourse between registered users. To keep things simple, we\n"
"only consider unformatted text input here. Users can write arbitrary\n"
"text in a text field and upon hitting Enter, the message is\n"
"displayed to all other registered users.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:871
#, no-wrap
msgid "Assume now a user decides to enter the following text:\n"
msgstr ""

#. type: Code fence info string
#: ../src/Tutorial/Prim.md:872
#, no-wrap
msgid "html"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:872
#, no-wrap
msgid "<script>alert(\"Hello World!\")</script>\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:884
#, no-wrap
msgid ""
"Well, it could have been (much) worse. Still, unless we take measures\n"
"to prevent this from happening, this might embed a JavaScript\n"
"program in our web page we never intended to have there!\n"
"What I described here, is a well known security vulnerability called\n"
"[cross-site "
"scripting](https://en.wikipedia.org/wiki/Cross-site_scripting).\n"
"It allows users of web pages to enter malicious JavaScript code in\n"
"text fields, which will then be included in the page's HTML structure\n"
"and executed when it is being displayed to other users.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:891
#, no-wrap
msgid ""
"We want to make sure, that this cannot happen on our own web page.\n"
"In order to protect us from this attack, we could for instance disallow\n"
"certain characters like `'<'` or `'>'` completely (although this might not\n"
"be enough!), but if our chat service is targeted at programmers,\n"
"this will be overly restrictive. An alternative\n"
"is to escape certain characters before rendering them on the page.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:892
#, no-wrap
msgid ""
"escape : String -> String\n"
"escape = concat . map esc . unpack\n"
"  where esc : Char -> String\n"
"        esc '<'  = \"&lt;\"\n"
"        esc '>'  = \"&gt;\"\n"
"        esc '\"'  = \"&quot;\"\n"
"        esc '&'  = \"&amp;\"\n"
"        esc '\\'' = \"&apos;\"\n"
"        esc c    = singleton c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:910
#, no-wrap
msgid ""
"What we now want to do is to store a string together with\n"
"a proof that is was properly escaped. This is another form\n"
"of existential quantification: \"Here is a string, and there\n"
"once existed another string, which we passed to `escape`\n"
"and arrived at the string we have now\". Here's how to encode\n"
"this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:911
#, no-wrap
msgid ""
"record Escaped where\n"
"  constructor MkEscaped\n"
"  value    : String\n"
"  0 origin : String\n"
"  0 prf    : escape origin === value\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:925
#, no-wrap
msgid ""
"Whenever we now embed a string of unknown origin in our web page,\n"
"we can request a value of type `Escaped` and have the very\n"
"strong guarantee that we are no longer vulnerable to cross-site\n"
"scripting attacks. Even better, it is also possible to safely\n"
"embed string literals known at compile time without the need\n"
"to escape them first:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:926
#, no-wrap
msgid ""
"namespace Escaped\n"
"  export\n"
"  fromString : (s : String) -> {auto 0 prf : escape s === s} -> Escaped\n"
"  fromString s = MkEscaped s s prf\n"
"\n"
"escaped : Escaped\n"
"escaped = \"Hello World!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:941
#, no-wrap
msgid ""
"In this massive set of exercises, you are going to build\n"
"a small library for working with predicates on primitives.\n"
"We want to keep the following goals in mind:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
msgid ""
"We want to use the usual operations of propositional logic to combine "
"predicates: Negation, conjuction (logical *and*), and disjunction (logical "
"*or*)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
msgid ""
"All predicates should be erased at runtime. If we proof something about a "
"primitive number, we want to make sure not to carry around a huge proof of "
"validity."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
msgid ""
"Calculations on predicates should make no appearance at runtime (with the "
"exception of `decide`; see below)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
msgid ""
"Recursive calculations on predicates should be tail recursive if they are "
"used in implementations of `decide`. This might be tough to achieve. If you "
"can't find a tail recursive solution for a given problem, use what feels "
"most natural instead."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:980
#, no-wrap
msgid ""
"A note on efficiency: In order to be able to run\n"
"computations on our predicates, we try to convert primitive\n"
"values to algebraic data types as often and as soon as possible:\n"
"Unsigned integers will be converted to `Nat` using `cast`,\n"
"and strings will be converted to `List Char` using `unpack`.\n"
"This allows us to work with proofs on `Nat` and `List` most\n"
"of the time, and such proofs can be implemented without\n"
"resorting to `believe_me` or other cheats. However, the one\n"
"advantage of primitive types over algebraic data types is\n"
"that they often perform much better. This is especially\n"
"critical when comparing integral types with `Nat`: Operations\n"
"on natural numbers often run with `O(n)` time complexity,\n"
"where `n` is the size of one of the natural numbers involved,\n"
"while with `Bits64`, for instance, many operations run in fast constant\n"
"time (`O(1)`). Luckily, the Idris compiler optimizes many\n"
"functions on natural number to use the corresponding `Integer`\n"
"operations at runtime. This has the advantage that we can\n"
"still use proper induction to proof stuff about natural\n"
"numbers at compile time, while getting the benefit of fast\n"
"integer operations at runtime. However, operations on `Nat` do\n"
"run with `O(n)` time complexity and *compile time*. Proofs\n"
"working on large natural number will therefore drastically\n"
"slow down the compiler. A way out of this is discussed at\n"
"the end of this section of exercises.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:983
#, no-wrap
msgid ""
"Enough talk, let's begin!\n"
"To start with, you are given the following utilities:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:984
#, no-wrap
msgid ""
"-- Like `Dec` but with erased proofs. Constructors `Yes0`\n"
"-- and `No0` will be converted to constants `0` and `1` by\n"
"-- the compiler!\n"
"data Dec0 : (prop : Type) -> Type where\n"
"  Yes0 : (0 prf : prop) -> Dec0 prop\n"
"  No0  : (0 contra : prop -> Void) -> Dec0 prop\n"
"\n"
"-- For interfaces with more than one parameter (`a` and `p`\n"
"-- in this example) sometimes one parameter can be determined\n"
"-- by knowing the other. For instance, if we know what `p` is,\n"
"-- we will most certainly also know what `a` is. We therefore\n"
"-- specify that proof search on `Decidable` should only be\n"
"-- based on `p` by listing `p` after a vertical bar: `| p`.\n"
"-- This is like specifing the search parameter(s) of\n"
"-- a data type with `[search p]` as was shown in the chapter\n"
"-- about predicates.\n"
"-- Specifying a single search parameter as shown here can\n"
"-- drastically help with type inference.\n"
"interface Decidable (0 a : Type) (0 p : a -> Type) | p where\n"
"  decide : (v : a) -> Dec0 (p v)\n"
"\n"
"-- We often have to pass `p` explicitly in order to help Idris with\n"
"-- type inference. In such cases, it is more convenient to use\n"
"-- `decideOn pred` instead of `decide {p = pred}`.\n"
"decideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> Dec0 (p v)\n"
"decideOn _ = decide\n"
"\n"
"-- Some primitive predicates can only be reasonably implemented\n"
"-- using boolean functions. This utility helps with decidability\n"
"-- on such proofs.\n"
"test0 : (b : Bool) -> Dec0 (b === True)\n"
"test0 True  = Yes0 Refl\n"
"test0 False = No0 absurd\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1025
#, no-wrap
msgid ""
"We also want to run decidable computations at compile time. This\n"
"is often much more efficient than running a direct proof search on\n"
"an inductive type. We therefore come up with a predicate witnessing\n"
"that a `Dec0` value is actually a `Yes0` together with two\n"
"utility functions:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1026
#, no-wrap
msgid ""
"data IsYes0 : (d : Dec0 prop) -> Type where\n"
"  ItIsYes0 : IsYes0 (Yes0 prf)\n"
"\n"
"0 fromYes0 : (d : Dec0 prop) -> (0 prf : IsYes0 d) => prop\n"
"fromYes0 (Yes0 x) = x\n"
"fromYes0 (No0 contra) impossible\n"
"\n"
"0 safeDecideOn :  (0 p : a -> Type)\n"
"               -> Decidable a p\n"
"               => (v : a)\n"
"               -> (0 prf : IsYes0 (decideOn p v))\n"
"               => p v\n"
"safeDecideOn p v = fromYes0 $ decideOn p v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1045
#, no-wrap
msgid ""
"Finally, as we are planning to refine mostly primitives, we will\n"
"at times require some sledge hammer to convince Idris that\n"
"we know what we are doing:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1046
#, no-wrap
msgid ""
"-- only use this if you are sure that `decideOn p v`\n"
"-- will return a `Yes0`!\n"
"0 unsafeDecideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> p v\n"
"unsafeDecideOn p v = case decideOn p v of\n"
"  Yes0 prf => prf\n"
"  No0  _   =>\n"
"    assert_total $ idris_crash \"Unexpected refinement failure in "
"`unsafeRefineOn`\"\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:1058
msgid "We start with equality proofs. Implement `Decidable` for `Equal v`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1061
#, no-wrap
msgid ""
"   Hint: Use `DecEq` from module `Decidable.Equality` as a constraint\n"
"         and make sure that `v` is available at runtime.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:1063
msgid "We want to be able to negate a predicate:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1064
#, no-wrap
msgid ""
"   data Neg : (p : a -> Type) -> a -> Type where\n"
"     IsNot : {0 p : a -> Type} -> (contra : p v -> Void) -> Neg p v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1070
#, no-wrap
msgid "   Implement `Decidable` for `Neg p` using a suitable constraint.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:1072
msgid "We want to describe the conjunction of two predicates:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1073
#, no-wrap
msgid ""
"   data (&&) : (p,q : a -> Type) -> a -> Type where\n"
"     Both : {0 p,q : a -> Type} -> (prf1 : p v) -> (prf2 : q v) -> (&&) p q "
"v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1079
#, no-wrap
msgid "   Implement `Decidable` for `(p && q)` using suitable constraints.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:1083
msgid ""
"Come up with a data type called `(||)` for the disjunction (logical *or*) of "
"two predicates and implement `Decidable` using suitable constraints."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Prim.md:1086
msgid ""
"Proof [De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws)  "
"by implementing the following propositions:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1087
#, no-wrap
msgid ""
"   negOr : Neg (p || q) v -> (Neg p && Neg q) v\n"
"\n"
"   andNeg : (Neg p && Neg q) v -> Neg (p || q) v\n"
"\n"
"   orNeg : (Neg p || Neg q) v -> Neg (p && q) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1100
#, no-wrap
msgid ""
"   The last of De Morgan's implications is harder to type and proof\n"
"   as we need a way to come up with values of type `p v` and `q v`\n"
"   and show that not both can exist. Here is a way to encode this\n"
"   (annotated with quantity 0 as we will need to access an erased\n"
"   contraposition):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1101
#, no-wrap
msgid ""
"   0 negAnd :  Decidable a p\n"
"            => Decidable a q\n"
"            => Neg (p && q) v\n"
"            -> (Neg p || Neg q) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1111
#, no-wrap
msgid ""
"   When you implement `negAnd`, remember that you can freely access\n"
"   erased (implicit) arguments, because `negAnd` itself can only be\n"
"   used in an erased context.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1117
#, no-wrap
msgid ""
"So far, we implemented the tools to algebraically describe\n"
"and combine several predicate. It is now time to come up\n"
"with some examples. As a first use case, we will focus on\n"
"limiting the valid range of natural numbers. For this,\n"
"we use the following data type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1118
#, no-wrap
msgid ""
"-- Proof that m <= n\n"
"data (<=) : (m,n : Nat) -> Type where\n"
"  ZLTE : 0 <= n\n"
"  SLTE : m <= n -> S m <= S n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1128
#, no-wrap
msgid ""
"This is similar to `Data.Nat.LTE` but I find operator\n"
"notation often to be clearer.\n"
"We also can define and use the following aliases:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1129
#, no-wrap
msgid ""
"(>=) : (m,n : Nat) -> Type\n"
"m >= n = n <= m\n"
"\n"
"(<) : (m,n : Nat) -> Type\n"
"m < n = S m <= n\n"
"\n"
"(>) : (m,n : Nat) -> Type\n"
"m > n = n < m\n"
"\n"
"LessThan : (m,n : Nat) -> Type\n"
"LessThan m = (< m)\n"
"\n"
"To : (m,n : Nat) -> Type\n"
"To m = (<= m)\n"
"\n"
"GreaterThan : (m,n : Nat) -> Type\n"
"GreaterThan m = (> m)\n"
"\n"
"From : (m,n : Nat) -> Type\n"
"From m = (>= m)\n"
"\n"
"FromTo : (lower,upper : Nat) -> Nat -> Type\n"
"FromTo l u = From l && To u\n"
"\n"
"Between : (lower,upper : Nat) -> Nat -> Type\n"
"Between l u = GreaterThan l && LessThan u\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Prim.md:1171
msgid ""
"Coming up with a value of type `m <= n` by pattern matching on `m` and `n` "
"is highly inefficient for large values of `m`, as it will require `m` "
"iterations to do so. However, while in an erased context, we don't need to "
"hold a value of type `m <= n`. We only need to show, that such a value "
"follows from a more efficient computation. Such a computation is `compare` "
"for natural numbers: Although this is implemented in the *Prelude* with a "
"pattern match on its arguments, it is optimized by the compiler to a "
"comparison of integers which runs in constant time even for very large "
"numbers.  Since `Prelude.(<=)` for natural numbers is implemented in terms "
"of `compare`, it runs just as efficiently."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1175
#, no-wrap
msgid ""
"   We therefore need to proof the following two lemmas (make\n"
"   sure to not confuse `Prelude.(<=)` with `Prim.(<=)` in\n"
"   these declarations):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1176
#, no-wrap
msgid ""
"   0 fromLTE : (n1,n2 : Nat) -> (n1 <= n2) === True -> n1 <= n2\n"
"\n"
"   0 toLTE : (n1,n2 : Nat) -> n1 <= n2 -> (n1 <= n2) === True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1185
#, no-wrap
msgid ""
"   They come with a quantity of 0, because they are just as inefficient\n"
"   as the other computations we discussed above. We therefore want\n"
"   to make absolutely sure that they will never be used at runtime!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1190
#, no-wrap
msgid ""
"   Now, implement `Decidable Nat (<= n)`, making use of `test0`,\n"
"   `fromLTE`, and `toLTE`.\n"
"   Likewise, implement `Decidable Nat (m <=)`, because we require\n"
"   both kinds of predicates.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1193
#, no-wrap
msgid ""
"   Note: You should by know figure out yourself that `n` must be\n"
"   available at runtime and how to make sure that this is the case.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Prim.md:1198
msgid ""
"Proof that `(<=)` is reflexive and transitive by declaring and implementing "
"corresponding propositions. As we might require the proof of transitivity to "
"chain several values of type `(<=)`, it makes sense to also define a short "
"operator alias for this."
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Prim.md:1200
msgid "Proof that from `n > 0` follows `IsSucc n` and vise versa."
msgstr ""

#. type: Bullet: '9. '
#: ../src/Tutorial/Prim.md:1207
msgid ""
"Declare and implement safe division and modulo functions for `Bits64`, by "
"requesting an erased proof that the denominator is strictly positive when "
"cast to a natural number. In case of the modulo function, return a refined "
"value carrying an erased proof that the result is strictly smaller than the "
"modulus:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1208
#, no-wrap
msgid ""
"   safeMod :  (x,y : Bits64)\n"
"           -> (0 prf : cast y > 0)\n"
"           => Subset Bits64 (\\v => cast v < cast y)\n"
msgstr ""

#. type: Bullet: '10. '
#: ../src/Tutorial/Prim.md:1218
msgid ""
"We will use the predicates and utilities we defined so far to convert a "
"value of type `Bits64` to a string of digits in base `b` with `2 <= b && b "
"<= 16`.  To do so, implement the following skeleton definitions:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1223
#, no-wrap
msgid ""
"    ```idris\n"
"    -- this will require some help from `assert_total`\n"
"    -- and `idris_crash`.\n"
"    digit : (v : Bits64) -> (0 prf : cast v < 16) => Char\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1228
#, no-wrap
msgid ""
"    record Base where\n"
"      constructor MkBase\n"
"      value : Bits64\n"
"      0 prf : FromTo 2 16 (cast value)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1230
#, no-wrap
msgid "    base : Bits64 -> Maybe Base\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1235
#, no-wrap
msgid ""
"    namespace Base\n"
"      public export\n"
"      fromInteger : (v : Integer) -> {auto 0 _ : IsJust (base $ cast v)} -> "
"Base\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1241
#, no-wrap
msgid ""
"    Finally, implement `digits`, using `safeDiv` and `safeMod`\n"
"    in your implementation. This might be challenging, as you will\n"
"    have to manually transform some proofs to satisfy the type\n"
"    checker. You might also require `assert_smaller` in the\n"
"    recursive step.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1245
#, no-wrap
msgid ""
"    ```idris\n"
"    digits : Bits64 -> Base -> String\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1255
#, no-wrap
msgid ""
"We will now turn our focus on strings. Two of the most\n"
"obvious ways in which we can restrict the strings we\n"
"accept are by limiting the set of characters and\n"
"limiting their lengths. More advanced refinements might\n"
"require strings to match a certain pattern or regular\n"
"expression. In such cases, we might either go for a\n"
"boolean check or use a custom data type representing the\n"
"different parts of the pattern, but we will not cover\n"
"these topics here.\n"
msgstr ""

#. type: Bullet: '11. '
#: ../src/Tutorial/Prim.md:1258
msgid "Implement the following aliases for useful predicates on characters."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1262
#, no-wrap
msgid ""
"    Hint: Use `cast` to convert characters to natural numbers,\n"
"    use `(<=)` and `InRange` to specify regions of characters,\n"
"    and use `(||)` to combine regions of characters.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1266
#, no-wrap
msgid ""
"    ```idris\n"
"    -- Characters <= 127\n"
"    IsAscii : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1269
#, no-wrap
msgid ""
"    -- Characters <= 255\n"
"    IsLatin : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1272
#, no-wrap
msgid ""
"    -- Characters in the interval ['A','Z']\n"
"    IsUpper : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1275
#, no-wrap
msgid ""
"    -- Characters in the interval ['a','z']\n"
"    IsLower : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1278
#, no-wrap
msgid ""
"    -- Lower or upper case characters\n"
"    IsAlpha : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1281
#, no-wrap
msgid ""
"    -- Characters in the range ['0','9']\n"
"    IsDigit : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1284
#, no-wrap
msgid ""
"    -- Digits or characters from the alphabet\n"
"    IsAlphaNum : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1287
#, no-wrap
msgid ""
"    -- Characters in the ranges [0,31] or [127,159]\n"
"    IsControl : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1290
#, no-wrap
msgid ""
"    -- An ASCII character that is not a control character\n"
"    IsPlainAscii : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1294
#, no-wrap
msgid ""
"    -- A latin character that is not a control character\n"
"    IsPlainLatin : Char -> Type\n"
"    ```\n"
msgstr ""

#. type: Bullet: '12. '
#: ../src/Tutorial/Prim.md:1301
msgid ""
"The advantage of this more modular approach to predicates on primitives is "
"that we can safely run calculations on our predicates and get the strong "
"guarantees from the existing proofs on inductive types like `Nat` and "
"`List`. Here are some examples of such calculations and conversions, all of "
"which can be implemented without cheating:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1304
#, no-wrap
msgid ""
"    ```idris\n"
"    0 plainToAscii : IsPlainAscii c -> IsAscii c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1306
#, no-wrap
msgid "    0 digitToAlphaNum : IsDigit c -> IsAlphaNum c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1308
#, no-wrap
msgid "    0 alphaToAlphaNum : IsAlpha c -> IsAlphaNum c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1310
#, no-wrap
msgid "    0 lowerToAlpha : IsLower c -> IsAlpha c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1312
#, no-wrap
msgid "    0 upperToAlpha : IsUpper c -> IsAlpha c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1314
#, no-wrap
msgid "    0 lowerToAlphaNum : IsLower c -> IsAlphaNum c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1317
#, no-wrap
msgid ""
"    0 upperToAlphaNum : IsUpper c -> IsAlphaNum c\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1324
#, no-wrap
msgid ""
"    The following (`asciiToLatin`) is trickier. Remember that\n"
"    `(<=)` is transitive. However, in your invocation of the proof\n"
"    of transitivity, you will not be able to apply direct proof search "
"using\n"
"    `%search` because the search depth is too small. You could\n"
"    increase the search depth, but it is much more efficient\n"
"    to use `safeDecideOn` instead.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1327
#, no-wrap
msgid ""
"    ```idris\n"
"    0 asciiToLatin : IsAscii c -> IsLatin c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1330
#, no-wrap
msgid ""
"    0 plainAsciiToPlainLatin : IsPlainAscii c -> IsPlainLatin c\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1334
#, no-wrap
msgid ""
"Before we turn our full attention to predicates on strings,\n"
"we have to cover lists first, because we will often treat\n"
"strings as lists of characters.\n"
msgstr ""

#. type: Bullet: '13. '
#: ../src/Tutorial/Prim.md:1336
msgid "Implement `Decidable` for `Head`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1341
#, no-wrap
msgid ""
"    ```idris\n"
"    data Head : (p : a -> Type) -> List a -> Type where\n"
"      AtHead : {0 p : a -> Type} -> (0 prf : p v) -> Head p (v :: vs)\n"
"    ```\n"
msgstr ""

#. type: Bullet: '14. '
#: ../src/Tutorial/Prim.md:1343
msgid "Implement `Decidable` for `Length`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1350
#, no-wrap
msgid ""
"    ```idris\n"
"    data Length : (p : Nat -> Type) -> List a -> Type where\n"
"      HasLength :  {0 p : Nat -> Type}\n"
"                -> (0 prf : p (List.length vs))\n"
"                -> Length p vs\n"
"    ```\n"
msgstr ""

#. type: Bullet: '15. '
#: ../src/Tutorial/Prim.md:1354
msgid ""
"The following predicate is a proof that all values in a list of values "
"fulfill the given predicate. We will use this to limit the valid set of "
"characters in a string."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1363
#, no-wrap
msgid ""
"    ```idris\n"
"    data All : (p : a -> Type) -> (as : List a) -> Type where\n"
"      Nil  : All p []\n"
"      (::) :  {0 p : a -> Type}\n"
"           -> (0 h : p v)\n"
"           -> (0 t : All p vs)\n"
"           -> All p (v :: vs)\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1365
#, no-wrap
msgid "    Implement `Decidable` for `All`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1373
#, no-wrap
msgid ""
"    For a real challenge, try to make your implementation of\n"
"    `decide` tail recursive. This will be important for real world\n"
"    applications on the JavaScript backends, where we might want to\n"
"    refine strings of thousands of characters without overflowing the\n"
"    stack at runtime. In order to come up with a tail recursive "
"implementation,\n"
"    you will need an additional data type `AllSnoc` witnessing that a "
"predicate\n"
"    holds for all elements in a `SnocList`.\n"
msgstr ""

#. type: Bullet: '16. '
#: ../src/Tutorial/Prim.md:1379
msgid ""
"It's time to come to an end here. An identifier in Idris is a sequence of "
"alphanumeric characters, possibly separated by underscore characters "
"(`_`). In addition, all identifiers must start with a letter.  Given this "
"specification, implement predicate `IdentChar`, from which we can define a "
"new wrapper type for identifiers:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1382
#, no-wrap
msgid ""
"    ```idris\n"
"    0 IdentChars : List Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1388
#, no-wrap
msgid ""
"    record Identifier where\n"
"      constructor MkIdentifier\n"
"      value : String\n"
"      0 prf : IdentChars (unpack value)\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1391
#, no-wrap
msgid ""
"    Implement a factory method `identifier` for converting strings\n"
"    of unknown source at runtime:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1395
#, no-wrap
msgid ""
"    ```idris\n"
"    identifier : String -> Maybe Identifier\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1398
#, no-wrap
msgid ""
"    In addition, implement `fromString` for `Identifier` and verify,\n"
"    that the following is a valid identifier:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1403
#, no-wrap
msgid ""
"    ```idris\n"
"    testIdent : Identifier\n"
"    testIdent = \"fooBar_123\"\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1409
#, no-wrap
msgid ""
"Final remarks: Proofing stuff about the primitives can be challenging,\n"
"both when deciding on what axioms to use and when trying to make\n"
"things perform well at runtime and compile time. I'm experimenting\n"
"with a library, which deals with these issues. It is not yet finished,\n"
"but you can have a look at it "
"[here](https://github.com/stefan-hoeck/idris2-prim).\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/Traverse.md:1
#, no-wrap
msgid "Effectful Traversals"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:11
#, no-wrap
msgid ""
"In this chapter, we are going to bring our treatment\n"
"of the higher-kinded interfaces in the *Prelude* to an\n"
"end. In order to do so, we will continue developing the\n"
"CSV reader we started implementing in chapter\n"
"[Functor and Friends](Functor.md). I moved some of\n"
"the data types and interfaces from that chapter to\n"
"their own modules, so we can import them here without\n"
"the need to start from scratch.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:16
#, no-wrap
msgid ""
"Note that unlike in our original CSV reader, we will use\n"
"`Validated` instead of `Either` for handling exceptions,\n"
"since this will allow us to accumulate all errors\n"
"when reading a CSV file.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:17
#, no-wrap
msgid ""
"module Tutorial.Traverse\n"
"\n"
"import Data.HList\n"
"import Data.IORef\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Validated\n"
"import Data.Vect\n"
"import Text.CSV\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Traverse.md:31
#, no-wrap
msgid "Reading CSV Tables"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:37
#, no-wrap
msgid ""
"We stopped developing our CSV reader with function\n"
"`hdecode`, which allows us to read a single line\n"
"in a CSV file and decode it to a heterogeneous list.\n"
"As a reminder, here is how to use `hdecode` at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:38
#, no-wrap
msgid ""
"Tutorial.Traverse> hdecode [Bool,String,Bits8] 1 \"f,foo,12\"\n"
"Valid [False, \"foo\", 12]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:51
#, no-wrap
msgid ""
"The next step will be to parse a whole CSV table, represented\n"
"as a list of strings, where each string corresponds to one\n"
"of the table's rows.\n"
"We will go about this stepwise as there are several aspects\n"
"about doing this properly. What we are looking for - eventually -\n"
"is a function of the following type (we are going to\n"
"implement several versions of this function, hence the\n"
"numbering):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:52
#, no-wrap
msgid ""
"hreadTable1 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:61
#, no-wrap
msgid ""
"In our first implementation, we are not going to care\n"
"about line numbers:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:62
#, no-wrap
msgid ""
"hreadTable1 _  []        = pure []\n"
"hreadTable1 ts (s :: ss) = [| hdecode ts 0 s :: hreadTable1 ts ss |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:72
#, no-wrap
msgid ""
"Note, how we can just use applicative syntax in the implementation\n"
"of `hreadTable1`. To make this clearer, I used `pure []` on the first\n"
"line instead of the more specific `Valid []`. In fact, if we used\n"
"`Either` or `Maybe` instead of `Validated` for error handling,\n"
"the implementation of `hreadTable1` would look exactly the same.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:81
#, no-wrap
msgid ""
"The question is: Can we extract a pattern to abstract over\n"
"from this observation? What we do in `hreadTable1` is running\n"
"an effectful computation of type `String -> Validated CSVError (HList ts)`\n"
"over a list of strings, so that the result is a list of `HList ts`\n"
"wrapped in a `Validated CSVError`. The first step of abstraction\n"
"should be to use type parameters for the input and output:\n"
"Run a computation of type `a -> Validated CSVError b` over a\n"
"list `List a`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:82
#, no-wrap
msgid ""
"traverseValidatedList :  (a -> Validated CSVError b)\n"
"                      -> List a\n"
"                      -> Validated CSVError (List b)\n"
"traverseValidatedList _ []        = pure []\n"
"traverseValidatedList f (x :: xs) = [| f x :: traverseValidatedList f xs "
"|]\n"
"\n"
"hreadTable2 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable2 ts = traverseValidatedList (hdecode ts 0)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:104
#, no-wrap
msgid ""
"But our observation was, that the implementation of `hreadTable1`\n"
"would be exactly the same if we used `Either CSVError` or `Maybe`\n"
"as our effect types instead of `Validated CSVError`.\n"
"So, the next step should be to abstract over the *effect type*.\n"
"We note, that we used applicative syntax (idiom brackets and\n"
"`pure`) in our implementation, so we will need to write\n"
"a function with an `Applicative` constraint\n"
"on the effect type:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:105
#, no-wrap
msgid ""
"traverseList :  Applicative f => (a -> f b) -> List a -> f (List b)\n"
"traverseList _ []        = pure []\n"
"traverseList f (x :: xs) = [| f x :: traverseList f xs |]\n"
"\n"
"hreadTable3 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable3 ts = traverseList (hdecode ts 0)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:120
#, no-wrap
msgid ""
"Note, how the implementation of `traverseList` is exactly the same\n"
"as the one of `traverseValidatedList`, but the types are more general\n"
"and therefore, `traverseList` is much more powerful.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:123
#, no-wrap
msgid ""
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"f,12\",\"t,0\"]\n"
"Valid [[False, 12], [True, 0]]\n"
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"f,12\",\"t,1000\"]\n"
"Invalid (FieldError 0 2 \"1000\")\n"
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"1,12\",\"t,1000\"]\n"
"Invalid (Append (FieldError 0 1 \"1\") (FieldError 0 2 \"1000\"))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:139
#, no-wrap
msgid ""
"This works very well already, but note how our error messages do\n"
"not yet print the correct line numbers. That's not surprising,\n"
"as we are using a dummy constant in our call to `hdecode`.\n"
"We will look at how we can come up with the line numbers on the\n"
"fly when we talk about stateful computations later in this chapter.\n"
"For now, we could just manually annotate the lines with their\n"
"numbers and pass a list of pairs to `hreadTable`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:140
#, no-wrap
msgid ""
"hreadTable4 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List (Nat, String)\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable4 ts = traverseList (uncurry $ hdecode ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:154
#, no-wrap
msgid ""
"If this is the first time you came across function `uncurry`,\n"
"make sure you have a look at its type and try to figure out why it is\n"
"used here. There are several utility functions like this\n"
"in the *Prelude*, such as `curry`, `uncurry`, `flip`, or even\n"
"`id`, all of which can be very useful when working with higher-order\n"
"functions.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:157
#, no-wrap
msgid ""
"While not perfect, this version at least allows us to verify at the REPL\n"
"that the line numbers are passed to the error messages correctly:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:158
#, no-wrap
msgid ""
"Tutorial.Traverse> hreadTable4 [Bool,Bits8] [(1,\"t,1000\"),(2,\"1,100\")]\n"
"Invalid (Append (FieldError 1 2 \"1000\") (FieldError 2 1 \"1\"))\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Traverse.md:163
#, no-wrap
msgid "Interface Traversable"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:172
#, no-wrap
msgid ""
"Now, here is an interesting observation: We can implement a function\n"
"like `traverseList` for other container types as well. You might think "
"that's\n"
"obvious, given that we can convert container types to lists via\n"
"function `toList` from interface `Foldable`. However, while going\n"
"via `List` might be feasible in some occasions, it is undesirable in\n"
"general, as we loose typing information. For instance, here\n"
"is such a function for `Vect`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:173
#, no-wrap
msgid ""
"traverseVect' : Applicative f => (a -> f b) -> Vect n a -> f (List b)\n"
"traverseVect' fun = traverseList fun . toList\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:182
#, no-wrap
msgid ""
"Note how we lost all information about the structure of the\n"
"original container type. What we are looking for is a function\n"
"like `traverseVect'`, which keeps this type level information:\n"
"The result should be a vector of the same length as the input.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:183
#, no-wrap
msgid ""
"traverseVect : Applicative f => (a -> f b) -> Vect n a -> f (Vect n b)\n"
"traverseVect _   []        = pure []\n"
"traverseVect fun (x :: xs) = [| fun x :: traverseVect fun xs |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:193
#, no-wrap
msgid ""
"That's much better! And as I wrote above, we can easily get the same\n"
"for other container types like `List1`, `SnocList`, `Maybe`, and so on.\n"
"As usual, some derived functions will follow immediately from "
"`traverseXY`.\n"
"For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:194
#, no-wrap
msgid ""
"sequenceList : Applicative f => List (f a) -> f (List a)\n"
"sequenceList = traverseList id\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:202
#, no-wrap
msgid ""
"All of this calls for a new interface, which is called\n"
"`Traversable` and is exported from the *Prelude*. Here is\n"
"its definition (with primes for disambiguation):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:203
#, no-wrap
msgid ""
"interface Functor t => Foldable t => Traversable' t where\n"
"  traverse' : Applicative f => (a -> f b) -> t a -> f (t b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:214
#, no-wrap
msgid ""
"Function `traverse` is one of the most abstract and versatile\n"
"functions available from the *Prelude*. Just how powerful\n"
"it is will only become clear once you start using it\n"
"over and over again in your code. However, it will be the\n"
"goal of the remainder of this chapter to show you several\n"
"diverse and interesting use cases.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:229
#, no-wrap
msgid ""
"For now, we will quickly focus on the degree of abstraction.\n"
"Function `traverse` is parameterized over no less than\n"
"four parameters: The container type `t` (`List`, `Vect n`,\n"
"`Maybe`, to just name a few), the effect type (`Validated e`,\n"
"`IO`, `Maybe`, and so on), the input element type `a`, and\n"
"the output element type `b`. Considering that the libraries\n"
"bundled with the Idris project export more than 30 data types\n"
"with an implementation of `Applicative` and more than ten\n"
"traversable container types, there are literally hundreds\n"
"of combinations for traversing a container with an effectful\n"
"computation. This number gets even larger once we realize\n"
"that traversable containers - like applicative functors -\n"
"are closed under composition (see the exercises and\n"
"the final section in this chapter).\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Traverse.md:230
#, no-wrap
msgid "Traversable Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:233
#, no-wrap
msgid "There are two laws function `traverse` must obey:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:241
msgid ""
"`traverse (Id . f) = Id . map f`: Traversing over the `Identity` monad is "
"just functor `map`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:241
msgid ""
"`traverse (MkComp . map f . g) = MkComp . map (traverse f) . traverse g`: "
"Traversing with a composition of effects must be the same when being done in "
"a single traversal (left hand side) or a sequence of two traversals (right "
"hand side)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:246
#, no-wrap
msgid ""
"Since `map id = id` (functor's identity law), we can derive\n"
"from the first law that `traverse Id = Id`. This means, that\n"
"`traverse` must not change the size or shape of the container\n"
"type, nor is it allowed to change the order of elements.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:253
msgid ""
"It is interesting that `Traversable` has a `Functor` constraint. Proof that "
"every `Traversable` is automatically a `Functor` by implementing `map` in "
"terms of `traverse`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:255
#, no-wrap
msgid "   Hint: Remember `Control.Monad.Identity`.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:259
msgid ""
"Likewise, proof that every `Traversable` is a `Foldable` by implementing "
"`foldMap` in terms of `Traverse`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:261
#, no-wrap
msgid "   Hint: Remember `Control.Applicative.Const`.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Traverse.md:264
msgid ""
"To gain some routine, implement `Traversable'` for `List1`, `Either e`, and "
"`Maybe`."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Traverse.md:266
msgid "Implement `Traversable` for `List01 ne`:"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Traverse.md:275
msgid ""
"Implement `Traversable` for rose trees. Try to satisfy the totality checker "
"without cheating."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:276
#, no-wrap
msgid ""
"   record Tree a where\n"
"     constructor Node\n"
"     value  : a\n"
"     forest : List (Tree a)\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Traverse.md:284
msgid "Implement `Traversable` for `Crud i`:"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Traverse.md:294
msgid "Implement `Traversable` for `Response e i`:"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Traverse.md:307
msgid ""
"Like `Functor`, `Applicative` and `Foldable`, `Traversable` is closed under "
"composition. Proof this by implementing `Traversable` for `Comp` and "
"`Product`:"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Traverse.md:319
#, no-wrap
msgid "Programming with State"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:324
#, no-wrap
msgid ""
"Let's go back to our CSV reader. In order to get reasonable\n"
"error messages, we'd like to tag each line with its\n"
"index:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:325
#, no-wrap
msgid "zipWithIndex : List a -> List (Nat, a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:331
#, no-wrap
msgid ""
"It is, of course, very easy to come up with an ad hoc\n"
"implementation for this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:332
#, no-wrap
msgid ""
"zipWithIndex = go 1\n"
"  where go : Nat -> List a -> List (Nat,a)\n"
"        go _ []        = []\n"
"        go n (x :: xs) = (n,x) :: go (S n) xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:344
#, no-wrap
msgid ""
"While this is perfectly fine, we should still note that\n"
"we might want to do the same thing with the elements of\n"
"trees, vectors, non-empty lists and so on.\n"
"And again, we are interested in whether there is some\n"
"form of abstraction we can use to describe such computations.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Traverse.md:345
#, no-wrap
msgid "Mutable References in Idris"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:352
#, no-wrap
msgid ""
"Let us for a moment think about how we'd do such a thing\n"
"in an imperative language. There, we'd probably define\n"
"a local (mutable) variable to keep track of the current\n"
"index, which would then be increased while iterating over the list\n"
"in a `for`- or `while`-loop.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:363
#, no-wrap
msgid ""
"In Idris, there is no such thing as mutable state.\n"
"Or is there? Remember, how we used a mutable reference\n"
"to simulate a data base connection in an earlier\n"
"exercise. There, we actually used some truly mutable\n"
"state. However, since accessing or modifying a mutable\n"
"variable is not a referential transparent operation,\n"
"such actions have to be performed within `IO`.\n"
"Other than that, nothing keeps us from using mutable\n"
"variables in our code. The necessary functionality is\n"
"available from module `Data.IORef` from the *base* library.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:367
#, no-wrap
msgid ""
"As a quick exercise, try to implement a function, which -\n"
"given an `IORef Nat` - pairs a value with the current\n"
"index and increases the index afterwards.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:369
#, no-wrap
msgid "Here's how I would do this:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:370
#, no-wrap
msgid ""
"pairWithIndexIO : IORef Nat -> a -> IO (Nat,a)\n"
"pairWithIndexIO ref va = do\n"
"  ix <- readIORef ref\n"
"  writeIORef ref (S ix)\n"
"  pure (ix,va)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:387
#, no-wrap
msgid ""
"Note, that every time we *run* `pairWithIndexIO ref`, the\n"
"natural number stored in `ref` is incremented by one.\n"
"Also, look at the type of `pairWithIndexIO ref`: `a -> IO (Nat,a)`.\n"
"We want to apply this effectful computation to each element\n"
"in a list, which should lead to a new list wrapped in `IO`,\n"
"since all of this describes a single computation with side\n"
"effects. But this is *exactly* what function `traverse` does: Our\n"
"input type is `a`, our output type is `(Nat,a)`, our\n"
"container type is `List`, and the effect type is `IO`!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:388
#, no-wrap
msgid ""
"zipListWithIndexIO : IORef Nat -> List a -> IO (List (Nat,a))\n"
"zipListWithIndexIO ref = traverse (pairWithIndexIO ref)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:397
#, no-wrap
msgid ""
"Now *this* is really powerful: We could apply the same function\n"
"to *any* traversable data structure. It therefore makes\n"
"absolutely no sense to specialize `zipListWithIndexIO` to\n"
"lists only:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:398
#, no-wrap
msgid ""
"zipWithIndexIO : Traversable t => IORef Nat -> t a -> IO (t (Nat,a))\n"
"zipWithIndexIO ref = traverse (pairWithIndexIO ref)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:405
#, no-wrap
msgid ""
"To please our intellectual minds even more, here is the\n"
"same function in point-free style:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:406
#, no-wrap
msgid ""
"zipWithIndexIO' : Traversable t => IORef Nat -> t a -> IO (t (Nat,a))\n"
"zipWithIndexIO' = traverse . pairWithIndexIO\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:413
#, no-wrap
msgid ""
"All that's left to do now is to initialize a new mutable variable\n"
"before passing it to `zipWithIndexIO`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:414
#, no-wrap
msgid ""
"zipFromZeroIO : Traversable t => t a -> IO (t (Nat,a))\n"
"zipFromZeroIO ta = newIORef 0 >>= (`zipWithIndexIO` ta)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:420
#, no-wrap
msgid "Quickly, let's give this a go at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:421
#, no-wrap
msgid ""
"> :exec zipFromZeroIO {t = List} [\"hello\", \"world\"] >>= printLn\n"
"[(0, \"hello\"), (1, \"world\")]\n"
"> :exec zipFromZeroIO (Just 12) >>= printLn\n"
"Just (0, 12)\n"
"> :exec zipFromZeroIO {t = Vect 2} [\"hello\", \"world\"] >>= printLn\n"
"[(0, \"hello\"), (1, \"world\")]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:432
#, no-wrap
msgid ""
"Thus, we solved the problem of tagging each element with its\n"
"index once and for all for all traversable container types.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Traverse.md:433
#, no-wrap
msgid "The State Monad"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:441
#, no-wrap
msgid ""
"Alas, while the solution presented above is elegant and\n"
"performs very well, it still carries its `IO` stain, which\n"
"is fine if we are already in `IO` land, but unacceptable\n"
"otherwise. We do not want to make our otherwise pure functions\n"
"much harder to test and reason about just for a simple\n"
"case of stateful element tagging.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:450
#, no-wrap
msgid ""
"Luckily, there is an alternative to using a mutable reference,\n"
"which allows us to keep our computations pure and\n"
"untainted. However, it is not easy to come upon this\n"
"alternative on one's own, and it can be hard to figure out\n"
"what's going on here, so I'll try to introduce this slowly.\n"
"We first need to ask ourselves what the essence of a\n"
"\"stateful\" but otherwise pure computation is. There\n"
"are two essential ingredients:\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:458
msgid ""
"Access to the *current* state. In case of a pure function, this means that "
"the function should take the current state as one of its arguments."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:458
msgid ""
"Ability to communicate the updated state to later stateful computations. In "
"case of a pure function this means, that the function will return a pair of "
"values: The computation's result plus the updated state."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:462
#, no-wrap
msgid ""
"These two prerequisites lead to the following generic\n"
"type for a pure, stateful computation operating on state\n"
"type `st` and producing values of type `a`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:463
#, no-wrap
msgid ""
"Stateful : (st : Type) -> (a : Type) -> Type\n"
"Stateful st a = st -> (st, a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:470
#, no-wrap
msgid ""
"Our use case is pairing elements with indices, which\n"
"can be implemented as a pure, stateful computation like so:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:471
#, no-wrap
msgid ""
"pairWithIndex' : a -> Stateful Nat (Nat,a)\n"
"pairWithIndex' v index = (S index, (index,v))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:479
#, no-wrap
msgid ""
"Note, how we at the same time increment the index, returning\n"
"the incremented value as the new state, while pairing\n"
"the first argument with the original index.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:488
#, no-wrap
msgid ""
"Now, here is an important thing to note: While `Stateful` is\n"
"a useful type alias, Idris in general does *not* resolve\n"
"interface implementations for function types. If we want to\n"
"write a small library of utility functions around such a type,\n"
"it is therefore best to wrap it in a single-constructor data type and\n"
"use this as our building block for writing more complex\n"
"computations. We therefore introduce record `State` as\n"
"a wrapper for pure, stateful computations:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:489
#, no-wrap
msgid ""
"record State st a where\n"
"  constructor ST\n"
"  runST : st -> (st,a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:496
#, no-wrap
msgid "We can now implement `pairWithIndex` in terms of `State` like so:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:497
#, no-wrap
msgid ""
"pairWithIndex : a -> State Nat (Nat,a)\n"
"pairWithIndex v = ST $ \\index => (S index, (index, v))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:505
#, no-wrap
msgid ""
"In addition, we can define some more utility functions. Here's\n"
"one for getting the current state without modifying it\n"
"(this corresponds to `readIORef`):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:506
#, no-wrap
msgid ""
"get : State st st\n"
"get = ST $ \\s => (s,s)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:513
#, no-wrap
msgid ""
"Here are two others, for overwriting the current state. These\n"
"corresponds to `writeIORef` and `modifyIORef`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:514
#, no-wrap
msgid ""
"put : st -> State st ()\n"
"put v = ST $ \\_ => (v,())\n"
"\n"
"modify : (st -> st) -> State st ()\n"
"modify f = ST $ \\v => (f v,())\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:524
#, no-wrap
msgid ""
"Finally, we can define three functions in addition to `runST`\n"
"for running stateful computations\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:525
#, no-wrap
msgid ""
"runState : st -> State st a -> (st, a)\n"
"runState = flip runST\n"
"\n"
"evalState : st -> State st a -> a\n"
"evalState s = snd . runState s\n"
"\n"
"execState : st -> State st a -> st\n"
"execState s = fst . runState s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:542
#, no-wrap
msgid ""
"All of these are useful on their own, but the real power of\n"
"`State s` comes from the observation that it is a monad.\n"
"Before you go on, please spend some time and try implementing\n"
"`Functor`, `Applicative`, and `Monad` for `State s` yourself.\n"
"Even if you don't succeed, you will have an easier time\n"
"understanding how the implementations below work.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:543
#, no-wrap
msgid ""
"Functor (State st) where\n"
"  map f (ST run) = ST $ \\s => let (s2,va) = run s in (s2, f va)\n"
"\n"
"Applicative (State st) where\n"
"  pure v = ST $ \\s => (s,v)\n"
"\n"
"  ST fun <*> ST val = ST $ \\s =>\n"
"    let (s2, f)  = fun s\n"
"        (s3, va) = val s2\n"
"     in (s3, f va)\n"
"\n"
"Monad (State st) where\n"
"  ST val >>= f = ST $ \\s =>\n"
"    let (s2, va) = val s\n"
"     in runST (f va) s2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:573
#, no-wrap
msgid ""
"This may take some time to digest, so we come back to it in a\n"
"slightly advanced exercise. The most important thing to note is,\n"
"that we use every state value only ever once. We *must* make sure\n"
"that the updated state is passed to later computations, otherwise\n"
"the information about state updates is being lost. This can\n"
"best be seen in the implementation of `Applicative`: The initial\n"
"state, `s`, is used in the computation of the function value,\n"
"which will also return an updated state, `s2`, which is then\n"
"used in the computation of the function argument. This will\n"
"again return an updated state, `s3`, which is passed on to\n"
"later stateful computations together with the result of\n"
"applying `f` to `va`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:583
#, no-wrap
msgid ""
"This sections consists of two extended exercise, the aim\n"
"of which is to increase your understanding of the state monad.\n"
"In the first exercise, we will look at random value generation,\n"
"a classical application of stateful computations.\n"
"In the second exercise, we will look at an indexed version of\n"
"a state monad, which allows us to not only change the\n"
"state's value but also its *type* during computations.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:590
msgid ""
"Below is the implementation of a simple pseudo-random number generator. We "
"call this a *pseudo-random* number generator, because the numbers look "
"pretty random but are generated predictably. If we initialize a series of "
"such computations with a truly random seed, most users of our library will "
"not be able to predict the outcome of our computations."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:591
#, no-wrap
msgid ""
"   rnd : Bits64 -> Bits64\n"
"   rnd seed = fromInteger\n"
"            $ (437799614237992725 * cast seed) `mod` 2305843009213693951\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:604
#, no-wrap
msgid ""
"   The idea here is that the next pseudo-random number gets\n"
"   calculated from the previous one. But once we think about\n"
"   how we can use these numbers as seeds for computing\n"
"   random values of other types, we realize that these are\n"
"   just stateful computations. We can therefore write\n"
"   down an alias for random value generators as stateful\n"
"   computations:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:605
#, no-wrap
msgid ""
"   Gen : Type -> Type\n"
"   Gen = State Bits64\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:617
#, no-wrap
msgid ""
"   Before we begin, please note that `rnd` is not a very strong\n"
"   pseudo-random number generator. It will not generate values in\n"
"   the full 64bit range, nor is it safe to use in cryptographic\n"
"   applications. It is sufficient for our purposes in this chapter,\n"
"   however. Note also, that we could replace `rnd` with a stronger\n"
"   generator without any changes to the functions you will implement\n"
"   as part of this exercise.\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Traverse.md:622
msgid ""
"Implement `bits64` in terms of `rnd`. This should return the current state, "
"updating it afterwards by invoking function `rnd`. Make sure the state is "
"properly updated, otherwise this won't behave as expected."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:626
#, no-wrap
msgid ""
"      ```idris\n"
"      bits64 : Gen Bits64\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:631
#, no-wrap
msgid ""
"      This will be our *only* primitive generator, from which\n"
"      we will derived all the others. Therefore,\n"
"      before you continue, quickly test your implementation of\n"
"      `bits64` at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:636
#, no-wrap
msgid ""
"      ```repl\n"
"      Solutions.Traverse> runState 100 bits64\n"
"      (2274787257952781382, 100)\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Traverse.md:642
msgid ""
"Implement `range64` for generating random values in the range "
"`[0,upper]`. Hint: Use `bits64` and `mod` in your implementation but make "
"sure to deal with the fact that `mod x upper` produces values in the range "
"`[0,upper)`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:646
#, no-wrap
msgid ""
"      ```idris\n"
"      range64 : (upper : Bits64) -> Gen Bits64\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:649
#, no-wrap
msgid ""
"      Likewise, implement `interval64` for generating values\n"
"      in the range `[min a b, max a b]`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:653
#, no-wrap
msgid ""
"      ```idris\n"
"      interval64 : (a,b : Bits64) -> Gen Bits64\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:655
#, no-wrap
msgid "      Finally, implement `interval` for arbitrary integral types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:659
#, no-wrap
msgid ""
"      ```idris\n"
"      interval : Num n => Cast n Bits64 => (a,b : n) -> Gen n\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:663
#, no-wrap
msgid ""
"      Note, that `interval` will not generate all possible values in\n"
"      the given interval but only such values with a `Bits64`\n"
"      representation in the the range `[0,2305843009213693950]`.\n"
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Traverse.md:665
msgid "Implement a generator for random boolean values."
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/Traverse.md:670
msgid ""
"Implement a generator for `Fin n`. You'll have to think carefully about "
"getting this one to typecheck and be accepted by the totality checker "
"without cheating.  Note: Have a look at function `Data.Fin.natToFin`."
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/Traverse.md:674
msgid ""
"Implement a generator for selecting a random element from a vector of "
"values. Use the generator from exercise 4 in your implementation."
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/Traverse.md:678
msgid ""
"Implement `vect` and `list`. In case of `list`, the first argument should be "
"used to randomly determine the length of the list."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:681
#, no-wrap
msgid ""
"      ```idris\n"
"      vect : {n : _} -> Gen a -> Gen (Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:684
#, no-wrap
msgid ""
"      list : Gen Nat -> Gen a -> Gen (List a)\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:687
#, no-wrap
msgid ""
"      Use `vect` to implement utility function `testGen` for\n"
"      testing your generators at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:691
#, no-wrap
msgid ""
"      ```idris\n"
"      testGen : Bits64 -> Gen a -> Vect 10 a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   7. '
#: ../src/Tutorial/Traverse.md:693
msgid "Implement `choice`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:697
#, no-wrap
msgid ""
"      ```idris\n"
"      choice : {n : _} -> Vect (S n) (Gen a) -> Gen a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   8. '
#: ../src/Tutorial/Traverse.md:699
msgid "Implement `either`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:703
#, no-wrap
msgid ""
"      ```idris\n"
"      either : Gen a -> Gen b -> Gen (Either a b)\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   9. '
#: ../src/Tutorial/Traverse.md:708
msgid ""
"Implement a generator for printable ASCII characters.  These are characters "
"with ASCII codes in the interval `[32,126]`. Hint: Function `chr` from the "
"*Prelude* will be useful here."
msgstr ""

#. type: Bullet: '   10. '
#: ../src/Tutorial/Traverse.md:711
msgid ""
"Implement a generator for strings. Hint: Function `pack` from the *Prelude* "
"might be useful for this."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:715
#, no-wrap
msgid ""
"       ```idris\n"
"       string : Gen Nat -> Gen Char -> Gen String\n"
"       ```\n"
msgstr ""

#. type: Bullet: '   11. '
#: ../src/Tutorial/Traverse.md:722
msgid ""
"We shouldn't forget about our ability to encode interesting things in the "
"types in Idris, so, for a challenge and without further ado, implement "
"`hlist` (note the distinction between `HListF` and `HList`). If you are "
"rather new to dependent types, this might take a moment to digest, so don't "
"forget to use holes."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:727
#, no-wrap
msgid ""
"       ```idris\n"
"       data HListF : (f : Type -> Type) -> (ts : List Type) -> Type where\n"
"         Nil  : HListF f []\n"
"         (::) : (x : f t) -> (xs : HLift f ts) -> HListF f (t :: ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:730
#, no-wrap
msgid ""
"       hlist : HListF Gen ts -> Gen (HList ts)\n"
"       ```\n"
msgstr ""

#. type: Bullet: '   12. '
#: ../src/Tutorial/Traverse.md:732
msgid "Generalize `hlist` to work with any applicative functor, not just `Gen`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:736
#, no-wrap
msgid ""
"   If you arrived here, please realize how we can now generate "
"pseudo-random\n"
"   values for most primitives, as well as regular sum- and product types.\n"
"   Here is an example REPL session:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:737
#, no-wrap
msgid ""
"   > testGen 100 $ hlist [bool, printableAscii, interval 0 127]\n"
"   [[True, ';', 5],\n"
"    [True, '^', 39],\n"
"    [False, 'o', 106],\n"
"    [True, 'k', 127],\n"
"    [False, ' ', 11],\n"
"    [False, '~', 76],\n"
"    [True, 'M', 11],\n"
"    [False, 'P', 107],\n"
"    [True, '5', 67],\n"
"    [False, '8', 9]]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:764
#, no-wrap
msgid ""
"   Final remarks: Pseudo-random value generators play an important role\n"
"   in property based testing libraries like "
"[QuickCheck](https://hackage.haskell.org/package/QuickCheck)\n"
"   or [Hedgehog](https://github.com/stefan-hoeck/idris2-hedgehog).\n"
"   The idea of property based testing is to test predefined *properties* "
"of\n"
"   pure functions against a large number of randomly generated arguments,\n"
"   to get strong guarantees about these properties to hold for *all*\n"
"   possible arguments. One example would be a test for verifying\n"
"   that the result of reversing a list twice equals the original list.\n"
"   While it is possible to proof many of the simpler properties in Idris\n"
"   directly without the need for tests, this is no longer possible\n"
"   as soon as functions are involved, which don't reduce during "
"unification\n"
"   such as foreign function calls or functions not publicly exported from\n"
"   other modules.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:770
msgid ""
"While `State s a` gives us a convenient way to talk about stateful "
"computations, it only allows us to mutate the state's *value* but not its "
"*type*. For instance, the following function cannot be encapsulated in "
"`State` because the type of the state changes:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:771
#, no-wrap
msgid ""
"   uncons : Vect (S n) a -> (Vect n a, a)\n"
"   uncons (x :: xs) = (xs, x)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:784
#, no-wrap
msgid ""
"   Your task is to come up with a new state type allowing for\n"
"   such changes (sometimes referred to as an *indexed* state data type).\n"
"   The goal of this exercise is to also sharpen your skills in\n"
"   expressing things at the type level including derived function\n"
"   types and interfaces. Therefore, I will give only little\n"
"   guidance on how to go about this. If you get stuck, feel free to\n"
"   peek at the solutions but make sure to only look at the types\n"
"   at first.\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Traverse.md:790
msgid ""
"Come up with a parameterized data type for encapsulating stateful "
"computations where the input and output state type can differ. It must be "
"possible to wrap `uncons` in a value of this type."
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Traverse.md:792
msgid "Implement `Functor` for your indexed state type."
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Traverse.md:797
msgid ""
"It is not possible to implement `Applicative` for this *indexed* state type "
"(but see also exercise 2.vii).  Still, implement the necessary functions to "
"use it with idom brackets."
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/Traverse.md:801
msgid ""
"It is not possible to implement `Monad` for this indexed state type. Still, "
"implement the necessary functions to use it in do blocks."
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/Traverse.md:805
msgid ""
"Generalize the functions from exercises 3 and 4 with two new interfaces "
"`IxApplicative` and `IxMonad` and provide implementations of these for your "
"indexed state data type."
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/Traverse.md:809
msgid ""
"Implement functions `get`, `put`, `modify`, `runState`, `evalState`, and "
"`execState` for the indexed state data type. Make sure to adjust the type "
"parameters where necessary."
msgstr ""

#. type: Bullet: '   7. '
#: ../src/Tutorial/Traverse.md:812
msgid ""
"Show that your indexed state type is strictly more powerful than `State` by "
"implementing `Applicative` and `Monad` for it."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:816
#, no-wrap
msgid ""
"      Hint: Keep the input and output state identical. Note also,\n"
"      that you might need to implement `join` manually if Idris\n"
"      has trouble inferring the types correctly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:821
#, no-wrap
msgid ""
"   Indexed state types can be useful when we want to make sure that\n"
"   stateful computations are combined in the correct sequence, or\n"
"   that scarce resources get cleaned up properly. We might get back\n"
"   to such use cases in later examples.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Traverse.md:822
#, no-wrap
msgid "The Power of Composition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:830
#, no-wrap
msgid ""
"After our excursion into the realms of stateful computations, we\n"
"will go back and combine mutable state with error accumulation\n"
"to tag and read CSV lines in a single traversal. We already\n"
"defined `pairWithIndex` for tagging lines with their indices.\n"
"We also have `uncurry $ hdecode ts` for decoding single tagged lines.\n"
"We can now combine the two effects in a single computation:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:831
#, no-wrap
msgid ""
"tagAndDecode :  (0 ts : List Type)\n"
"             -> CSVLine (HList ts)\n"
"             => String\n"
"             -> State Nat (Validated CSVError (HList ts))\n"
"tagAndDecode ts s = uncurry (hdecode ts) <$> pairWithIndex s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:851
#, no-wrap
msgid ""
"Now, as we learned before, applicative functors are closed under\n"
"composition, and the result of `tagAndDecode` is a nesting\n"
"of two applicatives: `State Nat` and `Validated CSVError`.\n"
"The *Prelude* exports a corresponding named interface implementation\n"
"(`Prelude.Applicative.Compose`), which we can use for traversing\n"
"a list of strings with `tagAndDecode`.\n"
"Remember, that we have to provide named implementations explicitly.\n"
"Since `traverse` has the applicative functor as its\n"
"second constraint, we also need to provide the first\n"
"constraint (`Traversable`) explicitly. But this\n"
"is going to be the unnamed default implementation! To get our hands on "
"such\n"
"a value, we can use the `%search` pragma:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:852
#, no-wrap
msgid ""
"readTable :  (0 ts : List Type)\n"
"          -> CSVLine (HList ts)\n"
"          => List String\n"
"          -> Validated CSVError (List $ HList ts)\n"
"readTable ts = evalState 1 . traverse @{%search} @{Compose} (tagAndDecode "
"ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:866
#, no-wrap
msgid ""
"This tells Idris to use the default implementation for the\n"
"`Traversable` constraint, and `Prelude.Applicatie.Compose` for the\n"
"`Applicative` constraint.\n"
"While this syntax is not very nice, it doesn't come up too often, and\n"
"if it does, we can improve things by providing custom functions\n"
"for better readability:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:867
#, no-wrap
msgid ""
"traverseComp : Traversable t\n"
"             => Applicative f\n"
"             => Applicative g\n"
"             => (a -> f (g b))\n"
"             -> t a\n"
"             -> f (g (t b))\n"
"traverseComp = traverse @{%search} @{Compose}\n"
"\n"
"readTable' :  (0 ts : List Type)\n"
"           -> CSVLine (HList ts)\n"
"           => List String\n"
"           -> Validated CSVError (List $ HList ts)\n"
"readTable' ts = evalState 1 . traverseComp (tagAndDecode ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:885
#, no-wrap
msgid ""
"Note, how this allows us to combine two computational effects\n"
"(mutable state and error accumulation) in a single list traversal.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:898
#, no-wrap
msgid ""
"But I am not yet done demonstrating the power of composition. As you "
"showed\n"
"in one of the exercises, `Traversable` is also closed under composition,\n"
"so a nesting of traversables is again a traversable. Consider the "
"following\n"
"use case: When reading a CSV file, we'd like to allow lines to be\n"
"annotated with additional information. Such annotations could be\n"
"mere comments but also some formatting instructions or other\n"
"custom data tags might be feasible.\n"
"Annotations are supposed to be separated from the rest of the\n"
"content by a single hash character (`#`).\n"
"We want to keep track of these optional annotations\n"
"so we come up with a custom data type encapsulating\n"
"this distinction:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:899
#, no-wrap
msgid ""
"data Line : Type -> Type where\n"
"  Annotated : String -> a -> Line a\n"
"  Clean     : a -> Line a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:908
#, no-wrap
msgid ""
"This is just another container type and we can\n"
"easily implement `Traversable` for `Line` (do this yourself as\n"
"a quick exercise):\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:909
#, no-wrap
msgid ""
"Functor Line where\n"
"  map f (Annotated s x) = Annotated s $ f x\n"
"  map f (Clean x)       = Clean $ f x\n"
"\n"
"Foldable Line where\n"
"  foldr f acc (Annotated _ x) = f x acc\n"
"  foldr f acc (Clean x)       = f x acc\n"
"\n"
"Traversable Line where\n"
"  traverse f (Annotated s x) = Annotated s <$> f x\n"
"  traverse f (Clean x)       = Clean <$> f x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:928
#, no-wrap
msgid ""
"Below is a function for parsing a line and putting it in its\n"
"correct category. For simplicity, we just split the line on hashes:\n"
"If the result consists of exactly two strings, we treat the second\n"
"part as an annotation, otherwise we treat the whole line as untagged\n"
"CSV content.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:929
#, no-wrap
msgid ""
"readLine : String -> Line String\n"
"readLine s = case split ('#' ==) s of\n"
"  h ::: [t] => Annotated t h\n"
"  _         => Clean s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:938
#, no-wrap
msgid ""
"We are now going to implement a function for reading whole\n"
"CSV tables, keeping track of line annotations:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:939
#, no-wrap
msgid ""
"readCSV :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => String\n"
"        -> Validated CSVError (List $ Line $ HList ts)\n"
"readCSV ts = evalState 1\n"
"           . traverse @{Compose} @{Compose} (tagAndDecode ts)\n"
"           . map readLine\n"
"           . lines\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:966
#, no-wrap
msgid ""
"Let's digest this monstrosity. This is written in point-free\n"
"style, so we have to read it from end to beginning. First, we\n"
"split the whole string at line breaks, getting a list of strings\n"
"(function `Data.String.lines`). Next, we analyze each line,\n"
"keeping track of optional annotations (`map readLine`).\n"
"This gives us a value of type `List (Line String)`. Since\n"
"this is a nesting of traversables, we invoke `traverse`\n"
"with a named instance from the *Prelude*: `Prelude.Traversable.Compose`.\n"
"Idris can disambiguate this based on the types, so we can\n"
"drop the namespace prefix. But the effectful computation\n"
"we run over the list of lines results in a composition\n"
"of applicative functors, so we also need the named implementation\n"
"for compositions of applicatives in the second\n"
"constraint (again without need of an explicit\n"
"prefix, which would be `Prelude.Applicative` here).\n"
"Finally, we evaluate the stateful computation with `evalState 1`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:974
#, no-wrap
msgid ""
"Honestly, I wrote all of this without verifying if it works,\n"
"so let's give it a go at the REPL. I'll provide two\n"
"example strings for this, a valid one without errors, and\n"
"an invalid one. I use *multiline string literals* here, about which\n"
"I'll talk in more detail in a later chapter. For the moment,\n"
"note that these allow us to conveniently enter string literals\n"
"with line breaks:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:975
#, no-wrap
msgid ""
"validInput : String\n"
"validInput = \"\"\"\n"
"  f,12,-13.01#this is a comment\n"
"  t,100,0.0017\n"
"  t,1,100.8#color: red\n"
"  f,255,0.0\n"
"  f,24,1.12e17\n"
"  \"\"\"\n"
"\n"
"invalidInput : String\n"
"invalidInput = \"\"\"\n"
"  o,12,-13.01#another comment\n"
"  t,100,0.0017\n"
"  t,1,abc\n"
"  f,256,0.0\n"
"  f,24,1.12e17\n"
"  \"\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:996
#, no-wrap
msgid "And here's how it goes at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid ""
"Tutorial.Traverse> readCSV [Bool,Bits8,Double] validInput\n"
"Valid [Annotated \"this is a comment\" [False, 12, -13.01],\n"
"       Clean [True, 100, 0.0017],\n"
"       Annotated \"color: red\" [True, 1, 100.8],\n"
"       Clean [False, 255, 0.0],\n"
"       Clean [False, 24, 1.12e17]]\n"
"\n"
"Tutorial.Traverse> readCSV [Bool,Bits8,Double] invalidInput\n"
"Invalid (Append (FieldError 1 1 \"o\")\n"
"  (Append (FieldError 3 3 \"abc\") (FieldError 4 2 \"256\")))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1015
#, no-wrap
msgid ""
"It is pretty amazing how we wrote dozens of lines of\n"
"code, always being guided by the type- and totality\n"
"checkers, arriving eventually at a function for parsing\n"
"properly typed CSV tables with automatic line numbering and\n"
"error accumulation, all of which just worked on first try.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1025
#, no-wrap
msgid ""
"The *Prelude* provides three additional interfaces for\n"
"container types parameterized over *two* type parameters\n"
"such as `Either` or `Pair`: `Bifunctor`, `Bifoldable`,\n"
"and `Bitraversable`. In the following exercises we get\n"
"some hands-one experience working with these. You are\n"
"supposed to look up what functions they provide\n"
"and how to implement and use them yourself.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:1029
msgid ""
"Assume we'd like to not only interpret CSV content but also the optional "
"comment tags in our CSV files.  For this, we could use a data type such as "
"`Tagged`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1030
#, no-wrap
msgid ""
"   data Tagged : (tag, value : Type) -> Type where\n"
"     Tag  : tag -> value -> Tagged tag value\n"
"     Pure : value -> Tagged tag value\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1039
#, no-wrap
msgid ""
"   Implement interfaces `Functor`, `Foldable`, and `Traversable`\n"
"   but also `Bifunctor`, `Bifoldable`, and `Bitraversable`\n"
"   for `Tagged`.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:1045
msgid ""
"Show that the composition of a bifunctor with two functors such as `Either "
"(List a) (Maybe b)` is again a bifunctor by defining a dedicated wrapper "
"type for such compositions and writing a corresponding implementation of "
"`Bifunctor`.  Likewise for `Bifoldable`/`Foldable` and "
"`Bitraversable`/`Traversable`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Traverse.md:1051
msgid ""
"Show that the composition of a functor with a bifunctor such as `List "
"(Either a b)` is again a bifunctor by defining a dedicated wrapper type for "
"such compositions and writing a corresponding implementation of "
"`Bifunctor`.  Likewise for `Bifoldable`/`Foldable` and "
"`Bitraversable`/`Traversable`."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Traverse.md:1055
msgid ""
"We are now going to adjust `readCSV` in such a way that it decodes comment "
"tags and CSV content in a single traversal.  We need a new error type to "
"include invalid tags for this:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1056
#, no-wrap
msgid ""
"   data TagError : Type where\n"
"     CE         : CSVError -> TagError\n"
"     InvalidTag : (line : Nat) -> (tag : String) -> TagError\n"
"     Append     : TagError -> TagError -> TagError\n"
"\n"
"   Semigroup TagError where (<+>) = Append\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1066
#, no-wrap
msgid "   For testing, we also define a simple data type for color tags:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1067
#, no-wrap
msgid "   data Color = Red | Green | Blue\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1076
#, no-wrap
msgid ""
"   You should now implement the following functions, but\n"
"   please note that while `readColor` will need to\n"
"   access the current line number in case of an error,\n"
"   it must *not* increase it, as otherwise line numbers\n"
"   will be wrong in the invocation of `tagAndDecodeTE`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1077
#, no-wrap
msgid ""
"   readColor : String -> State Nat (Validated TagError Color)\n"
"\n"
"   readTaggedLine : String -> Tagged String String\n"
"\n"
"   tagAndDecodeTE :  (0 ts : List Type)\n"
"                  -> CSVLine (HList ts)\n"
"                  => String\n"
"                  -> State Nat (Validated TagError (HList ts))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1094
#, no-wrap
msgid ""
"   Finally, implement `readTagged` by using the wrapper type\n"
"   from exercise 3 as well as `readColor` and `tagAndDecodeTE`\n"
"   in a call to `bitraverse`.\n"
"   The implementation will look very similar to `readCSV` but\n"
"   with some additional wrapping and unwrapping at the right\n"
"   places.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1095
#, no-wrap
msgid ""
"   readTagged :  (0 ts : List Type)\n"
"              -> CSVLine (HList ts)\n"
"              => String\n"
"              -> Validated TagError (List $ Tagged Color $ HList ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1103
#, no-wrap
msgid "   Test your implementation with some example strings at the REPL.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1108
#, no-wrap
msgid ""
"You can find more examples for functor/bifunctor compositions\n"
"in Haskell's [bifunctors](https://hackage.haskell.org/package/bifunctors)\n"
"package.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1117
#, no-wrap
msgid ""
"Interface `Traversable` and its main function `traverse` are incredibly\n"
"powerful forms of abstraction - even more so, because both `Applicative`\n"
"and `Traversable` are closed under composition. If you are interested\n"
"in additional use cases, the publication, which\n"
"introduced `Traversable` to Haskell, is a highly recommended read:\n"
"[The Essence of the Iterator "
"Pattern](https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1124
#, no-wrap
msgid ""
"The *base* library provides an extended version of the\n"
"state monad in module `Control.Monad.State`. We will look\n"
"at this in more detail when we talk about monad transformers.\n"
"Please note also, that `IO` itself is implemented as a\n"
"[simple state monad](IO.md#how-io-is-implemented)\n"
"over an abstract, primitive state type: `%World`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1126
#, no-wrap
msgid "Here's a short summary of what we learned in this chapter:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"Function `traverse` is used to run effectful computations over container "
"types without affecting their size or shape."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"We can use `IORef` as mutable references in stateful computations running in "
"`IO`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"For referentially transparent computations with \"mutable\" state, the "
"`State` monad is extremely useful."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"Applicative functors are closed under composition, so we can run several "
"effectful computations in a single traversal."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"Traversables are also closed under composition, so we can use `traverse` to "
"operate on a nesting of containers."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1146
#, no-wrap
msgid ""
"For now, this concludes our introduction of the *Prelude*'s\n"
"higher-kinded interfaces, which started with the introduction of\n"
"`Functor`, `Applicative`, and `Monad`, before moving on to `Foldable`,\n"
"and - last but definitely not least - `Traversable`.\n"
"There's one still missing - `Alternative` - but this will\n"
"have to wait a bit longer, because we need to first make\n"
"our brains smoke with some more type-level wizardry.\n"
msgstr ""

#. type: Title #
#: ../src/Appendices/Neovim.md:1
#, no-wrap
msgid "Interactive Editing in Neovim"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:10
#, no-wrap
msgid ""
"Idris provides extensive capabilities to interactively\n"
"analyze the types of values and expressions in our programs\n"
"and fill out skeleton implementations and sometimes even whole\n"
"programs for us based on the types provided. These interactive\n"
"editing features are available via plugins in different editors.\n"
"Since I am a Neovim user, I explain the Idris related parts of\n"
"my own setup in detail here.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:20
#, no-wrap
msgid ""
"The main component required to get all these features to run\n"
"in Neovim is an executable provided by the\n"
"[idris2-lsp](https://github.com/idris-community/idris2-lsp) project.\n"
"This executable makes use of the Idris compiler API (application\n"
"programming interface) internally and can check the syntax and\n"
"types of the source code we are working on. It communicates with\n"
"Neovim via the language server protocol (LSP). This communication\n"
"is setup through the "
"[idris2-nvim](https://github.com/ShinKage/idris2-nvim)\n"
"plugin.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:31
#, no-wrap
msgid ""
"As we will see in this tutorial, the `idris2-lsp` executable not only\n"
"supports syntax and type checking, but comes also with additional\n"
"interactive editing features. Finally, the Idris compiler API supports\n"
"semantic highlighting of Idris source code: Identifiers and keywords\n"
"are highlighted not only based on the language's syntax (that would\n"
"be *syntax highlighting*, a feature expected from all modern\n"
"programming environments and editors), but also based on their\n"
"*semantics*. For instance, a local variable in a function implementation\n"
"gets highlighted differently than the name of a top level function,\n"
"although syntactically these are both just identifiers.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:32
#, no-wrap
msgid ""
"module Appendices.Neovim\n"
"\n"
"import Data.Vect\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Neovim.md:40
#, no-wrap
msgid "Setup"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:44
#, no-wrap
msgid ""
"In order to make full use of interactive Idris editing in\n"
"Neovim, at least the following tools need to be installed:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
msgid "A recent version of Neovim (version 0.5 or later)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
msgid "A recent version of the Idris compiler (at least version 0.5.1)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
msgid "The Idris compiler API."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
msgid "The [idris2-lsp](https://github.com/idris-community/idris2-lsp) package."
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:52
#, no-wrap
msgid ""
"* The following Neovim plugins:\n"
"  * [idris2-nvim](https://github.com/ShinKage/idris2-nvim)\n"
"  * [nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:57
#, no-wrap
msgid ""
"The `idris2-lsp` project gives detailed instructions about how\n"
"to install Idris 2 together with its standard libraries and compiler\n"
"API. Make sure to follow these instructions so that your compiler\n"
"and `idris2-lsp` executable are in sync.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:67
#, no-wrap
msgid ""
"If you are new to Neovim, you might want to use the `init.vim`\n"
"file provided in the `resources` folder. In that case, the\n"
"necessary Neovim plugins are already included, but you need to install\n"
"[vim-plug](https://github.com/junegunn/vim-plug), a plugin manager.\n"
"Afterwards, copy all or parts of `resources/init.vim` to your own "
"`init.vim`\n"
"file. (Use `:help init.vim` from within Neovim in order to find\n"
"out where to look for this file.). After setting up your `init.vim`\n"
"file, restart Neovim and run `:PlugUpdate` to install the\n"
"necessary plugins.\n"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Neovim.md:68
#, no-wrap
msgid "A Typical Workflow"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:77
#, no-wrap
msgid ""
"In order to checkout the interactive editing features\n"
"available to us, we will reimplement some small utilities\n"
"from the *Prelude*. To follow along, you should have\n"
"already worked through the [Introduction](../Tutorial/Intro.md),\n"
"[Functions Part 1](../Tutorial/Functions1.md), and at least\n"
"parts of [Algebraic Data Types](../Tutorial/DataTypes.md), otherwise\n"
"it will be hard to understand what's going on here.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:83
#, no-wrap
msgid ""
"Before we begin, note that the commands and actions shown in this\n"
"tutorial might not work correctly after you edited a source file\n"
"but did not write your changes to disk. Therefore, the first thing\n"
"you should try if the things described here do not work, is to\n"
"quickly save the current file (`:w`).\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:85
#, no-wrap
msgid "Let's start with negation of a boolean value:\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:86
#, no-wrap
msgid "negate1 : Bool -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:102
#, no-wrap
msgid ""
"Typically, when writing Idris code we follow the mantra\n"
"\"types first\". Although you might already have an idea about\n"
"how to implement a certain piece of functionality, you still\n"
"need to provide an accurate type before you can start writing\n"
"your implementation. This means, when programming in Idris, we have\n"
"to mentally keep track of the implementation of an algorithm\n"
"and the types involved at the same time, both of which can\n"
"become arbitrarily complex. Or do we? Remember that Idris knows\n"
"at least as much about the variables and their types available\n"
"in the current context of a function implementation as we do,\n"
"so we probably should ask it for guidance instead of trying\n"
"to do everything on our own.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:112
#, no-wrap
msgid ""
"So, in order to proceed, we ask Idris for a skeleton function\n"
"body: In normal editor mode, move your cursor on the line where\n"
"`negate1` is declared and enter `<LocalLeader>a` in quick\n"
"succession. `<LocalLeader>` is a special key that can be specified\n"
"in the `init.vim` file. If you\n"
"use the `init.vim` from the `resources` folder, it is set to\n"
"the comma character (`,`), in which case the above command\n"
"consists of a comma quickly followed by the lowercase letter \"a\".\n"
"See also `:help leader` and `:help localleader` in Neovim\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:115
#, no-wrap
msgid ""
"Idris will generate a skeleton implementation similar to the\n"
"following:\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:116
#, no-wrap
msgid ""
"negate2 : Bool -> Bool\n"
"negate2 x = ?negate2_rhs\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:139
#, no-wrap
msgid ""
"Note, that on the left hand side a new variable with name\n"
"`x` was introduced, while on the right hand side Idris\n"
"added a *metavariable* (also called a *hole*). This is an\n"
"identifier prefixed with a question mark. It signals to Idris,\n"
"that we will implement this part of the function at a later time.\n"
"The great thing about holes is, that we can *hover* over them\n"
"and inspect their types and the types of values in the\n"
"surrounding context. You can do so by placing the cursor\n"
"on the identifier of a hole and entering `K` (the uppercase letter) in\n"
"normal mode. This will open a popup displaying the type of\n"
"the variable under the cursor plus the types and quantities of the "
"variables\n"
"in the surrounding context. You can also have this information\n"
"displayed in a separate window: Enter `<LocalLeader>so` to\n"
"open this window and repeat the hovering. The information will\n"
"appear in the new window and as an additional benefit, it will\n"
"be semantically highlighted. Enter `<LocalLeader>sc` to close\n"
"this window again. Go ahead and checkout the type and\n"
"context of `?negate2_rhs`.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:148
#, no-wrap
msgid ""
"Most functions in Idris are implemented by pattern matching\n"
"on one or more of the arguments. Idris,\n"
"knowing the data constructors of all non-primitive data types,\n"
"can write such pattern matches for us (a process also called\n"
"*case splitting*). To give this a try, move the cursor onto the `x`\n"
"in the skeleton implementation of `negate2`, and enter\n"
"`<LocalLeader>c` in normal mode. The result will look as\n"
"follows:\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:149
#, no-wrap
msgid ""
"negate3 : Bool -> Bool\n"
"negate3 False = ?negate3_rhs_0\n"
"negate3 True = ?negate3_rhs_1\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:158
#, no-wrap
msgid ""
"As you can see, Idris inserted a hole for each of the cases on the\n"
"right hand side. We can again inspect their types or\n"
"replace them with a proper implementation directly.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:164
#, no-wrap
msgid ""
"This concludes the introduction of the (in my opinion) core\n"
"features of interactive editing: Hovering on metavariables,\n"
"adding skeleton function implementations, and case splitting\n"
"(which also works in case blocks and for nested pattern\n"
"matches). You should start using these all the time *now*!\n"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Neovim.md:165
#, no-wrap
msgid "Expression Search"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:173
#, no-wrap
msgid ""
"Sometimes, Idris knows enough about the types involved to\n"
"come up with a function implementation on its own. For instance,\n"
"let us implement function `either` from the *Prelude*.\n"
"After giving its type, creating a skeleton implementation,\n"
"and case splitting on the `Either` argument, we arrive at\n"
"something similar to the following:\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:174
#, no-wrap
msgid ""
"either2 : (a -> c) -> (b -> c) -> Either a b -> c\n"
"either2 f g (Left x) = ?either2_rhs_0\n"
"either2 f g (Right x) = ?either2_rhs_1\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:186
#, no-wrap
msgid ""
"Idris can come up with expressions for the two metavariables\n"
"on its own, because the types are specific enough. Move\n"
"the cursor onto one of the metavariables and enter\n"
"`<LocalLeader>o` in normal mode. You will be given\n"
"a selection of possible expressions (only one in this case),\n"
"of which you can choose a fitting one (or abort with `q`).\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:190
#, no-wrap
msgid ""
"Here is another example: A reimplementation of function `maybe`.\n"
"If you run an expression search on `?maybe2_rhs1`, you will\n"
"get a larger list of choices.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:191
#, no-wrap
msgid ""
"maybe2 : b -> (a -> b) -> Maybe a -> b\n"
"maybe2 x f Nothing = x\n"
"maybe2 x f (Just y) = ?maybe2_rhs_1\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:208
#, no-wrap
msgid ""
"Idris is also sometimes capable of coming up with complete function\n"
"implementations based on a function's type. For this to work well\n"
"in practice, the number of possible implementations satisfying\n"
"the type checker must be pretty small. As an example, here is\n"
"function `zipWith` for vectors. You might not have heard\n"
"about vectors yet: They will be introduced in the chapter about\n"
"[dependent types](../Tutorial/Dependent.md). You can still give\n"
"this a go to check out its effect. Just move the cursor on the\n"
"line declaring `zipWithV`, enter `<LocalLeader>gd` and select the first "
"option.\n"
"This will automatically generate the whole function body including\n"
"case splits and implementations.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:209
#, no-wrap
msgid "zipWithV : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:218
#, no-wrap
msgid ""
"Expression search only works well if the types are specific\n"
"enough. If you feel like that might be the case, go ahead\n"
"and give it a go, either by running `<LocalLeader>o` on\n"
"a metavariable, or by trying `<LocalLeader>gd` on a\n"
"function declaration.\n"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Neovim.md:219
#, no-wrap
msgid "More Code Actions"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:223
#, no-wrap
msgid ""
"There are other shortcuts available for generating part of your code,\n"
"two of which I'll explain here.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:231
#, no-wrap
msgid ""
"First, it is possible to add a new case block by entering\n"
"`<LocalLeader>mc` in normal mode when on a metavariable.\n"
"For instance, here is part of an implementation of `filterList`,\n"
"which appears in an exercise in the chapter about\n"
"algebraic data types. I arrived at this by letting Idris\n"
"generate a skeleton implementation followed by a case split\n"
"and an expression search on the first metavariable:\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:232
#, no-wrap
msgid ""
"filterList : (a -> Bool) -> List a -> List a\n"
"filterList f [] = []\n"
"filterList f (x :: xs) = ?filterList_rhs_1\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:247
#, no-wrap
msgid ""
"We will next have to pattern match on the result of applying\n"
"`x` to `f`. Idris can introduce a new case block for us,\n"
"if we move the cursor onto metavariable `?filterList_rhs_1`\n"
"and enter `<LocalLeader>mc` in normal mode. We can then\n"
"continue with our implementation by first giving the\n"
"expression to use in the case block (`f x`) followed by a\n"
"case split on the new variable in the case block.\n"
"This will lead us to an implementation similar to the following\n"
"(I had to fix the indentation, though):\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:248
#, no-wrap
msgid ""
"filterList2 : (a -> Bool) -> List a -> List a\n"
"filterList2 f [] = []\n"
"filterList2 f (x :: xs) = case f x of\n"
"  False => ?filterList2_rhs_2\n"
"  True => ?filterList2_rhs_3\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:266
#, no-wrap
msgid ""
"Sometimes, we want to extract a utility function from\n"
"an implementation we are working on. For instance, this is often\n"
"useful or even necessary when we write proofs about our code\n"
"(see chapters [Propositional Equality](../Tutorial/Eq.md)\n"
"and [Predicates](../Tutorial/Predicates.md), for instance).\n"
"In order to do so, we can move the cursor on a metavariable,\n"
"and enter `<LocalLeader>ml`. Give this a try with\n"
"`?whatNow` in the following example (this will work better\n"
"in a regular Idris source file instead of the literate\n"
"file I use for this tutorial):\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:267
#, no-wrap
msgid ""
"traverseEither : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither f [] = Right []\n"
"traverseEither f (x :: xs) = ?whatNow x xs f (f x) (traverseEither f xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:279
#, no-wrap
msgid ""
"Idris will create a new function declaration with the\n"
"type and name of `?whatNow`, which takes as arguments\n"
"all variables currently in scope. It also replaces the hole in\n"
"`traverseEither` with a call to this new function. Typically,\n"
"you will have to manually remove unneeded arguments\n"
"afterwards. This led me to the following version:\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:280
#, no-wrap
msgid ""
"whatNow2 : Either e b -> Either e (List b) -> Either e (List b)\n"
"\n"
"traverseEither2 : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither2 f [] = Right []\n"
"traverseEither2 f (x :: xs) = whatNow2 (f x) (traverseEither f xs)\n"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Neovim.md:288
#, no-wrap
msgid "Getting Information"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:294
#, no-wrap
msgid ""
"The `idris2-lsp` executable and through it, the `idris2-nvim` plugin,\n"
"not only supports the code actions described above. Here is a\n"
"non-comprehensive list of other capabilities. I suggest you try\n"
"out each of them from within this source file.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
msgid ""
"Typing `K` when on an identifier or operator in normal mode shows its type "
"and namespace (if any). In case of a metavariable, variables in the current "
"context are displayed as well together with their types and quantities "
"(quantities will be explained in [Functions Part "
"2](../Tutorial/Functions2.md)).  If you don't like popups, enter "
"`<LocalLeader>so` to open a new window where this information is displayed "
"and semantically highlighted instead."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
msgid ""
"Typing `gd` on a function, operator, data constructor or type constructor in "
"normal mode jumps to the item's definition.  For external modules, this "
"works only if the module in question has been installed together with its "
"source code (by using the `idris2 --install-with-src` command)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
msgid ""
"Typing `<LocalLeader>mm` opens a popup window listing all metavariables in "
"the current module. You can place the cursor on an entry and jump to its "
"location by pressing `<Enter>`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
msgid ""
"Typing `<LocalLeader>mn` (or `<LocalLeader>mp`) jumps to the next (or "
"previous) metavariable in the current module."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
msgid ""
"Typing `<LocalLeader>br` opens a popup where you can enter a "
"namespace. Idris will then show all functions (plus their types)  exported "
"from that namespace in a popup window, and you can jump to a function's "
"definition by pressing enter on one of the entries. Note: The module in "
"question must be imported in the current source file."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
msgid ""
"Typing `<LocalLeader>x` opens a popup where you can enter a REPL command or "
"Idris expression, and the plugin will reply with a response from the "
"REPL. Whenever REPL examples are shown in the main part of this guide, you "
"can try them from within Neovim with this shortcut if you like."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
msgid ""
"Typing `<LocalLeader><LocalLeader>e` will display the error message from the "
"current line in a popup window. This can be highly useful, if error messages "
"are too long to fit on a single line. Likewise, "
"`<LocalLeader><LocalLeader>el` will list all error messages from the current "
"buffer in a new window. You can then select an error message and jump to its "
"origin by pressing `<Enter>`."
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:332
#, no-wrap
msgid ""
"Other use cases and examples are described on the GitHub page\n"
"of the `idris2-nvim` plugin and can be included as described there.\n"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Neovim.md:333
#, no-wrap
msgid "The `%name` Pragma"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:345
#, no-wrap
msgid ""
"When you ask Idris for a skeleton implementation with `<LocalLeader>a`\n"
"or a case split with `<LocalLeader>c`,\n"
"it has to decide on what names to use for the new variables it introduces.\n"
"If these variables already have predefined names (from the function's\n"
"signature, record fields, or named data constructor arguments),\n"
"those names will be used, but\n"
"otherwise Idris will as a default use names `x`, `y`, and `z`, followed\n"
"by other letters. You can change this default behavior by\n"
"specifying a list of names to use for such occasions for any\n"
"data type.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:347
#, no-wrap
msgid "For instance:\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:348
#, no-wrap
msgid ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"%name Element e,f\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:358
#, no-wrap
msgid ""
"Idris will then use these names (followed by these names postfixed\n"
"with increasing integers), when it has to come up with variable names of "
"this\n"
"type on its own. For instance, here is a test function and the\n"
"result of adding a skeleton definition to it:\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:359
#, no-wrap
msgid ""
"test : Element -> Element -> Element -> Element -> Element -> Element\n"
"test e f e1 f1 e2 = ?test_rhs\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:372
#, no-wrap
msgid ""
"Neovim, together with the `idris2-lsp` executable and the\n"
"`idris2-nvim` editor plugin, provides extensive utilities for\n"
"interactive editing when programming in Idris. Similar functionality\n"
"is available for some other editors, so feel free to ask what's\n"
"available for your editor of choice, for instance on the\n"
"[Idris 2 Discord channel](https://discord.gg/UX68fDs2jc).\n"
msgstr ""
